
# /Users/sherif/Documents/SASTDocs/CodeQL/docs/query-metadata-style-guide.md
# Query file metadata and alert message style guide

## Introduction

This document outlines the structure of CodeQL query files. You should adopt this structure when contributing custom queries to this repository, in order to ensure that new queries are consistent with the standard CodeQL queries.

## Query files (.ql extension)

Query files have the extension `.ql`. Each file has two distinct areas:

* Metadata area–displayed at the top of the file, contains the metadata that defines how results for the query are interpreted and gives a brief description of the purpose of the query.
* Query definition–defined using QL. The query includes a select statement, which defines the content and format of the results. For further information about writing QL, see the following topics:
  * [CodeQL documentation](https://codeql.github.com/docs/)
  * [QL language reference](https://codeql.github.com/docs/ql-language-reference/)
  * [CodeQL style guide](ql-style-guide.md)


For examples of query files for the languages supported by CodeQL, visit the following links:

* [C/C++ queries](https://codeql.github.com/codeql-query-help/cpp/)
* [C# queries](https://codeql.github.com/codeql-query-help/csharp/)
* [Go queries](https://codeql.github.com/codeql-query-help/go/)
* [Java queries](https://codeql.github.com/codeql-query-help/java/)
* [JavaScript queries](https://codeql.github.com/codeql-query-help/javascript/)
* [Python queries](https://codeql.github.com/codeql-query-help/python/)

## Metadata area

Query file metadata contains important information that defines the identifier and purpose of the query. The metadata is included as the content of a valid [QLDoc](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#qldoc) comment, on lines with leading whitespace followed by `*`, between an initial `/**` and a trailing `*/`. For example:

```ql
/**
 * @name Useless assignment to local variable
 * @description An assignment to a local variable that is not used later on, or whose value is always
 *              overwritten, has no effect.
 * @kind problem
 * @problem.severity warning
 * @id cs/useless-assignment-to-local
 * @tags maintainability
 *       external/cwe/cwe-563
 * @precision very-high
 * @security-severity 6.1
 */
 ```

To help others use your query, you should include all of the required information outlined below in the metadata, and as much of the optional information as possible. For further information on query metadata see [Metadata for CodeQL queries](https://codeql.github.com/docs/writing-codeql-queries/metadata-for-codeql-queries/) on codeql.github.com.

### Query name `@name`

You must specify an `@name` property for your query. This property defines the display name for the query. Query names should use sentence capitalization, but not include a full stop. For example:

* `@name Access to variable in enclosing class`
* `@name Array argument size mismatch`
* `@name Reference equality test on strings`
* `@name Return statement outside function`


### Query descriptions `@description`

You must define an `@description` property for your query. This property defines a short help message. Query descriptions should be written as a sentence or short-paragraph of plain prose, with sentence capitalization and full stop. The preferred pattern for alert queries is  "Syntax X causes behavior Y." Any code elements included in the description should be enclosed in single quotes. For example:


* `@description Using a format string with an incorrect format causes a 'System.FormatException'.`
* `@description Commented-out code makes the remaining code more difficult to read.`

### Query ID `@id`

You must specify an `@id` property for your query. It must be unique and should follow the standard CodeQL convention. That is, it should begin with the 'language code' for the language that the query analyzes followed by a forward slash. The following language codes are supported:

* C and C++: `cpp`
* C#: `cs`
* Go: `go`
* Java and Kotlin: `java`
* JavaScript and TypeScript: `js`
* Python: `py`

The `@id` should consist of a short noun phrase that identifies the issue that the query highlights. For example:



* `@id cs/command-line-injection`
* `@id java/string-concatenation-in-loop`

Further terms can be added to the `@id` to group queries that, for example, highlight similar issues or are of particular relevance to a certain framework. For example:

* `@id js/angular-js/missing-explicit-injection`
* `@id js/angular-js/duplicate-dependency`

Note, `@id` properties should be consistent for queries that highlight the same issue for different languages. For example, the following queries identify format strings that contain unsanitized input in Java and C++ code respectively:



* `@id java/tainted-format-string`
* `@id cpp/tainted-format-string`


### Query type `@kind`

`@kind` is a required property that defines the type of query. The main query types are:



* alerts (`@kind problem`)
* alerts containing path information (`@kind path-problem`)
* metrics (`@kind metric`)

Alert queries (`@kind problem` or `path-problem`) support two further properties. These are added by GitHub staff after the query has been tested. The following information is for reference:



* `@precision`–broadly indicates the proportion of query results that are true positives, while also considering their context and relevance:
  * `low`
  * `medium`
  * `high`
  * `very-high`
* `@problem.severity`–defines the likelihood that an alert, either security-related or not, causes an actual problem such as incorrect program behavior: 
  * `error`–an issue that is likely to cause incorrect program behavior, for example a crash or vulnerability.
  * `warning`–an issue that indicates a potential problem in the code, or makes the code fragile if another (unrelated) part of code is changed.
  * `recommendation`–an issue where the code behaves correctly, but it could be improved.
* `@security-severity`-defines the level of severity, between 0.0 and 10.0, for queries with `@tags security`. For more information about how this value is calculated and then used in code scanning analysis, see [About alert severity and security severity levels](https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels) in the GitHub user documentation.

## Query tags `@tags`

The `@tags` property is used to define categories that the query relates to. Each alert query should belong to one (or more, if necessary) of the following four top-level categories:

* `@tags correctness`–for queries that detect incorrect program behavior.
* `@tags maintainability`–for queries that detect patterns that make it harder for developers to make changes to the code.
* `@tags readability`–for queries that detect confusing patterns that make it harder for developers to read the code.
* `@tags security`–for queries that detect security weaknesses. See below for further information.

There are also more specific `@tags` that can be added. See, the following pages for examples of the low-level tags:

* [C/C++ queries](https://codeql.github.com/codeql-query-help/cpp/)
* [C# queries](https://codeql.github.com/codeql-query-help/csharp/)
* [Go queries](https://codeql.github.com/codeql-query-help/go/)
* [Java queries](https://codeql.github.com/codeql-query-help/java/)
* [JavaScript queries](https://codeql.github.com/codeql-query-help/javascript/)
* [Python queries](https://codeql.github.com/codeql-query-help/python/)

Metric queries (`@kind metric`) may have the `summary` tag. If SARIF output is used, the results of these queries can be found at `run[].properties.metricResults`.

If necessary, you can also define your own low-level tags to categorize the queries specific to your project or organization. When creating your own tags, you should:

* Use all lower-case letters, including for acronyms and proper nouns, with no spaces. All characters apart from * and @ are accepted.
* Use a forward slash / to indicate a hierarchical relationship between tags if necessary. For example, a query with tag `foo/bar` is also interpreted as also having tag `foo`, but not `bar`.
* Use a single-word `@tags` name. Multiple words, separated with hyphens, can be used for clarity if necessary.

#### Security query `@tags`

If your query is a security query, use one or more `@tags` to associate it with the relevant CWEs. Add `@tags` for the most specific Base Weakness or Class Weakness in [View 1000](https://cwe.mitre.org/data/definitions/1000.html), using the parent/child relationship. For example:

| `@tags security` | `external/cwe/cwe-022`|
|-|-|
||`external/cwe/cwe-023` |
||`external/cwe/cwe-036` |
||`external/cwe/cwe-073` |

When you tag a query like this, the associated CWE pages from [MITRE.org](https://cwe.mitre.org/index.html) will automatically appear in the references section of its associated qhelp file.

> [!NOTE]
> The automatic addition of CWE reference links works only if the qhelp file already contains a `<references>` section.

#### Metric/summary `@tags`

Code Scanning may use tags to identify queries with specific meanings across languages. Currently, there is only one such tag: `lines-of-code`. The sum of the results for queries with this tag that return a single number column ([example for JavaScript](https://github.com/github/codeql/blob/c47d680d65f09a851e41d4edad58ffa7486b5431/java/ql/src/Metrics/Summaries/LinesOfCode.ql)) is interpreted by Code Scanning as the lines of code under the source root present in the database. Each language should have exactly one query of this form.


Maintainers are expected to add a `@security-severity` tag to security relevant queries that will be run on Code Scanning.  There is a documented internal process for generating these `@security-severity` values.

## QL area

### Alert messages

The select clause of each alert query defines the alert message that is displayed for each result found by the query. Alert messages are strings that concisely describe the problem that the alert is highlighting and, if possible, also provide some context. For consistency, alert messages should adhere to the following guidelines:

* Each message should be a complete, standalone sentence. That is, it should be capitalized and have proper punctuation, including a full stop.
* The message should factually describe the problem that is being highlighted–it should not contain recommendations about how to fix the problem or value judgements.
* Program element references should be in 'single quotes' to distinguish them from ordinary words. Quotes are not needed around substitutions (`$@`).
* Avoid constant alert message strings and include some context, if possible. For example, `The class 'Foo' is duplicated as 'Bar'.` is preferable to `This class is duplicated here.`
* If a reference to the current location can't be avoided use "this location" instead of "here". For example, `Bad thing at this location.` is preferable to `Bad thing here.`. This avoids the "click here" anti-pattern.
* For path queries, if possible, try to follow the template: `This path depends on a [user-provided value].`, or alternatively (if the first option doesn't work) `[User-provided value] flows to this location and is used in a path.`.
* Taint tracking queries generally have a sink that "depends on" the source, and dataflow queries generally have a source that "flows to" the sink.

### Links in alert messages

* Where you reference another program element, link to it if possible using a substitution (`$@`). Links should be used inline in the sentence, rather than as parenthesised lists or appositions.
* Avoid using link texts that don't describe what they link to. For example, rewrite `This sensitive data is written to a logfile unescaped [here]` to `This sensitive data is [written to a logfile unescaped]`.
* Make link text as concise and precise as possible. For example, avoid starting a link text with an indefinite article (a, an). `Path construction depends on a [user-provided value]` is preferable to `Path construction depends on [a user-provided value]`. (Where the square brackets indicate a link.) See [the W3C guide on link texts](https://www.w3.org/WAI/WCAG22/Understanding/link-purpose-in-context.html) for further information.
* When a message contains multiple links, construct a sentence that has the most variable link (that is, the link with most targets) last. For further information, see [Defining the results of a query](https://codeql.github.com/docs/writing-codeql-queries/defining-the-results-of-a-query/).

For examples of select clauses and alert messages, see the query source files at the following pages:

* [C/C++ queries](https://codeql.github.com/codeql-query-help/cpp/)
* [C# queries](https://codeql.github.com/codeql-query-help/csharp/)
* [Go queries](https://codeql.github.com/codeql-query-help/go/)
* [Java queries](https://codeql.github.com/codeql-query-help/java/)
* [JavaScript queries](https://codeql.github.com/codeql-query-help/javascript/)
* [Python queries](https://codeql.github.com/codeql-query-help/python/)

For further information on query writing, see [CodeQL queries](https://codeql.github.com/docs/writing-codeql-queries/codeql-queries/). For more information on learning CodeQL, see [CodeQL documentation](https://codeql.github.com/docs/).

## Metric results

The `select` clause of a summary metric query must have one of the following result patterns:
- Just a `number`
  - This indicates a metric without a specific location in the codebase, for example the total lines of code in a codebase.
- A code `entity` followed by a `number`
  - This indicates a metric with a specific location in the codebase, for example the lines of code within a file. The `entity` here must have a valid location in the source code.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/qldoc-style-guide.md
# QLDoc style guide 

## Introduction

Valid QL comments are known as QLDoc. This document describes the recommended styles and conventions you should use when writing QLDoc for code contributions in this repository. If there is a conflict between any of the recommendations in this guide and clarity, then clarity should take precedence.

### General requirements

1. Documentation must adhere to the [QLDoc specification](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#qldoc).
1. Documentation comments should be appropriate for users of the code.
1. Documentation for maintainers of the code must use normal comments.
1. Use `/** ... */` for documentation, even for single line comments.
   - For single-line documentation, the `/**` and `*/` are written on the same line as the comment.
   - For multi-line documentation, the `/**` and `*/` are written on separate lines. There is a `*` preceding each comment line, aligned on the first `*`.
1. Use code formatting (backticks) within comments for code from the source language, and also for QL code (for example, names of classes, predicates, and variables).
1. Give explanatory examples of code in the target language, enclosed in ```` ```<target language> ````  or `` ` ``.


### Language requirements

1. Use American English.
1. Use full sentences, with capital letters and periods, except for the initial sentence of the comment, which may be fragmentary as described below.
1. Use simple sentence structures and avoid complex or academic language.
1. Avoid colloquialisms and contractions.
1. Use words that are in common usage.


### Requirements for specific items

1. Public declarations must be documented.
1. Non-public declarations should be documented.
1. Declarations in query files should be documented.
1. Library files (`.qll` files) should have a documentation comment at the top of the file.
1. Query files, except for tests, must have a QLDoc query documentation comment at the top of the file.

## QLDoc for predicates

1. Refer to all predicate parameters in the predicate documentation.
1. Reference names, such as types and parameters, using backticks `` ` ``.
1. Give examples of code in the target language, enclosed in ```` ```<target language> ````  or `` ` ``.
1. Predicates that override a single predicate don't need QLDoc, as they will inherit it.

### Predicates without result

1. Use a third-person verb phrase of the form ``Holds if `arg` has <property>.``
1. Avoid:
   - `/** Whether ... */`
   - `/**" Relates ... */`
   - Question forms:
     - ``/** Is `x` a foo? */``
     - ``/** Does `x` have a bar? */``

#### Example

```ql
/**
 * Holds if the qualifier of this call has type `qualifierType`.
 * `isExactType` indicates whether the type is exact, that is, whether
 * the qualifier is guaranteed not to be a subtype of `qualifierType`.
 */
```

### Predicates with result

1. Use a third-person verb phrase of the form `Gets (a|the) <thing>.`
1. Use "if any" if the item is usually unique but might be missing. For example
`Gets the body of this method, if any.`
1. If the predicate has more complex behaviour, for example multiple arguments are conceptually "outputs", it can be described like a predicate without a result. For example
``Holds if `result` is a child of this expression.``
1. Avoid:
   - `Get a ...`
   - `The ...`
   - `Results in ...`
   - Any use of `return`

#### Example
```ql
/**
 * Gets the expression denoting the super class of this class,
 * or nothing if this is an interface or a class without an `extends` clause.
 */
```

### Deprecated predicates

The documentation for deprecated predicates should be updated to emphasize the deprecation and specify what predicate to use as an alternative.
Insert a sentence of the form `DEPRECATED: Use <other predicate> instead.` at the start of the QLDoc comment. 

#### Example

```ql
/** DEPRECATED: Use `getAnExpr()` instead. */
deprecated Expr getInitializer()
```

### Internal predicates

Some predicates are internal-only declarations that cannot be made private. The documentation for internal predicates should begin with `INTERNAL: Do not use.`

#### Example

```ql
/**
 * INTERNAL: Do not use.
 */
```

### Special predicates

Certain special predicates should be documented consistently.

- Always document `toString` as 
  
  ```ql
  /** Gets a textual representation of this element. */
  string toString() { ... } 
  ```

- Always document `hasLocationInfo` as

  ```ql
  /**
   * Holds if this element is at the specified location.
   * The location spans column `startcolumn` of line `startline` to
   * column `endcolumn` of line `endline` in file `filepath`.
   * For more information, see
   * [Locations](https://codeql.github.com/docs/writing-codeql-queries/providing-locations-in-codeql-queries/).
   */

  predicate hasLocationInfo(string filepath, int startline, int startcolumn, int endline, int endcolumn) { ... }
  ```

## QLDoc for classes

1. Document classes using a noun phrase of the form `A <domain element> that <has property>.`
1. Use "that", not "which".
1. Refer to member elements in the singular.
1. Where a class denotes a generic concept with subclasses, list those subclasses.

#### Example

```ql
/**
 * A delegate declaration, for example
 * ```
 * delegate void Logger(string text);
 * ```
 */
class Delegate extends ...
```

```ql
/**
 * An element that can be called.
 *
 * Either a method (`Method`), a constructor (`Constructor`), a destructor
 * (`Destructor`), an operator (`Operator`), an accessor (`Accessor`),
 * an anonymous function (`AnonymousFunctionExpr`), or a local function
 * (`LocalFunction`).
 */
class Callable extends ...
```

## QLDoc for modules

Modules should be documented using a third-person verb phrase of the form `Provides <classes and predicates to do something>.` 

#### Example

```ql
/** Provides logic for determining constant expressions. */
```
```ql
/** Provides classes representing the control flow graph within functions. */
```

## Special variables

When referring to `this`, you may either refer to it as `` `this` `` or `this <type>`. For example:
- ``Holds if `this` is static.``
- `Holds if this method is static.`

When referring to `result`, you may either refer to it as `` `result` `` or as `the result`. For example:
- ``Holds if `result` is a child of this expression.``
- `Holds if the result is a child of this expression.`



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/change-notes.md
# Adding change notes for query and library changes

Each CodeQL query pack or library pack has its own change log to track how that pack changes with each release. Any non-trivial, user-visible change to a query or library should add a change note to the affected pack. This document describes how to do that.

## Creating a change note
To create a new change note for a pack, create a new markdown file in the `change-notes` directory of the pack (e.g., in `cpp/ql/src/change-notes` for the C++ standard query pack). The markdown file must be named `YYYY-MM-DD-id.md`, where `YYYY-MM-DD` is the date of the change, and `id` is a short string to help identify the change. For example, if you were adding a new integer overflow query to the C++ standard query pack, you might do so from a branch named `int-overflow-query`, with a change note file named `cpp/ql/src/change-notes/2021-12-14-int-overflow-query.md`. Here are a few example change note files:

```yaml
---
category: newQuery
---
* Added a new query, `cpp/integer-overflow`, to detect code that depends on the result of signed integer overflow.
```

```yaml
---
category: fix
---
* Fixed a performance issue where the `cpp/integer-overflow` query would time out on large databases.
```

```yaml
---
category: minorAnalysis
---
* Added taint flow model for `std::codecvt`.
```

```yaml
---
category: majorAnalysis
---
* Added taint flow model for `std::string`.
```

### Metadata
The change note file requires some metadata at the beginning of the file. This metadata is later used to determine how to advance the version number of the pack next time it is published, and to group related change notes in the final changelog. The metadata is YAML, enclosed by a `---` line before and after.

The valid YAML properties in the metadata are:

- `category` - Required. This is a string that identifies one of a fixed set of categories that the change falls into. In the full changelog for the pack, the change notes for a particular release will be grouped together by category. The category also determines how this change will affect the version number of the pack's next release. For more information on available categories, see the Change Categories section below.
- `tags` - Optional. A list of string tags. These are not currently used by the change note infrastructure, so just omit this property.

### Description
After the `---` line following the metadata, the rest of the markdown file is the user-visible content of the change note. This should usually be a single markdown bullet list entry (starting with `*`), although it is acceptable to have multiple bullet entries in the same change note if there are multiple changes that are closely related and have the same category metadata.

For consistency, change notes should use American English.

## Change categories
Each change note must specify a `category` property in its metadata. This category servers two purposes: It determines how the change affects the version number of the next release of the pack, and it is used to group related changes in the final changelog. There is one set of available categories for query packs, and another set of available categories for library packs.

### Query pack change categories
| Category       | SemVer effect      | Description |
|----------------|--------------------|-------------|
| breaking       | major version bump | Any breaking change to the query pack, the most common of which is the deletion of an existing query. |
| deprecated     | minor version bump | An existing query has been marked as `deprecated`. |
| newQuery       | minor version bump | A new query has been added. |
| queryMetadata  | minor version bump | The metadata of a query has been changed (e.g., to increase or reduce the `@precision`). |
| majorAnalysis  | minor version bump | The set of results produced by a query has changed (fewer false positives, more true positives, etc.) enough to be noticed by users of the query pack. |
| minorAnalysis  | patch version bump | The set of results produced by a query has changed, but only in scenarios that affect relatively few users. |
| fix            | patch version bump | A fix that does not change the results reported by a query (e.g., a performance fix). |

### Library pack change categories
| Category       | SemVer effect      | Description |
|----------------|--------------------|-------------|
| breaking       | major version bump | Any breaking change to the library pack, the most common of which is the deletion of an existing API. |
| deprecated     | minor version bump | An existing API has been marked as `deprecated`. |
| feature        | minor version bump | A new library API has been added. |
| majorAnalysis  | minor version bump | An API has changed in a way that may affect the results produced by a query that consumes the API. |
| minorAnalysis  | patch version bump | An API has changed in a way that may affect the results produced by a query that consumes the API, but only in scenarios that affect relatively few users. |
| fix            | patch version bump | An API has been fixed in a way that is not likely to affect the results produced by a query that consumes the API. |

## How the final changelog is created
When a new release of a pack is published, the publishing process consolidates all of the change note files from that pack's `change-notes` directory into the pack's `CHANGELOG.md` file. The consolidation process does the following:

- Strips all metadata from each change note.
- Strips all leading and trailing blank lines from the description of each change note.
- Adds a newline at the end of the description of any change note that does not already end with a newline.
- Groups change notes by category.
- Adds a section to the changelog for each category that contains at least one change note. The section consists of a section heading followed by the contents of each change note in that category.
- Deletes the individual change note files.

## How change notes affect the version of the pack
When a new release of a pack is published, the pack's version number is advanced based on the categories of the changes in that version:
- If any change note has a SemVer effect of `major version bump`, then the version number's major component will be incremented (e.g., `1.4.5` -> `2.0.0`).
- Otherwise, if any change note has a SemVer effect of `minor version bump`, then the version number's minor component will be incremented (e.g., `1.4.5` -> `1.5.0`).
- Otherwise, the version number's patch component will be incremented (e.g., `1.4.5` -> `1.4.6`).
Thus, it is important to choose the correct category for each change note, so that users can rely on the pack's version number to indicate compatibility with previous versions of the pack.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/pre-commit-hook-setup.md
# CodeQL pre-commit-hook setup


As stated in [CONTRIBUTING](../CONTRIBUTING.md) all CodeQL files must be formatted according to our [CodeQL style guide](ql-style-guide.md). You can use a pre-commit hook to avoid committing incorrectly formatted code, as well as prevent some other easily checkable errors.

## Using the `pre-commit` framework

Preferably, you can use the [pre-commit framework](https://pre-commit.com/). There are some pre-commit hooks already configured on [`.pre-commit-config.yaml`](../.pre-commit-config.yaml). In order to install them you need to follow pre-commit's [installation instructions](https://pre-commit.com/#installation) and then run `pre-commit install`. Typically (assuming you have [`pip`](https://pip.pypa.io/en/stable/installation/) installed):
```
python3 -m pip install pre-commit
pre-commit install
```

Also, make sure that the CodeQL CLI has been added to your `PATH`.

By default, pre-commit will check and fix:
* trailing whitespaces;
* absence of or duplicate newlines at end of files;
* QL formatting;
* files out of sync (see [`config/sync-files.py`](../config/sync-files.py)).

It will additionally check:
* `.qhelp` files for query help generation.

It will run the checks only on files changed by the commit (except for the file sync check) and it will skip all files under `test` directories unless they are `.ql`, `.qll` or `.qlref` files.

If you want to change any behaviour (for example, you want to skip the out-of-sync file check, or you want to avoid auto-fixing formatting or file syncing), you can copy the configuration file to a separate location, modify it and use that. For example
```
cp .pre-commit-config.yaml ~/my-codeql-pre-commit-config.yaml
pre-commit install --config ~/my-codeql-pre-commit-config.yaml
# edit ~/my-codeql-pre-commit-config.yaml to your liking
```

You can for example:
* change `--in-place` to `--check-only` in the `codeql-format` hook to have it report formatting problems instead of auto-fixing them;
* remove `--latest` in the `sync-files` hook to do the same;
* remove any hook altogether.

## Manual approach

You can have the formatting check in place by copying the [pre-commit](../misc/scripts/pre-commit) script to `.git/hooks/pre-commit` and make sure that:

- The script is executable. On Linux and macOS this can be done using `chmod +x`.
- The CodeQL CLI has been added to your `PATH`.

The script will abort a commit that contains incorrectly formatted code in .ql or .qll files and print an error message like:

```
> git commit -m "My commit."
ql/cpp/ql/src/Options.qll would change by autoformatting.
ql/cpp/ql/src/printAst.ql would change by autoformatting.
```

If you prefer to have the script automatically format the code (and not abort the commit), you can replace the line `codeql query format --check-only` with `codeql query format --in-place` (and `exit $exitVal` with `exit 0`).



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/ql-design-patterns.md
# CodeQL Design Patterns

A list of design patterns you are recommended to follow.

## `::Range` for extensibility and refinement

To allow both extensibility and refinement of classes, we use what is commonly referred to as the `::Range` pattern (since https://github.com/github/codeql/pull/727), but the actual implementation can use different names.

This pattern should be used when you want to model a user-extensible set of values ("extensibility"), while allowing restrictive subclasses, typically for the purposes of overriding predicates ("refinement"). Using a simple `abstract` class gives you the former, but makes it impossible to create overriding methods for all contributing extensions at once. Using a non-`abstract` class provides refinement-based overriding, but requires the original class to range over a closed, non-extensible set.
<details>
<summary>Generic example of how to define classes with ::Range</summary>

Using a single `abstract` class looks like this:
```ql
/** <QLDoc...> */
abstract class MySpecialExpr extends Expr {
  /** <QLDoc...> */
  abstract int memberPredicate();
}
class ConcreteSubclass extends MySpecialExpr { ... }
```

While this allows users of the library to add new types of `MySpecialExpr` (like, in this case, `ConcreteSubclass`), there is no way to override the implementations of `memberPredicate` of all extensions at once.

Applying the `::Range` pattern yields the following:

```ql
/**
 * <QLDoc...>
 *
 * Extend this class to refine existing API models. If you want to model new APIs,
 * extend `MySpecialExpr::Range` instead.
 */
class MySpecialExpr extends Expr instanceof MySpecialExpr::Range {
  /** <QLDoc...> */
  int memberPredicate() { result = super.memberPredicate() }
}

/** Provides a class for modeling new <...> APIs. */
module MySpecialExpr {
  /**
   * <QLDoc...>
   *
   * Extend this class to model new APIs. If you want to refine existing API models,
   * extend `MySpecialExpr` instead.
   */
  abstract class Range extends Expr {
    /** <QLDoc...> */
    abstract int memberPredicate();
  }
}
```
Now, a concrete subclass can derive from `MySpecialExpr::Range` if it wants to extend the set of values in `MySpecialExpr`, and it will be required to implement the abstract `memberPredicate()`. Conversely, if it wants to refine `MySpecialExpr` and override `memberPredicate` for all extensions, it can do so by deriving from `MySpecialExpr` directly.

</details>

### Rationale

Let's use an example from the Python libraries: https://github.com/github/codeql/blob/46751e515c40c6b4c9b61758cc840eec1894a624/python/ql/lib/semmle/python/Concepts.qll#L601-L683

`Escaping`, as the name suggests, models various APIs that escape meta-characters. It has a member-predicate `getKind()` that tells you what sort of escaping the modeled function does. For example, if the result of that predicate is `"html"`, then this means that the escaping function is meant to make things safe to embed inside HTML.
`Escaping::Range` is subclassed to model various APIs, and `kind()` is implemented accordingly (this typically happens in library models).
But we can also subclass `Escaping`, as in the above example, where `HtmlEscaping` represents all HTML-escaping functions.

You can, of course, do the same without the `::Range` pattern, but it's a little cumbersome:
If you only had an `abstract class Escaping { ... }`, then `HtmlEscaping` would need to be implemented in a slightly tricky way to prevent it from extending `Escaping` (instead of refining it). You would have to give it a charpred `this instanceof Escaping`, which looks useless but isn't. And additionally, you'd have to provide trivial `none()` overrides of all the abstract predicates defined in `Escaping`. This is all pretty awkward, and we can avoid it by distinguishing between `Escaping` and `Escaping::Range`.


## Importing all subclasses of a class

Importing new files can modify the behaviour of the standard library, by introducing new subtypes of `abstract` classes, by introducing new multiple inheritance relationships, or by overriding predicates. This can change query results and force evaluator cache misses.

Therefore, unless you have good reason not to, you should ensure that all subclasses are included when the base-class is (to the extent possible).


## Abstract classes as open or closed unions

A class declared as `abstract` in QL represents a union of its direct subtypes (restricted by the intersections of its supertypes and subject to its characteristic predicate). Depending on context, we may want this union to be considered "open" or "closed".

An open union is generally used for extensibility. For example, the abstract classes suggested by the `::Range` design pattern are explicitly intended as extension hooks.

A closed union is a class for which we do not expect users of the library to add more values. Historically, we have occasionally modelled this as `abstract` classes in QL, but these days that would be considered an anti-pattern: Abstract classes that are intended to be closed behave in surprising ways when subclassed by library users, and importing libraries that include derived classes can invalidate compilation caches and subvert the meaning of the program.

As an example, suppose we want to define a `BinaryExpr` class, which has subtypes of `PlusExpr`, `MinusExpr`, and so on. Morally, this represents a closed union: We do not anticipate new kinds of `BinaryExpr` being added. Therefore, it would be undesirable to model it as an abstract class:

```ql
/** ANTI-PATTERN */
abstract class BinaryExpr extends Expr {
  Expr getLhs() { result = this.getChild(0) }
  Expr getRight() { result = this.getChild(1) }
}

class PlusExpr extends BinaryExpr {}
class MinusExpr extends BinaryExpr {}
...
```

Instead, the `BinaryExpr` class should be non-`abstract`, and we have the following options for specifying its extent:

- Define a dbscheme type `@binary_expr = @plus_expr | @minus_expr | ...` and add it as an additional super-class for `BinaryExpr`.
- Define a type alias `class RawBinaryExpr = @plus_expr | @minus_expr | ...` and add it as an additional super-class for `BinaryExpr`.
- Add a characteristic predicate of `BinaryExpr() { this instanceof PlusExpr or this instanceof MinusExpr or ... }`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/query-help-style-guide.md
# Query help style guide

## Introduction

When you contribute a new [supported query](supported-queries.md) to this repository, you should also write a query help file. This file provides detailed information about the purpose and use of the query, which is available on the query homepages:

* [C/C++ queries](https://codeql.github.com/codeql-query-help/cpp/)
* [C# queries](https://codeql.github.com/codeql-query-help/csharp/)
* [Go queries](https://codeql.github.com/codeql-query-help/go/)
* [Java queries](https://codeql.github.com/codeql-query-help/java/)
* [JavaScript queries](https://codeql.github.com/codeql-query-help/javascript/)
* [Python queries](https://codeql.github.com/codeql-query-help/python/)

### Location and file name

Query help files must have the same base name as the query they describe and must be located in the same directory.  

### File structure and layout

Query help files are written using a custom XML format, and stored in a file with a `.qhelp` extension. The basic structure is as follows:

```xml
<!DOCTYPE qhelp SYSTEM "qhelp.dtd">
<qhelp>
    CONTAINS one or more section-level elements
</qhelp>
```

The header and single top-level `<qhelp>` element are both mandatory.

### Section-level elements

Section-level elements are used to group the information within the query help file. All query help files should include at least the following section elements, in the order specified:

1. `overview`—a short summary of the issue that the query identifies, including an explanation of how it could affect the behavior of the program.
2. `recommendation`—information on how to fix the issue highlighted by the query.
3. `example`—an example of code showing the problem. Where possible, this section should also include a solution to the issue.
4. `references`—relevant references, such as authoritative sources on language semantics and best practice.

For further information about the other section-level, block, list and table elements supported by query help files, see [Query help files](https://codeql.github.com/docs/writing-codeql-queries/query-help-files/) on codeql.github.com.


## English style

You should write the overview and recommendation elements in simple English that is easy to follow. You should:

* Use simple sentence structures and avoid complex or academic language.
* Avoid colloquialisms and contractions.
* Use US English spelling throughout.
* Use words that are in common usage.

## Code examples

Whenever possible, you should include a code example that helps to explain the issue you are highlighting. Any code examples that you include should adhere to the following guidelines:

* The example should be less than 20 lines, but it should still clearly illustrate the issue that the query identifies.  If appropriate, then the example may also be runnable.
* Put the code example after the recommendation element where possible. Only include an example in the description element if absolutely necessary.
* If you are using an example to illustrate the solution to a problem, and the change required is minor, avoid repeating the whole example. It is preferable to either describe the change required or to include a smaller snippet of the corrected code.
* Clearly indicate which of the samples is an example of bad coding practice and which is recommended practice.
* Define the code examples in `src` files. The language is inferred from the file extension:

  ```xml
  <example>
  <p>This example highlights poor coding practice</p>

  <sample src = "example-code-bad.java" />

  <p>This example shows how to fix the code</p>

  <sample src = "example-code-fixed.java" />
  </example>
  ```

Note, if any code words are included in the `overview` and `recommendation` sections, they should be formatted with `<code> ... </code>` for emphasis.

## Including references

You should include one or more references, list formatted with `<li> ... </li>` for each item, to provide further information about the problem that your query is designed to find. References can be of the following types:

### Books

If you are citing a book, use the following format:

>\<Author-initial. Surname>, _\<Book title>_ \<page/chapter etc.\>, \<Publisher\>, \<date\>.

For example:

>W. C. Wake, _Refactoring Workbook_, pp. 93 – 94, Addison-Wesley Professional, 2004.

Note, & symbols need to be replaced by \&amp;. The symbol will be displayed correctly in the HTML files generated from the query help files.

### Academic papers

If you are citing an academic paper, we recommend adopting the reference style of the journal that you are citing. For example:

>S. R. Chidamber and C. F. Kemerer, _A metrics suite for object-oriented design_. IEEE Transactions on Software Engineering, 20(6):476-493, 1994.


### Websites

If you are citing a website, please use the following format, without breadcrumb trails:

>\<Name of website>: \<Name of page or anchor>

For example:

>Java API Specification: [Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone()).

### Referencing potential security weaknesses

If your query checks code for a CWE weakness, you should use the `@tags` element in the query file to reference the associated CWEs, as explained [here](query-metadata-style-guide.md). When you use these tags, a link to the appropriate entry from the [MITRE.org](https://cwe.mitre.org/scoring/index.html) site will automatically appear as a reference in the output HTML file.

## Validating qhelp files

Before making a pull request, please ensure the `.qhelp` files are well-formed and can be generated without errors. This can be done locally with the CodeQL CLI, as shown in the following example:

```bash
# codeql generate query-help <path_to_your_qhelp_file> --format=<format>
# For example:
codeql generate query-help ./myCustomQuery.qhelp --format=markdown
```


Please include the `.qhelp` files (and any associated code snippets) in your pull request, but do not commit the generated Markdown.

More information on how to test your `.qhelp` files can be found [within the documentation](https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/testing-query-help-files)

## Query help example

The following example is a query help file for a query from the standard query suite for Java:

```xml
<!DOCTYPE qhelp PUBLIC
  "-//Semmle//qhelp//EN"
  "qhelp.dtd">
<qhelp>

<overview>
<p>A control structure (an <code>if</code> statement or a loop) has a body that is either a block
of statements surrounded by curly braces or a single statement.</p>

<p>If you omit braces, it is particularly important to ensure that the indentation of the code
matches the control flow of the code.</p>

</overview>
<recommendation>

<p>It is usually considered good practice to include braces for all control
structures in Java. This is because it makes it easier to maintain the code
later. For example, it's easy to see at a glance which part of the code is in the
scope of an <code>if</code> statement, and adding more statements to the body of the <code>if</code>
statement is less error-prone.</p>

<p>You should also ensure that the indentation of the code is consistent with the actual flow of 
control, so that it does not confuse programmers.</p>

</recommendation>
<example>

<p>In the example below, the original version of <code>Cart</code> is missing braces. This means 
that the code triggers a <code>NullPointerException</code> at runtime if <code>i</code>
is <code>null</code>.</p>

<sample src="UseBraces.java" />

<p>The corrected version of <code>Cart</code> does include braces, so
that the code executes as the indentation suggests.</p>

<sample src="UseBracesGood.java" />

<p>
In the following example the indentation may or may not be misleading depending on your tab width
settings. As such, mixing tabs and spaces in this way is not recommended, since what looks fine in
one context can be very misleading in another.
</p>

<sample src="UseBraces2.java" />

<p>
If you mix tabs and spaces in this way, then you might get seemingly false positives, since your
tab width settings cannot be taken into account.
</p>

</example>
<references>

<li>
  Java SE Documentation:
  <a href="https://www.oracle.com/java/technologies/javase/codeconventions-statements.html#15395">Compound Statements</a>.
</li>
<li>
  Wikipedia:
  <a href="https://en.wikipedia.org/wiki/Indentation_style">Indentation style</a>.
</li>

</references>
</qhelp>
```



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/experimental.md
# Experimental CodeQL queries and libraries

In addition to [our supported queries and libraries](supported-queries.md), this repository also contains queries and libraries of a more experimental nature. Experimental queries and libraries can be improved incrementally and may eventually reach a sufficient maturity to be included in our supported queries and libraries.

Experimental security queries are included in the `experimental` [CodeQL suite](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs). This suite is provided for testing purposes only, and should not be used in production code scanning workflows. 

Experimental queries and libraries may not be actively maintained as the [supported](supported-queries.md) libraries evolve. They may also be changed in backwards-incompatible ways or may be removed entirely in the future without deprecation warnings.

See [CONTRIBUTING.md](../CONTRIBUTING.md) for guidelines on submitting a new experimental query.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/ql-style-guide.md
# CodeQL style guide

## Introduction

This document describes how to format the code you contribute to this repository. It covers aspects such as layout, white-space, naming, and documentation. Adhering to consistent standards makes code easier to read and maintain. Of course, these are only guidelines, and can be overridden as the need arises on a case-by-case basis. Where existing code deviates from these guidelines, prefer consistency with the surrounding code.
Note, if you use [CodeQL for Visual Studio Code](https://docs.github.com/en/code-security/codeql-for-vs-code/), you can autoformat your query in the editor.

Words in *italic* are defined in the [Glossary](#glossary).

## Indentation
1. *Always* use 2 spaces for indentation.
1. *Always* indent:
   - The *body* of a module, newtype, class or predicate
   - The second and subsequent lines after you use a line break to split a long line
   - The *body* of a `from`, `where` or `select` clause where it spans multiple lines
   - The *body* of a *quantifier* that spans multiple lines


### Examples

```ql
module Helpers {
  /** ... */
  class X ... {
    /** ... */
    int getNumberOfChildren () {
      result = count(int child |
        exists(this.getChild(child))
      )
    }
  }
}
```

```ql
from Call c, string reason
where isDeprecated(c, reason)
select c, "This call to '$@' is deprecated because " + reason + ".",
  c.getTarget(), c.getTarget().getName()
```

## Line breaks
1. Use UNIX line endings.
1. Lines *must not* exceed 100 characters.
1. Long lines *should* be split with a line break, and the following lines *must* be indented one level until the next "regular" line break.
1. There *should* be a single blank line:
   - Between the file documentation and the first `import`
   - Before each declaration, except for the first declaration in a *body*
   - Before the `from`-`where`-`select` section in a query file
1. *Avoid* two or more adjacent blank lines.
1. There *must* be a new line after the *annotations* `cached`, `pragma`, `language` and `bindingset`. Other *annotations* do not have a new line.
1. There *should not* be additional blank lines within a predicate.
1. There *may* be a new line:
   - Immediately after the `from`, `where` or `select` keywords in a query.
   - Immediately after `if`, `then`, or `else` keywords.
1. *Avoid* other line breaks in declarations, other than to break long lines.
1. When operands of *binary operators* span two lines, the operator *should* be placed at the end of the first line.
1. If the parameter list needs to be broken across multiple lines then there *must* be a line break after the opening `(`, the parameter declarations indented one level, and the `) {` *must* be on its own line at the outer indentation.

### Examples

```ql
cached
private int getNumberOfParameters() {
  ...
}
```

```ql
predicate methodStats(
  string qualifiedName, string name, int numberOfParameters,
  int numberOfStatements, int numberOfExpressions, int linesOfCode,
  int nestingDepth, int numberOfBranches
) {
  ...
}
```

```ql
from Method main
where main.getName() = "Main"
select main, "This is the program entry point."
```

```ql
from Method main
where
  main.getName() = "Main" and
  main.getNumberOfParameters() = 0
select main, "Main method has no parameters."
```

```ql
  if x.isPublic()
  then result = "public"
  else result = "private"
```

```ql
  if
    x.isPublic()
  then
    result = "public"
  else
    result = "private"
```

```ql
  if x.isPublic()
  then result = "public"
  else
    if x.isPrivate()
    then result = "private"
    else result = "protected"
```


## Braces
1. Braces follow [Stroustrup](https://en.wikipedia.org/wiki/Indentation_style#Variant:_Stroustrup) style. The opening `{` *must* be placed at the end of the preceding line.
1. The closing `}` *must* be placed on its own line, indented to the outer level, or be on the same line as the opening `{`.
1. Braces of empty blocks *may* be placed on a single line, with a single space separating the braces.
1. Short predicates, not exceeding the maximum line width, *may* be placed on a single line, with a space following the opening brace and preceding the closing brace.

### Examples

```ql
class ThrowException extends ThrowExpr {
  Foo() {
    this.getTarget() instanceof ExceptionClass
  }

  override string toString() { result = "Throw Exception" }
}
```

## Spaces
1. There *must* be a space or line break:
   - Surrounding each `=` and `|`
   - After each `,`
1. There *should* be a space or line break:
   - Surrounding each *binary operator*, which *must* be balanced
   - Surrounding `..` in a range
   - Exceptions to this may be made to save space or to improve readability.
1. *Avoid* other spaces, for example:
   - After a *quantifier/aggregation* keyword
   - After the predicate name in a *call*
   - Inside brackets used for *calls*, single-line quantifiers, and parenthesised formulas
   - Surrounding a `.`
   - Inside the opening or closing `[ ]` in a range expression
   - Inside casts `a.(X)`
1. *Avoid* multiple spaces, except for indentation, and *avoid* additional indentation to align formulas, parameters or arguments.
1. *Do not* put whitespace on blank lines, or trailing on the end of a line.
1. *Do not* use tabs.


### Examples

```ql
cached
private predicate foo(Expr e, Expr p) {
  exists(int n |
    n in [0 .. 1] |
    e = p.getChild(n + 1)
  )
}
```

## Naming
1. Use [PascalCase](https://wiki.c2.com/?PascalCase) for:
   - `class` names
   - `module` names
   - `newtype` names
1. Use [camelCase](https://en.wikipedia.org/wiki/Camel_case) for:
   - Predicate names
   - Variable names
1. Acronyms *should* use normal PascalCase/camelCase. However, two-letter acronyms should have both letters capitalized.
1. Newtype predicate names *should* begin with `T`.
1. Predicates that have a result *should* be named `get...`
1. Predicates that can have multiple results *should* be named `getA...` or `getAn...`
1. Predicates that don't have a result or parameters *should* be named `is...` or `has...`
1. *Avoid* underscores in names.
1. *Avoid* short or single-letter names for classes, predicates and fields.
1. Short or single letter names for parameters and *quantifiers* *may* be used provided that they are sufficiently clear.
1. Use names as they are used in the target-language specification.
1. Use American English.


### Examples

```ql
/** ... */
predicate calls(Callable caller, Callable callee) {
  ...
}
```

```ql
/** ... */
class Type extends ... {
  /** ... */
  string getName() { ... }

  /** ... */
  predicate declares(Member m) { ... }

  /** ... */
  predicate isGeneric() { ... }

  /** ... */
  Type getTypeParameter(int n) { ... }

  /** ... */
  Type getATypeParameter() { ... }
  
  /** Gets the SSA variable ... */
  predicate getSsaVariable() { ... }
}
```

## Documentation

For more information about documenting the code that you contribute to this repository, see the [QLDoc style guide](qldoc-style-guide.md).

## Formulas
1. *Prefer* one *conjunct* per line.
1. Write the `and` at the end of the line. This also applies in `where` clauses.
1. *Prefer* to write the `or` keyword on its own line.
1. The `or` keyword *may* be written at the end of a line, or within a line, provided that it has no `and` operands.
1. Single-line formulas *may* be used in order to save space or add clarity, particularly in the *body* of a *quantifier/aggregation*.
1. *Always* use brackets to clarify the precedence of:
   - `implies`
   - `if`-`then`-`else`
1. *Avoid* using brackets to clarify the precedence of:
   - `not`
   - `and`
   - `or`
1. Parenthesised formulas *can* be written:
   - Within a single line. There *should not* be an additional space following the opening parenthesis or preceding the closing parenthesis.
   - Spanning multiple lines. The opening parenthesis *should* be placed at the end of the preceding line, the body should be indented one level, and the closing bracket should be placed on a new line at the outer indentation.
1. *Quantifiers/aggregations* *can* be written:
   - Within a single line. In this case, there is no space to the inside of the parentheses, or after the quantifier keyword.
   - Across multiple lines. In this case, type declarations are on the same line as the quantifier with the first `|` at the same line as the quantifier, the second `|` *must* be at the end of the same line as the quantifier or on its own line at the outer indentation, and the body of the quantifier *must* be indented one level. The closing `)` is written on a new line, at the outer indentation. If the type declarations need to be broken across multiple lines then there must *must* be a line break after the opening `(`, the type declarations indented one level, and the first `|` on its own line at the outer indentation.
1. `if`-`then`-`else` *can* be written:
   - On a single line
   - With the *body* after the `if`/`then`/`else` keyword
   - With the *body* indented on the next line
   - *Always* parenthesise the `else` part if it is a compound formula.
1. If an `if`-`then`-`else` is broken across multiple lines then the `then` and `else` keywords *should* be at the start of lines aligned with the `if`.
1. The `and` and `else` keywords *may* be placed on the same line as the closing parenthesis.
1. The `and` and `else` keywords *may* be "cuddled": `) else (`
1. *Always* qualify *calls* to predicates of the same class with `this`.
1. *Prefer* postfix casts `a.(Expr)` to prefix casts `(Expr)a`.

### Examples

```ql
  argumentType.isImplicitlyConvertibleTo(parameterType)
  or
  argumentType instanceof NullType and
  result.getParameter(i).isOut() and
  parameterType instanceof SimpleType
  or
  reflectionOrDynamicArg(argumentType, parameterType)
```

```ql
  this.getName() = "Finalize" and not exists(this.getAParameter())
```

```ql
  e1.getType() instanceof BoolType and (
    b1 = true
    or
    b1 = false
  ) and (
    b2 = true
    or
    b2 = false
  )
```

```ql
  if e1 instanceof BitwiseOrExpr or e1 instanceof LogicalOrExpr
  then (
    impliesSub(e1.(BinaryOperation).getAnOperand(), e2, b1, b2) and
    b1 = false
  ) else (
    e1.getType() instanceof BoolType and
    e1 = e2 and
    b1 = b2 and
    (b1 = true or b1 = false)
  )
```

```ql
  (x instanceof Exception implies x.isPublic()) and y instanceof Exception
```

```ql
  x instanceof Exception implies (x.isPublic() and y instanceof Exception)
```

```ql
  exists(Type arg | arg = this.getAChild() | arg instanceof TypeParameter)
```


```ql
  exists(Type qualifierType |
    this.hasNonExactQualifierType(qualifierType)
  |
    result = getANonExactQualifierSubType(qualifierType)
  )
```

```ql
  methods = count(Method m | t = m.getDeclaringType() and not ilc(m))
```

```ql
  if n = 0 then result = 1 else result = n * f(n - 1)
```

```ql
  if n = 0
  then result = 1
  else result = n * f(n - 1)
```

```ql
  if
    n = 0
  then
    result = 1
  else
    result = n * f(n - 1)
```

```ql
  if exists(this.getContainingType())
  then (
    result = "A nested class" and
    parentName = this.getContainingType().getFullyQualifiedName()
  ) else (
    result = parentName + "." + this.getName() and
    parentName = this.getNamespace().getFullyQualifiedName()
  )
```

## Glossary

| Phrase      | Meaning  |
|-------------|----------|
| *[annotation](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#annotations)* | An additional specifier used to modify a declaration, such as `private`, `override`, `deprecated`, `pragma`, `bindingset`, or `cached`. |
| *body* | The text inside `{ }`, `( )`, or each section of an `if`-`then`-`else` or `from`-`where`-`select`. |
| *binary operator* | An operator with two operands, such as comparison operators, `and`, `or`, `implies`, or arithmetic operators. |
| *call* | A *formula* that invokes a predicate, e.g. `this.isStatic()` or `calls(a,b)`. |
| *[conjunct](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#conjunctions)* | A formula that is an operand to an `and`. |
| *declaration* | A class, module, predicate, field or newtype. |
| *[disjunct](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#disjunctions)* | A formula that is an operand to an `or`. |
| *[formula](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#formulas)* | A logical expression, such as `A = B`, a *call*, a *quantifier*, `and`, `or`, `not`, `in` or `instanceof`. |
| *should/should not/avoid/prefer* | Adhere to this rule wherever possible, where it makes sense. |
| *may/can* | This is a reasonable alternative, to be used with discretion. |
| *must/always/do not* | Always adhere to this rule. |
| *[quantifier/aggregation](https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#aggregations)* | `exists`, `count`, `strictcount`, `any`, `forall`, `forex` and so on. |
| *variable* | A parameter to a predicate, a field, a from variable, or a variable introduced by a *quantifier* or *aggregation*. |



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/prepare-db-upgrade.md
# Upgrading a language database schema

When a `.dbscheme` file changes, you need to provide two things:

1. An upgrade script that modifies old databases (built against an earlier schema), so they can use new query functionality (albeit with possibly degraded results).
2. A downgrade script that reverses those changes, so that newer databases can be queried using older query and library packs.

This document explains how to write or generate those scripts.

## Process Overview

 1. Commit the change to your language's `.dbscheme` file, along with any library updates required to work with the change.
 2. Run `misc/scripts/prepare-db-upgrade.sh --lang <lang>`. This will generate skeleton upgrade/downgrade scripts in the appropriate directories.
 3. Fill in the details in the two `upgrade.properties` files that it generated, and add any required upgrade queries.

It may be helpful to look at some of the existing upgrade/downgrade scripts, to see how they work.

## Details

An `upgrade.properties` file will look something like:

```
description: what it does
compatibility: partial
some_relation.rel: run some_relation.qlo
```

The `description` field is a textual description of the aim of the upgrade.

The `compatibility` field takes one of four values:

 * **full**: results from the upgraded snapshot will be identical to results from a snapshot built with the new version of the toolchain.

 * **backwards**: the step is safe and preserves the meaning of the old database, but new features may not work correctly on the upgraded snapshot.

 * **partial**: the step is safe and preserves the meaning of the old database, but you would get better results if you rebuilt the snapshot with the new version of the toolchain.

 * **breaking**: the step is unsafe and will prevent certain queries from working.

The `some_relation.rel` line(s) are the actions required to perform the database upgrade. Do a diff on the new vs old `.dbscheme` file to get an idea of what they have to achieve. Sometimes you won't need any upgrade commands – this happens when the dbscheme has changed in "cosmetic" ways, for example by adding/removing comments or changing union type relationships, but still retains the same on-disk format for all tables; the purpose of the upgrade script is then to document the fact that it's safe to replace the old dbscheme with the new one.

Ideally, your downgrade script will perfectly revert the changes applied by the upgrade script, such that applying the upgrade and then the downgrade will result in the same database you started with.

Some typical upgrade commands look like this:

```
// Delete a relation that has been replaced in the new scheme
obsolete.rel: delete

// Create a new version of a table by applying an expression (using a simple
// synthetic language) to an existing table. The example duplicates the 'id'
// column of input.rel as the last column of extended.rel, perhaps to record our
// best guess at newly-populated "source declaration" information.
extended.rel: reorder input.rel (int id, string name, int parent) id name parent id

// Create relationname.rel by running relationname.qlo and writing the query
// results as a .rel file. The query file should be named relationname.ql and
// should be placed in the upgrade directory. It should avoid using the default
// QLL library, and will run in the context of the *old* dbscheme.
relationname.rel: run relationname.qlo

// Create relationname.rel by running the query predicate 'predicatename' in
// relationname.qlo and writing the query results as a .rel file. This command
// expects the upgrade relation to be a query predicate, which has the advantage
// of allowing multiple upgrade relations to appear in the same .ql file as
// multiple query predicates. The query file should be named relationname.ql and
// should be placed in the upgrade directory. It should avoid using the default
// QLL library, and will run in the context of the *old* dbscheme.
relationname.rel: run relationname.qlo predicatename
```

### Testing your scripts

Although we have some automated testing of the scripts (e.g. to test that you can upgrade databases all the way from an initial dbscheme to the newest, and back), it's essential that you apply some more rigorous testing for any non-trivial upgrade or downgrade. You might do so as follows:

#### Running qltests

To test the upgrade script, run:

```
codeql test run --search-path=<old-extractor-pack> --search-path=<codeql-root> <test-dir>
```

Where `<old-extractor-pack>` is an extractor pack containing the old extractor and dbscheme that pre-date your changes, `<test-dir>` is the directory containing the qltests for your language, and `<codeql-root>` is the root directory directory of the `github/codeql` clone that contains `<test-dir>`. This will run the tests using an old extractor, and the test databases will all be upgraded in place using your new upgrade script.

To test the downgrade script, create an extractor pack that includes your new dbscheme and extractor changes. Then checkout the `main` branch of `codeql` (i.e. a branch that does not include your changes), and run:

```
codeql test run --search-path=<new-extractor-pack> <test-dir>
```

This will run the tests using your new extractor, and the databases will be downgraded using your new downgrade script so that they match the dbscheme of the `main` branch.

#### Manual testing

You might also choose to test with a real-world database.

 1. Create a snapshot of your favourite project using the old version of the code.

 2. Switch to the new version of the code.

 3. Try to run some queries that will depend on your upgrade script working correctly.

 4. Observe the upgrade being performed in the query server log.

 5. Verify that your queries produced sensible results.

#### Doing the upgrade manually

To create the upgrade directory manually, without using `prepare-db-upgrade.sh`:

1. Get a hash of the old `.dbscheme` file from `main` (i.e. from just before your changes). You can do this by checking out the code prior to your changes and running `git hash-object ql/lib/<mylang>.dbscheme`

2. Go back to your branch and create an upgrade directory with that hash as its name, for example:
```
mkdir ql/lib/upgrades/454f1e15151422355049dc4f1f0486a03baeffef
```


3. Copy the old `.dbscheme` file to that directory, using the name old.dbscheme.

```
cp ql/lib/<mylang>.dbscheme ql/lib/upgrades/454f1e15151422355049dc4f1f0486a03baeffef/old.dbscheme
```

4. Put a copy of your new `.dbscheme` file in that directory and create an `upgrade.properties` file (as described above).

#### Doing the downgrade manually

The process is similar for downgrade scripts, but there is a reversal in terminology: your **new** dbscheme will now be the one called `old.dbscheme`.

1. Get a hash of your new `.dbscheme` file, with `git hash-object ql/lib/<mylang>.dbscheme`

2. Create a downgrade directory with that hash as its name, for example:
```
mkdir downgrades/9fdd1d40fd3c3f8f9db8fabf5a353580d14c663a
```

3. Copy your new `.dbscheme` file to that directory, using the name `old.dbscheme`.
```
cp ql/lib/<mylang>.dbscheme ql/lib/upgrades/454f1e15151422355049dc4f1f0486a03baeffef/old.dbscheme
```

4. Put a copy of the `.dbscheme` from `main` in that directory and create an `upgrade.properties` file that performs the downgrade (as described above).

### Debugging your scripts

Database upgrade/downgrade may fail for several reasons. To find out the exact issue it is recommended to rerun the `codeql test run` commands from above in a verbose mode, e.g. `codeql test run -vvvv ...`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/supported-queries.md
# Supported CodeQL queries and libraries

Queries and libraries outside [the `experimental` directories](experimental.md) are _supported_ by GitHub, allowing our users to rely on their continued existence and functionality in the future:

1. Once a query or library has appeared in a stable release, a one-year deprecation period is required before we can remove it. There can be exceptions to this when it's not technically possible to mark it as deprecated.
2. Major changes to supported queries and libraries are always announced in the [change notes for stable releases](../change-notes/).
3. We will do our best to address user reports of false positives or false negatives.

Because of these commitments, we set a high bar for accepting new supported queries. The requirements are detailed in the rest of this document.

## Steps for introducing a new supported query

The process must begin with the first step and must conclude with the final step. The remaining steps can be performed in any order.

1. **Have the query merged into the appropriate `experimental` subdirectory**

   See [CONTRIBUTING.md](../CONTRIBUTING.md).

2. **Write a query help file**

   Query help files explain the purpose of your query to other users. Write your query help in a `.qhelp` file and save it in the same directory as your query. For more information on writing query help, see the [Query help style guide](query-help-style-guide.md).

   - Note, in particular, that almost all queries need to have a pair of "before" and "after" examples demonstrating the kind of problem the query identifies and how to fix it. Make sure that the examples are actually consistent with what the query does, for example by including them in your unit tests. Examples must be original, not copied from third-party sources.
   - At the time of writing, there is no way of previewing help locally. Once you've opened a PR, a preview will be created as part of the CI checks. A GitHub employee will review this and let you know of any problems.

3. **Write unit tests**

   Add one or more unit tests for the query (and for any library changes you make) to the `ql/<language>/ql/test/experimental` directory. Tests for library changes go into the `library-tests` subdirectory, and tests for queries go into `query-tests` with their relative path mirroring the query's location under `ql/<language>/ql/src/experimental`.

   - See the section on [Testing custom queries](https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/testing-custom-queries) in the [CodeQL CLI documentation](https://docs.github.com/en/code-security/codeql-cli) for more information.
   - See [C/C++ CodeQL tests](/cpp/ql/test/README.md) for more information about contributing tests for C/C++ queries in particular.

4. **Test for correctness on real-world code**

   Test the query on a number of large real-world projects to make sure it doesn't give too many false positive results. Adjust the `@precision` and `@problem.severity` attributes in accordance with the real-world results you observe. See the advice on query metadata below.

   GitHub is running a private beta test of a new feature for testing CodeQL queries at scale from VS Code. To request access to the beta program, please respond to this [GitHub Discussion](https://github.com/orgs/community/discussions/40453).
   
5. **Test and improve performance**

   There must be a balance between the execution time of a query and the value of its results: queries that are highly valuable and broadly applicable can be allowed to take longer to run. In all cases, you need to address any easy-to-fix performance issues before the query is put into production.

   QL performance profiling and tuning is an advanced topic, and some tasks will require assistance from GitHub employees. With that said, there are several things you can do.

   - Understand [the evaluation model of QL](https://codeql.github.com/docs/ql-language-reference/evaluation-of-ql-programs/). It's more similar to SQL than to any mainstream programming language.
   - Most performance tuning in QL boils down to computing as few tuples (rows of data) as possible. As a mental model, think of predicate evaluation as enumerating all combinations of parameters that satisfy the predicate body. This includes the implicit parameters `this` and `result`.
   - The major libraries in CodeQL are _cached_ and will only be computed once for the entire suite of queries. The first query that needs a cached _stage_ will trigger its evaluation. This means that query authors should usually only look at the run time of the last stage of evaluation.
   - In [the settings for the VSCode extension](https://docs.github.com/en/code-security/codeql-for-vs-code/using-the-advanced-functionality-of-the-codeql-for-vs-code-extension/customizing-settings/), check the box "Running Queries: Debug" (`codeQL.runningQueries.debug`). Then find "CodeQL Query Server" in the VSCode Output panel (View -> Output) and capture the output when running the query. That output contains timing and tuple counts for all computed predicates.
   - To clear the entire cache, invoke "CodeQL: Clear Cache" from the VSCode command palette.

6. **Make sure your query has the correct metadata**

   For the full reference on writing query metadata, see the [Query metadata style guide](query-metadata-style-guide.md). The following constitutes a checklist.

   a. Each query needs a `@name`, a `@description`, and a `@kind`.

   b. Alert queries also need a `@problem.severity` and a `@precision`.

      - The severity is one of `error`, `warning`, or `recommendation`.
      - The precision is one of `very-high`, `high`, `medium` or `low`. It may take a few iterations to get this right.

   c. All queries need an `@id`.

      - The ID should be consistent with the ids of similar queries for other languages; for example, there is a C/C++ query looking for comments containing the word "TODO" which has id `cpp/todo-comment`, and its C# counterpart has id `cs/todo-comment`.

   d. Provide one or more `@tags` describing the query.

      - Tags are free-form, but we have some conventions. At a minimum, most queries should have at least one of `correctness`, `maintainability` or `security` to indicate the general kind of issue the query is intended to find. Security queries should also be tagged with corresponding [CWE](https://cwe.mitre.org/data/definitions/1000.html) numbers, for example `external/cwe/cwe-119` (prefer the most specific CWE that encompasses the target of the query).

7. **Move your query out of `experimental`**

   - The structure of an `experimental` subdirectory mirrors the structure of its parent directory, so this step may just be a matter of removing the `experimental/` prefix of the query and test paths. Be sure to also edit any references to the query path in tests.
   - Add the query to one of the legacy suite files in `ql/<language>/config/suites/<language>/` if it exists. Note that there are separate suite directories for C and C++, `c` and `cpp` respectively, and the query should be added to one or both as appropriate.
   - Add a release note to `change-notes/<next-version>/analysis-<language>.md`.
   - Your pull request will be flagged automatically for a review by the documentation team to ensure that the query help file is ready for wider use.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/contents.rst
CodeQL documentation
====================

.. toctree::
   :includehidden:
   :maxdepth: 3

   codeql-overview/index
   writing-codeql-queries/index
   codeql-language-guides/index
   ql-language-reference/index



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/CONTRIBUTING.md
# Contributing to CodeQL docs

We welcome contributions to our CodeQL docs. Want to improve existing docs or add new information you think would be helpful? Then please go ahead and open a pull request!

## Contributing to CodeQL docs on `codeql.github.com`

To make changes to the documentation on [codeql.github.com](https://codeql.github.com/docs/codeql-overview/), you can make changes to the documentation files using the GitHub UI, a codespace, or a local text editor, and then open a pull request for review. For more information about the format and structure of the CodeQL documentation on [codeql.github.com](https://codeql.github.com/docs/codeql-overview/), please see the [README](README.rst).

## Contributing to CodeQL CLI docs on `docs.github.com`

We have moved documentation about the CodeQL CLI from [github/codeql](docs/codeql) to the public [github/docs](https://github.com/github/docs) repository so that this documentation is published on the [GitHub Docs](https://docs.github.com/en/code-security/codeql-cli) site. This includes all articles that were under the "[Using the CodeQL CLI](https://codeql.github.com/docs/codeql-cli/using-the-codeql-cli/)" and "[CodeQL CLI reference](https://codeql.github.com/docs/codeql-cli/codeql-cli-reference/)" categories on the CodeQL microsite. This will make it easier for code scanning users to find information about using CodeQL to query their codebases.

To contribute to these docs, which are located in the [`codeql-cli`](https://github.com/github/docs/tree/main/content/code-security/codeql-cli) directory, please refer to the [CONTRIBUTING.md](https://github.com/github/docs/blob/main/CONTRIBUTING.md) file in the `docs` repository.






# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/README.rst
CodeQL documentation
####################

Overview
********

The CodeQL documentation in this repository is written in reStructuredText and converted to
HTML using Sphinx. 

For more information on writing in reStructuredText, 
see https://docutils.sourceforge.io/rst.html.

For more information on Sphinx, see https://www.sphinx-doc.org.

For information on contributing to CodeQL documentation, see the `contributing guide </CONTRIBUTING.md>`__.

Project structure
*****************

The project contains:

- an ``index.html`` file, the project's 
  `master document <https://www.sphinx-doc.org/en/master/glossary.html#term-master-document>`__.
- a ``conf.py`` file that defines some project-specific configuration values
- the reStructuredText source files

The documentation consists of the following categories:

- CodeQL overview
- Writing CodeQL queries
- CodeQL language guides
- QL language reference
- CodeQL CLI
- CodeQL for Visual Studio Code

The ``ql-training`` project contains the source files, themes, and static files 
used to generate the CodeQL training and variant analysis presentations. 
It uses a different configuration from the other projects, and is built using an 
extension specifically designed for HTML slide shows. 
For more information, see  
**Building and previewing the CodeQL training presentations** below.


Building and previewing the CodeQL documentation
************************************************

To build and preview the documentation and training presentations locally, you need to
install Sphinx 1.7.9 using Python 2 (for example: `pip install sphinx==1.7.9`).
More recent versions of Sphinx do not work with hieroglyph,
the Sphinx extension that we use to generate HTML slides, as explained below.
For installation options, see https://github.com/sphinx-doc/sphinx.


Using ``sphinx-build``
----------------------

After installing Sphinx, you can build the HTML files for a project by running 
`sphinx-build <https://www.sphinx-doc.org/en/master/man/sphinx-build.html>`__
from the project's 
`source directory <https://www.sphinx-doc.org/en/master/glossary.html#term-source-directory>`__. 
For example, to generate the HTML output for a project in the
``<docs-output>`` directory you would use:

.. code::

  sphinx-build -b html . <docs-output>

..
 
  Add the ``-W`` flag to turn *warnings* into *errors* during the build process. 
  You can use errors reported during the build to debug problems in your source 
  code, such as broken internal links and malformed tables. You can also check 
  external links using Sphinx's `external link builder 
  <http://www.sphinx-doc.org/en/master/usage/builders/index.html#sphinx.builders.linkcheck.CheckExternalLinksBuilder>`__.

  Add the ``-a`` flag to regenerate all output files. By default, only files that 
  have changed are rebuilt.
  
Using the reStructuredText Extension for Visual Studio Code
-----------------------------------------------------------

Visual Studio Code has an extension that can be used to preview Sphinx-generated 
output alongside ``.rst`` source code in your IDE. For more information, see the 
`Visual Studio Marketplace <https://marketplace.visualstudio.com/items?itemName=lextudio.restructuredtext>`__.

Building and previewing the CodeQL training presentations
*********************************************************

To build the training presentations, you need to install a Sphinx extension
called `hieroglyph <https://github.com/nyergler/hieroglyph>`__. 
You also need to install `graphviz <https://graphviz.gitlab.io/download/>`__, which 
is used to generate graphs on some slides.

After installing hieroglyph and graphviz, you can build the training presentations by running 
``sphinx-build``, specifying the ``slides`` builder. For example

.. code::

  sphinx-build -b slides . <slides-output>

generates html slide shows in the ``<slides-output>`` directory when run from
the ``ql-training`` source directory.

For more information about creating slides for QL training and variant analysis 
examples, see the `template slide deck <https://github.com/github/codeql/blob/main/docs/codeql/ql-training/template.rst>`__.

Viewing the current version of the CodeQL documentation
*******************************************************

The documentation for the most recent release is 
published to `codeql.github.com <https://codeql.github.com>`__. 
There, you can find the documentation for the CodeQL queries,
the CodeQL standard libraries, and can learn about CodeQL. 



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/index.rst
.. _ql-language-reference:

QL language reference
#####################

Learn all about QL, the powerful query language that underlies the code scanning tool CodeQL.

- :doc:`About the QL language <about-the-ql-language>`: QL is the powerful query language that underlies CodeQL, which is used to analyze code.

- :doc:`Predicates <predicates>`: Predicates are used to describe the logical relations that make up a QL program. 

- :doc:`Queries <queries>`: Queries are the output of a QL program. They evaluate to sets of results.

- :doc:`Types <types>`: QL is a statically typed language, so each variable must have a declared type.

- :doc:`Modules <modules>`: Modules provide a way of organizing QL code by grouping together related types, predicates, and other modules. 

- :doc:`Signatures <signatures>`: Signatures provide a typing mechanism to parameters of parameterized modules.

- :doc:`Aliases <aliases>`: An alias is an alternative name for an existing QL entity. 

- :doc:`Variables <variables>`: Variables in QL are used in a similar way to variables in algebra or logic. They represent sets of values, and those values are usually restricted by a formula.

- :doc:`Expressions <expressions>`: An expression evaluates to a set of values and has a type.

- :doc:`Formulas <formulas>`: Formulas define logical relations between the free variables used in expressions.

- :doc:`Annotations <annotations>`: An annotation is a string that you can place directly before the declaration of a QL entity or name.

- :doc:`Recursion <recursion>`: QL provides strong support for recursion. A predicate in QL is said to be recursive if it depends, directly or indirectly, on itself. 

- :doc:`Lexical syntax <lexical-syntax>`: The QL syntax includes different kinds of keywords, identifiers, and comments.

- :doc:`Name resolution <name-resolution>`: The QL compiler resolves names to program elements.

- :doc:`Evaluation of QL programs <evaluation-of-ql-programs>`: A QL program is evaluated in a number of different steps.

- :doc:`QL language specification <ql-language-specification>`: A formal specification for the QL language. It provides a comprehensive reference for terminology, syntax, and other technical details about QL. 

.. toctree::
   :maxdepth: 1
   :hidden:

   about-the-ql-language
   predicates
   queries
   types
   modules
   signatures
   aliases
   variables
   expressions
   formulas
   annotations
   recursion
   lexical-syntax
   name-resolution
   evaluation-of-ql-programs
   ql-language-specification



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/formulas.rst
:tocdepth: 1

.. _formulas:

Formulas
########

Formulas define logical relations between the free variables used in expressions.

Depending on the values assigned to those :ref:`free variables <free-variables>`, a formula can be true or false.
When a formula is true, we often say that the formula *holds*.
For example, the formula ``x = 4 + 5`` holds if the value ``9`` is assigned to ``x``, but it
doesn't hold for other assignments to ``x``. 
Some formulas don't have any free variables. For example ``1 < 2`` always holds, and ``1 > 2`` 
never holds.

You usually use formulas in the bodies of classes, predicates, and select clauses to constrain
the set of values that they refer to. 
For example, you can define a class containing all integers ``i`` for which the formula ``i in
[0 .. 9]`` holds.

The following sections describe the kinds of formulas that are available in QL.

Comparisons
***********

A comparison formula is of the form:

.. code-block:: ql

    <expression> <operator> <expression>

See the tables below for an overview of the available comparison operators.

Order
=====

To compare two expressions using one of these order operators, each expression must have a type
and those types must be :ref:`compatible <type-compatibility>` and 
`orderable <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#ordering>`_.

+--------------------------+--------+
| Name                     | Symbol |
+==========================+========+
| Greater than             | ``>``  |
+--------------------------+--------+
| Greater than or equal to | ``>=`` |
+--------------------------+--------+
| Less than                | ``<``  |
+--------------------------+--------+
| Less than or equal to    | ``<=`` |
+--------------------------+--------+

For example, the formulas ``"Ann" < "Anne"`` and ``5 + 6 >= 11`` both hold. 

.. index:: equals
.. _equality:

Equality
========

To compare two expressions using ``=``, at least one of the expressions must have a type. If
both expressions have a type, then their types must be :ref:`compatible <type-compatibility>`.

To compare two expressions using ``!=``, both expressions must have a type. Those types
must also be :ref:`compatible <type-compatibility>`.

+--------------+--------+
| Name         | Symbol |
+==============+========+
| Equal to     | ``=``  |
+--------------+--------+
| Not equal to | ``!=`` |
+--------------+--------+

For example, ``x.sqrt() = 2`` holds if ``x`` is ``4``, and ``4 != 5`` always holds.

For expressions ``A`` and ``B``, the formula ``A = B`` holds if there is a pair of values—one
from ``A`` and one from ``B``—that are the same. In other words, ``A`` and ``B`` have at least
one value in common. For example, ``[1 .. 2] = [2 .. 5]`` holds, since both expressions have
the value ``2``.

As a consequence, ``A != B`` has a very different meaning to the :ref:`negation <negation>` ``not A = B`` [#]_:

- ``A != B`` holds if there is a pair of values (one from ``A`` and one from ``B``) that are
  different.

- ``not A = B`` holds if it is *not* the case that there is a pair of values that are the same.
  In other words, ``A`` and ``B`` have no values in common.

**Examples**

#. If both expressions have a single value (for example ``1`` and ``0``), then comparison is straightforward:
      - ``1 != 0`` holds.
      - ``1 = 0`` doesn't hold.
      - ``not 1 = 0`` holds.

#. Now compare ``1`` and ``[1 .. 2]``:
      - ``1 != [1 .. 2]`` holds, because ``1 != 2``.
      - ``1 = [1 .. 2]`` holds, because ``1 = 1``.
      - ``not 1 = [1 .. 2]`` doesn't hold, because there is a common value (``1``).

#. Compare ``1`` and ``int empty() { none() }`` (a predicate defining the empty set of integers):
      - ``1 != empty()`` doesn't hold, because there are no values in ``empty()``, so no values
        that are not equal to ``1``.
      - ``1 = empty()`` also doesn't hold, because there are no values in ``empty()``, so no values
        that are equal to ``1``.
      - ``not 1 = empty()`` holds, because there are no common values.

.. index:: instanceof
.. _type-checks:

Type checks
***********

A type check is a formula that looks like:

.. code-block:: ql

    <expression> instanceof <type>

You can use a type check formula to check whether an expression has a certain type. For 
example, ``x instanceof Person`` holds if the variable ``x`` has type ``Person``.

.. index:: in

Range checks
************

A range check is a formula that looks like:

.. code-block:: ql

    <expression> in <range>

You can use a range check formula to check whether a numeric expression is in a given 
:ref:`range <ranges>`. For example, ``x in [2.1 .. 10.5]`` holds if the variable ``x`` is 
between the values ``2.1`` and ``10.5`` (including ``2.1`` and ``10.5`` themselves).

Note that ``<expression> in <range>`` is equivalent to ``<expression> = <range>``. 
Both formulas check whether the set of values denoted by ``<expression>`` is the same as the
set of values denoted by ``<range>``.

.. _calls:

Calls to predicates
*******************

A call is a formula or :ref:`expression <expressions>` that consists of a reference to a 
predicate and a number of arguments. 

For example, ``isThree(x)`` might be a call to a predicate that holds if the argument ``x`` is
``3``, and ``x.isEven()`` might be a call to a member predicate that holds if ``x`` is even.

A call to a predicate can also contain a closure operator, namely ``*`` or ``+``. For example,
``a.isChildOf+(b)`` is a call to the :ref:`transitive closure <transitive-closures>` of 
``isChildOf()``, so it holds if ``a`` is a descendant of ``b``.

The predicate reference must resolve to exactly one predicate. For more information about how a predicate 
reference is resolved, see ":ref:`name-resolution`." 

If the call resolves to a predicate without result, then the call is a formula.

It is also possible to call a predicate with result. This kind of call is an
expression in QL, instead of a formula. For more information, see ":ref:`calls-with-result`."

Member predicates only apply to members of a particular class and calls to
member predicates have a receiver of a matching type. Syntactically, if a call
contains a dot, then the expression before the dot specifies the receiver of
the call. For instance, ``x`` is the receiver for the call ``x.isEven()``.

For calls to member predicates of the enclosing class on the member itself
(i.e., the value of ``this``), the receiver may be omitted syntactically. In
this case we say the call has an implicit this receiver. For instance, in the
following example the ``isEven()`` call in ``isOdd()`` is a member predicate
call with an implicit this receiver and the call is equivalent to
``this.isEven()``:

.. code-block:: ql

  class OneTwoThree extends int {
    OneTwoThree() { this = 1 or this = 2 or this = 3 }

    predicate isEven() { this = 2 }

    predicate isOdd() { not isEven() }
  }

Use of implicit this receivers can make it harder to spot predicates that introduce
cartesian products by failing to relate the implicit ``this`` variable with
other variables, which can negatively affect query performance. For more
information on cartesian products, see ":ref:`Troubleshooting query performance
<troubleshooting-query-performance>`".

It is possible to enable warnings about implicit this receivers for `CodeQL packs
<https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs#warnonimplicitthis>`__
through the ``warnOnImplicitThis`` property.

.. _parenthesized-formulas:

Parenthesized formulas
**********************

A parenthesized formula is any formula surrounded by parentheses, ``(`` and ``)``. This formula
has exactly the same meaning as the enclosed formula. The parentheses often help to improve 
readability and group certain formulas together.

.. _quantified-formulas:

Quantified formulas
*******************

A quantified formula introduces temporary variables and uses them in formulas in its body.
This is a way to create new formulas from existing ones.

.. _explicit-quantifiers:

Explicit quantifiers
====================

The following explicit "quantifiers" are the same as the usual existential and universal quantifiers in 
mathematical logic.

.. index:: exists

``exists``
----------

This quantifier has the following syntax:

.. code-block:: ql

    exists(<variable declarations> | <formula>)

You can also write ``exists(<variable declarations> | <formula 1> | <formula 2>)``.
This is equivalent to ``exists(<variable declarations> | <formula 1> and <formula 2>)``.

This quantified formula introduces some new variables. It holds if there is at least one set of values
that the variables could take to make the formula in the body true.

For example, ``exists(int i | i instanceof OneTwoThree)`` introduces a temporary variable of
type ``int`` and holds if any value of that variable has type ``OneTwoThree``.

.. index:: forall 

``forall``
----------

This quantifier has the following syntax:

.. code-block:: ql

    forall(<variable declarations> | <formula 1> | <formula 2>)

``forall`` introduces some new variables, and typically has two formulas in its body. It holds
if ``<formula 2>`` holds for all values that ``<formula 1>`` holds for. 

For example, ``forall(int i | i instanceof OneTwoThree | i < 5)`` holds if all integers
that are in the class ``OneTwoThree`` are also less than ``5``.
In other words, if there is a value in ``OneTwoThree`` that is greater than or equal to ``5``,
then the formula doesn't hold.

Note that ``forall(<vars> | <formula 1> | <formula 2>)`` is 
logically the same as ``not exists(<vars> | <formula 1> | not <formula 2>)``.

.. index:: forex

``forex``
---------

This quantifier has the following syntax:

.. code-block:: ql

    forex(<variable declarations> | <formula 1> | <formula 2>)

This quantifier exists as a shorthand for:

.. code-block:: ql

    forall(<vars> | <formula 1> | <formula 2>) and 
    exists(<vars> | <formula 1> | <formula 2>)

In other words, ``forex`` works in a similar way to ``forall``, except that it ensures that
there is at least one value for which ``<formula 1>`` holds.
To see why this is useful, note that the ``forall`` quantifier could hold trivially. 
For example, ``forall(int i | i = 1 and i = 2 | i = 3)`` holds: there are no integers ``i``
which are equal to both ``1`` and ``2``, so the second part of the body ``(i = 3)`` holds for
every integer for which the first part holds.

Since this is often not the behavior that you want in a query, the ``forex`` quantifier is a
useful shorthand.

.. _implicit-quantifiers:

Implicit quantifiers
====================

Implicitly quantified variables can be introduced using "don't care expressions." These are used 
when you need to introduce a variable to use as an argument to a predicate call, but don't care 
about its value. For further information, see ":ref:`Don't-care expressions <don-t-care-expressions>`."

.. _logical-connectives:

Logical connectives
*******************

You can use a number of logical connectives between formulas in QL. They allow you to combine
existing formulas into longer, more complex ones.

To indicate which parts of the formula should take precedence, you can use parentheses.
Otherwise, the order of precedence from highest to lowest is as follows:

#. Negation (:ref:`not <negation>`)
#. Conditional formula (:ref:`if ... then ... else <conditional>`)
#. Conjunction (:ref:`and <conjunction>`)
#. Disjunction (:ref:`or <disjunction>`)
#. Implication (:ref:`implies <implication>`)

For example, ``A and B implies C or D`` is equivalent to ``(A and B) implies (C or D)``.

Similarly, ``A and not if B then C else D`` is equivalent to
``A and (not (if B then C else D))``.

Note that the :ref:`parentheses <parenthesized-formulas>` in the above examples are not
necessary, since they highlight the default precedence. You usually only add parentheses to
override the default precedence, but you can also add them to make your code easier to read
(even if they aren't required).

QL also has two nullary connectives indicating the always true formula,
``any()``, and the always false formula, ``none()``.

The logical connectives in QL work similarly to Boolean connectives in other programming
languages. Here is a brief overview:

.. index:: any, true
.. _true:

``any()``
=========

The built-in predicate ``any()`` is a formula that always holds.

**Example**

The following predicate defines the set of all expressions.

.. code-block:: ql

    Expr allExpressions() {
      any()
    }

.. index:: none, false
.. _false:

``none()``
==========

The built-in predicate ``none()`` is a formula that never holds.

**Example**

The following predicate defines the empty set of integers.

.. code-block:: ql

    int emptySet() {
      none()
    }

.. index:: not, negation
.. _negation:

``not``
=======

You can use the keyword ``not`` before a formula. The resulting formula is called a negation.

``not A`` holds exactly when ``A`` doesn't hold.

**Example**

The following query selects files that are not HTML files.

.. code-block:: ql

    from File f
    where not f.getFileType().isHtml()
    select f

.. pull-quote:: Note 

   You should be careful when using ``not`` in a recursive definition, as this could lead to
   non-monotonic recursion. For more information, ":ref:`non-monotonic-recursion`."

.. index:: if, then, else
.. _conditional:

``if ... then ... else``
========================

You can use these keywords to write a conditional formula. This is another way to simplify
notation: ``if A then B else C`` is the same as writing ``(A and B) or ((not A) and C)``.

**Example**

With the following definition, ``visibility(c)`` returns ``"public"`` if ``x`` is
a public class and returns ``"private"`` otherwise:

.. code-block:: ql

    string visibility(Class c){
      if c.isPublic()
      then result = "public"
      else result = "private"
    }

.. index:: and, conjunction
.. _conjunction:

``and``
=======

You can use the keyword ``and`` between two formulas. The resulting formula is called a 
conjunction. 

``A and B`` holds if, and only if, both ``A`` and ``B`` hold.

**Example**

The following query selects files that have the ``js`` extension and contain fewer
than 200 lines of code:

.. code-block:: ql

    from File f
    where f.getExtension() = "js" and 
      f.getNumberOfLinesOfCode() < 200
    select f

.. index:: or, disjunction
.. _disjunction:

``or``
======

You can use the keyword ``or`` between two formulas. The resulting formula is called a 
disjunction. 

``A or B`` holds if at least one of ``A`` or ``B`` holds.

**Example**

With the following definition, an integer is in the class ``OneTwoThree`` if it is equal to
``1``, ``2``, or ``3``:

.. code-block:: ql

    class OneTwoThree extends int {
      OneTwoThree() {
        this = 1 or this = 2 or this = 3
      }
    }

.. index:: implies
.. _implication:

``implies``
===========

You can use the keyword ``implies`` between two formulas. The resulting formula is called an 
implication. This is just a simplified notation: ``A implies B`` is the same as writing ``(not A) or B``.

**Example**

The following query selects any ``SmallInt`` that is odd, or a multiple of ``4``.

.. code-block:: ql

    class SmallInt extends int {
      SmallInt() { this = [1 .. 10] }
    }

    from SmallInt x
    where x % 2 = 0 implies x % 4 = 0
    select x

.. rubric:: Footnotes

.. [#] The difference between ``A != B`` and ``not A = B`` is due to the underlying quantifiers. 
       If you think of ``A`` and ``B`` as sets of values, then ``A != B`` means:

       .. code-block:: ql

          exists( a, b | a in A and b in B | a != b )

       On the other hand, ``not A = B`` means:

       .. code-block:: ql

           not exists( a, b | a in A and b in B | a = b )
       
       This is equivalent to ``forall( a, b | a in A and b in B | a != b )``, which is very
       different from the first formula.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/annotations.rst
:tocdepth: 1

.. _annotations:

Annotations
###########

An annotation is a string that you can place directly before the declaration of a QL entity or name.

For example, to declare a module ``M`` as private, you could use:

.. code-block:: ql

    private module M {
        ...
    }

Note that some annotations act on an entity itself, whilst others act on a particular *name* for the entity:
  - Act on an **entity**: ``abstract``, ``cached``, ``external``, ``transient``, ``override``, ``pragma``, ``language``,
    and ``bindingset``
  - Act on a **name**: ``deprecated``, ``library``, ``private``, ``final``, and ``query``

For example, if you annotate an entity with ``private``, then only that particular name is
private. You could still access that entity under a different name (using an :ref:`alias <aliases>`).
On the other hand, if you annotate an entity with ``cached``, then the entity itself is cached.

Here is an explicit example:

.. code-block:: ql

    module M {
      private int foo() { result = 1 }
      predicate bar = foo/0;
    }

In this case, the query ``select M::foo()`` gives a compiler error, since the name ``foo`` is private.
The query ``select M::bar()`` is valid (giving the result ``1``), since the name ``bar`` is visible
and it is an alias of the predicate ``foo``.

You could apply ``cached`` to ``foo``, but not ``bar``, since ``foo`` is the declaration
of the entity.

.. _annotations-overview:

Overview of annotations
***********************

This section describes what the different annotations do, and when you can use them.
You can also find a summary table in the Annotations section of the 
`QL language specification <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#annotations>`_.

.. index:: abstract
.. _abstract:

``abstract``
============

**Available for**: |classes|, |member predicates|

The ``abstract`` annotation is used to define an abstract entity.

For information about **abstract classes**, see ":ref:`Classes <abstract-classes>`."

**Abstract predicates** are member predicates that have no body. They can be defined on any 
class, and should be :ref:`overridden <overriding-member-predicates>` in non-abstract subtypes.

Here is an example that uses abstract predicates. A common pattern when writing data flow
analysis in QL is to define a configuration class. Such a configuration must describe, among
other things, the sources of data that it tracks. A supertype of all such configurations might
look like this:

.. code-block:: ql

    abstract class Configuration extends string {
      ...
      /** Holds if `source` is a relevant data flow source. */
      abstract predicate isSource(Node source);
      ...
    }

You could then define subtypes of ``Configuration``, which inherit the predicate ``isSource``,
to describe specific configurations. Any non-abstract subtypes must override it (directly or
indirectly) to describe what sources of data they each track.

In other words, all non-abstract classes that extend ``Configuration`` must override ``isSource`` in their
own body, or they must inherit from another class that overrides ``isSource``:

.. code-block:: ql

    class ConfigA extends Configuration {
      ...
      // provides a concrete definition of `isSource`
      override predicate isSource(Node source) { ... } 
    }
    class ConfigB extends ConfigA {
      ...
      // doesn't need to override `isSource`, because it inherits it from ConfigA
    }

.. index:: cached
.. _cached:

``cached``
==========

**Available for**: |classes|, |algebraic datatypes|, |characteristic predicates|, |member predicates|, |non-member predicates|, |modules|

The ``cached`` annotation indicates that an entity should be evaluated in its entirety and
stored in the evaluation cache. All later references to this entity will use the 
already-computed data. This affects references from other queries, as well as from the current query.

For example, it can be helpful to cache a predicate that takes a long time to evaluate, and is
reused in many places.

You should use ``cached`` carefully, since it may have unintended consequences. For example,
cached predicates may use up a lot of storage space, and may prevent the QL compiler from
optimizing a predicate based on the context at each place it is used. However, this may be a
reasonable tradeoff for only having to compute the predicate once.

If you annotate a class or module with ``cached``, then all non-:ref:`private` entities in its
body must also be annotated with ``cached``, otherwise a compiler error is reported.

.. index:: deprecated
.. _deprecated:

``deprecated``
==============

**Available for**: |classes|, |algebraic datatypes|, |member predicates|, |non-member predicates|, |imports|, |fields|, |modules|, |aliases|

The ``deprecated`` annotation is applied to names that are outdated and scheduled for removal
in a future release of QL.
If any of your QL files use deprecated names, you should consider rewriting them to use newer
alternatives.
Typically, deprecated names have a QLDoc comment that tells users which updated element they
should use instead.

For example, the name ``DataFlowNode`` is deprecated and has the following QLDoc comment:

.. code-block:: ql

    /**
     * DEPRECATED: Use `DataFlow::Node` instead.
     *
     * An expression or function/class declaration, 
     * viewed as a node in a data flow graph.
     */
    deprecated class DataFlowNode extends @dataflownode {
      ...
    }

This QLDoc comment appears when you use the name ``DataFlowNode`` in a QL editor.

.. index:: external
.. _external:

``external``
============

**Available for**: |non-member predicates|

The ``external`` annotation is used on predicates, to define an external "template"
predicate. This is similar to a :ref:`database predicate <database-predicates>`.

.. index:: transient
.. _transient:

``transient``
=============
**Available for**: |non-member predicates|

The ``transient`` annotation is applied to non-member predicates that are also annotated with ``external``,
to indicate that they should not be cached to disk during evaluation. Note, if you attempt to apply ``transient`` 
without ``external``, the compiler will report an error.

.. index:: final
.. _final:

``final``
=========

**Available for**: |classes|, |type-aliases|, |member predicates|, |fields|

The ``final`` annotation is applied to names that can't be overridden or extended.
In other words, a final class or a final type alias can't act as a base type for any other types,
and a final predicate or field can't be overridden in a subclass.

This is useful if you don't want subclasses to change the meaning of a particular entity.

For example, the predicate ``hasName(string name)`` holds if an element has the name ``name``. 
It uses the predicate ``getName()`` to check this, and it wouldn't make sense for a subclass to
change this definition. In this case, ``hasName`` should be final:

.. code-block:: ql

    class Element ... {
      string getName() { result = ... }
      final predicate hasName(string name) { name = this.getName() }
    }

.. _library:

``library``
===========

**Available for**: |classes|

.. pull-quote:: Important

   This annotation is deprecated. Instead of annotating a name with ``library``, put it in a
   private (or privately imported) module.

The ``library`` annotation is applied to names that you can only refer to from within a
``.qll`` file.
If you try to refer to that name from a file that does not have the ``.qll`` extension, then the QL
compiler returns an error.

.. index:: override
.. _override:

``override``
============

**Available for**: |member predicates|, |fields|

The ``override`` annotation is used to indicate that a definition :ref:`overrides
<overriding-member-predicates>` a member predicate or field from a base type.

If you override a predicate or field without annotating it, then the QL compiler gives a
warning.

.. index:: private
.. _private:

``private``
===========

**Available for**: |classes|, |algebraic datatypes|, |member predicates|, |non-member predicates|, |imports|, |fields|, |modules|, |aliases|

The ``private`` annotation is used to prevent names from being exported.

If a name has the annotation ``private``, or if it is accessed through an import statement
annotated with ``private``, then you can only refer to that name from within the current 
module's :ref:`namespace <namespaces>`.

.. _query:

``query``
=========

**Available for**: |non-member predicates|, |aliases|

The ``query`` annotation is used to turn a predicate (or a predicate alias) into a :ref:`query`.
This means that it is part of the output of the QL program.

.. index:: pragma
.. _pragma:

Compiler pragmas
================

The following compiler pragmas affect the compilation and optimization of queries. You
should avoid using these annotations unless you experience significant performance issues.

Before adding pragmas to your code, contact GitHub to describe the performance problems.
That way we can suggest the best solution for your problem, and take it into account when
improving the QL optimizer.

Inlining
--------

For simple predicates, the QL optimizer sometimes replaces a :ref:`call <calls>` to a predicate
with the predicate body itself. This is known as **inlining**. 

For example, suppose you have a definition ``predicate one(int i) { i = 1 }``
and a call to that predicate ``... one(y) ...``. The QL optimizer may inline the predicate to
``... y = 1 ...``. 

You can use the following compiler pragma annotations to control the way the QL optimizer inlines 
predicates.

``pragma[inline]``
------------------

**Available for**: |characteristic predicates|, |member predicates|, |non-member predicates|

The ``pragma[inline]`` annotation tells the QL optimizer to always inline the annotated predicate
into the places where it is called. This can be useful when a predicate body is very expensive to 
compute entirely, as it ensures that the predicate is evaluated with the other contextual information
at the places where it is called.

``pragma[inline_late]``
-----------------------

**Available for**: |characteristic predicates|, |member predicates|, |non-member predicates|

The ``pragma[inline_late]`` annotation must be used in conjunction with a
``bindingset[...]`` pragma. Together, they tell the QL optimiser to use the
specified binding set for assessing join orders both in the body of the
annotated predicate and at call sites and to inline the body into call sites
after join ordering. This can be useful to prevent the optimiser from choosing
a sub-optimal join order.

For instance, in the example below, the ``pragma[inline_late]`` and
``bindingset[x]`` annotations specify that calls to ``p`` should be join ordered
in a context where ``x`` is already bound. This forces the join orderer to
order ``q(x)`` before ``p(x)``, which is more computationally efficient
than ordering ``p(x)`` before ``q(x)``.

.. code-block:: ql

	bindingset[x]
	pragma[inline_late]
	predicate p(int x) { x in [0..100000000] }

	predicate q(int x) { x in [0..10000] }

	from int x
	where p(x) and q(x)
	select x

..


``pragma[noinline]``
--------------------

**Available for**: |characteristic predicates|, |member predicates|, |non-member predicates|

The ``pragma[noinline]`` annotation is used to prevent a predicate from being inlined into the
place where it is called. In practice, this annotation is useful when you've already grouped 
certain variables together in a "helper" predicate, to ensure that the relation is evaluated 
in one piece. This can help to improve performance. The QL optimizer's inlining may undo the 
work of the helper predicate, so it's a good idea to annotate it with ``pragma[noinline]``.

``pragma[nomagic]``
-------------------

**Available for**: |characteristic predicates|, |member predicates|, |non-member predicates|

The ``pragma[nomagic]`` annotation is used to prevent the QL optimizer from performing the "magic sets"
optimization on a predicate. 

This kind of optimization involves taking information from the context of a predicate 
:ref:`call <calls>` and pushing it into the body of a predicate. This is usually
beneficial, so you shouldn't use the ``pragma[nomagic]`` annotation unless recommended to do so
by GitHub.

Note that ``nomagic`` implies ``noinline``.

``pragma[noopt]``
-----------------

**Available for**: |characteristic predicates|, |member predicates|, |non-member predicates|

The ``pragma[noopt]`` annotation is used to prevent the QL optimizer from optimizing a
predicate, except when it's absolutely necessary for compilation and evaluation to work.

This is rarely necessary and you should not use the ``pragma[noopt]`` annotation unless
recommended to do so by GitHub, for example, to help resolve performance issues.

When you use this annotation, be aware of the following issues:

#. The QL optimizer automatically orders the conjuncts of a :ref:`complex formula <logical-connectives>`
   in an efficient way. In a ``noopt`` predicate, the conjuncts are evaluated in exactly the order 
   that you write them.
#. The QL optimizer automatically creates intermediary conjuncts to "translate" certain formulas 
   into a :ref:`conjunction <conjunction>` of simpler formulas. In a ``noopt`` predicate, you
   must write these conjunctions explicitly.
   In particular, you can't chain predicate :ref:`calls <calls>` or call predicates on a
   :ref:`cast <casts>`. You must write them as multiple conjuncts and explicitly order them.

   For example, suppose you have the following definitions:

   .. code-block:: ql

       class Small extends int {
         Small() { this in [1 .. 10] }
         Small getSucc() { result = this + 1}
       }
       
       predicate p(int i) {
         i.(Small).getSucc() = 2
       }
       
       predicate q(Small s) {
         s.getSucc().getSucc() = 3
       }
   
   If you add ``noopt`` pragmas, you must rewrite the predicates. For example:

   .. code-block:: ql

       pragma[noopt]
       predicate p(int i) {
         exists(Small s | s = i and s.getSucc() = 2)
       }
       
       pragma[noopt]
       predicate q(Small s) {
         exists(Small succ |
           succ = s.getSucc() and
           succ.getSucc() = 3
         )
       }

``pragma[only_bind_out]``
-------------------------

**Available for**: |expressions|

The ``pragma[only_bind_out]`` annotation lets you specify the direction in which the QL compiler should bind expressions.
This can be useful to improve performance in rare cases where the QL optimizer orders parts of the QL program in an inefficient way.

For example, ``x = pragma[only_bind_out](y)`` is semantically equivalent to ``x = y``, but has different binding behavior. 
``x = y`` binds ``x`` from ``y`` and vice versa, while ``x = pragma[only_bind_out](y)`` only binds ``x`` from ``y``.

For more information, see ":ref:`Binding <binding>`."

``pragma[only_bind_into]``
--------------------------

**Available for**: |expressions|

The ``pragma[only_bind_into]`` annotation lets you specify the direction in which the QL compiler should bind expressions.
This can be useful to improve performance in rare cases where the QL optimizer orders parts of the QL program in an inefficient way.

For example, ``x = pragma[only_bind_into](y)`` is semantically equivalent to ``x = y``, but has different binding behavior. 
``x = y`` binds ``x`` from ``y`` and vice versa, while ``x = pragma[only_bind_into](y)`` only binds ``y`` from ``x``.

For more information, see ":ref:`Binding <binding>`."

``pragma[assume_small_delta]``
------------------------------

**Available for**: |characteristic predicates|, |member predicates|, |non-member predicates|

.. pull-quote:: Important

   This annotation is deprecated.

The ``pragma[assume_small_delta]`` annotation has no effect and can be safely removed.

.. _language:

Language pragmas
================

**Available for**: |modules|, |classes|, |characteristic predicates|, |member predicates|, |non-member predicates|

``language[monotonicAggregates]``
---------------------------------

This annotation allows you to use **monotonic aggregates** instead of the standard QL
:ref:`aggregates <aggregations>`.

For more information, see ":ref:`monotonic-aggregates`."

.. _bindingset:

Binding sets
============

**Available for**: |classes|, |characteristic predicates|, |member predicates|, |non-member predicates|

``bindingset[...]``
-------------------

You can use this annotation to explicitly state the binding sets for a predicate or class. A binding set
is a subset of a predicate's or class body's arguments such that, if those arguments are constrained to a
finite set of values, then the predicate or class itself is finite (that is, it evaluates to a finite 
set of tuples).

The ``bindingset`` annotation takes a comma-separated list of variables.

- When you annotate a predicate, each variable must be an argument of the predicate, possibly including ``this``
  (for characteristic predicates and member predicates) and ``result`` (for predicates that return a result). 
  For more information, see ":ref:`predicate-binding`."
- When you annotate a class, each variable must be ``this`` or a field in the class. 

.. Links to use in substitutions

.. |classes|                   replace:: :ref:`classes <classes>`
.. |characteristic predicates| replace:: :ref:`characteristic predicates <characteristic-predicates>`
.. |member predicates|         replace:: :ref:`member predicates <member-predicates>`
.. |non-member predicates|     replace:: :ref:`non-member predicates <non-member-predicates>`
.. |imports|                   replace:: :ref:`imports <import-statements>`
.. |fields|                    replace:: :ref:`fields <fields>`
.. |modules|                   replace:: :ref:`modules <modules>`
.. |aliases|                   replace:: :ref:`aliases <aliases>`
.. |type-aliases|              replace:: :ref:`type aliases <type-aliases>`
.. |algebraic datatypes|       replace:: :ref:`algebraic datatypes <algebraic-datatypes>`
.. |expressions|               replace:: :ref:`expressions <expressions>`



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/queries.rst
:tocdepth: 1

.. index:: query

.. _queries:

Queries
#######

Queries are the output of a QL program. They evaluate to sets of results.

There are two kinds of queries. For a given :ref:`query module <query-modules>`, the queries in that module are:
  - The :ref:`select clause <select-clauses>`, if any, defined in that module.
  - Any :ref:`query predicates <query-predicates>` in that module's predicate 
    :ref:`namespace <namespaces>`. That is, they can be defined in the module itself, or 
    imported from a different module.

We often also refer to the whole QL program as a query.

.. index:: from, where, select
.. _select-clauses:

Select clauses
**************

When writing a query module, you can include a **select clause** (usually at the end of the
file) of the following form:

.. code-block:: ql

    from /* ... variable declarations ... */
    where /* ... logical formula ... */
    select /* ... expressions ... */

The ``from`` and ``where`` parts are optional.

Apart from the expressions described in ":ref:`expressions`," you can also include:
 - The ``as`` keyword, followed by a name. This gives a "label" to a column of results, and allows
   you to use them in subsequent select expressions.
 - The ``order by`` keywords, followed by the name of a result column, and optionally the
   keyword ``asc`` or ``desc``. This determines the order in which to display the results.

.. TODO: link to topics on formulas and expressions in QL

For example:

.. code-block:: ql

    from int x, int y 
    where x = 3 and y in [0 .. 2]
    select x, y, x * y as product, "product: " + product

This select clause returns the following results:

+---+---+---------+------------+
| x | y | product |            |
+===+===+=========+============+
| 3 | 0 | 0       | product: 0 |
+---+---+---------+------------+
| 3 | 1 | 3       | product: 3 |
+---+---+---------+------------+
| 3 | 2 | 6       | product: 6 |
+---+---+---------+------------+

You could also add ``order by y desc`` at the end of the select clause. Now the results are 
ordered according to the values in the ``y`` column, in descending order:

+---+---+---------+------------+
| x | y | product |            |
+===+===+=========+============+
| 3 | 2 | 6       | product: 6 |
+---+---+---------+------------+
| 3 | 1 | 3       | product: 3 |
+---+---+---------+------------+
| 3 | 0 | 0       | product: 0 |
+---+---+---------+------------+

.. _query-predicates:

Query predicates
****************

A query predicate is a :ref:`non-member predicate <non-member-predicates>` with a ``query`` 
annotation. It returns all the tuples that the predicate evaluates to.

For example:

.. code-block:: ql

    query int getProduct(int x, int y) {
      x = 3 and 
      y in [0 .. 2] and 
      result = x * y
    }

This predicate returns the following results:

+---+---+--------+
| x | y | result |
+===+===+========+
| 3 | 0 | 0      |
+---+---+--------+
| 3 | 1 | 3      |
+---+---+--------+
| 3 | 2 | 6      |
+---+---+--------+

A benefit of writing a query predicate instead of a select clause is that you can call the
predicate in other parts of the code too. For example, you can call ``getProduct`` inside
the body of a :ref:`class <classes>`:

.. code-block:: ql

    class MultipleOfThree extends int {
      MultipleOfThree() { this = getProduct(_, _) }
    }

In contrast, the select clause is like an anonymous predicate, so you can't call it later.

It can also be helpful to add a ``query`` annotation to a predicate while you debug code. That
way you can explicitly see the set of tuples that the predicate evaluates to.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/predicates.rst
:tocdepth: 1

.. _predicates:

Predicates
##########

Predicates are used to describe the logical relations that make up a QL program. 

Strictly speaking, a predicate evaluates to a set of tuples. For example, consider the 
following two predicate definitions:

.. code-block:: ql

    predicate isCountry(string country) {
      country = "Germany"
      or
      country = "Belgium"
      or
      country = "France"
    }

    predicate hasCapital(string country, string capital) {
      country = "Belgium" and capital = "Brussels" 
      or
      country = "Germany" and capital = "Berlin" 
      or
      country = "France" and capital = "Paris"
    }

.. index:: arity

The predicate ``isCountry`` is the set of one-tuples ``{("Belgium"),("Germany"),("France")}``,
while ``hasCapital`` is the set of two-tuples ``{("Belgium","Brussels"),("Germany","Berlin"),("France","Paris")}``.
The `arity <https://en.wikipedia.org/wiki/Arity>`_ of these predicates is one and two, respectively.

In general, all tuples in a predicate have the same number of elements. The **arity** of 
a predicate is that number of elements, not including a possible ``result`` variable. For more information, see ":ref:`predicates-with-result`."

There are a number of `built-in predicates <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins>`_ 
in QL. You can use these in any queries without needing to :ref:`import <importing-modules>`
any additional modules. In addition to these built-in predicates, you can also define your
own:

.. _defining-a-predicate:

Defining a predicate
********************

When defining a predicate, you should specify:

#. The keyword ``predicate`` (for a :ref:`predicate without result <predicates-without-result>`), 
   or the type of the result (for a :ref:`predicate with result <predicates-with-result>`).
#. The name of the predicate. This is an `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_ 
   starting with a lowercase letter.
#. The arguments to the predicate, if any, separated by commas. For each argument, specify the
   argument type and an identifier for the argument variable.
#. The predicate body itself. This is a logical formula enclosed in braces. 

.. pull-quote:: Note

   An :ref:`abstract` or :ref:`external` predicate has no body. To define such a predicate, 
   end the predicate definition with a semicolon (``;``) instead.

.. _predicates-without-result:

Predicates without result
=========================

These predicate definitions start with the keyword ``predicate``. If a value satisfies the 
logical property in the body, then the predicate holds for that value.

For example:

.. code-block:: ql

    predicate isSmall(int i) { 
      i in [1 .. 9]
    }

If ``i`` is an integer, then ``isSmall(i)`` holds if ``i`` is a positive 
integer less than 10. 

.. _predicates-with-result:

Predicates with result
======================

.. index:: result

You can define a predicate with result by replacing the keyword ``predicate`` with the type 
of the result. This introduces the special variable ``result``. 

For example:

.. code-block:: ql

    int getSuccessor(int i) {
      result = i + 1 and
      i in [1 .. 9]
    }

If ``i`` is a positive integer less than 10, then the result of the predicate 
is the successor of ``i``. 

Note that you can use ``result`` in the same way as any other argument to the predicate. 
You can express the relation between ``result`` and other variables in any way you like. 
For example, given a predicate ``getAParentOf(Person x)`` that returns parents of ``x``, you can 
define a "reverse" predicate as follows:

.. code-block:: ql

    Person getAChildOf(Person p) {
      p = getAParentOf(result)
    }


It is also possible for a predicate to have multiple results (or none at all) for each value 
of its arguments. For example:

.. code-block:: ql

    string getANeighbor(string country) {
      country = "France" and result = "Belgium" 
      or
      country = "France" and result = "Germany"
      or
      country = "Germany" and result = "Austria"
      or
      country = "Germany" and result = "Belgium"
    }

In this case:
  - The predicate call ``getANeighbor("Germany")`` returns two results: ``"Austria"`` and 
    ``"Belgium"``.
  - The predicate call ``getANeighbor("Belgium")`` returns no results, since ``getANeighbor``
    does not define a ``result`` for ``"Belgium"``.

Recursive predicates
********************

A predicate in QL can be **recursive**. This means that it depends, directly or indirectly,
on itself. 

For example, you could use recursion to refine the above example. As it stands, the relation 
defined in ``getANeighbor`` is not symmetric—it does not capture the fact that if x is a 
neighbor of y, then y is a neighbor of x. A simple way to capture this is to call this 
predicate recursively, as shown below:

.. code-block:: ql

    string getANeighbor(string country) {
      country = "France" and result = "Belgium"
      or
      country = "France" and result = "Germany"
      or
      country = "Germany" and result = "Austria"
      or
      country = "Germany" and result = "Belgium"
      or
      country = getANeighbor(result)
    }

Now ``getANeighbor("Belgium")`` also returns results, namely ``"France"`` and ``"Germany"``.

For a more general discussion of recursive predicates and queries, see ":ref:`recursion`."

Kinds of predicates
*******************

.. _non-member-predicates:

There are three kinds of predicates, namely non-member predicates, member predicates, and
characteristic predicates.

Non-member predicates are defined outside a class, that is, they are not members of any class.

For more information about the other kinds of predicates, see :ref:`characteristic predicates
<characteristic-predicates>` and :ref:`member predicates <member-predicates>` in the 
":ref:`Classes <classes>`" topic.

Here is an example showing a predicate of each kind:

.. code-block:: ql

    int getSuccessor(int i) {  // 1. Non-member predicate 
      result = i + 1 and
      i in [1 .. 9]
    } 

    class FavoriteNumbers extends int {
      FavoriteNumbers() {  // 2. Characteristic predicate
        this = 1 or
        this = 4 or
        this = 9
      }

      string getName() {   // 3. Member predicate for the class `FavoriteNumbers`
        this = 1 and result = "one"
        or
        this = 4 and result = "four"
        or
        this = 9 and result = "nine"
      }
    }
   
You can also annotate each of these predicates. See the list of 
:ref:`annotations <annotations-overview>` available for each kind of predicate.

.. _predicate-binding:

Binding behavior
****************

It must be possible to evaluate a predicate in a finite amount of time, so the set it describes 
is not usually allowed to be infinite. In other words, a predicate can only contain a finite number of tuples.

The QL compiler reports an error when it can prove that a predicate contains variables that
aren't constrained to a finite number of values. For more information, see ":ref:`binding`."

Here are a few examples of infinite predicates:

.. code-block:: ql

    /*
      Compilation errors:
      ERROR: "i" is not bound to a value.
      ERROR: "result" is not bound to a value.
      ERROR: expression "i * 4" is not bound to a value.
    */
    int multiplyBy4(int i) {
      result = i * 4
    }
    
    /*
      Compilation errors:
      ERROR: "str" is not bound to a value.
      ERROR: expression "str.length()" is not bound to a value.
    */
    predicate shortString(string str) {
      str.length() < 10
    }

In ``multiplyBy4``, the argument ``i`` is declared as an ``int``, which is an infinite 
type. It is used in the binary operation ``*``, which does not bind its operands. 
``result`` is unbound to begin with, and remains unbound since it is used in an equality 
check with ``i * 4``, which is also unbound. 

In ``shortString``, ``str`` remains unbound since it is declared with the infinite type 
``string``, and the built-in function ``length()`` does not bind it.

.. index:: binding set
.. _binding-sets:

Binding sets
============

Sometimes you may want to define an "infinite predicate" anyway, because you only intend to
use it on a restricted set of arguments. In that case, you can specify an explicit binding 
set using the ``bindingset`` :ref:`annotation <bindingset>`. This annotation is valid for any
kind of predicate.

For example:

.. code-block:: ql

    bindingset[i]
    int multiplyBy4(int i) {
      result = i * 4
    }

    from int i
    where i in [1 .. 10]
    select multiplyBy4(i)

Although ``multiplyBy4`` is an infinite predicate, the above QL :ref:`query <queries>` is legal. 
It first uses the ``bindingset`` annotation to state that the predicate ``multiplyBy4`` will be 
finite provided that ``i`` is bound to a finite number of values. Then it uses the predicate in 
a context where ``i`` is restricted to to the range ``[1 .. 10]``.

It is also possible to state multiple binding sets for a predicate. This can be done by adding 
multiple binding set annotations, for example:

.. code-block:: ql

    bindingset[x] bindingset[y]
    predicate plusOne(int x, int y) {
      x + 1 = y
    }

    from int x, int y
    where y = 42 and plusOne(x, y)
    select x, y

Multiple binding sets specified this way are independent of each other. The above example means:
  - If ``x`` is bound, then ``x`` and ``y`` are bound.
  - If ``y`` is bound, then ``x`` and ``y`` are bound.

That is, ``bindingset[x] bindingset[y]``, which states that at least one of ``x`` or ``y`` must 
be bound, is different from ``bindingset[x, y]``, which states that both ``x`` and ``y`` must be 
bound.

The latter can be useful when you want to declare a :ref:`predicate with result <predicates-with-result>` that takes multiple input arguments.
For example, the following predicate takes a string ``str`` and truncates it to a maximum length of ``len`` characters:

.. code-block:: ql

    bindingset[str, len]
    string truncate(string str, int len) {
      if str.length() > len
      then result = str.prefix(len)
      else result = str
    }

You can then use this in a :ref:`select clause <select-clauses>`, for example:

.. code-block:: ql

    select truncate("hello world", 5)

.. _database-predicates:

Database predicates
*******************

Each database that you query contains tables expressing relations between values. These tables
("database predicates") are treated in the same way as other predicates in QL.

For example, if a database contains a table for persons, you can write 
``persons(x, firstName, _, age)`` to constrain ``x``, ``firstName``, and ``age`` to be the 
first, second, and fourth columns of rows in that table.

The only difference is that you can't define database predicates in QL. They are defined by the
underlying database. Therefore, the available database predicates vary according to the 
database that you are querying.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/variables.rst
:tocdepth: 1

.. index:: variable

.. _variables:

Variables
#########

Variables in QL are used in a similar way to variables in algebra or logic. They represent sets
of values, and those values are usually restricted by a formula.

This is different from variables in some other programming languages, where variables represent
memory locations that may contain data. That data can also change over time. For example, in
QL, ``n = n + 1`` is an equality :ref:`formula <formulas>` that holds only
if ``n`` is equal to ``n + 1`` (so in fact it does not hold for any numeric value).
In Java, ``n = n + 1`` is not an equality, but an assignment that changes the value of ``n`` by
adding ``1`` to the current value.
 
.. _variable-declarations:

Declaring a variable
********************

All variable declarations consist of a :ref:`type <types>` and a name for the variable. 
The name can be any `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_
that starts with a lowercase letter.

For example, ``int i``, ``SsaDefinitionNode node``, and ``LocalScopeVariable lsv`` declare
variables ``i``, ``node``, and ``lsv`` with types ``int``, ``SsaDefinitionNode``, and
``LocalScopeVariable`` respectively.

Variable declarations appear in different contexts, for example in a :ref:`select clause <select-clauses>`,
inside a :ref:`quantified formula <quantified-formulas>`, as an argument of a :ref:`predicate <predicates>`,
and many more.

Conceptually, you can think of a variable as holding all the values that its type allows, subject
to any further constraints.

For example, consider the following select clause:

.. code-block:: ql

    from int i
    where i in [0 .. 9]
    select i

Just based on its type, the variable ``i`` could contain all integers. However, it is
constrained by the formula ``i in [0 .. 9]``. Consequently, the result of the select clause is
the ten numbers between ``0`` and ``9`` inclusive.

As an aside, note that the following query leads to a compile-time error:

.. code-block:: ql

    from int i
    select i

In theory, it would have infinitely many results, as the variable ``i`` is not constrained to a
finite number of possible values. For more information, see ":ref:`binding`."

.. index:: variable; free, variable; bound
.. _free-variables:

Free and bound variables
************************

Variables can have different roles. Some variables are **free**, and their values directly
affect the value of an :ref:`expression <expressions>` that uses them, or whether a 
:ref:`formula <formulas>` that uses them holds or not.
Other variables, called **bound** variables, are restricted to specific sets of values.

It might be easiest to understand this distinction in an example. Take a look at the following
expressions:

.. code-block:: ql

    "hello".indexOf("l")

    min(float f | f in [-3 .. 3])

    (i + 7) * 3

    x.sqrt()

The first expression doesn't have any variables. It finds the (zero-based) indices of
where ``"l"`` occurs in the string ``"hello"``, so it evaluates to ``2`` and ``3``.

The second expression evaluates to ``-3``, the minimum value in the range ``[-3 .. 3]``.
Although this expression uses a variable ``f``, it is just a placeholder or "dummy" variable,
and you can't assign any values to it.
You could replace ``f`` with a different variable without changing the meaning of the 
expression. For example, ``min(float f | f in [-3 .. 3])`` is always equal to 
``min(float other | other in [-3 .. 3])``. This is an example of a **bound variable**.

What about the expressions ``(i + 7) * 3`` and ``x.sqrt()``? 
In these two cases, the values of the expressions depend on what values are assigned to the 
variables ``i`` and ``x`` respectively. In other words, the value of the variable has an impact
on the value of the expression. These are examples of **free variables**.

Similarly, if a formula contains free variables, then the formula can hold or not hold
depending on the values assigned to those variables [#]_. For example:

.. code-block:: ql

    "hello".indexOf("l") = 1

    min(float f | f in [-3 .. 3]) = -3

    (i + 7) * 3 instanceof int

    exists(float y | x.sqrt() = y)

The first formula doesn't contain any variables, and it never holds (since ``"hello".indexOf("l")``
has values ``2`` and ``3``, never ``1``).

The second formula only contains a bound variable, so is unaffected by changes to that
variable. Since ``min(float f | f in [-3 .. 3])`` is equal to ``-3``, this formula always holds.

The third formula contains a free variable ``i``. Whether or not the formula holds, depends on
what values are assigned to ``i``.
For example, if ``i`` is assigned ``1`` or ``2`` (or any other ``int``) then the formula holds.
On the other hand, if ``i`` is assigned ``3.5``, then it doesn't hold.

The last formula contains a free variable ``x`` and a bound variable ``y``. If ``x`` is assigned
a non-negative number, then the final formula holds. On the other hand, if ``x`` is assigned 
``-9`` for example, then the formula doesn't hold. The variable ``y`` doesn't affect whether
the formula holds or not.

For more information about how assignments to free variables are computed, see ":ref:`evaluation of QL programs <evaluation-of-ql-programs>`."

.. rubric:: Footnotes

.. [#] This is a slight simplification. There are some formulas that are always true or always
       false, regardless of the assignments to their free variables. However, you won't usually
       use these when you're writing QL.
       For example, and ``a = a`` is always true (known as a 
       `tautology <https://en.wikipedia.org/wiki/Tautology_(logic)>`_), and ``x and not x`` is
       always false.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/name-resolution.rst
:tocdepth: 1

.. _name-resolution:

Name resolution
###############

The QL compiler resolves names to program elements.

As in other programming languages, there is a distinction between the names used in QL code, 
and the underlying QL entities they refer to.

It is possible for different entities in QL to have the same name, for example if they are 
defined in separate modules. Therefore, it is important that the QL compiler can resolve the 
name to the correct entity. 

When you write your own QL, you can use different kinds of expressions to refer to entities. 
Those expressions are then resolved to QL entities in the appropriate :ref:`namespace <namespaces>`.

In summary, the kinds of expressions are:
  - **Module expressions**
      - These refer to modules.
      - They can be simple :ref:`names <names>`, :ref:`qualified references <qualified-references>` 
        (in import statements), :ref:`selections <selections>`, or :ref:`instantiations <parameterized-modules>`.
  - **Type expressions**
      - These refer to types.
      - They can be simple :ref:`names <names>` or :ref:`selections <selections>`.
  - **Predicate expressions**
      - These refer to predicates.
      - They can be simple :ref:`names <names>` or names with arities (for example in an :ref:`alias <aliases>`
        definition), or :ref:`selections <selections>`.
  - **signature expressions**
      - These refer to module signatures, type signatures, or predicate signatures.
      - They can be simple :ref:`names <names>`, names with arities, :ref:`selections <selections>`,
        or :ref:`instantiations <parameterized-modules>`.

.. _names:

Names
*****

To resolve a simple name (with arity), the compiler looks for that name (and arity)
in the :ref:`namespaces <namespaces>` of the current module.

In an :ref:`import statement <import-statements>`, name resolution is slightly more complicated.
For example, suppose you define a :ref:`query module <query-modules>` ``Example.ql`` with the 
following import statement:

.. code-block:: ql

    import javascript

The compiler first checks for a :ref:`library module <library-modules>` ``javascript.qll``, 
using the steps described below for qualified references. If that fails, it checks for an 
:ref:`explicit module <explicit-modules>` named ``javascript`` defined in the 
:ref:`module namespace <namespaces>` of ``Example.ql``.

.. _qualified-references:

Qualified references
********************

A qualified reference is a module expression that uses ``.`` as a file path separator. You can
only use such an expression in :ref:`import statements <import-statements>`, to import a 
library module defined by a relative path.

For example, suppose you define a :ref:`query module <query-modules>` ``Example.ql`` with the 
following import statement:

.. code-block:: ql

    import examples.security.MyLibrary

To find the precise location of this :ref:`library module <library-modules>`, the QL compiler processes the import 
statement as follows:

  #. The ``.``\ s in the qualified reference correspond to file path separators, so it first looks 
     up ``examples/security/MyLibrary.qll`` from the directory containing ``Example.ql``. 

  #. If that fails, it looks up ``examples/security/MyLibrary.qll`` relative to the query 
     directory, if any.
     The query directory is the first enclosing directory containing a file called ``qlpack.yml``. (Or, in legacy products, a file called ``queries.xml``.)
  
  #. If the compiler can't find the library file using the above two checks, it looks up ``examples/security/MyLibrary.qll``
     relative to each library path entry.
     The library path is usually specified using the ``libraryPathDependencies`` of the ``qlpack.yml`` file, though it may also depend on the tools you use to run your query, and whether you have specified any extra settings.
     For more information, see "`Library path <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#library-path>`__" in the QL language specification.
     
If the compiler cannot resolve an import statement, then it gives a compilation error.

.. _selections:

Selections
**********

You can use a selection to refer to a module, type, or predicate inside a particular 
module. A selection is of the form:

.. code-block:: ql

    <module_expression>::<name>

The compiler resolves the module expression first, and then looks for the name in 
the :ref:`namespaces <namespaces>` for that module.

Example
=======

Consider the following :ref:`library module <library-modules>`:

**CountriesLib.qll**

.. code-block:: ql

    class Countries extends string {
      Countries() {
        this = "Belgium"
        or
        this = "France"
        or
        this = "India"
      }
    }

    module M {
      class EuropeanCountries extends Countries {
        EuropeanCountries() {
          this = "Belgium"
          or
          this = "France"
        }
      }
    }

You could write a query that imports ``CountriesLib`` and then uses ``M::EuropeanCountries``
to refer to the class ``EuropeanCountries``:

.. code-block:: ql

    import CountriesLib

    from M::EuropeanCountries ec 
    select ec

Alternatively, you could import the contents of ``M`` directly by using the selection
``CountriesLib::M`` in the import statement:

.. code-block:: ql

    import CountriesLib::M 

    from EuropeanCountries ec 
    select ec

That gives the query access to everything within ``M``, but nothing within ``CountriesLib`` that
isn't also in ``M``.

.. index:: namespace
.. _namespaces:

Namespaces
**********

When writing QL, it's useful to understand how namespaces (also known as 
`environments <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#name-resolution>`_) work.

As in many other programming languages, a namespace is a mapping from **keys** to
**entities**. A key is a kind of identifier, for example a name, and a QL entity is
a :ref:`module <modules>`, a :ref:`type <types>`, or a :ref:`predicate <predicates>`.

Each module in QL has six namespaces:

    - The **module namespace**, where the keys are module names and the entities are modules.
    - The **type namespace**, where the keys are type names and the entities are types.
    - The **predicate namespace**, where the keys are pairs of predicate names and arities, 
      and the entities are predicates.
    - The **module signature namespace**, where the keys are module signature names and the entities are module signatures.
    - The **type signature namespace**, where the keys are type signature names and the entities are type signatures.
    - The **predicate signature namespace**, where the keys are pairs of predicate signature names and arities,
      and the entities are predicate signatures.

The six namespaces of any module are not completely independent of each other:

    - No keys may be shared between the **module namespace** and the **module signature namespace**.
    - No keys may be shared between the **type namespace** and the **type signature namespace**.
    - No keys may be shared between the **module namespace** and the **type signature namespace**.
    - No keys may be shared between the **type namespace** and the **module signature namespace**.
    - No keys may be shared between the **predicate namespace** and the **predicate signature namespace**.
    - No keys may be shared between the **module signature namespace** and the **type signature namespace**.

There is no relation between names in namespaces of different modules.
For example, two different modules can define a predicate ``getLocation()`` without confusion. As long as 
it's clear which namespace you are in, the QL compiler resolves the name to the correct predicate.

Global namespaces
=================

The namespaces containing all the built-in entities are called **global namespaces**, 
and are automatically available in any module.
In particular: 

    - The **global module namespace** has a single entry ``QlBuiltins``.
    - The **global type namespace** has entries for the :ref:`primitive types <primitive-types>` ``int``, ``float``, 
      ``string``, ``boolean``, and ``date``, as well as any :ref:`database types <database-types>` defined in the database schema.
    - The **global predicate namespace** includes all the `built-in predicates <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins>`_,
      as well as any :ref:`database predicates <database-predicates>`.
    - The **global signature namespaces** are empty.

In practice, this means that you can use the built-in types and predicates directly in a QL module (without
importing any libraries). You can also use any database predicates and types directly—these depend on the
underlying database that you are querying.

Local namespaces
================

In addition to the global module, type, and predicate namespaces, each module defines a number of local 
module, type, and predicate namespaces.

For a module ``M``, it is useful to distinguish between its **privately declared**, **publically declared**, **exported**, and **visible** namespaces.
(These are described generically, but remember that there is always one for each of modules, module signatures, types, type signatures, predicates, and predicate signatures.)

- The **privately declared** namespaces of ``M`` contain all entities and aliases that are declared—that is, defined—in ``M`` and that are annotated as ``private``.
- The **publically declared** namespaces of ``M`` contain all entities and aliases that are declared—that is, defined—in ``M`` and that are not annotated as ``private``.
- The **exported** namespaces of ``M`` contain
    1. all entries from the **publically declared** namespaces of ``M``, and
    2. for each module ``N`` that is imported into ``M`` with an import statement that is not annotated as ``private``: all entries from the **exported** namespaces of ``N`` that do not have the same name as any of the entries in the **publically declared** namespaces of ``M``, and
    3. for each module signature ``S`` that is implemented by ``M``: an entry for each module signature default predicate in ``S`` that does not have the same name and arity as any of the entries in the **publically declared** predicate namespace of ``M``.
- The **visible** namespaces of ``M`` contain
    1. all entries from the **exported** namespaces of ``M``, and
    2. all entries from the **global** namespaces, and
    3. all entries from the **privately declared** namespace of ``M``, and
    4. for each module ``N`` that is imported into ``M`` with an import statement that is annotated as ``private``: all entries from the **exported** namespaces of ``N`` that do not have the same name as any of the entries in the **publically declared** namespaces of ``M``.
    5. if ``M`` is nested within a module ``N``: all entries from the **visible** namespaces of ``N`` that do not have the same name as any of the entries in the **publically declared** namespaces of ``M``, and
    6. all parameters of ``M``.


This is easiest to understand in an example: 

**OneTwoThreeLib.qll**

.. code-block:: ql

    import MyFavoriteNumbers

    class OneTwoThree extends int {
      OneTwoThree() {
        this = 1 or this = 2 or this = 3
      }
    }

    private module P {
      class OneTwo extends OneTwoThree {
        OneTwo() {
          this = 1 or this = 2
        }
      }
    }

The module ``OneTwoThreeLib`` **publically declares** the class ``OneTwoThree`` and **privately declares** the module ``P``.

It **exports** the class ``OneTwoThree`` and anything that is exported by ``MyFavoriteNumbers``
(assuming ``MyFavoriteNumbers`` does not export a type ``OneTwoThree``, which would not be **exported** by ``OneTwoThreeLib``).

Within it, the class ``OneTwoThree`` and the module ``P`` are **visible**, as well as anything exported by `MyFavoriteNumbers``
(assuming ``MyFavoriteNumbers`` does not export a type ``OneTwoThree``, which would not be **visible** within ``OneTwoThreeLib``).

Example
=======

Let's see what the module, type, and predicate namespaces look like in a concrete example:

For example, you could define a library module ``Villagers`` containing some of the classes and predicates that 
were defined in the :ref:`QL tutorials <ql-tutorials>`:
    
**Villagers.qll**

.. code-block:: ql

    import tutorial
        
    predicate isBald(Person p) {
      not exists(string c | p.getHairColor() = c)
    }
 
    class Child extends Person {
      Child() { 
        this.getAge() < 10 
      }
    }

    module S {
      predicate isSouthern(Person p) {
        p.getLocation() = "south"
      }
      
      class Southerner extends Person {
        Southerner() {
          isSouthern(this)
        }
      }
    }

**Module namespace**

The module namespace of ``Villagers`` has entries for: 
    - The module ``S``.
    - Any modules exported by ``tutorial``.

The module namespace of ``S`` also has entries for the module ``S`` itself, and for any 
modules exported by ``tutorial``.

**Type namespace**

The type namespace of ``Villagers`` has entries for:
    - The class ``Child``.
    - The types exported by the module ``tutorial``.
    - The built-in types, namely ``int``, ``float``, ``string``, ``date``, and ``boolean``.

The type namespace of ``S`` has entries for:
    - All the above types.
    - The class ``Southerner``.

**Predicate namespace**

The predicate namespace of ``Villagers`` has entries for:
    - The predicate ``isBald``, with arity 1.
    - Any predicates (and their arities) exported by ``tutorial``. 
    - The `built-in predicates <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins>`_.

The predicate namespace of ``S`` has entries for:
    - All the above predicates.
    - The predicate ``isSouthern``, with arity 1.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/aliases.rst
:tocdepth: 1

.. index:: alias

.. _aliases:

Aliases
#######

An alias is an alternative name for an existing QL entity. 

Once you've defined an alias, you can use that new name to refer to the entity in the current module's :ref:`namespace <namespaces>`.

Defining an alias
*****************

You can define an alias in the body of any :ref:`module <modules>`. To do this, you should specify:

#. The keyword ``module``, ``class``, or ``predicate`` to define an alias for a :ref:`module <modules>`, 
   :ref:`type <types>`, or :ref:`non-member predicate <non-member-predicates>` respectively.
#. The name of the alias. This should be a valid name for that kind of entity. For example, a valid predicate 
   alias starts with a lowercase letter.
#. A reference to the QL entity. This includes the original name of the entity and, for predicates, 
   the arity of the predicate.

You can also annotate an alias. See the list of :ref:`annotations <annotations-overview>`
available for aliases.

Note that these annotations apply to the name introduced by the alias (and not
the underlying QL entity itself). For example, an alias can have different visibility 
to the name that it aliases.

Module aliases
==============

Use the following syntax to define an alias for a :ref:`module <modules>`:

.. code-block:: ql

    module ModAlias = ModuleName;

For example, if you create a new module ``NewVersion`` that is an updated version 
of ``OldVersion``, you could deprecate the name ``OldVersion`` as follows:

.. code-block:: ql

    deprecated module OldVersion = NewVersion;

That way both names resolve to the same module, but if you use the name ``OldVersion``,
a deprecation warning is displayed.

.. _type-aliases:

Type aliases
============

Use the following syntax to define an alias for a :ref:`type <types>`:

.. code-block:: ql

    class TypeAlias = TypeName;

Note that ``class`` is just a keyword. You can define an alias for any type—namely, :ref:`primitive types <primitive-types>`,
:ref:`database types <database-types>` and user-defined :ref:`classes <classes>`.

For example, you can use an alias to abbreviate the name of the primitive type ``boolean`` to ``Bool``:

.. code-block:: ql

    class Bool = boolean;

Or, to use a class ``OneTwo`` defined in a :ref:`module <explicit-modules>` ``M`` in 
``OneTwoThreeLib.qll``, you could create an alias to use the shorter name ``OT`` instead:

.. code-block:: ql

    import OneTwoThreeLib
    
    class OT = M::OneTwo;
    
    ...

    from OT ot 
    select ot

Predicate aliases
=================

Use the following syntax to define an alias for a :ref:`non-member predicate <non-member-predicates>`:

.. code-block:: ql

    predicate PredAlias = PredicateName/Arity;

This works for predicates :ref:`with <predicates-with-result>` or :ref:`without <predicates-without-result>` result. 

For example, suppose you frequently use the following predicate, which calculates the successor of a positive integer 
less than ten:

.. code-block:: ql
    
    int getSuccessor(int i) {
      result = i + 1 and
      i in [1 .. 9]
    }
    
You can use an alias to abbreviate the name to ``succ``:

.. code-block:: ql

    predicate succ = getSuccessor/1;

As an example of a predicate without result, suppose you have a predicate that holds 
for any positive integer less than ten:

.. code-block:: ql

    predicate isSmall(int i) { 
      i in [1 .. 9]
    }

You could give the predicate a more descriptive name as follows:

.. code-block:: ql

    predicate lessThanTen = isSmall/1;

.. _weak_strong_aliases:

Strong and weak aliases
=======================

Every alias definition is either **strong** or **weak**.
An alias definition is **strong** if and only if it is a :ref:`type alias <type-aliases>` definition with
:ref:`annotation <annotations>` ``final``.
During :ref:`name resolution <name-resolution>`, ambiguity between aliases from **weak** alias definitions
for the same module/type/predicate is allowed, but ambiguity between between aliases from distinct **strong**
alias definitions is invalid QL.
Likewise, for the purpose of applicative instantiation of :ref:`parameterised modules <parameterized-modules>`
and `:ref:`parameterised module signatures <parameterized-module-signatures>`, aliases from **weak** alias
definitions for instantiation arguments do not result in separate instantiations, but aliases from **strong**
alias definitions for instantiation arguments do.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/modules.rst
:tocdepth: 1

.. _modules:

Modules
#######
   
Modules provide a way of organizing QL code by grouping together related types, predicates, and other modules. 

You can import modules into other files, which avoids duplication, and helps 
structure your code into more manageable pieces.

.. _defining-module:

Defining a module
*****************

There are various ways to define modules—here is an example of the simplest way, declaring an
:ref:`explicit module  <explicit-modules>` named ``Example`` containing 
a class ``OneTwoThree``:

.. code-block:: ql

    module Example {
      class OneTwoThree extends int {
        OneTwoThree() {
          this = 1 or this = 2 or this = 3
        }
      }
    } 

The name of a module can be any `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_
that starts with an uppercase or lowercase letter. 

``.ql`` or ``.qll`` files also implicitly define modules.
For more information, see ":ref:`kinds-of-modules`."

You can also annotate a module. For more information, see of ":ref:`annotations-overview`."

Note that you can only annotate :ref:`explicit modules <explicit-modules>`. 
File modules cannot be annotated.

.. _kinds-of-modules:

Kinds of modules
****************

File modules
============

Each query file (extension ``.ql``) and library file (extension ``.qll``) implicitly defines 
a module. The module has the same name as the file, but any spaces in the file name are replaced
by underscores (``_``). The contents of the file form the :ref:`body of the module <module-bodies>`.

.. _library-modules:

Library modules
---------------

A library module is defined by a ``.qll`` file. It can contain any of the 
elements listed in :ref:`module-bodies` below, apart from select clauses.

For example, consider the following QL library:

**OneTwoThreeLib.qll**

.. code-block:: ql

    class OneTwoThree extends int {
      OneTwoThree() {
        this = 1 or this = 2 or this = 3
      }
    }

This file defines a library module named ``OneTwoThreeLib``. The body of this module
defines the class ``OneTwoThree``.

.. _query-modules: 

Query modules
-------------

A query module is defined by a ``.ql`` file. It can contain any of the elements listed 
in :ref:`module-bodies` below. 

Query modules are slightly different from other modules:

- A query module can't be imported.
- A query module must have at least one query in its 
  :ref:`namespace <namespaces>`. This is usually a :ref:`select clause <select-clauses>`, 
  but can also be a :ref:`query predicate <query-predicates>`.

For example:

**OneTwoQuery.ql**

.. code-block:: ql

    import OneTwoThreeLib
    
    from OneTwoThree ott
    where ott = 1 or ott = 2
    select ott

This file defines a query module named ``OneTwoQuery``. The body of this module consists of an
:ref:`import statement <importing-modules>` and a :ref:`select clause <select-clauses>`.

.. _explicit-modules:

Explicit modules
================

You can also define a module within another module. This is an explicit module definition. 

An explicit module is defined with the keyword ``module`` followed by 
the module name, and then the module body enclosed in braces. It can contain any 
of the elements listed in ":ref:`module-bodies`" below, apart from select clauses. 

For example, you could add the following QL snippet to the library file **OneTwoThreeLib.qll** 
defined :ref:`above <library-modules>`:

.. code-block:: ql

    ...
    module M {
      class OneTwo extends OneTwoThree {
        OneTwo() {
          this = 1 or this = 2
        }
      }
    }
    
This defines an explicit module named ``M``. The body of this module defines
the class ``OneTwo``.

.. _parameterized-modules:

Parameterized modules
=====================

Parameterized modules are QL's approach to generic programming.
Similar to explicit modules, parameterized modules are defined within other modules using the keyword ``module``.
In addition to the module name, parameterized modules declare one or more parameters between the name and the module body.

For example, consider the module ``M``, which takes two predicate parameters and defines a new predicate
that applies them one after the other:

.. code-block:: ql

    module M<transformer/1 first, transformer/1 second> {
      bindingset[x]
      int applyBoth(int x) {
        result = second(first(x))
      }
    }

Parameterized modules cannot be directly referenced.
Instead, you instantiate a parameterized module by passing arguments enclosed in angle brackets (``<`` and ``>``) to the module.
Instantiated parameterized modules can be used as a :ref:`module expression <name-resolution>`, identical to explicit module references.

For example, we can instantiate ``M`` with two identical arguments ``increment``, creating a module
containing a predicate that adds 2:

.. code-block:: ql

    bindingset[result] bindingset[x]
    int increment(int x) { result = x + 1 }

    module IncrementTwice = M<increment/1, increment/1>;

    select IncrementTwice::applyBoth(40) // 42

The parameters of a parameterized module are (meta-)typed with :ref:`signatures <signatures>`.

For example, in the previous two snippets, we relied on the predicate signature ``transformer``:

.. code-block:: ql

    bindingset[x]
    signature int transformer(int x);

The instantiation of parameterized modules is applicative.
That is, if you instantiate a parameterized module twice with equivalent arguments, the resulting object is the same.
Arguments are considered equivalent in this context if they differ only by :ref:`weak aliasing <weak_strong_aliases>`.
This is particularly relevant for type definitions inside parameterized modules as :ref:`classes <classes>`
or via :ref:`newtype <algebraic-datatypes>`, because the duplication of such type definitions would result in
incompatible types.

The following example instantiates module ``M`` inside calls to predicate ``foo`` twice.
The first call is valid but the second call generates an error.

.. code-block:: ql

    bindingset[this]
    signature class TSig;

    module M<TSig T> {
      newtype A = B() or C()
    }

    string foo(M<int>::A a) { ... }

    select foo(M<int>::B()),  // valid: repeated identical instantiation of M does not duplicate A, B, C
           foo(M<float>::B()) // ERROR: M<float>::B is not compatible with M<int>::A

Module parameters are dependently typed, meaning that signature expressions in parameter definitions can reference
preceding parameters.

For example, we can declare the signature for ``T2`` dependent on ``T1``, enforcing a subtyping relationship
between the two parameters:

.. code-block:: ql

    signature class TSig;

    module Extends<TSig T> { signature class Type extends T; }

    module ParameterizedModule<TSig T1, Extends<T1>::Type T2> { ... }

Dependently typed parameters are particularly useful in combination with
:ref:`parameterized module signatures <parameterized-module-signatures>`.

.. _module-bodies:

Module bodies
*************

The body of a module is the code inside the module definition, for example
the class ``OneTwo`` in the :ref:`explicit module <explicit-modules>` ``M``. 

In general, the body of a module can contain the following constructs:

- :ref:`import-statements`
- :ref:`predicates`
- :ref:`types` (including user-defined :ref:`classes <classes>`)
- :ref:`aliases`
- :ref:`explicit-modules`
- :ref:`select-clauses` (only available in a :ref:`query module <query-modules>`)

.. index:: import
.. _importing-modules:

Importing modules
*****************

The main benefit of storing code in a module is that you can reuse it in other modules. 
To access the contents of an external module, you can import the module using an 
:ref:`import statement <import-statements>`.

When you import a module this brings all the names in its namespace, apart from :ref:`private` names, 
into the :ref:`namespace <namespaces>` of the current module.

.. _import-statements:

Import statements
=================

Import statements are used for importing modules. They are of the form:

.. code-block:: ql

    import <module_expression1> as <name>
    import <module_expression2>

Import statements are usually listed at the beginning of the module. Each
import statement imports one module. You can import multiple modules by 
including multiple import statements (one for each module you want to import).

An import statement can also be :ref:`annotated <annotations-overview>` with
``private`` or ``deprecated``. If an import statement is annotated with
``private`` then the imported names are not reexported. If an imported name is
only reachable through deprecated imports in a given context then usage of the
name in that context will generate deprecation warnings.

You can import a module under a different name using the ``as`` keyword, 
for example ``import javascript as js``.

The ``<module_expression>`` itself can be a module name, a selection, or a qualified
reference. For more information, see ":ref:`name-resolution`."

For information about how import statements are looked up, see "`Module resolution <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#module-resolution>`__"
in the QL language specification. 

Built-in modules
****************

QL defines a ``QlBuiltins`` module that is always in scope.
``QlBuiltins`` defines parameterized sub-modules for working with
(partial) equivalence relations (``EquivalenceRelation``) and sets
(``InternSets``) in QL.

Equivalence relations
=====================

The built-in ``EquivalenceRelation`` module is parameterized by a type ``T`` and a
binary base relation ``base`` on ``T``. The symmetric and transitive closure of ``base``
induces a partial equivalence relation on ``T``. If every value of ``T`` appears in
``base``, then the induced relation is an equivalence relation on ``T``.

The ``EquivalenceRelation`` module exports a ``getEquivalenceClass`` predicate that
gets the equivalence class, if any, associated with a given ``T`` element by the
(partial) equivalence relation induced by ``base``.

The following example illustrates an application of the ``EquivalenceRelation``
module to generate a custom equivalence relation:

.. code-block:: ql

  class Node extends int {
    Node() { this in [1 .. 6] }
  }

  predicate base(Node x, Node y) {
    x = 1 and y = 2
    or
    x = 3 and y = 4
  }

  module Equiv = QlBuiltins::EquivalenceRelation<Node, base/2>;

  from int x, int y
  where Equiv::getEquivalenceClass(x) = Equiv::getEquivalenceClass(y)
  select x, y

Since ``base`` does not relate ``5`` or ``6`` to any nodes, the induced
relation is a partial equivalence relation on ``Node`` and does not relate ``5``
or ``6`` to any nodes either.

The above select clause returns the following partial equivalence relation:

+---+---+
| x | y |
+===+===+
| 1 | 1 |
+---+---+
| 1 | 2 |
+---+---+
| 2 | 1 |
+---+---+
| 2 | 2 |
+---+---+
| 3 | 3 |
+---+---+
| 3 | 4 |
+---+---+
| 4 | 3 |
+---+---+
| 4 | 4 |
+---+---+

Sets
====

The built-in ``InternSets`` module is parameterized by ``Key`` and ``Value`` types
and a ``Value getAValue(Key key)`` relation. The module groups the ``Value``
column by ``Key`` and creates a set for each group of values related by a key. 

The ``InternSets`` module exports a functional ``Set getSet(Key key)`` relation
that relates keys with the set of value related to the given key by
``getAValue``. Sets are represented by the exported ``Set`` type which exposes
a ``contains(Value v)`` member predicate that holds for values contained in the
given set. `getSet(k).contains(v)` is thus equivalent to `v = getAValue(k)` as
illustrated by the following ``InternSets`` example:

.. code-block:: ql

  int getAValue(int key) {
    key = 1 and result = 1
    or
    key = 2 and
    (result = 1 or result = 2)
    or
    key = 3 and result = 1
    or
    key = 4 and result = 2
  }

  module Sets = QlBuiltins::InternSets<int, int, getAValue/1>;

  from int k, int v
  where Sets::getSet(k).contains(v)
  select k, v

This evalutes to the `getAValue` relation:

+---+---+
| k | v |
+===+===+
| 1 | 1 |
+---+---+
| 2 | 1 |
+---+---+
| 2 | 2 |
+---+---+
| 3 | 1 |
+---+---+
| 4 | 2 |
+---+---+

If two keys `k1` and `k2` relate to the same set of values, then `getSet(k1) = getSet(k2)`.
For the above example, keys 1 and 3 relate to the same set of values (namely the singleton
set containing 1) and are therefore related to the same set by ``getSet``:

.. code-block:: ql

  from int k1, int k2
  where Sets::getSet(k1) = Sets::getSet(k2)
  select k1, k2

The above query therefore evalutes to:

+----+----+
| k1 | k2 |
+====+====+
| 1  | 1  |
+----+----+
| 1  | 3  |
+----+----+
| 2  | 2  |
+----+----+
| 3  | 1  |
+----+----+
| 3  | 3  |
+----+----+
| 4  | 4  |
+----+----+



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/evaluation-of-ql-programs.rst
:tocdepth: 1

.. _evaluation-of-ql-programs:

Evaluation of QL programs
#########################

A QL program is evaluated in a number of different steps.

Process
*******

When a QL program is run against a database, it is compiled into a variant of the logic
programming language `Datalog <https://en.wikipedia.org/wiki/Datalog>`_. It is optimized for
performance, and then evaluated to produce results. 

These results are sets of ordered tuples. An ordered tuple is a finite, ordered sequence of
values. For example, ``(1, 2, "three")`` is an ordered tuple with two integers and a string.
There may be intermediate results produced while the program is being evaluated: these are also 
sets of tuples.

A QL program is evaluated from the bottom up, so a predicate is usually only evaluated after
all the predicates it depends on are evaluated. 

The database includes sets of ordered tuples for the `built-in predicates 
<https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins>`_ and :ref:`external predicates <external>`. 
Each evaluation starts from these sets of tuples.
The remaining predicates and types in the program are organized into a number of layers, based 
on the dependencies between them.
These layers are evaluated to produce their own sets of tuples, by finding the least fixed point
of each predicate. (For example, see ":ref:`recursion`.")

The program's :ref:`queries <query>` determine which of these sets of tuples make up the final 
results of the program. The results are sorted according to any ordering directives 
(``order by``) in the queries.

For more details about each step of the evaluation process, see the "`QL language specification
<https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#evaluation>`_."

Validity of programs
********************

The result of a query must always be a **finite** set of values, otherwise it can't be
evaluated. If your QL code contains an infinite predicate or query, the QL compiler
usually gives an error message, so that you can identify the error more easily.

Here are some common ways that you might define infinite predicates. These all generate
compilation errors:

- The following query conceptually selects all values of type ``int``, without restricting them.
  The QL compiler returns the error ``'i' is not bound to a value``:

  .. code-block:: ql
  
      from int i
      select i

- The following predicate generates two errors: ``'n' is not bound to a value`` and ``'result' is
  not bound to a value``:
  
  .. code-block:: ql

      int timesTwo(int n) {
        result = n * 2
      }

- The following class ``Person`` contains all strings that start with ``"Peter"``. There are
  infinitely many such strings, so this is another invalid definition. The QL compiler gives the
  error message ``'this' is not bound to a value``:
  
  .. code-block:: ql
  
      class Person extends string {
        Person() {
          this.matches("Peter%")
        }
      }

.. index:: variable; unbound

To fix these errors, it's useful to think about **range restriction**: A predicate or query is
**range-restricted** if each of its variables has at least one :ref:`binding <binding>`
occurrence.
A variable without a binding occurrence is called **unbound**.
Therefore, to perform a range restriction check, the QL compiler verifies that there are no
unbound variables.

.. _binding:

Binding
=======

To avoid infinite relations in your queries, you must ensure that there are no unbound variables.
To do this, you can use the following mechanisms:

#. **Finite types**: Variables of a finite :ref:`type <types>` are bound. In particular, any
   type that is not :ref:`primitive <primitive-types>` is finite. 
   To give a finite type to a variable, you can :ref:`declare <variable-declarations>` it with
   a finite type, use a :ref:`cast <casts>`, or use a :ref:`type check <type-checks>`.

#. **Predicate calls**: A valid :ref:`predicate <predicates>` is usually range-restricted, so it
   :ref:`binds <predicate-binding>` all its arguments.
   Therefore, if you :ref:`call <calls>` a predicate on a variable, the variable becomes bound.
   
   .. pull-quote:: Important 
      
      If a predicate uses non-standard binding sets, then it does **not** always bind
      all its arguments. In such a case, whether the predicate call binds a specific argument
      depends on which other arguments are bound, and what the binding sets say about the
      argument in question. For more information, see ":ref:`binding-sets`."

#. **Binding operators**: Most operators, such as the :ref:`arithmetic operators <binary-operations>`,
   require that all their operands are bound. For example, you can't add two variables in QL 
   unless you have a finite set of possible values for both of them.

   However, there are some built-in operators that can bind their arguments. For example, if
   one side of an :ref:`equality check <equality>` (using ``=``) is bound and the other side is
   a variable, then the variable becomes bound too.
   See the table below for examples.

Intuitively, a binding occurrence restricts the variable to a finite set of values, while a
non-binding occurrence doesn't. Here are some examples to clarify the difference between
binding and non-binding occurrences of variables:

+-------------------------+-------------------------------------------------------------------+
| Variable occurrence     | Details                                                           |
+=========================+===================================================================+
| ``x = 1``               | Binding: restricts ``x`` to the value ``1``                       |
+-------------------------+-------------------------------------------------------------------+
| ``x != 1``,             | Not binding                                                       |
| ``not x = 1``           |                                                                   |
+-------------------------+-------------------------------------------------------------------+
| ``x = 2 + 3``,          | Binding                                                           |
| ``x + 1 = 3``           |                                                                   |
+-------------------------+-------------------------------------------------------------------+
| ``x in [0 .. 3]``       | Binding                                                           |
+-------------------------+-------------------------------------------------------------------+
| ``p(x, _)``             | Binding, since ``p()`` is a call to a predicate.                  |
+-------------------------+-------------------------------------------------------------------+
| ``x = y``,              | Binding for ``x`` if and only if the variable ``y`` is bound.     |
| ``x = y + 1``           | Binding for ``y`` if and only if the variable ``x`` is bound.     |
+-------------------------+-------------------------------------------------------------------+
| ``x = y * 2``           | Binding for ``x`` if the variable ``y`` is bound.                 |
|                         | Not binding for ``y``.                                            |
+-------------------------+-------------------------------------------------------------------+
| ``x > y``               | Not binding for ``x`` or ``y``                                    |
+-------------------------+-------------------------------------------------------------------+
| ``"string".matches(x)`` | Not binding for ``x``                                             |
+-------------------------+-------------------------------------------------------------------+
| ``x.matches(y)``        | Not binding for ``x`` or ``y``                                    |
+-------------------------+-------------------------------------------------------------------+
| ``not (... x ...)``     | Generally non-binding for ``x``, since negating a                 |
|                         | binding occurrence typically makes it non-binding.                |
|                         | There are certain exceptions: ``not not x = 1`` is                |
|                         | correctly recognized as binding for ``x``.                        |
+-------------------------+-------------------------------------------------------------------+
| ``sum(int y |           | Not binding for ``x``.                                            |
| y = 1 and x = y |       | ``strictsum(int y | y = 1 and x = y | y)`` would be               |
| y)``                    | binding for ``x``. Expressions in the body of an                  |
|                         | :ref:`aggregate <aggregations>` are only binding outside of the   |
|                         | body if the aggregate is *strict*.                                |
+-------------------------+-------------------------------------------------------------------+
| ``x = 1 or y = 1``      | Not binding for ``x`` or for ``y``.                               |
|                         | The first subexpression, ``x = 1``, is binding for ``x``, and the |
|                         | second subexpression, ``y = 1``, is binding for ``y``.            |
|                         | However, combining them with :ref:`disjunction <disjunction>` is  |
|                         | only binding for variables for which **all** disjuncts            |
|                         | are binding—in this case, that's no variable.                     |
+-------------------------+-------------------------------------------------------------------+

While the occurrence of a variable can be binding or non-binding, the variable's property of
being "bound" or "unbound" is a global concept—a single binding occurrence is enough to make a
variable bound.

Therefore, you could fix the "infinite" examples above by providing a binding occurrence. For
example, instead of ``int timesTwo(int n) { result = n * 2 }``, you could write:

.. code-block:: ql

    int timesTwo(int n) {
      n in [0 .. 10] and 
      result = n * 2
    }

The predicate now binds ``n``, and the variable ``result`` automatically becomes bound by the 
computation ``result = n * 2``.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/about-the-ql-language.rst
:tocdepth: 1

.. _about-the-ql-language:

About the QL language
######################

QL is the powerful query language that underlies CodeQL, which is used to analyze code.

About query languages and databases
-----------------------------------

QL is a declarative, object-oriented query language that is optimized to enable efficient analysis of hierarchical data structures, in particular, databases representing software artifacts.

A database is an organized collection of data. The most commonly used database model is a relational model which stores data in tables and SQL (Structured Query Language) is the most commonly used query language for relational databases.

The purpose of a query language is to provide a programming platform where you can ask questions about information stored in a database. A database management system manages the storage and administration of data and provides the querying mechanism. A query typically refers to the relevant database entities and specifies various conditions (called predicates) that must be satisfied by the results. Query evaluation involves checking these predicates and generating the results. Some of the desirable properties of a good query language and its implementation include:

-  Declarative specifications - a declarative specification describes properties that the result must satisfy, rather than providing the procedure to compute the result. In the context of database query languages, declarative specifications abstract away the details of the underlying database management system and query processing techniques. This greatly simplifies query writing.
-  Expressiveness - a powerful query language allows you to write complex queries. This makes the language widely applicable.
-  Efficient execution - queries can be complex and databases can be very large, so it is crucial for a query language implementation to process and execute queries efficiently.

Properties of QL
----------------

The syntax of QL is similar to SQL, but the semantics of QL are based on Datalog, a declarative logic programming language often used as a query language. This makes QL primarily a logic language, and all operations in QL are logical operations. Furthermore, QL inherits recursive predicates from Datalog, and adds support for aggregates, making even complex queries concise and simple. For example, consider a database containing parent-child relationships for people. If we want to find the number of descendants of a person, typically we would:

#. Find a descendant of the given person, that is, a child or a descendant of a child.
#. Count the number of descendants found using the previous step.

When you write this process in QL, it closely resembles the above structure. Notice that we used recursion to find all descendants of the given person, and an aggregate to count the number of descendants. Translating these steps into the final query without adding any procedural details is possible due to the declarative nature of the language. The QL code would look something like this:

.. code-block:: ql

   Person getADescendant(Person p) {
     result = p.getAChild() or
     result = getADescendant(p.getAChild())
   }

   int getNumberOfDescendants(Person p) {
     result = count(getADescendant(p))
   }

For more information about the important concepts and syntactic constructs of QL, see the individual reference topics such as ":doc:`Expressions <expressions>`" and ":doc:`Recursion <recursion>`."
The explanations and examples help you understand how the language works, and how to write more advanced QL code.

For a formal specification of the QL language, see the ":doc:`QL language specification <ql-language-specification>`."

QL and object orientation
-------------------------

Object orientation is an important feature of QL. The benefits of object orientation are well known – it increases modularity, enables information hiding, and allows code reuse. QL offers all these benefits without compromising on its logical foundation. This is achieved by defining a simple object model where classes are modeled as predicates and inheritance as implication. The libraries made available for all supported languages make extensive use of classes and inheritance.

QL and general purpose programming languages
--------------------------------------------

Here are a few prominent conceptual and functional differences between general purpose programming languages and QL:

-  QL does not have any imperative features such as assignments to variables or file system operations.
-  QL operates on sets of tuples and a query can be viewed as a complex sequence of set operations that defines the result of the query.
-  QL's set-based semantics makes it very natural to process collections of values without having to worry about efficiently storing, indexing and traversing them.
-  In object oriented programming languages, instantiating a class involves creating an object by allocating physical memory to hold the state of that instance of the class. In QL, classes are just logical properties describing sets of already existing values.

Further reading
---------------

`Academic references <https://codeql.github.com/publications/>`__ also provide an overview of QL and its semantics. Other useful references on database query languages and Datalog:

-  `Database theory: Query languages <http://www.lsv.fr/~segoufin/Papers/Mypapers/DB-chapter.pdf>`__
-  `Logic Programming and Databases book <https://doi.org/10.1007/978-3-642-83952-8>`__
-  `Foundations of Databases <http://webdam.inria.fr/Alice/>`__
-  `Datalog <https://en.wikipedia.org/wiki/Datalog>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/lexical-syntax.rst
:tocdepth: 1

.. _lexical-syntax:

Lexical syntax
##############

The QL syntax includes different kinds of keywords, identifiers, and comments.

For an overview of the lexical syntax, see "`Lexical syntax 
<https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#lexical-syntax>`_" in the QL language specification.

.. index:: comment, QLDoc
.. _comments:

Comments
********

All standard one-line and multiline comments are ignored by the QL 
compiler and are only visible in the source code.
You can also write another kind of comment, namely **QLDoc comments**. These comments describe
QL entities and are displayed as pop-up information in QL editors.

The following example uses these three different kinds of comments:

.. code-block:: ql

    /**
     * A QLDoc comment that describes the class `Digit`.
     */
    class Digit extends int {  // A short one-line comment
      Digit() {
        this in [0 .. 9]
      }
    }

    /* 
      A standard multiline comment, perhaps to provide 
      additional details, or to write a TODO comment.
    */



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/expressions.rst
:tocdepth: 1

.. _expressions:

Expressions
###########

An expression evaluates to a set of values and has a type.

For example, the expression ``1 + 2`` 
evaluates to the integer ``3`` and the expression ``"QL"`` evaluates to the string ``"QL"``. ``1 + 2`` has :ref:`type <types>` ``int`` and ``"QL"`` has type ``string``.

The following sections describe the expressions that are available in QL.

Variable references
*******************

A variable reference is the name of a declared :ref:`variable <variables>`. This kind of 
expression has the same type as the variable it refers to.

For example, if you have :ref:`declared <variable-declarations>` the variables ``int i`` and ``LocalScopeVariable lsv``, then 
the expressions ``i`` and ``lsv`` have types ``int`` and ``LocalScopeVariable`` respectively.

You can also refer to the variables ``this`` and ``result``. These are used in :ref:`predicate
<predicates>` definitions and act in the same way as other variable references.

.. index:: literal

Literals
********

You can express certain values directly in QL, such as numbers, booleans, and strings.

- :ref:`Boolean <boolean>` literals: These are the values ``true`` and ``false``.

- :ref:`Integer <int>` literals: These are sequences of decimal digits (``0`` through ``9``),
  possibly starting with a minus sign (``-``).
  For example:

  .. code-block:: ql

    0
    42
    -2048 

- :ref:`Float <float>` literals: These are sequences of decimal digits separated by a dot 
  (``.``), possibly starting with a minus sign (``-``).
  For example:
  
  .. code-block:: ql
      
    2.0
    123.456
    -100.5

- :ref:`String <string>` literals: These are finite strings of 16-bit characters. You can 
  define a string literal by enclosing characters in quotation marks (``"..."``). Most 
  characters represent themselves, but there are a few characters that you need to "escape"
  with a backslash. The following are examples of string literals:

  .. code-block:: ql

    "hello"
    "They said, \"Please escape quotation marks!\""
  
  See `String literals <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#string-literals-string>`__
  in the QL language specification for more details. 
    
  Note: there is no "date literal" in QL. Instead, to specify a :ref:`date <date>`, you should
  convert a string to the date that it represents using the ``toDate()`` predicate. For example,
  ``"2016-04-03".toDate()`` is the date April 3, 2016, and ``"2000-01-01 00:00:01".toDate()`` is the
  point in time one second after New Year 2000.
  
  The following string formats are recognized as dates:
   - **ISO dates**, such as ``"2016-04-03 17:00:24"``. The seconds part is optional (assumed 
     to be ``"00"`` if it's missing), and the entire time part can also be missing (in which 
     case it's assumed to be ``"00:00:00"``).
   - **Short-hand ISO dates**, such as ``"20160403"``.
   - **UK-style dates**, such as ``"03/04/2016"``.
   - **Verbose dates**, such as ``"03 April 2016"``.

Parenthesized expressions
*************************

A parenthesized expression is an expression surrounded by parentheses, ``(`` and ``)``. This 
expression has exactly the same type and values as the original expression. 
Parentheses are useful for grouping expressions together to remove ambiguity and improve
readability.

.. index:: range
.. _ranges:

Ranges
******

A range expression denotes a range of values ordered between two expressions. It consists of 
two expressions separated by ``..`` and enclosed in brackets (``[`` and ``]``). 
For example, ``[3 .. 7]`` is a valid range expression. Its values are any integers between 
``3`` and ``7`` (including ``3`` and ``7`` themselves).

In a valid range, the start and end expression are integers, floats, or dates. If one of them 
is a date, then both must be dates. If one of them is an integer and the other a float, then
both are treated as floats.

.. index:: setliteral
.. _setliteral:

Set literal expressions
***********************

A set literal expression allows the explicit listing of a choice between several values.
It consists of a comma-separated collection of expressions that are enclosed in brackets (``[`` and ``]``).
For example, ``[2, 3, 5, 7, 11, 13, 17, 19, 23, 29]`` is a valid set literal expression.
Its values are the first ten prime numbers.

The values of the contained expressions need to be of :ref:`compatible types <type-compatibility>` for a valid set literal expression.
Furthermore, at least one of the set elements has to be of a type that is a supertype of the types of all
the other contained expressions.

.. index:: super
.. _super:

Super expressions
*****************

Super expressions in QL are similar to super expressions in other programming languages, such
as Java. You can use them in predicate calls, when you want to use the predicate definition 
from a supertype. In practice, this is useful when a predicate inherits two definitions from 
its supertypes. In that case, the predicate must :ref:`override <overriding-member-predicates>`
those definitions to avoid ambiguity.
However, if you want to use the definition from a particular supertype instead of writing a 
new definition, you can use a super expression.

In the following example, the class ``C`` inherits two definitions of the predicate 
``getANumber()``—one from ``A`` and one from ``B``. 
Instead of overriding both definitions, it uses the definition from ``B``.

.. code-block:: ql
   
    class A extends int {
      A() { this = 1 }
      int getANumber() { result = 2 }
    }
    
    class B extends int {
      B() { this = 1 }
      int getANumber() { result = 3 }
    }
    
    class C extends A, B {
      // Need to define `int getANumber()`; otherwise it would be ambiguous
      override int getANumber() {
        result = B.super.getANumber()
      }
    }
    
    from C c
    select c, c.getANumber()

The result of this query is ``1, 3``.

.. _calls-with-result:

Calls to predicates (with result)
*********************************

Calls to :ref:`predicates with results <predicates-with-result>` are themselves expressions,
unlike calls to :ref:`predicates without results <predicates-without-result>` which are
formulas. For more information, see ":ref:`calls`."

A call to a predicate with result evaluates to the values of the ``result`` variable of the
called predicate.

For example ``a.getAChild()`` is a call to a predicate ``getAChild()`` on a variable ``a``.
This call evaluates to the set of children of ``a``.

.. index:: aggregate
.. _aggregations:

Aggregations
************

An aggregation is a mapping that computes a result value from a set of input values that are
specified by a formula. 

The general syntax is:

.. code-block:: ql

    <aggregate>(<variable declarations> | <formula> | <expression>)

The variables :ref:`declared <variable-declarations>` in ``<variable declarations>`` are called
the **aggregation variables**.

Ordered aggregates (namely ``min``, ``max``, ``rank``, ``concat``, and ``strictconcat``) are
ordered by their ``<expression>`` values by default. The ordering is either numeric (for 
integers and floating point numbers) or lexicographic (for strings). Lexicographic ordering is
based on the `Unicode value <https://en.wikipedia.org/wiki/List_of_Unicode_characters#Basic_Latin>`_
of each character.

To specify a different order, follow ``<expression>`` with the keywords ``order by``, then
one or more comma-separated expressions that specify the order, and optionally the keyword ``asc`` or ``desc`` after each expression
(to determine whether to order the expression in ascending or descending order). If you don't
specify an ordering, it defaults to ``asc``. For example, ``order by o.getName() asc, o.getSize() desc``
might be used to order some object by name, breaking ties by descending size.

The following aggregates are available in QL:

.. index:: count

- ``count``: This aggregate determines the number of distinct values of ``<expression>`` for
  each possible assignment of the aggregation variables.
  
  For example, the following aggregation returns the number of files that have more than 
  ``500`` lines:

  .. code-block:: ql

      count(File f | f.getTotalNumberOfLines() > 500 | f)
  
  If there are no possible assignments to the aggregation variables that satisfy the formula, as in 
  ``count(int i | i = 1 and i = 2 | i)``, then ``count`` defaults to the value ``0``.

.. index:: min, max, minimum, maximum

- ``min`` and ``max``: These aggregates determine the smallest (``min``) or largest (``max``)
  value of ``<expression>`` among the possible assignments to the aggregation variables. 
  ``<expression>`` must be of numeric type or of type ``string``, or an explicit order must be defined with ``order by``.
  When using ``order by``, more than one result may exist in case of ties.
  
  For example, the following aggregation returns the name of the ``.js`` file (or files) with the 
  largest number of lines, using the number of lines of code to break ties:

  .. code-block:: ql

      max(File f | f.getExtension() = "js" | f.getBaseName() order by f.getTotalNumberOfLines(), f.getNumberOfLinesOfCode())

  The following aggregation returns the minimum string ``s`` out of the three strings mentioned
  below, that is, the string that comes first in the lexicographic ordering of all the possible
  values of ``s``. (In this case, it returns ``"De Morgan"``.)
  
  .. code-block:: ql

      min(string s | s = "Tarski" or s = "Dedekind" or s = "De Morgan" | s)

.. index:: avg, average

- ``avg``: This aggregate determines the average value of ``<expression>`` for all possible
  assignments to the aggregation variables. The type of ``<expression>`` must be numeric.
  If there are no possible assignments to the aggregation variables that satisfy the formula, the aggregation fails and
  returns no values. In other words, it evaluates to the empty set.
  
  For example, the following aggregation returns the average of the integers ``0``, ``1``,
  ``2``, and ``3``:

  .. code-block:: ql

      avg(int i | i = [0 .. 3] | i)

.. index:: sum

- ``sum``: This aggregate determines the sum of the values of ``<expression>`` over all possible 
  assignments to the aggregation variables. The type of ``<expression>`` must be numeric. 
  If there are no possible assignments to the aggregation variables that satisfy the formula, then the sum is ``0``.

  For example, the following aggregation returns the sum of ``i * j`` for all possible values
  of ``i`` and ``j``:

  .. code-block:: ql

      sum(int i, int j | i = [0 .. 2] and j = [3 .. 5] | i * j)

.. index:: concat

- ``concat``: This aggregate concatenates the values of ``<expression>`` over all possible 
  assignments to the aggregation variables. Note that ``<expression>`` must be of type 
  ``string``. If there are no possible assignments to the aggregation variables that satisfy
  the formula, then ``concat`` defaults to the empty string.

  For example, the following aggregation returns the string ``"3210"``, that is, the
  concatenation of the strings ``"0"``, ``"1"``, ``"2"``, and ``"3"`` in descending order:

  .. code-block:: ql

      concat(int i | i = [0 .. 3] | i.toString() order by i desc)

  The ``concat`` aggregate can also take a second expression, separated from the first one by
  a comma. This second expression is inserted as a separator between each concatenated value.

  For example, the following aggregation returns ``"0|1|2|3"``:

  .. code-block:: ql

      concat(int i | i = [0 .. 3] | i.toString(), "|")

.. index:: rank

- ``rank``: This aggregate takes the possible values of ``<expression>`` and ranks them. 
  ``<expression>`` must be of numeric type or of type ``string``, or an explicit order must be defined with ``order by``.
  The aggregation returns the value that is ranked in the position specified by the **rank expression**.
  You must include this rank expression in brackets after the keyword ``rank``.
  When using ``order by``, more than one result may exist in case of ties.

  For example, the following aggregation returns the value that is ranked 4th out of all the
  possible values. In this case, ``8`` is the 4th integer in the range from ``5`` through
  ``15``:

  .. code-block:: ql

      rank[4](int i | i = [5 .. 15] | i)

  .. pull-quote:: Note

     - Rank indices start at ``1``, so ``rank[0](...)`` has no result.
     - ``rank[1](...)`` is the same as ``min(...)``.

.. index:: strictconcat, strictcount, strictsum

- ``strictconcat``, ``strictcount``, and ``strictsum``: These aggregates work like ``concat``,
  ``count``, and ``sum`` respectively, except that they are *strict*. That is, if there are no
  possible assignments to the aggregation variables that satisfy the formula, then the entire aggregation fails and
  evaluates to the empty set (instead of defaulting to ``0`` or the empty string).
  This is useful if you're only interested in results where the aggregation body is non-trivial.

.. index:: unique

- ``unique``: This aggregate depends on the values of ``<expression>`` over all possible assignments to
  the aggregation variables. If there is a unique value of ``<expression>`` over the aggregation variables,
  then the aggregate evaluates to that value.
  Otherwise, the aggregate has no value.

  For example, the following query returns the positive integers ``1``, ``2``, ``3``, ``4``, ``5``.
  For negative integers ``x``, the expressions ``x`` and ``x.abs()`` have different values, so the
  value for ``y`` in the aggregate expression is not uniquely determined.

  .. code-block:: ql

      from int x
      where x in [-5 .. 5] and x != 0
      select unique(int y | y = x or y = x.abs() | y)

Evaluation of aggregates
========================

In general, aggregate evaluation involves the following steps:

#. Determine the input variables: these are the aggregation variables declared in ``<variable declarations>`` and 
   also the variables declared outside of the aggregate that are used in some component of the aggregate.

#. Generate all possible distinct tuples (combinations) of the values of input variables such that the
   ``<formula>`` holds true. Note that the same value of an aggregate variable may appear in 
   multiple distinct tuples. All such occurrences of the same value are treated as distinct occurrences 
   when processing tuples.

#. Apply ``<expression>`` on each tuple and collect the generated (distinct) values. The application 
   of ``<expression>`` on a tuple may result in generating more than one value.

#. Apply the aggregation function on the values generated in step 3 to compute the final result.

Let us apply these steps to the ``sum`` aggregate in the following query:

.. code-block:: ql

   select sum(int i, int j |
       exists(string s | s = "hello".charAt(i)) and exists(string s | s = "world!".charAt(j)) | i)

#. Input variables: ``i``, ``j``.

#. All possible tuples ``(<value of i>, <value of j>)`` satisfying the given condition: 
   ``(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (1, 0), (1, 1), ..., (4, 5)``.

   30 tuples are generated in this step.

#. Apply the ``<expression> i`` on all tuples. This means selecting all values of ``i`` from 
   all tuples: ``0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4.``

#. Apply the aggregation function ``sum`` on the above values to get the final result ``60``.

If we change ``<expression>`` to ``i + j`` in the above query, the query result is ``135`` since 
applying ``i + j`` on all tuples results in following values:
\ ``0, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6, 2, 3, 4, 5, 6, 7, 3, 4, 5, 6, 7, 8, 4, 5, 6, 7, 8, 9``.

Next, consider the following query:

.. code-block:: ql
 
   select count(string s | s = "hello" | s.charAt(_))

#. ``s`` is the input variable of the aggregate.

#. A single tuple ``"hello"`` is generated in this step.

#. The ``<expression> charAt(_)`` is applied on this tuple. The underscore ``_`` in ``charAt(_)``
   is a :ref:`don't-care expression <don-t-care-expressions>`, which represents any value.
   ``s.charAt(_)`` generates four distinct values ``h, e, l, o``.

#. Finally, ``count`` is applied on these values, and the query returns ``4``.  



Omitting parts of an aggregation
================================

The three parts of an aggregation are not always required, so you can often write the 
aggregation in a simpler form:

#. If you want to write an aggregation of the form ``<aggregate>(<type> v | <expression> = v | v)``,
   then you can omit the ``<variable declarations>`` and ``<formula>`` parts and write it 
   as follows:

   .. code-block:: ql

       <aggregate>(<expression>)

   For example, the following aggregations determine how many times the letter ``l`` occurs in
   string ``"hello"``. These forms are equivalent:

   .. code-block:: ql
   
       count(int i | i = "hello".indexOf("l") | i)
       count("hello".indexOf("l"))

#. If there is only one aggregation variable, you can omit the ``<expression>`` part instead.
   In this case, the expression is considered to be the aggregation variable itself.
   For example, the following aggregations are equivalent:

   .. code-block:: ql

       avg(int i | i = [0 .. 3] | i)
       avg(int i | i = [0 .. 3])
   
#. As a special case, you can omit the ``<expression>`` part from ``count`` even if there is more
   than one aggregation variable. In such a case, it counts the number of distinct tuples of
   aggregation variables that satisfy the formula. In other words, the expression part is
   considered to be the constant ``1``. For example, the following aggregations are equivalent:

   .. code-block:: ql
  
       count(int i, int j | i in [1 .. 3] and j in [1 .. 3] | 1)
       count(int i, int j | i in [1 .. 3] and j in [1 .. 3])

#. You can omit the ``<formula>`` part, but in that case you should include two vertical bars:

   .. code-block:: ql

       <aggregate>(<variable declarations> | | <expression>)

   This is useful if you don't want to restrict the aggregation variables any further. 
   For example, the following aggregation returns the maximum number of lines across all files:

   .. code-block:: ql

       max(File f | | f.getTotalNumberOfLines())

#. Finally, you can also omit both the ``<formula>`` and ``<expression>`` parts. For example,
   the following aggregations are equivalent ways to count the number of files in a database:

   .. code-block:: ql

       count(File f | any() | 1)
       count(File f | | 1)
       count(File f)

.. _monotonic-aggregates:

Monotonic aggregates
====================

In addition to standard aggregates, QL also supports monotonic aggregates.
Monotonic aggregates differ from standard aggregates in the way that they deal with the
values generated by the ``<expression>`` part of the formula:

- Standard aggregates take the ``<expression>`` values for each ``<formula>`` value and 
  flatten them into a list. A single aggregation function is applied to all the values.
- Monotonic aggregates take an ``<expression>`` for each value given by the ``<formula>``, 
  and create combinations of all the possible values. The aggregation 
  function is applied to each of the resulting combinations.

In general, if the ``<expression>`` is total and functional, then monotonic aggregates are 
equivalent to standard aggregates. Results differ when there is not precisely one ``<expression>`` 
value for each value generated by the ``<formula>``:

- If there are missing ``<expression>`` values (that is, there is no 
  ``<expression>`` value for a value generated by the ``<formula>``), monotonic aggregates 
  won't compute a result, as you cannot create combinations of values  
  including exactly one ``<expression>`` value for each value generated by the ``<formula>``.

- If there is more than one ``<expression>`` per ``<formula>`` result, you can create multiple 
  combinations of values including exactly one ``<expression>`` value for each 
  value generated by the ``<formula>``. Here, the aggregation function is applied to each of the 
  resulting combinations.

Example of monotonic aggregates
-------------------------------

Consider this query:

.. code-block:: ql

   string getPerson() { result = "Alice" or
                        result = "Bob" or
                        result = "Charles" or
                        result = "Diane"
                      }
   string getFruit(string p) { p = "Alice"   and result = "Orange" or
                               p = "Alice"   and result = "Apple" or
                               p = "Bob"     and result = "Apple" or
                               p = "Charles" and result = "Apple" or
                               p = "Charles" and result = "Banana"
                             }
   int getPrice(string f) { f = "Apple"  and result = 100 or
                            f = "Orange" and result = 100 or
                            f = "Orange" and result =   1
                          }

   predicate nonmono(string p, int cost) {
     p = getPerson() and cost = sum(string f | f = getFruit(p) | getPrice(f))
   }

   language[monotonicAggregates]
   predicate mono(string p, int cost) {
     p = getPerson() and cost = sum(string f | f = getFruit(p) | getPrice(f))
   }

   from string variant, string person, int cost
   where variant = "default"  and nonmono(person, cost) or
         variant = "monotonic" and mono(person, cost)
   select variant, person, cost
   order by variant, person

The query produces these results:

+-----------+---------+------+
|  variant  | person  | cost |
+===========+=========+======+
| default   | Alice   | 201  |
+-----------+---------+------+
| default   | Bob     | 100  |
+-----------+---------+------+
| default   | Charles | 100  |
+-----------+---------+------+
| default   | Diane   | 0    |
+-----------+---------+------+
| monotonic | Alice   | 101  |
+-----------+---------+------+
| monotonic | Alice   | 200  |
+-----------+---------+------+
| monotonic | Bob     | 100  |
+-----------+---------+------+
| monotonic | Diane   | 0    |
+-----------+---------+------+

The two variants of the aggregate semantics differ in what happens
when ``getPrice(f)`` has either multiple results or no results
for a given ``f``.

In this query, oranges are available at two different prices, and the
default ``sum`` aggregate returns a single line where Alice buys an
orange at a price of 100, another orange at a price of 1, and an apple
at a price of 100, totalling 201. On the other hand, in the 
*monotonic* semantics for ``sum``, Alice always buys one orange and
one apple, and a line of output is produced for each *way* she can
complete her shopping list.

If there had been two different prices for apples too, the monotonic
``sum`` would have produced *four* output lines for Alice.

Charles wants to buy a banana, which is not for sale at all. In the
default case, the sum produced for Charles includes the cost of the
apple he *can* buy, but there's no line for Charles in the monotonic
``sum`` output, because there *is no way* for Charles to buy one apple
plus one banana.

(Diane buys no fruit at all, and in both variants her total cost
is 0. The ``strictsum`` aggregate would have excluded her from the
results in both cases).

In actual QL practice, it is quite rare to use monotonic aggregates
with the *goal* of having multiple output lines, as in the "Alice"
case of this example. The more significant point is the "Charles"
case: As long as there's no price for bananas, no output is produced
for him. This means that if we later do learn of a banana price, we
don't need to *remove* any output tuple already produced. The
importance of this is that the monotonic aggregate behavior works well
with a fixpoint-based semantics for recursion, so it will be meaningful
to let the ``getPrice`` predicate be mutually recursive with the count
aggregate itself. (On the other hand, ``getFruit`` still cannot be
allowed to be recursive, because adding another fruit to someone's
shopping list would invalidate the total costs we already knew for
them).

This opportunity to use recursion is the main practical reason for
requesting monotonic semantics of aggregates.

Recursive monotonic aggregates
------------------------------

Monotonic aggregates may be used :ref:`recursively <recursion>`, but the recursive call may only appear in the 
expression, and not in the range. The recursive semantics for aggregates are the same as the
recursive semantics for the rest of QL. For example, we might define a predicate to calculate 
the distance of a node in a graph from the leaves as follows:

.. code-block:: ql

   language[monotonicAggregates]
   int depth(Node n) {
     if not exists(n.getAChild())
     then result = 0
     else result = 1 + max(Node child | child = n.getAChild() | depth(child))
   }

Here the recursive call is in the expression, which is legal. The recursive semantics for aggregates 
are the same as the recursive semantics for the rest of QL. If you understand how aggregates work in 
the non-recursive case then you should not find it difficult to use them recursively. However, it is 
worth seeing how the evaluation of a recursive aggregation proceeds.

Consider the depth example we just saw with the following graph as input (arrows point from children to parents):

.. |image0| image:: ../images/monotonic-aggregates-graph.png

|image0|

Then the evaluation of the ``depth`` predicate proceeds as follows:

+-----------+--------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Stage** | **depth**                                  | **Comments**                                                                                                                                                             |
+===========+============================================+==========================================================================================================================================================================+
| 0         |                                            | We always begin with the empty set.                                                                                                                                      |
+-----------+--------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 1         | ``(0, b), (0, d), (0, e)``                 | The nodes with no children have depth 0. The recursive step for **a** and **c** fails to produce a value, since some of their children do not have values for ``depth``. |
+-----------+--------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 2         | ``(0, b), (0, d), (0, e), (1, c)``         | The recursive step for **c** succeeds, since ``depth`` now has a value for all its children (**d** and **e**). The recursive step for **a** still fails.                 |
+-----------+--------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 3         | ``(0, b), (0, d), (0, e), (1, c), (2, a)`` | The recursive step for **a** succeeds, since ``depth`` now has a value for all its children (**b** and **c**).                                                           |
+-----------+--------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Here, we can see that at the intermediate stages it is very important for the aggregate to 
fail if some of the children lack a value - this prevents erroneous values being added.

.. index:: any

Any
***

The general syntax of an ``any`` expression is similar to the syntax of an
:ref:`aggregation <aggregations>`, namely:

.. code-block:: ql

    any(<variable declarations> | <formula> | <expression>)

You should always include the :ref:`variable declarations <variable-declarations>`, but the
:ref:`formula <formulas>` and :ref:`expression <expressions>` parts are optional.

The ``any`` expression denotes any values that are of a particular form and that satisfy a
particular condition.
More precisely, the ``any`` expression:

#. Introduces temporary variables.
#. Restricts their values to those that satisfy the ``<formula>`` part (if it's present).
#. Returns ``<expression>`` for each of those variables. If there is no ``<expression>`` part,
   then it returns the variables themselves.

The following table lists some examples of different forms of ``any`` expressions:

+------------------------------------------+-------------------------------------------------+
| Expression                               | Values                                          |
+==========================================+=================================================+
| ``any(File f)``                          | all ``File``\ s in the database                 |
+------------------------------------------+-------------------------------------------------+
| ``any(Element e | e.getName())``         | the names of all ``Element``\ s in the database |
+------------------------------------------+-------------------------------------------------+
| ``any(int i | i = [0 .. 3])``            | the integers ``0``, ``1``, ``2``, and ``3``     |
+------------------------------------------+-------------------------------------------------+
| ``any(int i | i = [0 .. 3] | i * i)``    | the integers ``0``, ``1``, ``4``, and ``9``     |
+------------------------------------------+-------------------------------------------------+

.. pull-quote:: Note

   There is also a `built-in predicate <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#non-member-built-ins>`_
   ``any()``. This is a predicate that always holds.

Unary operations
****************

A unary operation is a minus sign (``-``) or a plus sign (``+``) followed by an expression of type
``int`` or ``float``. For example:

.. code-block:: ql

    -6.28
    +(10 - 4)
    +avg(float f | f = 3.4 or f = -9.8)
    -sum(int i | i in [0 .. 9] | i * i)

A plus sign leaves the values of the expression unchanged, while a minus sign takes the
arithmetic negations of the values.

.. _binary-operations:

Binary operations
*****************

A binary operation consists of an expression, followed by a binary operator, followed by 
another expression. For example:

.. code-block:: ql

    5 % 2
    (9 + 1) / (-2)
    "Q" + "L"
    2 * min(float f | f in [-3 .. 3])

.. index:: addition, concatenation, multiplication, division, subtraction, modulo
   seealso: concatenation; concat

You can use the following binary operators in QL:

+------------------------+--------+
| Name                   | Symbol |
+========================+========+
| Addition/concatenation | ``+``  |
+------------------------+--------+
| Multiplication         | ``*``  |
+------------------------+--------+
| Division               | ``/``  |
+------------------------+--------+
| Subtraction            | ``-``  |
+------------------------+--------+
| Modulo                 | ``%``  |
+------------------------+--------+

If both expressions are numbers, these operators act as standard arithmetic operators. For 
example, ``10.6 - 3.2`` has value ``7.4``, ``123.456 * 0`` has value ``0``, and ``9 % 4`` has 
value ``1`` (the remainder after dividing ``9`` by ``4``).
If both operands are integers, then the result is an integer. Otherwise the result is a 
floating-point number.

You can also use ``+`` as a string concatenation operator. In this case, at least one of the 
expressions must be a string—the other expression is implicitly converted to a string using the
``toString()`` predicate. The two expressions are concatenated, and the result is a string. For
example, the expression ``221 + "B"`` has value ``"221B"``.

.. _casts:

Casts
*****

A cast allows you to constrain the :ref:`type <types>` of an expression. This is similar to casting in other 
languages, for example in Java. 

You can write a cast in two ways: 
  - As a "postfix" cast: A dot followed by the name of a type in parentheses. 
    For example, ``x.(Foo)`` restricts the type of ``x`` to ``Foo``.
  - As a "prefix" cast: A type in parentheses followed by another expression. 
    For example, ``(Foo)x`` also restricts the type of ``x`` to ``Foo``.

Note that a postfix cast is equivalent to a prefix cast surrounded by parentheses—``x.(Foo)``
is exactly equivalent to ``((Foo)x)``.

Casts are useful if you want to call a :ref:`member predicate <member-predicates>` that is only defined for a more 
specific type. For example, the following query selects Java 
`classes <https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Type.qll/type.Type$Class.html>`_
that have a direct supertype called "List":

.. code-block:: ql

    import java
    
    from Type t
    where t.(Class).getASupertype().hasName("List")    
    select t

Since the predicate ``getASupertype()`` is defined for ``Class``, but not for ``Type``, you 
can't call ``t.getASupertype()`` directly. The cast ``t.(Class)`` ensures that ``t`` is
of type ``Class``, so it has access to the desired predicate.

If you prefer to use a prefix cast, you can rewrite the ``where`` part as:

.. code-block:: ql

    where ((Class)t).getASupertype().hasName("List")

.. index:: underscore
.. _don-t-care-expressions:

Don't-care expressions
**********************

This is an expression written as a single underscore ``_``. It represents any value. (You 
"don't care" what the value is.) 

Unlike other expressions, a don't-care expression does not have a type. In practice, this 
means that ``_`` doesn't have any :ref:`member predicates <member-predicates>`, so you can't
call ``_.somePredicate()``.

For example, the following query selects all the characters in the string ``"hello"``:

.. code-block:: ql

    from string s
    where s = "hello".charAt(_)
    select s

The ``charAt(int i)`` predicate is defined on strings and usually takes an ``int`` argument.
Here the don't care expression ``_`` is used to tell the query to select characters at
every possible index. The query returns the values ``h``, ``e``, ``l``, and ``o``.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/ql-language-specification.rst
:tocdepth: 1

.. _ql-language-specification:

QL language specification
=========================

This is a formal specification for the QL language. It provides a comprehensive reference for terminology, syntax, and other technical details about QL.

Introduction
------------

QL is a query language for CodeQL databases. The data is relational: named relations hold sets of tuples. The query language is a dialect of Datalog, using stratified semantics, and it includes object-oriented classes.

Notation
--------

This section describes the notation used in the specification.

Unicode characters
~~~~~~~~~~~~~~~~~~

Unicode characters in this document are described in two ways. One is to supply the character inline in the text, between double quote marks. The other is to write a capital U, followed by a plus sign, followed by a four-digit hexadecimal number representing the character's code point. As an example of both, the first character in the name QL is "Q" (U+0051).

Grammars
~~~~~~~~

The syntactic forms of QL constructs are specified using a modified Backus-Naur Form (BNF). Syntactic forms, including classes of tokens, are named using bare identifiers. Quoted text denotes a token by its exact sequence of characters in the source code.

BNF derivation rules are written as an identifier naming the syntactic element, followed by ``::=``, followed by the syntax itself.

In the syntax itself, juxtaposition indicates sequencing. The vertical bar (``|``, U+007C) indicates alternate syntax. Parentheses indicate grouping. An asterisk (``*``, U+002A) indicates repetition zero or more times, and a plus sign (``+``, U+002B) indicates repetition one or more times. Syntax followed by a question mark (``?``, U+003F) indicates zero or one occurrences of that syntax.

Architecture
------------

A *QL program* consists of a query module defined in a QL file and a number of library modules defined in QLL files that it imports (see "`Import directives <#import-directives>`__"). The module in the QL file includes one or more queries (see "`Queries <#queries>`__"). A module may also include *import directives* (see "`Import directives <#import-directives>`__"), non-member predicates (see "`Non-member predicates <#non-member-predicates>`__"), class definitions (see "`Classes <#classes>`__"), and module definitions (see "`Modules <#modules>`__").

QL programs are interpreted in the context of a *database* and a *library path* . The database provides a number of definitions: database types (see "`Types <#types>`__"), entities (see "`Values <#values>`__"), built-in predicates (see "`Built-ins <#built-ins>`__"), and the *database content* of built-in predicates and external predicates (see "`Evaluation <#evaluation>`__"). The library path is a sequence of file-system directories that hold QLL files.

A QL program can be *evaluated* (see "`Evaluation <#evaluation>`__") to produce a set of tuples of values (see "`Values <#values>`__").

For a QL program to be *valid*, it must conform to a variety of conditions that are described throughout this specification; otherwise the program is said to be *invalid*. An implementation of QL must detect all invalid programs and refuse to evaluate them.

Library path
------------

The library path is an ordered list of directory locations. It is used
for resolving module imports (see "`Module resolution <#module-resolution>`__"). The library path is not strictly
speaking a core part of the QL language, since different
implementations of QL construct it in slightly different ways. Most QL
tools also allow you to explicitly specify the library path on the command line for a
particular invocation, though that is rarely done, and only
useful in very special situations. This section describes the default
construction of the library path.

First, determine the *query directory* of the ``.ql`` file being
compiled. Starting with the directory containing the ``.ql`` file, and
walking up the directory structure, each directory is checked for a
file called ``qlpack.yml`` or ``codeql-pack.yml``. The first directory
where such a file is found is the query directory. If there is no such
directory, the directory of the ``.ql`` file itself is the query
directory.

A ``qlpack.yml`` file defines a `CodeQL pack <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs>`__.
The content of a ``qlpack.yml`` file is described in the CodeQL CLI documentation.
``codeql-pack.yml`` is an alias for ``qlpack.yml``.

The CodeQL CLI and tools based on it (such as,
GitHub code scanning and the CodeQL extension for Visual Studio Code)
construct a library path using CodeQL packs. For each CodeQL pack
added to the library path, the CodeQL packs named in its
``dependencies`` will be subsequently added to the library
path, and the process continues until all packs have been
resolved. The actual library path consists of the root directories of
the selected CodeQL packs. This process depends on a mechanism for finding
CodeQL packs by pack name and version, as described in the `CodeQL CLI documentation <https://docs.github.com/en/code-security/codeql-cli>`__.

When the query directory contains neither a ``qlpack.yml`` nor
``codeql-pack.yml`` file, it is considered to be a CodeQL pack with no name and
no library dependencies. This causes the library path to consist of
*only* the query directory itself. This is not generally useful,
but it suffices for running toy examples of QL code that don't
use information from the database.

Name resolution
---------------

All modules have six environments that dictate name resolution. These are multimaps of keys to declarations.

The environments are:

-  The *module environment*, whose keys are module names and whose values are modules.
-  The *type environment*, whose keys are type names and whose values are types.
-  The *predicate environment*, whose keys are pairs of predicate names and arities and whose values are predicates.
-  The *module signature environment*, whose keys are module signature names and whose values are module signatures.
-  The *type signature environment*, whose keys are type signature names and whose values are type signatures.
-  The *predicate signature environment*, whose keys are pairs of predicate signature names and arities and whose values are predicate signatures.

For each module, some namespaces are enforced to be disjoint:

-  No keys may be shared between the **module namespace** and the **module signature namespace**.
-  No keys may be shared between the **type namespace** and the **type signature namespace**.
-  No keys may be shared between the **module namespace** and the **type signature namespace**.
-  No keys may be shared between the **type namespace** and the **module signature namespace**.
-  No keys may be shared between the **predicate namespace** and the **predicate signature namespace**.
-  No keys may be shared between the **module signature namespace** and the **type signature namespace**.

If not otherwise specified, then the environment for a piece of syntax is the same as the environment of its enclosing syntax.

When a key is resolved in an environment, if there is no value for that key, then the program is invalid.

Environments may be combined as follows:

-  *Union*. This takes the union of the entry sets of the two environments.
-  *Overriding union*. This takes the union of two environments, but if there are entries for a key in the first map, then no additional entries for that key are included from the second map.

A *definite* environment has only values that are *equal modulo weak aliasing* for each key.

Global environments
~~~~~~~~~~~~~~~~~~~

The global module environment has a single entry ``QlBuiltins``.

The global type environment has entries for the primitive types ``int``, ``float``, ``string``, ``boolean``, and ``date``.

The global predicate environment includes all the built-in classless predicates.

The three global signature environments are empty.

Database schema environments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The database schema type environment has entries for types declared in the database schema.

The database schema predicate environment has entries for extensional predicates declared in the database schema.

The program is invalid if any of these environments is not definite.

Module environments
~~~~~~~~~~~~~~~~~~~

For each of modules, types, predicates, module signatures, type signatures, and predicates signatures, we distinguish four environments: *publically declared*, *privately declared*, *exported*, and *visible*.
These are defined as follows (with X denoting the type of entity we are currently considering):

-  The *privately declared X environment* of a module is the multimap of X declarations and aliases in the module itself that are annotated as ``private``.

-  The *publically declared X environment* of a module is the multimap of X declarations and aliases in the module itself that are not annotated as ``private``.

-  The *exported X environment* of a module is the union of

    1.  its *publically declared X environment*, and

    2.  for each module which the current module directly imports (excluding ``private`` imports - see "`Import directives <#import-directives>`__"): all entries from the *exported X environment* that have a key not present in the *publically declared X environment* of the current module, and

    3.  if X is ``predicate``, then for each module signature ``S`` that is implemented by the current module: an entry for each module signature default predicate in ``S`` that does not have the same name and arity as any of the entries in the **publically declared predicate environment** of the current module.

-  The *visible X environment* of a module is the union of

    1. its *exported X environment*, and

    2. its *privately declared X environment*, and

    3. the *global X environment*, and

    4. for each module which the current module privately imports: all entries from the *exported X environment* that have a key not present in the *publically declared X environment* of the current module, and

    5. if there is an enclosing module: all entries from the *visible X environment* of the enclosing module that have a key not present in the *publically declared X environment* of the current module, and

    6. if there is no enclosing module and X is either ``type`` or ``predicate``: all entries from the *database schema X environment* that have a key not present in the *publically declared X environment* of the current module, and

    7. all parameters of the current module that are of type X.

The program is invalid if any of these environments is not definite.

Module definitions may be recursive, so the module environments are defined as the least fixed point of the operator given by the above definition. Since all the operations involved are monotonic, this fixed point exists and is unique.

Modules
-------

Module definitions
~~~~~~~~~~~~~~~~~~

A QL module definition has the following syntax:

::

   module ::= annotation* "module" modulename parameters? implements? "{" moduleBody "}"

   parameters ::= "<" signatureExpr parameterName ("," signatureExpr parameterName)* ">"

   implements ::= "implements" moduleSignatureExpr ("," moduleSignatureExpr)*

   moduleBody ::= (import | predicate | class | module | signature | alias | select)*

A module definition extends the current module's declared module environment with a mapping from the module name to the module definition.

QL files and QLL files consist of simply a module body without a name and surrounding braces:

::

   ql ::= moduleBody

QL files and QLL files define a module corresponding to the file, whose name is the same as the filename.

Kinds of modules
~~~~~~~~~~~~~~~~

A module may be:

-  A *declared module*, if it is defined by the ``module`` or ``ql`` grammar rules.
-  A *non-declared module*, if it is not a *declared module*.

A *declared module* may be:

-  A *file module*, if it is defined implicitly by a QL file or a QLL file.
-  A *query module*, if it is defined implicitly by a QL file.
-  A *library module*, if it is not a query module.

A *non-declared module* may be:

-  A *built-in module*.
-  An *instantiated module* (see :ref:`Parameterized modules`).
-  An *instantiation-nested module*  (see :ref:`Parameterized modules`).

A query module must contain one or more queries.

Import directives
~~~~~~~~~~~~~~~~~

An import directive refers to a module expression:

::

   import ::= annotations "import" importModuleExpr ("as" modulename)?

   importModuleExpr ::= importModuleId arguments?

   importModuleId ::= qualId | importModuleExpr "::" modulename

   qualId ::= simpleId | qualId "." simpleId

   arguments ::= "<" argument ("," argument)* ">"

   argument ::= moduleExpr | type | predicateRef "/" int

An import directive may optionally name the imported module using an ``as`` declaration. If a name is defined, then the import directive adds to the declared module environment of the current module a mapping from the name to the declaration of the imported module. Otherwise, the current module *directly imports* the imported module.

Module resolution
~~~~~~~~~~~~~~~~~

Module identifiers are resolved to modules as follows.

For simple identifiers:

-  First, the identifier is resolved as a one-segment qualified identifier (see below).

-  If this fails, the identifier is resolved in the current module's visible module environment.

For selection identifiers (``a::b``):

-  The qualifier of the selection (``a``) is resolved as a module, and then the name (``b``) is resolved in the exported module environment of the qualifier module.

For qualified identifiers (``a.b``):

-  Build up a list of *candidate search paths*, consisting of the current file's directory, then the *query directory* of the current file, and finally each of the directories on the `library path <#library-path>`__ (in order).

-  Determine the first candidate search path that has a *matching* QLL file for the import directive's qualified name. A QLL file in a candidate search path is said to match a qualified name if, starting from the candidate search path, there is a subdirectory for each successive qualifier in the qualified name, and the directory named by the final qualifier contains a file whose base name matches the qualified name's base name, with the addition of the file extension ``.qll``. The file and directory names are matched case-sensitively, regardless of whether the filesystem is case-sensitive or not.

-  The resolved module is the module defined by the selected candidate search path.

A qualified module identifier is only valid within an import.

Module expressions contain a module identifier and optional arguments. If arguments are present, the module expression instantiates the module that the identifier resolves to (see :ref:`Parameterized modules`).

Module expressions cannot refer to :ref:`Parameterized modules`. Instead, parameterized modules must always be fully instantiated when they are referenced.

.. _Parameterized modules:

Parameterized modules
~~~~~~~~~~~~~~~~~~~~~

Modules with parameters are called *parameterized modules*. A *declared module* has parameters if and only if it is a *library module* and its declaration uses the ``parameters`` syntax.

*Parameterized modules* can be instantiated with arguments that match the signatures of the parameters:

- Given a type signature, the corresponding argument must be a type that transitively extends the specified ``extends`` types and is a transitive subtype of the specified ``instanceof`` types.
- Given a predicate signature, the corresponding argument must be a predicate with exactly matching relational types.
- Given a module signature, the corresponding argument must be a module that exports all the specified type and predicate members. Furthermore, the module must be declared as matching the module signature via the ``implements`` syntax.

The result of instantiating a *parameterized module* is an *instantiated module*. The parameterized module is called the *underlying module* of the *instantiated module*.

Instantiation-relative and instantiation-nested entities
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Given an *instantiated module*, every entity has a corresponding entity called the *instantiation-relative* entity, which is determined as follows:

- If the entity is the *underlying module*, its *instantiation-relative* entity is the *instantiated module*.
- If the entity is a parameter of the *underlying module*, its *instantiation-relative* entity is the corresponding argument.
- If the entity is declared inside the *underlying module* or its nested modules, its *instantiation-relative* entity is an *instantiation-nested* entity that is generated by the module instantiation. Parameters of any modules that are nested inside the *underlying module* are considered declared inside the module for this purpose.
- Otherwise, the entity's *instantiation-relative* entity is the initial entity itself.

When the *instantiation-relative* entity of an entity is an *instantiation-nested* entity, then the initial entity is called the *underlying nested* entity of the *instantiation-nested* entity*, the *instantiated module* is called the *instantiation root* of the *instantiation-nested* entity, and the *underlying module* is called the *underlying root* of the *instantiation-nested* entity.

The components of an *instantiation-nested* entity are the *instantiation-relative* entities of the components of its *underlying nested* entity. Among other things, this applies to:

- values in the exported environments of *instantiation-nested* modules,
- relational types of *instantiation-nested* predicates and predicate signatures,
- required signatures of *instantiation-nested* parameters,
- parameters of an *instantiation-nested* *parameterized module*,
- fields and member predicates of *instantiation-nested* dataclasses.

Given an *instantiated module*, any alias in the program has a corresponding alias called the *instantiation-relative* alias, which targets the *instantiation-relative* entity.

Applicative instantiation
~~~~~~~~~~~~~~~~~~~~~~~~~

Every entity has an *underlying completely uninstantiated* entity that is determined as follows:

- If the entity is an *instantiated module*, its *underlying completely uninstantiated* entity is the *underlying completely uninstantiated* entity of the *underlying module*.
- If the entity is an *instantiation-nested* entity, its *underlying completely uninstantiated* entity is the *underlying completely uninstantiated* entity of the *underlying nested* entity.
- Otherwise, its *underlying completely uninstantiated* entity is the entity itself.

An entity is called *completely uninstantiated* entity if it is its own *underlying completely uninstantiated* entity.

Every *completely uninstantiated* entity has a *relevant set of parameters*, which is the set of all parameters of all the modules that the entity is transitively nested inside. For entities that are not nested inside any modules, the *relevant set of parameters* is empty.

Note that the *relevant set of parameters* by construction contains only *completely uninstantiated* parameters.

For a *completely uninstantiated* parameter, the *bottom-up instantiation-resolution* relative to an entity is defined as:

- If the entity is an *instantiated module* or an *instantiation-nested* entity, the *bottom-up instantiation-resolution* is the *instantiation-relative* entity of the *bottom-up instantiation-resolution* relative to the *underlying module*.
- Otherwise, the *bottom-up instantiation-resolution* is the parameter itself.

An entity is called *fully instantiated* if none of the *bottom-up instantiation-resolutions* of the parameters in the *relevant set of parameters* of the entity's *underlying completely uninstantiated* entity are parameters.

Two *instantiated modules* or two *instantiation-nested* entities are considered *equivalent* if they have the same *underlying completely uninstantiated* entity and each parameter in its *relevant set of parameters* has *bottom-up instantiation-resolution*s relative both *instantiated module*s that are *equivalent modulo weak aliases*.

Module instantiation is applicative, meaning that *equivalent* *instantiated modules* and *equivalent* *instantiation-nested* entities are indistinguishable.

Module references and active modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A module ``M`` *references* another module ``N`` if any of the following holds:

-  ``M`` imports ``N``.
-  ``M`` defines ``N``.
-  ``N`` is ``M``'s enclosing module.

In a QL program, the *active* modules are the modules which are referenced transitively by the query module.

Types
-----

QL is a typed language. This section specifies the kinds of types available, their attributes, and the syntax for referring to them.

Kinds of types
~~~~~~~~~~~~~~

Types in QL are either *primitive* types, *database* types, *class* types, *character* types, *class domain* types, type *parameters*, or *instantiation-nested* types.

The primitive types are ``boolean``, ``date``, ``float``, ``int``, and ``string``.

Database types are supplied as part of the database. Each database type has a *name*, which is an identifier starting with an at sign (``@``, U+0040) followed by lower-case letter. Database types have some number of *base types*, which are other database types. In a valid database, the base types relation is non-cyclic.

Class types are defined in QL, in a way specified later in this document (see "`Classes <#classes>`__"). Each class type has a name that is an identifier starting with an upper-case letter. Each class type has one or more base types, which can be any kind of type except a class domain type. A class type may be declared *abstract*.

Any class in QL has an associated class domain type and an associated character type.

Within the specification the class type for ``C`` is written ``C.class``, the character type is written ``C.C`` and the domain type is written ``C.extends``. However the class type is still named ``C``.

Type references
~~~~~~~~~~~~~~~

With the exception of class domain types and character types (which cannot be referenced explicitly in QL source), a reference to a type is written as the name of the type. In the case of database types, the name includes the at sign (``@``, U+0040).

::

   type ::= (moduleExpr "::")? classname | dbasetype | "boolean" | "date" | "float" | "int" | "string"

   moduleExpr ::= moduleId arguments?

   moduleId ::= modulename | moduleExpr "::" modulename

A type reference is resolved to a type as follows:

-  If it is a selection identifier (for example, ``a::B``), then the qualifier (``a``) is resolved as a module (see "`Module resolution <#module-resolution>`__"). The identifier (``B``) is then resolved in the exported type environment of the qualifier module.

-  Otherwise, the identifier is resolved in the current module's visible type environment.

Relations among types
~~~~~~~~~~~~~~~~~~~~~

Types are in a subtype relationship with each other. Type A is a *subtype* of type B if one of the following is true:

-  A and B are the same type.

-  There is some type C, where A is a subtype of C and C is a subtype of B.

-  A and B are database types, and B is a base type of A.

-  A is the character type of C, and B is the class domain type of C.

-  A is a class type, and B is the character type of A.

-  A is a class domain type, and B is a base type of the associated class type.

-  A is ``int`` and B is ``float``.

Supertypes are the converse of subtypes: A is a *supertype* of B if B is a subtype of A.

Types A and B are *compatible* with each other if they either have a common supertype, or they each have some supertype that is a database type.

Typing environments
~~~~~~~~~~~~~~~~~~~

A *typing environment* is a finite map of variables to types. Each variable in the map is either an identifier or one of two special symbols: ``this``, and ``result``.

Most forms of QL syntax have a typing environment that applies to them. That typing environment is determined by the context the syntax appears in.

Note that this is distinct from the type environment, which is a map from type names to types.

Active types
~~~~~~~~~~~~

In a QL program, the *active* types are those defined in active modules. In the remainder of this specification, any reference to the types in the program refers only to the active types.

Values
------

Values are the fundamental data that QL programs compute over. This section specifies the kinds of values available in QL, specifies the sorting order for them, and describes how values can be combined into tuples.

Kinds of values
~~~~~~~~~~~~~~~

There are six kinds of values in QL: one kind for each of the five primitive types, and *entities*. Each value has a type.

A boolean value is of type ``boolean``, and may have one of two distinct values: ``true`` or ``false``.

A date value is of type ``date``. It encodes a time and a date in the Gregorian calendar. Specifically, it includes a year, a month, a day, an hour, a minute, a second, and a millisecond, each of which are integers. The year ranges from -16777216 to 16777215, the month from 0 to 11, the day from 1 to 31, the hour from 0 to 23, the minutes from 0 to 59, the seconds from 0 to 59, and the milliseconds from 0 to 999.

A float value is of type ``float``. Each float value is a binary 64-bit floating-point value as specified in IEEE 754.

An integer value is of type ``int``. Each value is a 32-bit two's complement integer.

A string is a finite sequence of 16-bit characters. The characters are interpreted as Unicode code points.

The database includes a number of opaque entity values. Each such value has a type that is one of the database types, and an identifying integer. An entity value is written as the name of its database type followed by its identifying integer in parentheses. For example, ``@tree(12)``, ``@person(16)``, and ``@location(38132)`` are entity values. The identifying integers are left opaque to programmers in this specification, so an implementation of QL is free to use some other set of countable labels to identify its entities.

Ordering
~~~~~~~~

Values in general do not have a specified ordering. In particular, entity values have no specified ordering with entities or any other values. Primitive values, however, have a total ordering with other primitive values in the same type. Primitives types and their subtypes are said to be *orderable*.

For booleans, ``false`` is ordered before ``true``.

For dates, the ordering is chronological.

For floats, the ordering is as specified in IEEE 754 when one exists, except that NaN is considered equal to itself and is ordered after all other floats, and negative zero is considered to be strictly less than positive zero.

For integers, the ordering is as for two's complement integers.

For strings, the ordering is lexicographic.

Tuples
~~~~~~

Values can be grouped into tuples in two different ways.

An *ordered tuple* is a finite, ordered sequence of values. For example, (``1``, ``2``, ``"three"``) is an ordered sequence of two integers and a string.

A *named tuple* is a finite map of variables to values. Each variable in a named tuple is either an identifier, ``this``, or ``result``.

A *variable declaration list* provides a sequence of variables and a type for each one:

::

   var_decls ::= (var_decl ("," var_decl)*)?
   var_decl ::= type lowerId

A valid variable declaration list must not include two declarations with the same variable name. Moreover, if the declaration has a typing environment that applies, it must not use a variable name that is already present in that typing environment.

An *extension* of a named tuple for a given variable declaration list is a named tuple that additionally maps each variable in the list to a value. The value mapped by each new variable must be in the type that is associated with that variable in the given list; see "`The store <#the-store>`__" for the definition of a value being in a type.

The store
---------

QL programs evaluate in the context of a *store*. This section specifies several definitions related to the store.

A *fact* is a predicate or type along with a named tuple. A fact is written as the predicate name or type name followed immediately by the tuple. Here are some examples of facts:

::

   successor(fst: 0, snd:1)
   Tree.toString(this:@method_tree(12), result:"def println")
   Location.class(this:@location(43))
   Location.getURL(this: @location(43), result:"file:///etc/hosts:2:0:2:12")

A *store* is a mutable set of facts. The store can be mutated by adding more facts to it.

An named tuple *directly satisfies* a predicate or type with a given tuple if there is a fact in the store with the given tuple and predicate or type.

A value ``v`` is in a type ``t`` under any of the following conditions:

-  The type of ``v`` is ``t`` and ``t`` is a primitive type.
-  There is a tuple with ``this`` component ``v`` that directly satisfies ``t``.

An ordered tuple ``v`` *directly satisfies* a predicate with a given tuple if there is a fact in the store with the given predicate and a named tuple ``v'``
such that taking the ordered tuple formed by the ``this`` component of ``v'`` followed by the component for each argument equals the ordered tuple.

An ordered tuple *satisfies a predicate* ``p`` under the following circumstances. If ``p`` is not a member predicate, then the tuple satisfies the predicate whenever the named tuple satisfies the tuple.

Otherwise, the tuple must be the tuple of a fact in the store with predicate ``q``, where ``q`` shares a root definition with ``p``. The `first` element of the tuple must be in the type before the dot in ``q``, and there must be no other predicate that overrides ``q`` such that this is true (see "`Classes <#classes>`__" for details on overriding and root definitions).

An ordered tuple ``(a0, an)`` satisfies the ``+`` closure of a predicate if there is a sequence of binary tuples ``(a0, a1)``, ``(a1, a2)``, ..., ``(an-1, an)`` that all satisfy the predicate. An ordered tuple ``(a, b)`` satisfies the ``*`` closure of a predicate if it either satisfies the ``+`` closure, or if ``a`` and ``b`` are the same, and if moreover they are in each argument type of the predicate.

Lexical syntax
--------------

QL and QLL files contain a sequence of *tokens* that are encoded as Unicode text. This section describes the tokenization algorithm, the kinds of available tokens, and their representation in Unicode.

Some kinds of tokens have an identifier given in parentheses in the section title. That identifier, if present, is a terminal used in grammar productions later in the specification. Additionally, the "`Identifiers <#identifiers>`__" section gives several kinds of identifiers, each of which has its own grammar terminal.

Tokenization
~~~~~~~~~~~~

Source files are interpreted as a sequence of tokens according to the following algorithm. First, the longest-match rule, described below, is applied starting at the beginning of the file. Second, all whitespace tokens and comments are discarded from the sequence.

The longest-match rule is applied as follows. The first token in the file is the longest token consisting of a contiguous sequence of characters at the beginning of the file. The next token after any other token is the longest token consisting of contiguous characters that immediately follow any previous token.

If the file cannot be tokenized in its entirety, then the file is invalid.

Whitespace
~~~~~~~~~~

A whitespace token is a sequence of spaces (U+0020), tabs (U+0009), carriage returns (U+000D), and line feeds (U+000A).

Comments
~~~~~~~~

There are two kinds of comments in QL: one-line and multiline.

A one-line comment is two slash characters (``/``, U+002F) followed by any sequence of characters other than line feeds (U+000A) and carriage returns (U+000D). Here is an example of a one-line comment:

::

   // This is a comment

A multiline comment is a *comment start*, followed by a *comment body*, followed by a *comment end*. A comment start is a slash (``/``, U+002F) followed by an asterisk (``*``, U+002A), and a comment end is an asterisk followed by a slash. A comment body is any sequence of characters that does not include a comment end and does not start with an asterisk. Here is an example multiline comment:

::

   /*
     It was the best of code.
     It was the worst of code.
     It had a multiline comment.
   */

QLDoc (qldoc)
~~~~~~~~~~~~~

A QLDoc comment is a *qldoc comment start*, followed by a *qldoc comment body*, followed by a *qldoc comment end*. A comment start is a slash (``/``, U+002F) followed by two asterisks (``*``, U+002A), and a qldoc comment end is an asterisk followed by a slash. A qldoc comment body is any sequence of characters that does not include a comment end. Here is an example QLDoc comment:

::

   /**
     It was the best of code.
     It was the worst of code.
     It had a qldoc comment.
   */

The "content" of a QLDoc comment is the comment body of the comment, omitting the initial ``/**``, the trailing ``*/``, and the leading whitespace followed by ``*`` on each internal line.

For more information about how the content is interpreted, see "`QLDoc <#qldoc>`__" below.

Keywords
~~~~~~~~

The following sequences of characters are keyword tokens:

::

   and
   any
   as
   asc
   avg
   boolean
   by
   class
   concat
   count
   date
   desc
   else
   exists
   extends
   false
   float
   forall
   forex
   from
   if
   implies
   import
   in
   instanceof
   int
   max
   min
   module
   newtype
   none
   not
   or
   order
   predicate
   rank
   result
   select
   strictconcat
   strictcount
   strictsum
   string
   sum
   super
   then
   this
   true
   unique
   where

Operators
~~~~~~~~~

The following sequences of characters are operator tokens:

::

   <
   <=
   =
   >
   >=
   _
   -
   ,
   ;
   !=
   /
   .
   ..
   (
   )
   [
   ]
   {
   }
   *
   %
   +
   |

Identifiers
~~~~~~~~~~~

An identifier is an optional "@" sign (U+0040) followed by a sequence of identifier characters. Identifier characters are lower-case ASCII letters (``a`` through ``z``, U+0061 through U+007A), upper-case ASCII letters (``A`` through ``Z``, U+0041 through U+005A), decimal digits (``0`` through ``9``, U+0030 through U+0039), and underscores (``_``, U+005F). The first character of an identifier other than any "@" sign must be a letter.

An identifier cannot have the same sequence of characters as a keyword, nor can it be an "@" sign followed by a keyword.

Here are some examples of identifiers:

::

   width
   Window_width
   window5000_mark_II
   @expr

There are several kinds of identifiers:

-  ``lowerId``: an identifier that starts with a lower-case letter.

-  ``upperId``: an identifier that starts with an upper-case letter.

-  ``atLowerId``: an identifier that starts with an "@" sign and then a lower-case letter.

Identifiers are used in following syntactic constructs:

::

   simpleId            ::= lowerId | upperId
   modulename          ::= simpleId
   moduleSignatureName ::= upperId
   classname           ::= upperId
   dbasetype           ::= atLowerId
   predicateRef        ::= (moduleExpr "::")? literalId
   signatureExpr       ::= (moduleExpr "::")? simpleId ("/" Integer | arguments)?;
   predicateName       ::= lowerId
   parameterName       ::= simpleId
   varname             ::= lowerId
   literalId           ::= lowerId | atLowerId

Integer literals (int)
~~~~~~~~~~~~~~~~~~~~~~

An integer literal is a possibly negated sequence of decimal digits (``0`` through ``9``, U+0030 through U+0039). Here are some examples of integer literals:

::

   0
   42
   123
   -2147483648

Float literals (float)
~~~~~~~~~~~~~~~~~~~~~~

A floating-point literals is a possibly negated two non-negative integers literals separated by a dot (``.``, U+002E). Here are some examples of float literals:

::

   0.5
   2.0
   123.456
   -100.5

String literals (string)
~~~~~~~~~~~~~~~~~~~~~~~~

A string literal denotes a sequence of characters. It begins and ends with a double quote character (U+0022). In between the double quotes are a sequence of string character indicators, each of which indicates one character that should be included in the string. The string character indicators are as follows.

-  Any character other than a double quote (U+0022), backslash (U+005C), line feed (U+000A), carriage return (U+000D), or tab (U+0009). Such a character indicates itself.

-  A backslash (U+005C) followed by one of the following characters:

   -  Another backslash (U+005C), in which case a backslash character is indicated.
   -  A double quote (U+0022), in which case a double quote is indicated.
   -  The letter "n" (U+006E), in which case a line feed (U+000A) is indicated.
   -  The letter "r" (U+0072), in which case a carriage return (U+000D) is indicated.
   -  The letter "t" (U+0074), in which case a tab (U+0009) is indicated.

Here are some examples of string literals:

::

   "hello"
   "He said, \"Logic clearly dictates that the needs of the many...\""

Annotations
-----------

Various kinds of syntax can have *annotations* applied to them. Annotations are as follows:

::

   annotations ::= annotation*

   annotation ::= simpleAnnotation | argsAnnotation

   simpleAnnotation ::= "abstract"
                    |   "cached"
                    |   "external"
                    |   "extensible"
                    |   "final"
                    |   "transient"
                    |   "library"
                    |   "private"
                    |   "deprecated"
                    |   "override"
                    |   "additional"
                    |   "query"

   argsAnnotation ::= "pragma" "[" ("inline" | "inline_late" | "noinline" | "nomagic" | "noopt" | "assume_small_delta") "]"
                  |   "language" "[" "monotonicAggregates" "]"
                  |   "bindingset" "[" (variable ( "," variable)*)? "]"

Each simple annotation adds a same-named attribute to the syntactic entity it precedes. For example, if a class is preceded by the ``abstract`` annotation, then the class is said to be abstract.

A valid annotation list may not include the same simple annotation more than once, or the same parameterized annotation more than once with the same arguments. However, it may include the same parameterized annotation more than once with different arguments.

Simple annotations
~~~~~~~~~~~~~~~~~~

The following table summarizes the syntactic constructs which can be marked with each annotation in a valid program; for example, an ``abstract`` annotation preceding a character is invalid.

+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| Annotation     | Classes | Characters | Member predicates | Non-member predicates | Imports | Fields | Modules | Aliases | Signatures |
+================+=========+============+===================+=======================+=========+========+=========+=========+============+
| ``abstract``   | yes     |            | yes               |                       |         |        |         |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``cached``     | yes     | yes        | yes               | yes                   |         |        | yes     |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``external``   |         |            |                   | yes                   |         |        |         |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``extensible`` |         |            |                   | yes                   |         |        |         |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``final``      | yes     |            | yes               |                       |         | yes    |         | (yes)   |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``transient``  |         |            |                   | yes                   |         |        |         |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``library``    | (yes)   |            |                   |                       |         |        |         |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``private``    | yes     |            | yes               | yes                   | yes     | yes    | yes     | yes     | yes        |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``deprecated`` | yes     |            | yes               | yes                   | yes     | yes    | yes     | yes     | yes        |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``override``   |         |            | yes               |                       |         | yes    |         |         |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``additional`` | yes     |            |                   | yes                   |         |        | yes     | yes     | yes        |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| ``query``      |         |            |                   | yes                   |         |        |         | yes     |            |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+

The ``library`` annotation is only usable within a QLL file, not a QL file.
The ``final`` annotation is usable on type aliases, but not on module aliases and predicate aliases.

Annotations on aliases apply to the name introduced by the alias. An alias may, for example, have different privacy to the name it aliases.

Parameterized annotations
~~~~~~~~~~~~~~~~~~~~~~~~~

Parameterized annotations take some additional arguments.

The parameterized annotation ``pragma`` supplies compiler pragmas, and may be applied in various contexts depending on the pragma in question.

+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| Pragma                    | Classes | Characters | Member predicates | Non-member predicates | Imports | Fields | Modules | Aliases |
+===========================+=========+============+===================+=======================+=========+========+=========+=========+
| ``inline``                |         | yes        | yes               | yes                   |         |        |         |         |
+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| ``inline_late``           |         | yes        | yes               | yes                   |         |        |         |         |
+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| ``noinline``              |         | yes        | yes               | yes                   |         |        |         |         |
+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| ``nomagic``               |         | yes        | yes               | yes                   |         |        |         |         |
+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| ``noopt``                 |         | yes        | yes               | yes                   |         |        |         |         |
+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| ``assume_small_delta``    |         | yes        | yes               | yes                   |         |        |         |         |
+---------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+

The parameterized annotation ``language`` supplies language pragmas which change the behavior of the language. Language pragmas apply at the scope level, and are inherited by nested scopes.

+-------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+
| Pragma                  | Classes | Characters | Member predicates | Non-member predicates | Imports | Fields | Modules | Aliases |
+=========================+=========+============+===================+=======================+=========+========+=========+=========+
| ``monotonicAggregates`` | yes     | yes        | yes               | yes                   |         |        | yes     |         |
+-------------------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+

A binding set for a predicate is a subset of the predicate’s arguments such that if those arguments are bound (restricted to a finite range of values), then all of the predicate’s arguments are bound.

The parameterized annotation ``bindingset`` can be applied to a predicate (see "`Non-member predicates <#non-member-predicates>`__" and "`Members <#members>`__") to specify a binding set.

This annotation accepts a (possibly empty) list of variable names as parameters. The named variables must all be arguments of the predicate, possibly including ``this`` for characteristic predicates and member predicates, and ``result`` for predicates that yield a result.

In the default case where no binding sets are specified by the user, then it is assumed that there is precisely one, empty binding set - that is, the body of the predicate must bind all the arguments.

Binding sets are checked by the QL compiler in the following way:

#. It assumes that all variables mentioned in the binding set are bound.
#. It checks that, under this assumption, all the remaining argument variables are bound by the predicate body.

A predicate may have several different binding sets, which can be stated by using multiple ``bindingset`` annotations on the same predicate.

+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+
| Annotation     | Classes | Characters | Member predicates | Non-member predicates | Imports | Fields | Modules | Aliases | Signatures |
+================+=========+============+===================+=======================+=========+========+=========+=========+============+
| ``bindingset`` |         | yes        | yes               | yes                   |         |        |         |         | (yes)      |
+----------------+---------+------------+-------------------+-----------------------+---------+--------+---------+---------+------------+

The ``bindingset`` pragma is usable with type signatures and predicate signatures, but not with module signatures.

QLDoc
-----

QLDoc is used for documenting QL entities and bindings. QLDoc that is used as part of the
declaration is said to be declared.

Ambiguous QLDoc
~~~~~~~~~~~~~~~

If QLDoc can be parsed as part of a file module or as part of the first declaration in the file then
it is parsed as part of the first declaration.

Inheriting QLDoc
~~~~~~~~~~~~~~~~

If no QLDoc is provided then it may be inherited.

In the case of an alias then it may be inherited from the right-hand side of the alias.

In the case of a member predicate we collect all member predicates that it overrides with declared QLDoc. If there is a member predicate in that collection that
overrides every other member predicate in that collection, then the QLDoc of that member predicate is used as the QLDoc.

In the case of a field we collect all fields that it overrides with declared QLDoc. If there is a field in that collection that
overrides every other field in that collection, then the QLDoc of that field is used as the QLDoc.

Content
~~~~~~~

The content of a QLDoc comment is interpreted as `CommonMark <https://commonmark.org/>`__, with the following extensions:

-  Automatic interpretation of links and email addresses.
-  Use of appropriate characters for ellipses, dashes, apostrophes, and quotes.

The content of a QLDoc comment may contain metadata tags as follows:

The tag begins with any number of whitespace characters, followed by an ``@`` sign. At this point there may be any number of non-whitespace characters, which form the key of the tag. Then, a single whitespace character which separates the key from the value. The value of the tag is formed by the remainder of the line, and any subsequent lines until another ``@`` tag is seen, or the end of the content is reached. Any sequence of consecutive whitespace characters in the value are replaced by a single space.

Metadata
~~~~~~~~

If the query file starts with whitespace followed by a QLDoc comment, then the tags from that QLDoc comment form the query metadata.

Top-level entities
------------------

Modules include five kinds of top-level entity: predicates, classes, modules, aliases, signatures, and select clauses.

Non-member predicates
~~~~~~~~~~~~~~~~~~~~~

A *predicate* is declared as a sequence of annotations, a head, and an optional body:

::

   predicate ::= qldoc? annotations head optbody

A predicate definition adds a mapping from the predicate name and arity to the predicate declaration to the current module's declared predicate environment.

When a predicate is a top-level clause in a module, it is called a non-member predicate. See below for "`Member predicates <#member-predicates>`__."

A valid non-member predicate can be annotated with ``cached``, ``deprecated``, ``external``, ``transient``, ``private``, and ``query``. Note, the ``transient`` annotation can only be applied if the non-member predicate is also annotated with ``external``.

The head of the predicate gives a name, an optional *result type*, and a sequence of variables declarations that are *arguments*:

::

   head ::= ("predicate" | type) predicateName "(" var_decls ")"

The body of a predicate is of one of three forms:

::

   optbody ::= ";"
           |  "{" formula "}"
           |  "=" literalId "(" (predicateRef "/" int ("," predicateRef "/" int)*)? ")" "(" (exprs)? ")"

In the first form, with just a semicolon, the predicate is said to not have a body. In the second form, the body of the predicate is the given formula (see "`Formulas <#formulas>`__"). In the third form, the body is a higher-order relation.

A valid non-member predicate must have a body, either a formula or a higher-order relation, unless it is external, in which case it must not have a body.

The typing environment for the body of the formula, if present, maps the variables in the head of the predicate to their associated types. If the predicate has a result type, then the typing environment also maps ``result`` to the result type.

Classes
~~~~~~~

A class definition has the following syntax:

::

   class ::= qldoc? annotations "class" classname ("extends" type ("," type)*)? ("instanceof" type ("," type)*)? "{" member* "}"

The identifier following the ``class`` keyword is the name of the class.

The types specified after the ``extends`` keyword are the *base types* of the class.

The types specified after the ``instanceof`` keyword are the *instanceof types* of the class.

A class type is said to *final inherit* from base types that are final or referenced through final aliases, and a class type is said to *inherit* from its other base types. In addition, inheritance is transitive:

- If a type ``A`` inherits from a type ``B``, and ``B`` inherits from a type ``C``, then ``A`` inherits from ``C``.
- If a type ``A`` final inherits from a type ``B``, and ``B`` inherits from a type ``C``, then ``A`` final inherits from ``C``.
- If a type ``A`` inherits from a type ``B``, and ``B`` final inherits from a type ``C``, then ``A`` final inherits from ``C``.
- If a type ``A`` final inherits from a type ``B``, and ``B`` final inherits from a type ``C``, then ``A`` final inherits from ``C``.

A class adds a mapping from the class name to the class declaration to the current module's declared type environment.

A valid class can be annotated with ``abstract``, ``final``, ``library``, and ``private``. Any other annotation renders the class invalid.

A valid class may not inherit from itself, or from more than one primitive type. The set of types that a valid class inherits from must be disjoint from the set of types that it final inherits from.

A valid class must have at least one base type or instanceof type.

Class dependencies
~~~~~~~~~~~~~~~~~~

The program is invalid if there is a cycle of class dependencies.

The following are class dependencies:

- ``C`` depends on ``C.C``
- ``C.C`` depends on ``C.extends``
- If ``C`` is abstract then it depends on all classes ``D`` such that ``C`` is a base type of ``D`` and ``D`` inherits from ``C``.
- ``C.extends`` depends on ``D.D`` for each base type ``D`` of ``C``.
- ``C.extends`` depends on ``D`` for each instanceof type ``D`` of ``C``.

Class environments
~~~~~~~~~~~~~~~~~~

For each of member predicates and fields a class *inherits* and *declares*, and *exports* an environment. These are defined as follows (with X denoting the type of entity we are currently considering):

-  The *inherited X environment* of a class is the union of the exported X environments of types it inherits from, excluding any elements that are ``overridden`` by another element.

-  The *declared X environment* of a class is the multimap of X declarations in the class itself.

-  The *exported X environment* of a class is the overriding union of its declared X environment (excluding ``private`` declaration entries) with its inherited X environment.

-  The *visible X environment* is the overriding union of the declared X environment and the inherited X environment.

The program is invalid if any of these environments is not definite.

For each of member predicates and fields a domain type *exports* an environment. We say the *exported X extends environment* is the union of the exported ``X`` environments of types the class inherits from, excluding any elements that are ``overridden`` by another element.
We say the *exported X instanceof environement* is the union of the exported ``X`` environments of types that a instanceof type inherits from, excluding any elements that are ``overridden`` by another element.
The *exported X environment* of the domain type is the union of the exported ``X`` extends environment and the exported ``X`` instanceof environement.

Members
~~~~~~~

Each member of a class is either a *character*, a predicate, or a field:

::

   member ::= character | predicate | field
   character ::= qldoc? annotations classname "(" ")" "{" formula "}"
   field ::= qldoc? annotations var_decl ";"

Characters
^^^^^^^^^^

A valid character must have the same name as the name of the class. A valid class has at most one character provided in the source code.

A valid character can be annotated with ``cached``. Any other annotation renders the character invalid.

Member predicates
^^^^^^^^^^^^^^^^^

A predicate that is a member of a class is called a *member predicate*. The name of the predicate is the identifier just before the open parenthesis.

A member predicate adds a mapping from the predicate name and arity to the predicate declaration in the class's declared member predicate environment.

A valid member predicate can be annotated with ``abstract``, ``cached``, ``final``, ``private``, ``deprecated``, and ``override``.

If a type is provided before the name of the member predicate, then that type is the *result type* of the predicate. Otherwise, the predicate has no result type. The types of the variables in the ``var_decls`` are called the predicate's *argument types*.

A member predicate ``p`` with enclosing class ``C`` *overrides* a member predicate ``p'`` with enclosing class ``D`` when ``p`` is annotated ``overrride``, ``C`` inherits from ``D``, ``p'`` is visible in ``C``, ``p'`` is not final, and both ``p`` and ``p'`` have the same name and the same arity. An overriding predicate must have the same sequence of argument types as any predicates which it overrides, otherwise the program is invalid.

A member predicate ``p`` with enclosing class ``C`` *shadows* a member predicate ``p'`` with enclosing class ``D`` when ``C`` final inherits from ``D``, ``p'`` is visible in ``C``, and both ``p`` and ``p'`` have the same name and the same arity. Additionally, a member predicate ``p`` with enclosing class ``C`` *shadows* a member predicate ``p'`` with enclosing class ``D`` when ``C`` inherits from ``D``, ``p'`` is visible in ``C``, ``p'`` is final, and both ``p`` and ``p'`` have the same name and the same arity.

Member predicates have one or more *root definitions*. If a member predicate overrides no other member predicate, then it is its own root definition. Otherwise, its root definitions are those of any member predicate that it overrides.

A valid member predicate must have a body unless it is abstract or external, in which case it must not have a body.

A valid member predicate must override another member predicate if it is annotated override.

When member predicate ``p`` overrides member predicate ``q``, either ``p`` and ``q`` must both have a result type, or neither of them may have a result type. If they do have result types, then the result type of ``p`` must be a subtype of the result type of ``q``. ``q`` may not be a final predicate. If ``p`` is abstract, then ``q`` must be as well.

A class may not inherit from a class with an abstract member predicate unless it either includes a member predicate overriding that abstract predicate, or it inherits from another class that does.

A valid class must include a non-private predicate named ``toString`` with no arguments and a result type of ``string``, or it must inherit from a class that does.

A valid class may not inherit from two different classes that include a predicate with the same name and number of arguments, unless either one of the predicates overrides or shadows the other, or the class defines a predicate that overrides or shadows both of them.

A valid class may not final inherit from two different classes that include a predicate with the same name and number of arguments, unless either one of the predicates overrides or shadows the other, or the class defines a predicate that shadows both of them.

The typing environment for a member predicate or character is the same as if it were a non-member predicate, except that it additionally maps ``this`` to a type and also maps any fields on a class to a type. If the member is a character, then the typing environment maps ``this`` to the class domain type of the class. Otherwise, it maps ``this`` to the class type of the class itself.
The typing environment also maps any field to the type of the field.

Fields
^^^^^^

A field declaration introduces a mapping from the field name to the field declaration in the class's declared field environment.

A field ``f`` with enclosing class ``C`` *overrides* a field ``f'`` with enclosing class ``D`` when ``f`` is annotated ``override``, ``C`` inherits from ``D``, ``p'`` is visible in ``C``, ``p'`` is not final, and both ``p`` and ``p'`` have the same name.

A field ``f`` with enclosing class ``C`` *shadows* a field ``f'`` with enclosing class ``D`` when ``C`` final inherits from ``D``, ``p'`` is visible in ``C``, and both ``p`` and ``p'`` have the same name. Additionally, a field ``f`` with enclosing class ``C`` *shadows* a field ``f'`` with enclosing class ``D`` when ``C`` inherits from ``D``, ``p'`` is visible in ``C``, ``p'`` is final, and both ``p`` and ``p'`` have the same name.

A valid class may not inherit from two different classes that include a field with the same name, unless either one of the fields overrides or shadows the other, or the class defines a field that overrides or shadows both of them.

A valid class may not final inherit from two different classes that include a field with the same name, unless either one of the fields overrides or shadows the other, or the class defines a field that shadows both of them.

A valid field must override another field if it is annotated ``override``.

When field ``f`` overrides field ``g`` the type of ``f`` must be a subtype of the type of ``g``. ``f`` may not be a final field.


Signatures
~~~~~~~~~~

A signature definition has the following syntax:

::

   signature ::= predicateSignature | typeSignature | moduleSignature

   predicateSignature ::= qldoc? annotations "signature" head ";"

   typeSignature ::= qldoc? annotations "signature" "class" classname ("extends" type ("," type)*)? (";" | "{" signaturePredicate* "}")

   moduleSignature ::= qldoc? annotation* "signature" "module" moduleSignatureName parameters? "{" moduleSignatureBody "}"

   moduleSignatureBody ::= (signaturePredicate | defaultPredicate | signatureType)*

   signaturePredicate ::= qldoc? annotations head ";"

   defaultPredicate ::= qldoc? annotations "default" head "{" formula "}"

   signatureType ::= qldoc? annotations "class" classname ("extends" type ("," type)*)? "{" signaturePredicate* "}"


A predicate signature definition extends the current module's declared predicate signature environment with a mapping from the predicate signature name and arity to the predicate signature definition.

A type signature definition extends the current module's declared type signature environment with a mapping from the type signature name to the type signature definition.

A module signature definition extends the current module's declared module signature environment with a mapping from the module signature name to the module signature definition.

Select clauses
~~~~~~~~~~~~~~

A QL file may include at most one *select clause*. That select clause has the following syntax:

::

   select ::= ("from" var_decls)? ("where" formula)? "select" select_exprs ("order" "by" orderbys)?

A valid QLL file may not include any select clauses.

A select clause is considered to be a declaration of an anonymous predicate whose arguments correspond to the select expressions of the select clause.

The ``from`` keyword, if present, is followed by the *variables* of the formula. Otherwise, the select clause has no variables.

The ``where`` keyword, if present, is followed by the *formula* of the select clause. Otherwise, the select clause has no formula.

The ``select`` keyword is followed by a number of *select expressions*. Select expressions have the following syntax:

::

   as_exprs ::= as_expr ("," as_expr)*
   as_expr ::= expr ("as" lowerId)?

The keyword ``as`` gives a *label* to the select expression it is part of. No two select expressions may have the same label. No expression label may be the same as one of the variables of the select clause.

The ``order`` keyword, if present, is followed by a number of *ordering directives*. Ordering directives have the following syntax:

::

   orderbys ::= orderby ("," orderby)*
   orderby ::= lowerId ("asc" | "desc")?

Each identifier in an ordering directive must identify exactly one of the select expressions. It must either be the label of the expression, or it must be a variable expression that is equivalent to exactly one of the select expressions. The type of the designated select expression must be a subtype of a primitive type.

No select expression may be specified by more than one ordering directive. See "`Ordering <#ordering>`__" for more information.

Queries
~~~~~~~

The queries in a QL module are:

-  The select clause, if any, defined in that module.
-  Any predicates annotated with ``query`` which are in scope in that module.

The target predicate of the query is either the select clause or the annotated predicate.

Each argument of the target predicate of the query must be of a type which has a ``toString()`` member predicate.

Expressions
-----------

Expressions are a form of syntax used to denote values. Every expression has a typing environment that is determined by the context where the expression occurs. Every valid expression has a type, as specified in this section, except if it is a don't-care expression.

Given a named tuple and a store, each expression has one or more *values*. This section specifies the values of each kind of expression.

There are several kinds of expressions:

::

   exprs ::= expr ("," expr)*

   expr ::= dontcare
        |   unop
        |   binop
        |   cast
        |   primary

   primary ::= eparen
           |   literal
           |   variable
           |   super_expr
           |   postfix_cast
           |   callwithresults
           |   aggregation
           |   expression_pragma
           |   any
           |   range
           |   setliteral


Parenthesized expressions
~~~~~~~~~~~~~~~~~~~~~~~~~

A parenthesized expression is an expression surrounded by parentheses:

::

   eparen ::= "(" expr ")"

The type environment of the nested expression is the same as that of the outer expression. The type and values of the outer expression are the same as those of the nested expression.

Don't-care expressions
~~~~~~~~~~~~~~~~~~~~~~

A don't-care expression is written as a single underscore:

::

   dontcare ::= "_"

All values are values of a don't-care expression.

Literals
~~~~~~~~

A literal expression is as follows:

::

   literal ::= "false" | "true" | int | float | string

The type of a literal expression is the type of the value denoted by the literal: ``boolean`` for ``false`` or ``true``, ``int`` for an integer literal, ``float`` for a floating-point literal, or ``string`` for a string literal. The value of a literal expression is the same as the value denoted by the literal.

Unary operations
~~~~~~~~~~~~~~~~

A unary operation is the application of ``+`` or ``-`` to another expression:

::

   unop ::= "+" expr
        |   "-" expr

The ``+`` or ``-`` in the operation is called the *operator*, and the expression is called the *operand*. The typing environment of the operand is the same as for the unary operation.

For a valid unary operation, the operand must be of type ``int`` or ``float``. The operation has the same type as its operand.

If the operator is ``+``, then the values of the expression are the same as the values of the operand. If the operator is ``-``, then the values of the expression are the arithmetic negations of the values of the operand.

Binary operations
~~~~~~~~~~~~~~~~~

A binary operation is written as a *left operand* followed by a *binary operator*, followed by a *right operand*:

::

   binop ::= expr "+" expr
         |   expr "-" expr
         |   expr "*" expr
         |   expr "/" expr
         |   expr "%" expr

The typing environment for the two environments is the same as for the operation. If the operator is ``+``, then either both operands must be subtypes of ``int`` or ``float``, or at least one operand must be a subtype of ``string``. If the operator is anything else, then each operand must be a subtype of ``int`` or ``float``.

The type of the operation is ``string`` if either operand is a subtype of ``string``. Otherwise, the type of the operation is ``int`` if both operands are subtypes of ``int``. Otherwise, the type of the operation is ``float``.

If the result is of type ``string``, then the *left values* of the operation are the values of a "call with results" expression with the left operand as the receiver, ``toString`` as the predicate name, and no arguments (see "`Calls with results <#calls-with-results>`__"). Otherwise the left values are the values of the left operand. Likewise, the *right values* are either the values from calling ``toString`` on the right operand, or the values of the right operand as it is.

The binary operation has one value for each combination of a left value and a right value. That value is determined as follows:

-  If the left and right operand types are subtypes of string, then the operation has a value that is the concatenation of the left and right values.

-  Otherwise, if both operand types are subtypes of ``int``, then the value of the operation is the result of applying the two's-complement 32-bit integer operation corresponding to the QL binary operator.

-  Otherwise, both operand types must be subtypes of ``float``. If either operand is of type ``int`` then they are converted to a float. The value of the operation is then the result of applying the IEEE 754 floating-point operator that corresponds to the QL binary operator: addition for ``+``, subtraction for ``-``, multiplication for ``*``, division for ``/``, or remainder for ``%``.

Variables
~~~~~~~~~

A variable has the following syntax:

::

   variable ::= varname | "this" | "result"

A valid variable expression must occur in the typing environment. The type of the variable expression is the same as the type of the variable in the typing environment.

The value of the variable is the value of the variable in the named tuple.

Super
~~~~~

A super expression has the following syntax:

::

   super_expr ::= "super" | type "." "super"

For a super expression to be valid, the ``this`` keyword must have a type and value in the typing environment. The type of the expression is the same as the domain type of the type of ``this`` in the typing environment.

The value of a super expression is the same as the value of ``this`` in the named tuple.

Casts
~~~~~

A cast expression is a type in parentheses followed by another expression:

::

   cast ::= "(" type ")" expr

The typing environment for the nested expression is the same as for the cast expression. The type of the cast expression is the type between parentheses.

The values of the cast expression are those values of the nested expression that are in the type given within parentheses.

For casts between the primitive ``float`` and ``int`` types, the above rule means that for the cast expression to have a value, it must be representable as both 32-bit two's complement integers and 64-bit IEEE 754 floats. Other values will not be included in the values of the cast expression.

Postfix casts
~~~~~~~~~~~~~

A postfix cast is a primary expression followed by a dot and then a class or primitive type in parentheses:

::

   postfix_cast ::= primary "." "(" type ")"

All the rules for ordinary casts apply to postfix casts: a postfix cast is exactly equivalent to a parenthesized ordinary cast.

Calls with results
~~~~~~~~~~~~~~~~~~

An expression for a call with results is of one of two forms:

::

   callwithresult ::= predicateRef (closure)? "(" (exprs)? ")"
                  |   primary "." predicateName (closure)? "(" (exprs)? ")"
   closure        ::= "*" | "+"

The expressions in parentheses are the *arguments* of the call. The expression before the dot, if there is one, is the *receiver* of the call.

The type environment for the arguments is the same as for the call.

A valid call with results *resolves* to a set of predicates. The ways a call can resolve are as follows:

-  If the call has no receiver and the predicate reference is a simple identifier, then the call is resolved by looking up the predicate reference and arity in the visible predicate environment of the enclosing class.

-  If the call has no receiver and the predicate reference is a simple identifier, then the call is resolved by looking up the predicate reference and arity in the visible predicate environment of the enclosing module.

-  If the call has no receiver and the predicate reference is a selection identifier, then the qualifier is resolved as a module (see "`Module resolution <#module-resolution>`__") and the call is resolved by looking up the identifier in the exported predicate environment of the qualifier module.

-  If the the call has a receiver and the type of the receiver is the same as the enclosing class, the call is resolved by looking up the predicate name and arity in the visible predicate environment of the enclosing class.

-  If the the call has a receiver and the type of the receiver is not the same as the enclosing class, the call is resolved by looking up the predicate name and arity in the exported predicate environment of the type of the receiver.

If all the predicates that the call resolves to are declared on a primitive type, we then restrict to the set of predicates where each argument of the call is a subtype of the corresponding predicate argument type.
Then we find all predicates ``p`` from this new set such that there is not another predicate ``p'`` where each argument of ``p'`` is a subtype of the corresponding argument in ``p``. We then say the call resolves to this set instead.

A valid call must only resolve to a single predicate.

For each argument other than a don't-care expression, the type of the argument must be compatible with the type of the corresponding argument type of the predicate, otherwise the call is invalid.

A valid call with results must resolve to a predicate that has a result type. That result type is also the type of the call.

If the resolved predicate is built in, then the call may not include a closure. If the call does have a closure, then it must resolve to a predicate where the *relational arity* of the predicate is 2. The relational arity of a predicate is the sum of the following numbers:

-  The number of arguments to the predicate.

-  The number 1 if the predicate is a member predicate, otherwise 0.

-  The number 1 if the predicate has a result, otherwise 0.

If the call includes a closure, then all declared predicate arguments, the enclosing type of the declaration (if it exists), and the result type of the declaration (if it exists) must be compatible. If one of those types is a subtype of ``int``, then all the other arguments must be a subtype of ``int``.

A call to a member predicate may  be a *direct* call:
 - If the receiver is not a super expression it is not direct.
 - If the receiver is ``A.super`` and ``A`` is an instanceof type and not a base type that is inherited from then it is not direct.
 - If the receiver is ``A.super`` and ``A`` is a base type that is final inherited from then it is not direct.
 - If the receiver is ``A.super`` and ``A`` is a base type that is inherited from and not an instanceof type then it is direct.
 - If the receiver is ``A.super`` and ``A`` is a base type that is inherited from and an instanceof type then the call is not valid.
 - If the receiver is ``super`` and the member predicate is in the exported member predicate environment of an instanceof type and not in the exported member predicate environment of a base type then it isn't direct.
 - If the receiver is ``super`` and the member predicate is in the exported member predicate environment of a base type and not in the exported member predicate environment of an instanceof type then it is direct.
 - If the receiver is ``super`` and the member predicate is in the exported member predicate environment of a base type and in the exported member predicate environment of an instanceof type then the call is not valid.

If the call resolves to a member predicate, then the *receiver values* are as follows. If the call has a receiver, then the receiver values are the values of that receiver. If the call does not have a receiver, then the single receiver value is the value of ``this`` in the contextual named tuple.

The *tuple prefixes* of a call with results include one value from each of the argument expressions' values, in the same order as the order of the arguments. If the call resolves to a non-member predicate, then those values are exactly the tuple prefixes of the call. If the call instead resolves to a member predicate, then the tuple prefixes additionally include a receiver value, ordered before the argument values.

The *matching tuples* of a call with results are all ordered tuples that are one of the tuple prefixes followed by any value of the same type as the call. If the call has no closure, then all matching tuples must additionally satisfy the resolved predicate of the call, unless the call is direct in which case they must *directly* satisfy the resolved predicate of the call. If the call has a ``*`` or ``+`` closure, then the matching tuples must satisfy or directly satisfy the associated closure of the resolved predicate.

The values of a call with results are the final elements of each of the call's matching tuples.

Aggregations
~~~~~~~~~~~~

An aggregation can be written in one of two forms:

::

   aggregation ::= aggid ("[" expr "]")? "(" var_decls ("|" (formula)? ("|" as_exprs ("order" "by" aggorderbys)?)?)? ")"
               |   aggid ("[" expr "]")? "(" as_exprs ("order" "by" aggorderbys)? ")"
               |   "unique" "(" var_decls "|" (formula)? ("|" as_exprs)? ")"

   aggid ::= "avg" | "concat" | "count" | "max" | "min" | "rank" | "strictconcat" | "strictcount" | "strictsum" | "sum"

   aggorderbys ::= aggorderby ("," aggorderby)*

   aggorderby ::= expr ("asc" | "desc")?

The expression enclosed in square brackets (``[`` and ``]``, U+005B and U+005D), if present, is called the *rank expression*. It must have type ``int``.

The ``as_exprs``, if present, are called the *aggregation expressions*. If an aggregation expression is of the form ``expr as v`` then the expression is said to be *named* v.

The rank expression must be present if the aggregate id is ``rank``; otherwise it must not be present.

Apart from the presence or absence of the rank variable, all other reduced forms of an aggregation are equivalent to a full form using the following steps:

-  If the formula is omitted, then it is taken to be ``any()``.
-  If there are no aggregation expressions, then either:

   - The aggregation id is ``count`` or ``strictcount`` and the expression is taken to be ``1``.
   - There must be precisely one variable declaration, and the aggregation expression is taken to be a reference to that variable.

-  If the aggregation id is ``concat`` or ``strictconcat`` and it has a single expression then the second expression is taken to be ``""``.
-  If the ``monotonicAggregates`` language pragma is not enabled, or the original formula and variable declarations are both omitted, then the aggregate is transformed as follows:

   - For each aggregation expression ``expr_i``, a fresh variable ``v_i`` is declared with the same type as the expression in addition to the original variable declarations.
   - The new range is the conjunction of the original range and a term ``v_i = expr_i`` for each aggregation expression ``expr_i``.
   - Each original aggregation expression ``expr_i`` is replaced by a new aggregation expression ``v_i``.

The variables in the variable declarations list must not occur in the typing environment.

The typing environment for the rank expression is the same as for the aggregation.

The typing environment for the formula is obtained by taking the typing environment for the aggregation and adding all the variable types in the given ``var_decls`` list.

The typing environment for an aggregation expression is obtained by taking the typing environment for the formula and then, for each named aggregation expression that occurs earlier than the current expression, adding a mapping from the earlier expression's name to the earlier expression's type.

The typing environment for ordering directives is obtained by taking the typing environment for the formula and then, for each named aggregation expression in the aggregation, adding a mapping from the expression's name to the expression's type.

The number and types of the aggregation expressions are restricted as follows:

-  A ``max``, ``min``, ``rank`` or ``unique`` aggregation must have a single expression.
-  The type of the expression in a ``max``, ``min`` or ``rank`` aggregation without an ordering directive expression must be an orderable type.
-  A ``count`` or ``strictcount`` aggregation must not have an expression.
-  A ``sum``, ``strictsum`` or ``avg`` aggregation must have a single aggregation expression, which must have a type which is a subtype of ``float``.
-  A ``concat`` or ``strictconcat`` aggregation must have two expressions. Both expressions must have types which are subtypes of ``string``.

The type of a ``count``, ``strictcount`` aggregation is ``int``. The type of an ``avg`` aggregation is ``float``. The type of a ``concat`` or ``strictconcat`` aggregation is ``string``. The type of a ``sum`` or ``strictsum`` aggregation is ``int`` if the aggregation expression is a subtype of ``int``, otherwise it is ``float``. The type of a ``rank``, ``min`` or ``max`` aggregation is the type of the single expression.

An ordering directive may only be specified for a ``max``, ``min``, ``rank``, ``concat`` or ``strictconcat`` aggregation. The type of the expression in an ordering directive must be an orderable type.

The values of the aggregation expression are determined as follows. Firstly, the *range tuples* are extensions of the named tuple that the aggregation is being evaluated in with the variable declarations of the aggregation, and which *match* the formula (see "`Formulas <#formulas>`__").

For each range tuple, the *aggregation tuples* are the extension of the range tuples to *aggregation variables* and *sort variables*.

The aggregation variables are given by the aggregation expressions. If an aggregation expression is named, then its aggregation variable is given by its name, otherwise a fresh synthetic variable is created. The value is given by evaluating the expression with the named tuple being the result of the previous expression, or the range tuple if this is the first aggregation expression.

The sort variables are synthetic variables created for each expression in the ordering directive with values given by the values of the expressions within the ordering directive.

If the aggregation id is ``max``, ``min`` or ``rank`` and there was no ordering directive, then for each aggregation tuple a synthetic sort variable is added with value given by the aggregation variable.

The values of the aggregation expression are given by applying the aggregation function to each set of tuples obtained by picking exactly one aggregation tuple for each range tuple.

-  If the aggregation id is ``avg``, and the set is non-empty, then the resulting value is the average of the value for the aggregation variable in each tuple in the set, weighted by the number of tuples in the set, after converting the value to a floating-point number.

-  If the aggregation id is ``count``, then the resulting value is the number of tuples in the set. If there are no tuples in the set, then the value is the integer ``0``.

-  If the aggregation id is ``max``, then the values are the those values of the aggregation variable which are associated with a maximal tuple of sort values. If the set is empty, then the aggregation has no value.

-  If the aggregation id is ``min``, then the values are the those values of the aggregation variable which are associated with a minimal tuple of sort values. If the set is empty, then the aggregation has no value.

-  If the aggregation id is ``rank``, then the resulting values are values of the aggregation variable such that the number of aggregation tuples with a strictly smaller tuple of sort variables is exactly one less than an integer bound by the rank expression of the aggregation. If no such values exist, then the aggregation has no values.

-  If the aggregation id is ``strictcount``, then the resulting value is the same as if the aggregation id were ``count``, unless the set of tuples is empty. If the set of tuples is empty, then the aggregation has no value.

-  If the aggregation id is ``strictsum``, then the resulting value is the same as if the aggregation id were ``sum``, unless the set of tuples is empty. If the set of tuples is empty, then the aggregation has no value.

-  If the aggregation id is ``sum``, then the resulting value is the same as the sum of the values of the aggregation variable across the tuples in the set, weighted by the number of times each value occurs in the tuples in the set. If there are no tuples in the set, then the resulting value of the aggregation is the integer ``0``.

-  If the aggregation id is ``concat``, then there is one value for each value of the second aggregation variable, given by the concatenation of the value of the first aggregation variable of each tuple with the value of the second aggregation variable used as a separator, ordered by the sort variables. If there are multiple aggregation tuples with the same sort variables then the first distinguished value is used to break ties. If there are no tuples in the set, then the single value of the aggregation is the empty string.

-  If the aggregation id is ``strictconcat``, then the result is the same as for ``concat`` except in the case where there are no aggregation tuples in which case the aggregation has no value.

 -  If the aggregation id is ``unique``, then the result is the value of the aggregation variable if there is precisely one such value. Otherwise, the aggregation has no value.

Any
~~~

The ``any`` expression is a special kind of quantified expression.

::

   any ::= "any" "(" var_decls ("|" (formula)? ("|" expr)?)? ")"

The values of an ``any`` expression are those values of the expression for which the formula matches.

The abbreviated cases for an ``any`` expression are interpreted in the same way as for an aggregation.

Expression Pragma
~~~~~~~~~~~~~~~~~

Expression pragmas can be used to guide optimization.

::
   expression_pragma ::= "pragma" "[" expression_pragma_type "]" "(" expr ")"

   expression_pragma_type ::= "only_bind_out" | "only_bind_into"

The values of an expression pragma are the values of the contained expression.

The type `only_bind_out` hints that uses of the result of the expression pragma should not be used to guide the evaluation of the result of the contained expression.
When checking to see that all values are bound the compiler does not assume that if the result of the expression pragma is bound then the result of the contained
expression is bound.

The type `only_bind_into` hints that uses of the contained expression should not be used to guide the evaluation of the result of the expression pragma.
When checking to see that all values are bound the compiler does not assume that if the result of the contained expression is bound then the result of the
expression pragma is bound.

Ranges
~~~~~~

Range expressions denote a range of values.

::

   range ::= "[" expr ".." expr "]"

Both expressions must be subtypes of ``int``, ``float``, or ``date``. If either of them are type ``date``, then both of them must be.

If both expressions are subtypes of ``int`` then the type of the range is ``int``. If both expressions are subtypes of ``date`` then the type of the range is ``date``. Otherwise the type of the range is ``float``.

The values of a range expression are those values which are ordered inclusively between a value of the first expression and a value of the second expression.

Set literals
~~~~~~~~~~~~

Set literals denote a choice from a collection of values.

::

   setliteral ::= "[" expr ("," expr)* ","? "]"

Set literals can be of any type, but the types within a set literal have to be consistent according to the following criterion: At least one of the set elements has to be of a type that is a supertype of all the set element types. This supertype is the type of the set literal. For example, ``float`` is a supertype of ``float`` and ``int``, therefore ``x = [4, 5.6]`` is valid. On the other hand, ``y = [5, "test"]`` does not adhere to the criterion.

The values of a set literal expression are all the values of all the contained element expressions.

Since release 2.7.1 of the CodeQL CLI, a trailing comma is allowed in a set literal.

Disambiguation of expressions
-----------------------------

The grammar given in this section is disambiguated first by precedence, and second by associating left to right. The order of precedence from highest to lowest is:

-  casts
-  unary ``+`` and ``-``
-  binary ``*`` , ``/`` and ``%``
-  binary ``+`` and ``-``

Whenever a sequence of tokens can be interpreted either as a call to a predicate with result (with specified closure), or as a binary operation with operator ``+`` or ``*``, the syntax is interpreted as a call to a predicate with result.

Whenever a sequence of tokens can be interpreted either as arithmetic with a parenthesized variable or as a prefix cast of a unary operation, the syntax is interpreted as a cast.

Formulas
--------

A formula is a form of syntax used to *match* a named tuple given a store.

There are several kinds of formulas:

::

   formula ::= fparen
           |   disjunction
           |   conjunction
           |   implies
           |   ifthen
           |   negated
           |   quantified
           |   comparison
           |   instanceof
           |   inrange
           |   call

This section specifies the syntax for each kind of formula and what tuples they match.

Parenthesized formulas
~~~~~~~~~~~~~~~~~~~~~~

A parenthesized formula is a formula enclosed by a pair of parentheses:

::

   fparen ::= "(" formula ")"

A parenthesized formula matches the same tuples as the nested formula matches.

Disjunctions
~~~~~~~~~~~~

A disjunction is two formulas separated by the ``or`` keyword:

::

   disjunction ::= formula "or" formula

A disjunction matches any tuple that matches either of the nested formulas.

Conjunctions
~~~~~~~~~~~~

A conjunction is two formulas separated by the ``and`` keyword:

::

   conjunction ::= formula "and" formula

A conjunction matches any tuple that also matches both of the two nested formulas.

Implications
~~~~~~~~~~~~

An implication formula is two formulas separated by the ``implies`` keyword:

::

   implies ::= formula "implies" formula

Neither of the two formulas may be another implication.

An implied formula matches if either the second formula matches, or the first formula does not match.

Conditional formulas
~~~~~~~~~~~~~~~~~~~~

A conditional formula has the following syntax:

::

   ifthen ::= "if" formula "then" formula "else" formula

The first formula is called the *condition* of the conditional formula. The second formula is called the *true branch*, and the second formula is called the *false branch*.

The conditional formula matches if the condition and the true branch both match. It also matches if the false branch matches and the condition does not match.

Negations
~~~~~~~~~

A negation formula is a formula preceded by the ``not`` keyword:

::

   negated ::= "not" formula

A negation formula matches any tuple that does not match the nested formula.

Quantified formulas
~~~~~~~~~~~~~~~~~~~

A quantified formula has several syntaxes:

::

   quantified ::= "exists" "(" expr ")"
              |   "exists" "(" var_decls ("|" formula)? ("|" formula)? ")"
              |   "forall" "(" var_decls ("|" formula)? "|" formula ")"
              |   "forex"  "(" var_decls ("|" formula)? "|" formula ")"

In all cases, the typing environment for the nested expressions or formulas is the same as the typing environment for the quantified formula, except that it also maps the variables in the variable declaration to their associated types.

The first form matches if the given expression has at least one value.

For the other forms, the extensions of the current named tuple for the given variable declarations are called the *quantifier extensions*. The nested formulas are called the *first quantified formula* and, if present, the *second quantified formula*.

The second ``exists`` formula matches if one of the quantifier extensions is such that the quantified formula or formulas all match.

A ``forall`` formula that has one quantified formula matches if that quantified formula matches all of the quantifier extensions. A ``forall`` with two quantified formulas matches if the second formula matches all extensions where the first formula matches.

A ``forex`` formula with one quantified formula matches under the same conditions as a ``forall`` formula matching, except that there must be at least one quantifier extension where that first quantified formula matches.

Comparisons
~~~~~~~~~~~

A comparison formula is two expressions separated by a comparison operator:

::

   comparison ::= expr compop expr
   compop ::= "=" | "!=" | "<" | ">" | "<=" | ">="

A comparison formula matches if there is one value of the left expression that is in the given ordering with one of the values of the right expression. The ordering used is specified in "`Ordering <#ordering>`__." If one of the values is an integer and the other is a float value, then the integer is converted to a float value before the comparison.

If the operator is ``=``, then at least one of the left and right expressions must have a type; if they both have a type, those types must be compatible.

If the operator is ``!=``, then both expressions must have a type, and those types must be compatible.

If the operator is any other operator, then both expressions must have a type. Those types must be compatible with each other. Each of those types must be orderable.

Type checks
~~~~~~~~~~~

A type check formula has the following syntax:

::

   instanceof ::= expr "instanceof" type

The type to the right of ``instanceof`` is called the *type-check type*.

The type of the expression must be compatible with the type-check type.

The formula matches if one of the values of the expression is in the type-check type.

Range checks
~~~~~~~~~~~~

A range check has the following syntax:

::

   inrange ::= expr "in" (range | setliteral)


The formula is equivalent to ``expr "=" range`` or ``expr "=" setliteral``.

Calls
~~~~~

A call has the following syntax:

::

   call ::= predicateRef (closure)? "(" (exprs)? ")"
        |   primary "." predicateName (closure)? "(" (exprs)? ")"

The identifier is called the *predicate name* of the call.

A call must resolve to a predicate, using the same definition of resolve as for calls with results (see "`Calls with results <#calls-with-results>`__").

A call may be direct using the same definition of direct as for calls with results (see "`Calls with results <#calls-with-results>`__").

The resolved predicate must not have a result type.

If the resolved predicate is a built-in member predicate of a primitive type, then the call may not include a closure. If the call does have a closure, then the call must resolve to a predicate with relational arity of 2.

The *candidate tuples* of a call are the ordered tuples formed by selecting a value from each of the arguments of the call.

If the call has no closure, then it matches whenever one of the candidate tuples satisfies the resolved predicate of the call, unless the call is direct, in which case the candidate tuple must *directly* satisfy the resolved predicate. If the call has ``*`` or ``+`` closure, then the call matches whenever one of the candidate tuples satisfies or directly satisfies the associated closure of the resolved predicate.

Disambiguation of formulas
~~~~~~~~~~~~~~~~~~~~~~~~~~

The grammar given in this section is disambiguated first by precedence, and second by associating left to right, except for implication which is non-associative. The order of precedence from highest to lowest is:

-  Negation

-  Conditional formulas

-  Conjunction

-  Disjunction

-  Implication

Aliases
-------

Aliases define new names for existing QL bindings.

::

   alias ::= qldoc? annotations "predicate" literalId "=" predicateRef "/" int ";"
         |   qldoc? annotations "class" classname "=" type ";"
         |   qldoc? annotations "module" modulename "=" moduleExpr ";"


An alias introduces a binding from the new name to the binding referred to by the right-hand side in the current module's visible predicate, type, or module environment respectively.

An alias is called a *strong alias* if and only if it has the ``final`` annotation. Otherwise, it is called a *weak alias*.

Two bindings `A`, `B` are called *equal modulo weak aliasing* if and only if one of the following conditions are satisfied:

- `A` and `B` are the same binding or

- `A`` is introduced by a *weak alias* for `C`, where `B` and `C` are *equal modulo weak aliasing* (or vice versa) or

- `A` and `B` are introduced by the same strong alias and they are aliases for bindings that are *equal modulo weak aliasing*.

Note that the third condition is only relevant in :ref:`Parameterized modules`, where the binding introduced by the alias can depend on instantiation parameters.

Built-ins
---------

A QL database includes a number of *built-in predicates* . This section defines a number of built-in predicates that all databases include. Each database also includes a number of additional non-member predicates that are not specified in this document.

This section gives several tables of built-in predicates. For each predicate, the table gives the result type of each predicate that has one, and the sequence of argument types.

Each table also specifies which ordered tuples are in the database content of each predicate. It specifies this with a description that holds true for exactly the tuples that are included. In each description, the "result" is the last element of each tuple, if the predicate has a result type. The "receiver" is the first element of each tuple. The "arguments" are all elements of each tuple other than the result and the receiver.

Non-member built-ins
~~~~~~~~~~~~~~~~~~~~

The following built-in predicates are non-member predicates:

+-----------+-------------+------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Name      | Result type | Argument types                     | Content                                                                                                                                                                                                    |
+===========+=============+====================================+============================================================================================================================================================================================================+
| ``any``   |             |                                    | The empty tuple.                                                                                                                                                                                           |
+-----------+-------------+------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``none``  |             |                                    | No tuples.                                                                                                                                                                                                 |
+-----------+-------------+------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toUrl`` |             | string, int, int, int, int, string | Let the arguments be ``file``, ``startLine``, ``startCol``, ``endLine``, ``endCol``, and ``url``. The predicate holds if ``url`` is equal to the string ``file://file:startLine:startCol:endLine:endCol``. |
+-----------+-------------+------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Built-ins for boolean
~~~~~~~~~~~~~~~~~~~~~

The following built-in predicates are members of type ``boolean``:

+----------------+-------------+----------------+--------------------------------------------------------------------------+
| Name           | Result type | Argument types | Content                                                                  |
+================+=============+================+==========================================================================+
| ``booleanAnd`` | boolean     | boolean        | The result is the boolean and of the receiver and the argument.          |
+----------------+-------------+----------------+--------------------------------------------------------------------------+
| ``booleanNot`` | boolean     |                | The result is the boolean not of the receiver.                           |
+----------------+-------------+----------------+--------------------------------------------------------------------------+
| ``booleanOr``  | boolean     | boolean        | The result is the boolean or of the receiver and the argument.           |
+----------------+-------------+----------------+--------------------------------------------------------------------------+
| ``booleanXor`` | boolean     | boolean        | The result is the boolean exclusive or of the receiver and the argument. |
+----------------+-------------+----------------+--------------------------------------------------------------------------+
| ``toString``   | string      |                | The result is "true" if the receiver is ``true``, otherwise "false."     |
+----------------+-------------+----------------+--------------------------------------------------------------------------+

Built-ins for date
~~~~~~~~~~~~~~~~~~

The following built-in predicates are members of type ``date``:

+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| Name           | Result type | Argument types | Content                                                                                        |
+================+=============+================+================================================================================================+
| ``daysTo``     | int         | date           | The result is the number of days between but not including the receiver and the argument.      |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``getDay``     | int         |                | The result is the day component of the receiver.                                               |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``getHours``   | int         |                | The result is the hours component of the receiver.                                             |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``getMinutes`` | int         |                | The result is the minutes component of the receiver.                                           |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``getMonth``   | string      |                | The result is a string that is determined by the month component of the receiver.              |
|                |             |                | The string is one of ``January``, ``February``, ``March``, ``April``, ``May``, ``June``,       |
|                |             |                | ``July``, ``August``, ``September``, ``October``, ``November``, or ``December``.               |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``getSeconds`` | int         |                | The result is the seconds component of the receiver.                                           |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``getYear``    | int         |                | The result is the year component of the receiver.                                              |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``toISO``      | string      |                | The result is a string representation of the date. The representation is left unspecified.     |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+
| ``toString``   | string      |                | The result is a string representation of the date. The representation is left unspecified.     |
+----------------+-------------+----------------+------------------------------------------------------------------------------------------------+

Built-ins for float
~~~~~~~~~~~~~~~~~~~

The following built-in predicates are members of type ``float``:

+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| Name          | Result type | Argument types | Content                                                                                                                   |
+===============+=============+================+===========================================================================================================================+
| ``abs``       | float       |                | The result is the absolute value of the receiver.                                                                         |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``acos``      | float       |                | The result is the inverse cosine of the receiver.                                                                         |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``asin``      | float       |                | The result is the inverse sine of the receiver.                                                                           |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``atan``      | float       |                | The result is the inverse tangent of the receiver.                                                                        |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``ceil``      | int         |                | The result is the smallest integer greater than or equal to the receiver.                                                 |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``copySign``  | float       | float          | The result is the floating point number with the magnitude of the receiver and the sign of the argument.                  |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``cos``       | float       |                | The result is the cosine of the receiver.                                                                                 |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``cosh``      | float       |                | The result is the hyperbolic cosine of the receiver.                                                                      |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``exp``       | float       |                | The result is the value of e, the base of the natural logarithm, raised to the power of the receiver.                     |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``floor``     | int         |                | The result is the largest integer that is not greater than the receiver.                                                  |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``log``       | float       |                | The result is the natural logarithm of the receiver.                                                                      |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``log``       | float       | float          | The result is the logarithm of the receiver with the base of the argument.                                                |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``log``       | float       | int            | The result is the logarithm of the receiver with the base of the argument.                                                |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``log10``     | float       |                | The result is the base-10 logarithm of the receiver.                                                                      |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``log2``      | float       |                | The result is the base-2 logarithm of the receiver.                                                                       |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``maximum``   | float       | float          | The result is the larger of the receiver and the argument.                                                                |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``maximum``   | float       | int            | The result is the larger of the receiver and the argument.                                                                |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``minimum``   | float       | float          | The result is the smaller of the receiver and the argument.                                                               |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``minimum``   | float       | int            | The result is the smaller of the receiver and the argument.                                                               |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``nextAfter`` | float       | float          | The result is the number adjacent to the receiver in the direction of the argument.                                       |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``nextDown``  | float       |                | The result is the number adjacent to the receiver in the direction of negative infinity.                                  |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``nextUp``    | float       |                | The result is the number adjacent to the receiver in the direction of positive infinity.                                  |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``pow``       | float       | float          | The result is the receiver raised to the power of the argument.                                                           |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``pow``       | float       | int            | The result is the receiver raised to the power of the argument.                                                           |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``signum``    | float       |                | The result is the sign of the receiver: zero if it is zero, 1.0 if it is greater than zero, -1.0 if it is less than zero. |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``sin``       | float       |                | The result is the sine of the receiver.                                                                                   |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``sinh``      | float       |                | The result is the hyperbolic sine of the receiver.                                                                        |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``sqrt``      | float       |                | The result is the square root of the receiver.                                                                            |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``tan``       | float       |                | The result is the tangent of the receiver.                                                                                |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``tanh``      | float       |                | The result is the hyperbolic tangent of the receiver.                                                                     |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``toString``  | string      |                | The decimal representation of the number as a string.                                                                     |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+
| ``ulp``       | float       |                | The result is the ULP (unit in last place) of the receiver.                                                               |
+---------------+-------------+----------------+---------------------------------------------------------------------------------------------------------------------------+

Built-ins for int
~~~~~~~~~~~~~~~~~

The following built-in predicates are members of type ``int``:

+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| Name                    | Result type | Argument types | Content                                                                                                        |
+=========================+=============+================+================================================================================================================+
| ``abs``                 | int         |                | The result is the absolute value of the receiver.                                                              |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``acos``                | float       |                | The result is the inverse cosine of the receiver.                                                              |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``asin``                | float       |                | The result is the inverse sine of the receiver.                                                                |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``atan``                | float       |                | The result is the inverse tangent of the receiver.                                                             |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``cos``                 | float       |                | The result is the cosine of the receiver.                                                                      |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``cosh``                | float       |                | The result is the hyperbolic cosine of the receiver.                                                           |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``exp``                 | float       |                | The result is the value of value of e, the base of the natural logarithm, raised to the power of the receiver. |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``gcd``                 | int         | int            | The result is the greatest common divisor of the receiver and the argument.                                    |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``log``                 | float       |                | The result is the natural logarithm of the receiver.                                                           |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``log``                 | float       | float          | The result is the logarithm of the receiver with the base of the argument.                                     |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``log``                 | float       | int            | The result is the logarithm of the receiver with the base of the argument.                                     |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``log10``               | float       |                | The result is the base-10 logarithm of the receiver.                                                           |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``log2``                | float       |                | The result is the base-2 logarithm of the receiver.                                                            |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``maximum``             | float       | float          | The result is the larger of the receiver and the argument.                                                     |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``maximum``             | int         | int            | The result is the larger of the receiver and the argument.                                                     |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``minimum``             | float       | float          | The result is the smaller of the receiver and the argument.                                                    |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``minimum``             | int         | int            | The result is the smaller of the receiver and the argument.                                                    |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``pow``                 | float       | float          | The result is the receiver raised to the power of the argument.                                                |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``pow``                 | float       | int            | The result is the receiver raised to the power of the argument.                                                |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``sin``                 | float       |                | The result is the sine of the receiver.                                                                        |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``sinh``                | float       |                | The result is the hyperbolic sine of the receiver.                                                             |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``sqrt``                | float       |                | The result is the square root of the receiver.                                                                 |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``tan``                 | float       |                | The result is the tangent of the receiver.                                                                     |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``tanh``                | float       |                | The result is the hyperbolic tangent of the receiver.                                                          |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitAnd``              | int         | int            | The result is the bitwise and of the receiver and the argument.                                                |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitOr``               | int         | int            | The result is the bitwise or of the receiver and the argument.                                                 |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitXor``              | int         | int            | The result is the bitwise xor of the receiver and the argument.                                                |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitNot``              | int         |                | The result is the bitwise complement of the receiver.                                                          |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitShiftLeft``        | int         | int            | The result is the bitwise left shift of the receiver by the argument, modulo 32.                               |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitShiftRight``       | int         | int            | The result is the bitwise right shift of the receiver by the argument, modulo 32.                              |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``bitShiftRightSigned`` | int         | int            | The result is the signed bitwise right shift of the receiver by the argument, modulo 32.                       |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``toString``            | string      |                | The result is the decimal representation of the number as a string.                                            |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+
| ``toUnicode``           | string      |                | The result is the unicode character for the receiver seen as a unicode code point.                             |
+-------------------------+-------------+----------------+----------------------------------------------------------------------------------------------------------------+

The leftmost bit after ``bitShiftRightSigned`` depends on sign extension, whereas after ``bitShiftRight`` it is zero.

Built-ins for string
~~~~~~~~~~~~~~~~~~~~

The following built-in predicates are members of type ``string``:

+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Name                 | Result type | Argument types   | Content                                                                                                                                                                                                                                                                                                                                                                                |
+======================+=============+==================+========================================================================================================================================================================================================================================================================================================================================================================================+
| ``charAt``           | string      | int              | The result is a 1-character string containing the character in the receiver at the index given by the argument. The first element of the string is at index 0.                                                                                                                                                                                                                         |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``indexOf``          | int         | string           | The result is an index into the receiver where the argument occurs.                                                                                                                                                                                                                                                                                                                    |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``indexOf``          | int         | string, int, int | Let the arguments be ``s``, ``n``, and ``start``. The result is the index of occurrence ``n`` of ``substring`` ``s`` in the receiver that is no earlier in the string than ``start``.                                                                                                                                                                                                  |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``isLowercase``      |             |                  | The receiver contains no upper-case letters.                                                                                                                                                                                                                                                                                                                                           |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``isUppercase``      |             |                  | The receiver contains no lower-case letters.                                                                                                                                                                                                                                                                                                                                           |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``length``           | int         |                  | The result is the number of characters in the receiver.                                                                                                                                                                                                                                                                                                                                |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``matches``          |             | string           | The argument is a pattern that matches the receiver, in the same way as the LIKE operator in SQL. Patterns may include ``_`` to match a single character and ``%`` to match any sequence of characters. A backslash can be used to escape an underscore, a percent, or a backslash. Otherwise, all characters in the pattern other than ``_`` and ``%`` and ``\\`` must match exactly. |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``prefix``           | string      | int              | The result is the prefix of the receiver that has a length exactly equal to the argument. If the argument is negative or greater than the receiver's length, then there is no result.                                                                                                                                                                                                  |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``regexpCapture``    | string      | string, int      | The receiver exactly matches the regex in the first argument, and the result is the group of the match numbered by the second argument.                                                                                                                                                                                                                                                |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``regexpFind``       | string      | string, int, int | The receiver contains one or more occurrences of the regex in the first argument. The result is the ``substring`` which matches the regex, the second argument is the occurrence number, and the third argument is the index within the receiver at which the occurrence begins.                                                                                                       |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``regexpMatch``      |             | string           | The receiver matches the argument as a regex.                                                                                                                                                                                                                                                                                                                                          |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``regexpReplaceAll`` | string      | string, string   | The result is obtained by replacing all occurrences in the receiver of the first argument as a regex by the second argument.                                                                                                                                                                                                                                                           |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``replaceAll``       | string      | string, string   | The result is obtained by replacing all occurrences in the receiver of the first argument by the second.                                                                                                                                                                                                                                                                               |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``splitAt``          | string      | string           | The result is one of the strings obtained by splitting the receiver at every occurrence of the argument.                                                                                                                                                                                                                                                                               |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``splitAt``          | string      | string, int      | Let the arguments be ``delim`` and ``i``. The result is field number ``i`` of the fields obtained by splitting the receiver at every occurrence of ``delim``.                                                                                                                                                                                                                          |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``substring``        | string      | int, int         | The result is the ``substring`` of the receiver starting at the index of the first argument and ending just before the index of the second argument.                                                                                                                                                                                                                                   |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``suffix``           | string      | int              | The result is the suffix of the receiver that has a length exactly equal to the receiver's length minus the argument. If the argument is negative or greater than the receiver's length, then there is no result. As a result, the identity ``s.prefix(i)+s.suffix(i)=s`` holds for ``i`` in ``[0, s.length()]``.                                                                      |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toDate``           | date        |                  | The result is a date value determined by the receiver. The format of the receiver is unspecified, except that if ``(d, s)`` is in ``date.toString``, ``(s, d)`` is in ``string.toDate``.                                                                                                                                                                                               |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toFloat``          | float       |                  | The result is the float whose value is represented by the receiver. If the receiver cannot be parsed as a float then there is no result.                                                                                                                                                                                                                                               |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toInt``            | int         |                  | The result is the integer whose value is represented by the receiver. If the receiver cannot be parsed as an integer or cannot be represented as a QL ``int``, then there is no result. The parser accepts an optional leading ``-`` or ``+`` character, followed by one or more decimal digits.                                                                                       |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toLowerCase``      | string      |                  | The result is the receiver with all letters converted to lower case.                                                                                                                                                                                                                                                                                                                   |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toString``         | string      |                  | The result is the receiver.                                                                                                                                                                                                                                                                                                                                                            |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``toUpperCase``      | string      |                  | The result is the receiver with all letters converted to upper case.                                                                                                                                                                                                                                                                                                                   |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``trim``             | string      |                  | The result is the receiver with all whitespace removed from the beginning and end of the string.                                                                                                                                                                                                                                                                                       |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``codePointAt``      | int         | int              | The result is the unicode code point at the index given by the argument.                                                                                                                                                                                                                                                                                                               |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``codePointCount``   | int         | int, int         | The result is the number of unicode code points in the receiver between the given indices.                                                                                                                                                                                                                                                                                             |
+----------------------+-------------+------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Regular expressions are as defined by ``java.util.regex.Pattern`` in Java.
For more information, see the `Java API Documentation <https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/regex/Pattern.html>`__.

Evaluation
----------

This section specifies the evaluation of a QL program. Evaluation happens in three phases. First, the program is stratified into a number of layers. Second, the layers are evaluated one by one. Finally, the queries in the QL file are evaluated to produce sets of ordered tuples.

Stratification
~~~~~~~~~~~~~~

A QL program can be *stratified* to a sequence of *layers*. A layer is a set of predicates and types.

A valid stratification must include each predicate and type in the QL program that is *fully instantiated*. It must not include any other predicates or types.

A valid stratification must not include the same predicate in multiple layers.

Each non-abstract predicate has an associated body. For predicates inside *declared modules*, this is the predicate declaration. The body of an *instantiation-nested* predicate is the body of the *underlying nested* predicate where all references and calls have been substituted with the *instantiation-relative* entity or alias.

Formulas, variable declarations and expressions within a predicate body have a *negation polarity* that is positive, negative, or zero. Positive and negative are opposites of each other, while zero is the opposite of itself. The negation polarity of a formula or expression is then determined as follows:

-  The body of a predicate is positive.

-  The formula within a negation formula has the opposite polarity to that of the negation formula.

-  The condition of a conditional formula has zero polarity.

-  The formula on the left of an implication formula has the opposite polarity to that of the implication.

-  The formula and variable declarations of an aggregate have zero polarity.

-  If the ``monotonicAggregates`` language pragma is not enabled, or the original formula and variable declarations are both omitted, then the expressions and order by expressions of the aggregate have zero polarity.

-  If the ``monotonicAggregates`` language pragma is enabled, and the original formula and variable declarations were not both omitted, then the expressions and order by expressions of the aggregate have the polarity of the aggregate.

-  If a ``forall`` has two quantified formulas, then the first quantified formula has the opposite polarity to that of the ``forall``.

-  The variable declarations of a ``forall`` have the opposite polarity to that of the ``forall``.

-  If a ``forex`` has two quantified formulas, then the first quantified formula has zero polarity.

-  The variable declarations of a ``forex`` have zero polarity.

-  In all other cases, a formula or expression has the same polarity as its immediately enclosing formula or expression.

For a member predicate ``p`` we define the *strict dispatch dependencies*. The strict dispatch dependencies are defined as:

-  The strict dispatch dependencies of any predicates that override ``p``.
-  If ``p`` is not abstract, ``C.class`` for any class ``C`` with a predicate that overrides ``p``.

For a member predicate ``p`` we define the *dispatch dependencies*. The dispatch dependencies are defined as:

-  The dispatch dependencies of predicates that override ``p``.
-  The predicate ``p`` itself.
-  ``C.class`` where ``C`` is the class that defines ``p``.

Predicates, and types can *depend* and *strictly depend* on each other. Such dependencies exist in the following circumstances:

-  If ``A`` strictly depends on ``B``, then ``A`` depends on ``B``.

-  If ``A`` depends on ``B``, then ``A`` also depends on anything on which ``B`` depends.

-  If ``A`` strictly depends on ``B``, then ``A`` and anything depending on ``A`` strictly depend on anything on which ``B`` depends (including ``B`` itself).

-  If a predicate has a parameter whose declared type is a class type ``C``, it depends on ``C.class``.

-  If a predicate declares a result type which is a class type ``C``, it depends on ``C.class``.

-  A member predicate of class ``C`` depends on ``C.class``.

-  If a predicate contains a variable declaration of a variable whose declared type is a class type ``C``, then the predicate depends on ``C.class``. If the declaration has negative or zero polarity then the dependency is strict.

-  If a predicate contains a variable declaration with negative or zero polarity of a variable whose declared type is a class type ``C``, then the predicate strictly depends on ``C.class``.

-  If a predicate contains an expression whose type is a class type ``C`` which is not a variable reference, then the predicate depends on ``C.class``. If the expression has negative or zero polarity then the dependency is strict.

-  A predicate containing a predicate call depends on the predicate to which the call resolves. If the call has negative or zero polarity then the dependency is strict.

-  A predicate containing a predicate call, which resolves to a member predicate, where the call is not direct, depends on the dispatch dependencies of the root definitions of the target of the call. If the call has negative or zero polarity then the dependencies are strict. The predicate strictly depends on the strict dispatch dependencies of the root definitions.

-  For each class ``C`` in the program, for each base class ``B`` of ``C``, ``C.extends`` depends on ``B.B``.

-  For each class ``C`` in the program, for each instanceof type ``B`` of ``C``, ``C.extends`` depends on ``B``.

-  For each class ``C`` in the program, for each base type ``B`` of ``C`` that is not a class type, ``C.extends`` depends on ``B``.

-  For each class ``C`` in the program, ``C.class`` depends on ``C.C``.

-  For each class ``C`` in the program, ``C.C`` depends on ``C.extends``.

-  For each class ``C`` in the program that declares a field of class type ``B``, ``C.C`` depends on ``B.class``.

-  For each class ``C`` with a characteristic predicate, ``C.C`` depends on the characteristic predicate.

-  For each abstract class ``A`` in the program, for each type ``C`` that inherits from ``A`` and has ``A`` as a base type, ``A.class`` depends on ``C.class``.

-  A predicate with a higher-order body may strictly depend or depend on each predicate reference within the body. The exact dependencies are left unspecified.

A valid stratification must have no predicate that depends on a predicate in a later layer. Additionally, it must have no predicate that strictly depends on a predicate in the same layer.

If a QL program has no valid stratification, then the program itself is not valid. If it does have a stratification, a QL implementation must choose exactly one stratification. The precise stratification chosen is left unspecified.

Layer evaluation
~~~~~~~~~~~~~~~~

The store is first initialized with the *database content* of all built-in predicates and external predicates. The database content of a predicate is a set of ordered tuples that are included in the database.

Each layer of the stratification is *populated* in order. To populate a layer, each predicate in the layer is repeatedly populated until the store stops changing. The way that a predicate is populated is as follows:

-  To populate a predicate that has a formula as a body, find each named tuple ``t`` that has the following properties:

     - The tuple matches the body formula.
     - The variables should be the predicate's arguments.
     - If the predicate has a result, then the tuples should additionally have a value for ``result``.
     - If the predicate is a member predicate or characteristic predicate of a class ``C`` then the tuples should additionally have a value for ``this`` and each visible field on the class.
     - The values corresponding to the arguments should all be a member of the declared types of the arguments.
     - The values corresponding to ``result`` should all be a member of the result type.
     - The values corresponding to the fields should all be a member of the declared types of the fields.
     - If the predicate is a member predicate of a class ``C`` and not a characteristic predicate, then the tuples should additionally extend some tuple in ``C.class``.
     - If the predicate is a characteristic predicate of a class ``C``, then there should be a tuple ``t'`` in ``C.extends`` such that for each visible field in ``C``, any field that is equal to or overrides a field in ``t'`` should have the same value in ``t``. ``this`` should also map to the same value in ``t`` and ``t'``.

   For each such tuple remove any components that correspond to fields and add it to the predicate in the store.

-  To populate an abstract predicate, do nothing.

-  The population of predicates with a higher-order body is left only partially specified. A number of tuples are added to the given predicate in the store. The tuples that are added must be fully determined by the QL program and by the state of the store.

-  To populate the type ``C.extends`` for a class ``C``, identify each named tuple that has the following properties:

     - The value of ``this`` is in all non-class base types of ``C``.
     - The value of ``this`` is in all instanceof types of ``C``.
     - The keys of the tuple are ``this`` and the union of the public fields from each base type.
     - For each class base type ``B`` of ``C`` there is a named tuple with variables from the public fields of ``B`` and ``this`` that the given tuple and some tuple in ``B.B`` both extend.

   For each such tuple add it to ``C.extends``.

-  To populate the type ``C.C`` for a class ``C``, if ``C`` has a characteristic predicate, then add all tuples from that predicate to the store. Otherwise add all tuples ``t`` such that:

     - The variables of ``t`` should be ``this`` and the visible fields of ``C``.
     - The values corresponding to the fields should all be a member of the declared types of the fields.
     - If the predicate is a characteristic predicate of a class ``C``, then there should be a tuple ``t'`` in ``C.extends`` such that for each visible field in ``C``, any field that is equal to or overrides a field in ``t'`` should have the same value in ``t``. ``this`` should also map to the same value in ``t`` and ``t'``.

-  To populate the type ``C.class`` for a non-abstract class type ``C``, add each tuple in ``C.C`` to ``C.class``.

-  To populate the type ``C.class`` for an abstract class type ``C``, identify each named tuple that has the following properties:
     - It is a member of ``C.C``.
     - For each class ``D`` that inherits from ``C`` and has ``C`` as a base type then there is a named tuple with variables from the public fields of ``C`` and ``this`` that the given tuple and a tuple in ``D.class`` both extend.


Query evaluation
~~~~~~~~~~~~~~~~

A query is evaluated as follows:

#. Identify all facts about query predicates.
#. If there is a select clause then find all named tuples with the variables declared in the ``from`` clause that match the formula given in the ``where`` clause, if there is one. For each named tuple, convert it to a set of ordered tuples where each element of the ordered tuple is, in the context of the named tuple, a value of one of the corresponding select expressions. Then sequence the ordered tuples lexicographically. The first elements of the lexicographic order are the tuple elements specified by the ordering directives of the predicate targeted by the query, if it has any. Each such element is ordered either ascending (``asc``) or descending (``desc``) as specified by the ordering directive, or ascending if the ordering directive does not specify. This lexicographic order is only a partial order, if there are fewer ordering directives than elements of the tuples. An implementation may produce any sequence of the ordered tuples that satisfies this partial order.
#. The result is the facts from the query predicates plus the list of ordered tuples from the select clause if it exists.

Summary of syntax
-----------------

The complete grammar for QL is as follows:

::

   ql ::= qldoc? moduleBody

   module ::= annotation* "module" modulename parameters? implements? "{" moduleBody "}"

   parameters ::= "<" signatureExpr parameterName ("," signatureExpr parameterName)* ">"

   implements ::= "implements" moduleSignatureExpr ("," moduleSignatureExpr)*

   moduleBody ::= (import | predicate | class | module | alias | select)*

   import ::= annotations "import" importModuleExpr ("as" modulename)?

   qualId ::= simpleId | qualId "." simpleId

   importModuleExpr ::= qualId | importModuleExpr "::" modulename arguments?

   arguments ::= "<" argument ("," argument)* ">"

   argument ::= moduleExpr | type | predicateRef "/" int

   signature ::= predicateSignature | typeSignature | moduleSignature

   predicateSignature ::= qldoc? annotations "signature" head ";"

   typeSignature ::= qldoc? annotations "signature" "class" classname ("extends" type ("," type)*)? (";" | "{" signaturePredicate* "}")

   moduleSignature ::= qldoc? annotation* "signature" "module" moduleSignatureName parameters? "{" moduleSignatureBody "}"

   moduleSignatureBody ::= (signaturePredicate | defaultPredicate | signatureType)*

   signaturePredicate ::= qldoc? annotations head ";"

   defaultPredicate ::= qldoc? annotations "default" head "{" formula "}"

   signatureType ::= qldoc? annotations "class" classname ("extends" type ("," type)*)? "{" signaturePredicate* "}"

   select ::= ("from" var_decls)? ("where" formula)? "select" as_exprs ("order" "by" orderbys)?

   as_exprs ::= as_expr ("," as_expr)*

   as_expr ::= expr ("as" lowerId)?

   orderbys ::= orderby ("," orderby)*

   orderby ::= lowerId ("asc" | "desc")?

   predicate ::= qldoc? annotations head optbody

   annotations ::= annotation*

   annotation ::= simpleAnnotation | argsAnnotation

   simpleAnnotation ::= "abstract"
                    |   "cached"
                    |   "external"
                    |   "extensible"
                    |   "final"
                    |   "transient"
                    |   "library"
                    |   "private"
                    |   "deprecated"
                    |   "override"
                    |   "additional"
                    |   "query"

   argsAnnotation ::= "pragma" "[" ("inline" | "inline_late" | "noinline" | "nomagic" | "noopt" | "assume_small_delta") "]"
                  |   "language" "[" "monotonicAggregates" "]"
                  |   "bindingset" "[" (variable ( "," variable)*)? "]"

   head ::= ("predicate" | type) predicateName "(" var_decls ")"

   optbody ::= ";"
           |  "{" formula "}"
           |  "=" literalId "(" (predicateRef "/" int ("," predicateRef "/" int)*)? ")" "(" (exprs)? ")"

   class ::= qldoc? annotations "class" classname ("extends" type ("," type)*)? ("instanceof" type ("," type)*)?  "{" member* "}"

   member ::= character | predicate | field

   character ::= qldoc? annotations classname "(" ")" "{" formula "}"

   field ::= qldoc? annotations var_decl ";"

   moduleExpr ::= modulename arguments? | moduleExpr "::" modulename arguments?

   moduleSignatureExpr ::= (moduleExpr "::")? moduleSignatureName arguments?

   signatureExpr : (moduleExpr "::")? simpleId ("/" Integer | arguments)?;

   type ::= (moduleExpr "::")? classname | dbasetype | "boolean" | "date" | "float" | "int" | "string"

   exprs ::= expr ("," expr)*

   alias ::= qldoc? annotations "predicate" literalId "=" predicateRef "/" int ";"
         |  qldoc? annotations "class" classname "=" type ";"
         |  qldoc? annotations "module" modulename "=" moduleExpr ";"

   var_decls ::= (var_decl ("," var_decl)*)?

   var_decl ::= type lowerId

   formula ::= fparen
           |   disjunction
           |   conjunction
           |   implies
           |   ifthen
           |   negated
           |   quantified
           |   comparison
           |   instanceof
           |   inrange
           |   call

   fparen ::= "(" formula ")"

   disjunction ::= formula "or" formula

   conjunction ::= formula "and" formula

   implies ::= formula "implies" formula

   ifthen ::= "if" formula "then" formula "else" formula

   negated ::= "not" formula

   quantified ::= "exists" "(" expr ")"
              |   "exists" "(" var_decls ("|" formula)? ("|" formula)? ")"
              |   "forall" "(" var_decls ("|" formula)? "|" formula ")"
              |   "forex"  "(" var_decls ("|" formula)? "|" formula ")"

   comparison ::= expr compop expr

   compop ::= "=" | "!=" | "<" | ">" | "<=" | ">="

   instanceof ::= expr "instanceof" type

   inrange ::= expr "in" (range | setliteral)

   call ::= predicateRef (closure)? "(" (exprs)? ")"
        |   primary "." predicateName (closure)? "(" (exprs)? ")"

   closure ::= "*" | "+"

   expr ::= dontcare
        |   unop
        |   binop
        |   cast
        |   primary


   primary ::= eparen
           |   literal
           |   variable
           |   super_expr
           |   postfix_cast
           |   callwithresults
           |   aggregation
           |   expression_pragma
           |   any
           |   range
           |   setliteral

   eparen ::= "(" expr ")"

   dontcare ::= "_"

   literal ::= "false" | "true" | int | float | string

   unop ::= "+" expr
        |   "-" expr

   binop ::= expr "+" expr
         |   expr "-" expr
         |   expr "*" expr
         |   expr "/" expr
         |   expr "%" expr

   variable ::= varname | "this" | "result"

   super_expr ::= "super" | type "." "super"

   cast ::= "(" type ")" expr

   postfix_cast ::= primary "." "(" type ")"

   aggregation ::= aggid ("[" expr "]")? "(" var_decls ("|" (formula)? ("|" as_exprs ("order" "by" aggorderbys)?)?)? ")"
               |   aggid ("[" expr "]")? "(" as_exprs ("order" "by" aggorderbys)? ")"
               |   "unique" "(" var_decls "|" (formula)? ("|" as_exprs)? ")"

   expression_pragma ::= "pragma" "[" expression_pragma_type "]" "(" expr ")"

   expression_pragma_type ::= "only_bind_out" | "only_bind_into"

   aggid ::= "avg" | "concat" | "count" | "max" | "min" | "rank" | "strictconcat" | "strictcount" | "strictsum" | "sum"

   aggorderbys ::= aggorderby ("," aggorderby)*

   aggorderby ::= expr ("asc" | "desc")?

   any ::= "any" "(" var_decls ("|" (formula)? ("|" expr)?)? ")"

   callwithresults ::= predicateRef (closure)? "(" (exprs)? ")"
                   |   primary "." predicateName (closure)? "(" (exprs)? ")"

   range ::= "[" expr ".." expr "]"

   setliteral ::= "[" expr ("," expr)* ","? "]"

   simpleId ::= lowerId | upperId

   modulename ::= simpleId

   moduleSignatureName ::= upperId

   classname ::= upperId

   dbasetype ::= atLowerId

   predicateRef ::= (moduleExpr "::")? literalId

   predicateName ::= lowerId

   parameterName ::= simpleId

   varname ::= lowerId

   literalId ::= lowerId | atLowerId | "any" | "none"



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/recursion.rst
:tocdepth: 1

.. index:: recursion

.. _recursion:

Recursion
#########

QL provides strong support for recursion. A predicate in QL is said to be recursive if
it depends, directly or indirectly, on itself. 

To evaluate a recursive predicate, the QL compiler finds the `least fixed point 
<https://en.wikipedia.org/wiki/Least_fixed_point>`_ of the recursion. 
In particular, it starts with the empty set of values, and finds new values by repeatedly 
applying the predicate until the set of values no longer changes. This set is the least fixed
point and hence the result of the evaluation. 
Similarly, the result of a QL query is the least fixed point of the predicates referenced in
the query.

In certain cases, you can also use aggregates recursively. For more information, see ":ref:`monotonic-aggregates`."

Examples of recursive predicates
********************************

Here are a few examples of recursive predicates in QL:

Counting from 0 to 100
======================

The following query uses the predicate ``getANumber()`` to list all integers from 0 to 100
(inclusive):

.. code-block:: ql

    int getANumber() {
      result = 0
      or
      result <= 100 and result = getANumber() + 1
    }

    select getANumber()

The predicate ``getANumber()`` evaluates to the set containing ``0`` and any integers that are
one more than a number already in the set (up to and including ``100``).

Mutual recursion
================

Predicates can be mutually recursive, that is, you can have a cycle of predicates that
depend on each other. For example, here is a QL query that counts to 100 using even numbers:

.. code-block:: ql

    int getAnEven() {
      result = 0
      or
      result <= 100 and result = getAnOdd() + 1
    }
    
    int getAnOdd() {
      result = getAnEven() + 1
    }
    
    select getAnEven()
    
The results of this query are the even numbers from 0 to 100.
You could replace ``select getAnEven()`` with ``select getAnOdd()`` to list the odd numbers from 1 to 101.
    
.. index:: transitive closure
.. _transitive-closures:

Transitive closures
===================

The `transitive closure <https://en.wikipedia.org/wiki/Transitive_closure>`_ 
of a predicate is a recursive predicate whose results are obtained by repeatedly
applying the original predicate.

In particular, the original predicate must have two arguments (possibly including a ``this`` or
``result`` value) and those arguments must have :ref:`compatible types <type-compatibility>`.

Since transitive closures are a common form of recursion, QL has two
helpful abbreviations:

#. **Transitive closure** ``+``
  
   To apply a predicate **one** or more times, append ``+`` to the predicate name.
   
   For example, suppose that you have a class ``Person`` with a :ref:`member predicate
   <member-predicates>` ``getAParent()``. Then ``p.getAParent()`` returns any parents of ``p``.
   The transitive closure ``p.getAParent+()`` returns parents of ``p``, parents of parents of 
   ``p``, and so on.
   
   Using this ``+`` notation is often simpler than defining the recursive predicate explicitly. 
   In this case, an explicit definition could look like this:

   .. code-block:: ql
   
       Person getAnAncestor() {
         result = this.getAParent()
         or
         result = this.getAParent().getAnAncestor()
       }
   
   The predicate ``getAnAncestor()`` is equivalent to ``getAParent+()``.

#. **Reflexive transitive closure** ``*``
  
   This is similar to the above transitive closure operator, except that you can use it to apply a
   predicate to itself **zero** or more times.
   
   For example, the result of ``p.getAParent*()`` is an ancestor of ``p`` (as above), or ``p``
   itself.
   
   In this case, the explicit definition looks like this:

   .. code-block:: ql
   
       Person getAnAncestor2() {
         result = this
         or
         result = this.getAParent().getAnAncestor2()
       }
   
   The predicate ``getAnAncestor2()`` is equivalent to ``getAParent*()``.

Restrictions and common errors
******************************

While QL is designed for querying recursive data, recursive definitions are sometimes difficult
to get right. If a recursive definition contains an error, then usually you get no results, or 
a compiler error.

The following examples illustrate common mistakes that lead to invalid recursion:

Empty recursion
===============

Firstly, a valid recursive definition must have a starting point or *base case*.
If a recursive predicate evaluates to the empty set of values, there is usually something
wrong.

For example, you might try to define the predicate ``getAnAncestor()`` (from the 
:ref:`above <transitive-closures>` example) as follows:

.. code-block:: ql

    Person getAnAncestor() {
      result = this.getAParent().getAnAncestor()
    }

In this case, the QL compiler gives an error stating that this is an empty recursive call.

Since ``getAnAncestor()`` is initially assumed to be empty, there is no way for new values to
be added. The predicate needs a starting point for the recursion, for example:

.. code-block:: ql

    Person getAnAncestor() {
      result = this.getAParent()
      or
      result = this.getAParent().getAnAncestor()
    }

.. _non-monotonic-recursion:

Non-monotonic recursion
=======================

A valid recursive predicate must also be `monotonic <https://en.wikipedia.org/wiki/Monotonic_function>`_.
This means that (mutual) recursion is only allowed under an even number of :ref:`negations <negation>`.

Intuitively, this prevents "`liar's paradox <https://en.wikipedia.org/wiki/Liar_paradox>`_"
situations, where there is no solution to the recursion. For example:

.. code-block:: ql

    predicate isParadox() {
      not isParadox()
    }

According to this definition, the predicate ``isParadox()`` holds precisely when it doesn't hold.
This is impossible, so there is no fixed point solution to the recursion.

If the recursion appears under an even number of negations, then this isn't a problem.
For example, consider the following (slightly macabre) member predicate of class ``Person``:

.. code-block:: ql

    predicate isExtinct() {
      this.isDead() and
      not exists(Person descendant | descendant.getAParent+() = this |
        not descendant.isExtinct()
      )
    }

``p.isExtinct()`` holds if ``p`` and all of ``p``'s descendants are dead.

The recursive call to ``isExtinct()`` is nested in an even number of negations, so this is a
valid definition. 
In fact, you could rewrite the second part of the definition as follows:

.. code-block:: ql

    forall(Person descendant | descendant.getAParent+() = this | 
      descendant.isExtinct()
    )


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/signatures.rst
:tocdepth: 1

.. index:: signature

.. _signatures:

Signatures
##########

Parameterized modules use signatures as a type system for their parameters.
There are three categories of signatures: **predicate signatures**, **type signatures**, and **module signatures**.

Predicate signatures
====================

Predicate signatures declare module parameters that will be substituted with predicates when the module is instantiated.

The substitution of predicate signatures relies on structural typing. That is, predicates do not have to be explicitly
defined as implementing a predicate signature - they just have to match the return and argument types.

Predicate signatures are defined much like predicates themselves, but they do not have a body.
In detail, a predicate signature definition consists of:

#. The keyword ``signature``.
#. The keyword ``predicate`` (allows substitution with a :ref:`predicate without result <predicates-without-result>`),
   or the type of the result (allows substitution with a :ref:`predicate with result <predicates-with-result>`).
#. The name of the predicate signature. This is an `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_
   starting with a lowercase letter.
#. The arguments to the predicate signature, if any, separated by commas.
   For each argument, specify the argument type and an identifier for the argument variable.
#. A semicolon ``;``.

For example:

.. code-block:: ql

    signature int operator(int lhs, int rhs);

Type signatures
===============

Type signatures declare module parameters that will be substituted with types when the module is instantiated.
Type signatures may specify supertypes and required member predicates (in addition to those member predicates that are
implied by the supertypes).

The substitution of type signatures relies on structural typing. That is, types do not have to be explicitly defined as
implementing a type signature - they just need to have the specified (transitive) supertypes and member predicates.

In detail, a type signature definition consists of:

#. The keyword ``signature``.
#. The keyword ``class``.
#. The name of the type signature. This is an `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_
   starting with a uppercase letter.
#. Optionally, the keyword ``extends`` followed by a list of types, separated by commas.
#. Either a semicolon ``;`` or a list of predicate signatures enclosed in braces.
   The ``signature`` keyword is omitted for these contained signatures.

For example:

.. code-block:: ql

    signature class ExtendsInt extends int;

    signature class CanBePrinted {
      string toString();
    }

Module signatures
=================

Module signatures declare module parameters that will be substituted with modules when the module is instantiated.
Module signatures specify a collection of types and predicates that a module needs to contain under given names and
matching given signatures.

Unlike type signatures and predicate signatures, the substitution of module signatures relies on nominal typing.
That is, the definition of a module must declare the module signatures it implements.

In detail, a type signature definition consists of:

#. The keyword ``signature``.
#. The keyword ``module``.
#. The name of the module signature. This is an `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_
   starting with a uppercase letter.
#. Optionally, a list of parameters for :ref:`parameterized module signatures <parameterized-module-signatures>`.
#. The module signature body, consisting of type signatures, predicate signatures, and default predicates enclosed in braces.
   The ``signature`` keyword is omitted for these contained signatures.

Module signature default predicates are syntactically constructed like predicate signatures,
but preceded by the ``default`` keyword, and with a predicate body instead of the concluding
semicolon ``;``.
Default predicate bodies are restricted in that they may not use entities that in any way
depend on other module signature members or parameters of the module signature or any
existing enclosing modules.

For example:

.. code-block:: ql

    signature module MSig {
      class T;
      predicate restriction(T t);
      default string descr(T t) { result = "default" }
    }

    module Module implements MSig {
      newtype T = A() or B();

      predicate restriction(T t) { t = A() }
    }

.. _parameterized-module-signatures:

Parameterized module signatures
-------------------------------

Module signatures can themselves be parameterized in exactly the same way as parameterized modules.
This is particularly useful in combination with the dependent typing of module parameters.

For example:

.. code-block:: ql

    signature class NodeSig;

    signature module EdgeSig<NodeSig Node> {
      predicate apply(Node src, Node dst);
    }

    module Reachability<NodeSig Node, EdgeSig<Node> Edge> {
      Node reachableFrom(Node src) {
        Edge::apply+(src, result)
      }
    }



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-language-reference/types.rst
:tocdepth: 1

.. index:: type

.. _types:

Types
#####

QL is a statically typed language, so each variable must have a declared type.

A type is a set of values.
For example, the type ``int`` is the set of integers. 
Note that a value can belong to more than one of these sets, which means that it can have more 
than one type.

The kinds of types in QL are :ref:`primitive types <primitive-types>`, :ref:`classes <classes>`,
:ref:`character types <character-types>`, :ref:`class domain types <domain-types>`, 
:ref:`algebraic datatypes <algebraic-datatypes>`, :ref:`type unions <type-unions>`,
and :ref:`database types <database-types>`.

.. index:: boolean, float, int, string, date
.. _primitive-types:

Primitive types
***************

These types are built in to QL and are always available in the global :ref:`namespace <namespaces>`,
independent of the database that you are querying.

   .. _boolean:

#. **boolean**: This type contains the values ``true`` and ``false``.
    
   .. _float:

#. **float**: This type contains 64-bit floating point numbers, such as ``6.28`` and ``-0.618``.
    
   .. _int:

#. **int**: This type contains 32-bit `two's complement <https://en.wikipedia.org/wiki/Two%27s_complement>`_ integers, such as ``-1`` and ``42``.
    
   .. _string:

#. **string**: This type contains finite strings of 16-bit characters.
    
   .. _date:

#. **date**: This type contains dates (and optionally times). 
    

QL has a range of built-in operations defined on primitive types. These are available by using dispatch on expressions of the appropriate type. For example, ``1.toString()`` is the string representation of the integer constant ``1``. For a full list of built-in operations available in QL, see the
section on `built-ins <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins>`__ in the QL language specification.

.. index:: class
.. _classes:

Classes
*******

You can define your own types in QL. One way to do this is to define a **class**.

Classes provide an easy way to reuse and structure code. For example, you can:
  - Group together related values.
  - Define :ref:`member predicates <member-predicates>` on those values.
  - Define subclasses that :ref:`override member predicates <overriding-member-predicates>`.

A class in QL doesn't "create" a new object, it just represents a logical property. A value is 
in a particular class if it satisfies that logical property.

.. _defining-a-class:

Defining a class
================

To define a class, you write:

#. The keyword ``class``. 
#. The name of the class. This is an `identifier <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_ 
   starting with an uppercase letter.
#. The supertypes that the class is derived from via `extends` and/or `instanceof`
#. The :ref:`body of the class <class-bodies>`, enclosed in braces.

For example:

.. code-block:: ql

    class OneTwoThree extends int {
      OneTwoThree() { // characteristic predicate
        this = 1 or this = 2 or this = 3
      }
 
      string getAString() { // member predicate
        result = "One, two or three: " + this.toString()
      }
    
      predicate isEven() { // member predicate
        this = 2
      }
    }

This defines a class ``OneTwoThree``, which contains the values ``1``, ``2``, and ``3``. The
:ref:`characteristic predicate <characteristic-predicates>` captures the logical property of
"being one of the integers 1, 2, or 3." 

.. index:: extends

``OneTwoThree`` extends ``int``, that is, it is a subtype of ``int``. A class in QL must always
have at least one supertype. Supertypes that are referenced with the `extends` keyword are called
the **base types** of the class. The values of a class are contained within the intersection of
the supertypes (that is, they are in the :ref:`class domain type <domain-types>`).
A class inherits all member predicates from its base types.

A class can extend multiple types. For more information, see ":ref:`multiple-inheritance`."
A class can extend final types (or final aliases of types), see ":ref:`final-extensions`."
Classes can also specialise other types without extending the class interface via `instanceof`,
see ":ref:`instanceof-extensions`.".

To be valid, a class:
  - Must not extend itself.
  - Must not (transitively) extend a non-final type and a final alias of that same type.
  - Must not extend types that are incompatible. For more information, see ":ref:`type-compatibility`."

You can also annotate a class. See the list of :ref:`annotations <annotations-overview>`
available for classes.

.. _class-bodies:

Class bodies
============

The body of a class can contain:
  -  A :ref:`characteristic predicate <characteristic-predicates>` declaration.
  -  Any number of :ref:`member predicate <member-predicates>` declarations.
  -  Any number of :ref:`field <fields>` declarations. 

When you define a class, that class also inherits all non-:ref:`private` member predicates and
fields from its supertypes.

Depending on whether they are final, you can :ref:`override <overriding-member-predicates>` or 
:ref:`shadow <final-extensions>` those predicates and fields to give them a more specific definition.

.. _characteristic-predicates:

Characteristic predicates
-------------------------

These are :ref:`predicates <predicates>` defined inside the body of a class. They are logical
properties that use the variable ``this`` to restrict the possible values in the class.

.. _member-predicates:

Member predicates
-----------------

These are :ref:`predicates <predicates>` that only apply to members of a particular class.
You can :ref:`call <calls>` a member predicate on a value. For example, you can use the member
predicate from the :ref:`above <defining-a-class>` class:

.. code-block:: ql

    1.(OneTwoThree).getAString()

This call returns the result ``"One, two or three: 1"``.

The expression ``(OneTwoThree)`` is a :ref:`cast <casts>`. It ensures that ``1`` has type
``OneTwoThree`` instead of just ``int``. Therefore, it has access to the member predicate
``getAString()``.

Member predicates are especially useful because you can chain them together. For example, you
can use ``toUpperCase()``, a built-in function defined for ``string``:

.. code-block:: ql

    1.(OneTwoThree).getAString().toUpperCase()

This call returns ``"ONE, TWO OR THREE: 1"``.

.. index:: this
.. _this:

.. pull-quote:: Note

    Characteristic predicates and member predicates often use the variable ``this``. 
    This variable always refers to a member of the class—in this case a value belonging to the 
    class ``OneTwoThree``.
    In the :ref:`characteristic predicate <characteristic-predicates>`, the variable ``this`` 
    constrains the values that are in the class.
    In a :ref:`member predicate <member-predicates>`, ``this`` acts in the same way as any 
    other argument to the predicate.

.. index:: field
.. _fields: 

Fields
------

These are variables declared in the body of a class. A class can have any number of field
declarations (that is, variable declarations) within its body. You can use these variables in 
predicate declarations inside the class. Much like the :ref:`variable <this>` ``this``, fields
must be constrained in the :ref:`characteristic predicate <characteristic-predicates>`.

For example:

.. code-block:: ql

    class SmallInt extends int {
      SmallInt() { this = [1 .. 10] }
    }
    
    class DivisibleInt extends SmallInt {
      SmallInt divisor;   // declaration of the field `divisor`
      DivisibleInt() { this % divisor = 0 }
    	
      SmallInt getADivisor() { result = divisor }
    }
    
    from DivisibleInt i
    select i, i.getADivisor()

In this example, the declaration ``SmallInt divisor`` introduces a field ``divisor``, constrains
it in the characteristic predicate, and then uses it in the declaration of the member predicate
``getADivisor``. This is similar to introducing variables in a :ref:`select clause <select-clauses>`
by declaring them in the ``from`` part. 

You can also annotate predicates and fields. See the list of :ref:`annotations <annotations-overview>`
that are available.

.. _concrete-classes:

Concrete classes
================

The classes in the above examples are all **concrete** classes. They are defined by 
restricting the values in a larger type. The values in a concrete class are precisely those
values in the intersection of the supertypes that also satisfy the
:ref:`characteristic predicate <characteristic-predicates>` of the class.

.. _abstract-classes:

Abstract classes
================

A class :ref:`annotated <abstract>` with ``abstract``, known as an **abstract** class, is also a restriction of 
the values in a larger type. However, an abstract class is defined as the union of its 
subclasses. In particular, for a value to be in an abstract class, it must satisfy the 
characteristic predicate of the class itself **and** the characteristic predicate of a subclass.
Note that final extensions are not considered subclasses in this context.

An abstract class is useful if you want to group multiple existing classes together 
under a common name. You can then define member predicates on all those classes. You can also 
extend predefined abstract classes: for example, if you import a library that contains an 
abstract class, you can add more subclasses to it.

**Example**

If you are writing a security query, you may be interested in identifying 
all expressions that can be interpreted as SQL queries. 
You can use the following abstract class to describe these expressions:

.. code-block:: ql

    abstract class SqlExpr extends Expr {
      ... 
    }

Now define various subclasses—one for each kind of database management system. For example, you
can define a subclass ``class PostgresSqlExpr extends SqlExpr``, which contains expressions 
passed to some Postgres API that performs a database query. 
You can define similar subclasses for MySQL and other database management systems.

The abstract class ``SqlExpr`` refers to all of those different expressions. If you want to add
support for another database system later on, you can simply add a new subclass to ``SqlExpr``;
there is no need to update the queries that rely on it.

.. pull-quote:: Important


   You must take care when you add a new subclass to an existing abstract class. Adding a subclass
   is not an isolated change, it also extends the abstract class since that is a union of its
   subclasses. 

.. _overriding-member-predicates:

Overriding member predicates
============================

If a class inherits a member predicate from a non-final supertype, you can **override** the
inherited definition. You do this by defining a member predicate with the same name and arity
as the inherited predicate, and by adding the ``override`` :ref:`annotation <override>`.
This is useful if you want to refine the predicate to give a more specific result for the 
values in the subclass.

For example, extending the class from the :ref:`first example <defining-a-class>`:

.. code-block:: ql

    class OneTwo extends OneTwoThree {
      OneTwo() {
        this = 1 or this = 2
      }
    
      override string getAString() {
        result = "One or two: " + this.toString()
      }
    }

The member predicate ``getAString()`` overrides the original definition of ``getAString()``
from ``OneTwoThree``.

Now, consider the following query:

.. code-block:: ql

    from OneTwoThree o
    select o, o.getAString()

The query uses the "most specific" definition(s) of the predicate ``getAString()``, so the results
look like this:

+---+-------------------------+
| o | ``getAString()`` result |
+===+=========================+
| 1 | One or two: 1           |
+---+-------------------------+
| 2 | One or two: 2           |
+---+-------------------------+
| 3 | One, two or three: 3    |
+---+-------------------------+

In QL, unlike other object-oriented languages, different subtypes of the same types don't need to be 
disjoint. For example, you could define another subclass of ``OneTwoThree``, which overlaps
with ``OneTwo``:

.. code-block:: ql

    class TwoThree extends OneTwoThree {
      TwoThree() {
        this = 2 or this = 3
      }
    
      override string getAString() {
        result = "Two or three: " + this.toString()
      }
    }

Now the value 2 is included in both class types ``OneTwo`` and ``TwoThree``. Both of these classes 
override the original definition of ``getAString()``. There are two new "most specific" definitions, 
so running the above query gives the following results:

+---+-------------------------+
| o | ``getAString()`` result |
+===+=========================+
| 1 | One or two: 1           |
+---+-------------------------+
| 2 | One or two: 2           |
+---+-------------------------+
| 2 | Two or three: 2         |
+---+-------------------------+
| 3 | Two or three: 3         |
+---+-------------------------+

.. _multiple-inheritance:

Multiple inheritance
====================

A class can extend multiple types. In that case, it inherits from all those types.

For example, using the definitions from the above section:

.. code-block:: ql

    class Two extends OneTwo, TwoThree {}

Any value in the class ``Two`` must satisfy the logical property represented by ``OneTwo``, 
**and** the logical property represented by ``TwoThree``. Here the class ``Two`` contains one
value, namely 2.

It inherits member predicates from ``OneTwo`` and ``TwoThree``. It also (indirectly) inherits
from ``OneTwoThree`` and ``int``.

.. pull-quote:: Note

   If a subclass inherits multiple definitions for the same predicate name, then it
   must :ref:`override <overriding-member-predicates>` those definitions to avoid ambiguity.
   :ref:`Super expressions <super>` are often useful in this situation.

.. _final-extensions:

Final extensions
================

A class can extend final types or final aliases of types. In that case, it inherits final
versions of all the member predicates and fields of those supertypes.
Member predicates that are inherited through final extensions cannot be overridden,
but they can be shadowed.

For example, extending the class from the :ref:`first example <defining-a-class>`:

.. code-block:: ql

    final class FinalOneTwoThree = OneTwoThree;
    
    class OneTwoFinalExtension extends FinalOneTwoThree {
      OneTwoFinalExtension() {
        this = 1 or this = 2
      }
    
      string getAString() {
        result = "One or two: " + this.toString()
      }
    }

The member predicate ``getAString()`` shadows the original definition of ``getAString()``
from ``OneTwoThree``.

Different to overriding (see ":ref:`overriding-member-predicates`"),
final extensions leave the extended type unchanged:

.. code-block:: ql

    from OneTwoTree o
    select o, o.getAString()

+---+-------------------------+
| o | ``getAString()`` result |
+===+=========================+
| 1 | One, two or three: 1    |
+---+-------------------------+
| 2 | One, two or three: 2    |
+---+-------------------------+
| 3 | One, two or three: 3    |
+---+-------------------------+

However, when calling ``getAString()`` on ``OneTwoFinalExtension``, the original definition is shadowed:

.. code-block:: ql

    from OneTwoFinalExtension o
    select o, o.getAString()

+---+-------------------------+
| o | ``getAString()`` result |
+===+=========================+
| 1 | One or two: 1           |
+---+-------------------------+
| 2 | One or two: 2           |
+---+-------------------------+

.. _instanceof-extensions:

Non-extending subtypes
======================

Besides extending base types, classes can also declare ``instanceof`` relationships with other types.
Declaring a class as ``instanceof Foo`` is roughly equivalent to saying ``this instanceof Foo`` in the characteristic predicate.
The main differences are that you can call methods on ``Bar`` via ``super`` and you can get better optimisation.

.. code-block:: ql

    class Foo extends int {
      Foo() { this in [1 .. 10] }

      string fooMethod() { result = "foo" }
    }

    class Bar instanceof Foo {
      string toString() { result = super.fooMethod() }
    }

In this example, the characteristic predicate from ``Foo`` also applies to ``Bar``.
However, ``fooMethod`` is not exposed in ``Bar``, so the query ``select any(Bar b).fooMethod()``
results in a compile time error. Note from the example that it is still possible to access
methods from instanceof supertypes from within the specialising class with the ``super`` keyword.

Crucially, the instanceof **supertypes** are not **base types**.
This means that these supertypes do not participate in overriding, and any fields of such
supertypes are not part of the new class.
This has implications on method resolution when complex class hierarchies are involved.
The following example demonstrates this.

.. code-block:: ql

    class Interface extends int {
      Interface() { this in [1 .. 10] }
      string foo() { result = "" }
   }

    class Foo extends int {
      Foo() { this in [1 .. 5] }
      string foo() { result = "foo" }
    }

    class Bar extends Interface instanceof Foo {
      override string foo() { result = "bar" }
    }

Here, the method ``Bar::foo`` does not override ``Foo::foo``.
Instead, it overrides only ``Interface::foo``.
This means that ``select any(Foo f).foo()`` yields ``foo``.
Had ``Bar`` been defined as ``extends Foo``, then ``select any(Foo f).foo()`` would yield ``bar``.

.. _character-types:
.. _domain-types:

Character types and class domain types
**************************************

You can't refer to these types directly, but each class in QL implicitly defines a character 
type and a class domain type. (These are rather more subtle concepts and don't appear very 
often in practical query writing.)

The **character type** of a QL class is the set of values satisfying the :ref:`characteristic 
predicate <characteristic-predicates>` of the class. 
It is a subset of the domain type. For concrete classes, a value belongs to 
the class if, and only if, it is in the character type. For :ref:`abstract classes 
<abstract-classes>`, a value must also belong to at least one of the subclasses, in addition to
being in the character type. 

The **domain type** of a QL class is the intersection of the character types of all its supertypes, that is, a value
belongs to the domain type if it belongs to every supertype. It occurs as the type of ``this`` 
in the characteristic predicate of a class.

.. index:: newtype
.. _algebraic-datatypes:

Algebraic datatypes
*******************

.. pull-quote:: Note

   The syntax for algebraic datatypes is considered experimental and is subject to
   change. However, they appear in the `standard QL libraries <https://github.com/github/codeql>`_
   so the following sections should help you understand those examples.

An algebraic datatype is another form of user-defined type, declared with the keyword ``newtype``.

Algebraic datatypes are used for creating new values that are neither primitive values nor entities from
the database. One example is to model flow nodes when analyzing data flow through a program.

An algebraic datatype consists of a number of mutually disjoint *branches*, that each define
a branch type. The algebraic datatype itself is the union of all the branch types.
A branch can have arguments and a body. A new value of the branch type is produced for each set
of values that satisfy the argument types and the body.

A benefit of this is that each branch can have a different structure. For example, if you want
to define an "option type" that either holds a value (such as a ``Call``) or is empty, you
could write this as follows:

.. code-block:: ql

    newtype OptionCall = SomeCall(Call c) or NoCall()

This means that for every ``Call`` in the program, a distinct ``SomeCall`` value is produced.
It also means that a unique ``NoCall`` value is produced.

Defining an algebraic datatype
==============================

To define an algebraic datatype, use the following general syntax:

.. code-block:: ql

    newtype <TypeName> = <branches>

The branch definitions have the following form:

.. code-block:: ql

    <BranchName>(<arguments>) { <body> }

- The type name and the branch names must be `identifiers <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#identifiers>`_ 
  starting with an uppercase letter. Conventionally, they start with ``T``.
- The different branches of an algebraic datatype are separated by ``or``.
- The arguments to a branch, if any, are :ref:`variable declarations <variable-declarations>`
  separated by commas.
- The body of a branch is a :ref:`predicate <predicates>` body. You can omit the branch body, in which case
  it defaults to ``any()``. 
  Note that branch bodies are evaluated fully, so they must be finite. They should be kept small
  for good performance.

For example, the following algebraic datatype has three branches:

.. code-block:: ql

    newtype T =
      Type1(A a, B b) { body(a, b) }
      or 
      Type2(C c)
      or 
      Type3()

Standard pattern for using algebraic datatypes
==============================================

Algebraic datatypes are different from :ref:`classes <classes>`. In particular, algebraic datatypes don't have a 
``toString()`` member predicate, so you can't use them in a :ref:`select clause <select-clauses>`.

Classes are often used to extend algebraic datatypes (and to provide a ``toString()`` predicate). 
In the standard QL language libraries, this is usually done as follows:

- Define a class ``A`` that extends the algebraic datatype and optionally declares :ref:`abstract`
  predicates.
- For each branch type, define a class ``B`` that extends both ``A`` and the branch type, 
  and provide a definition for any abstract predicates from ``A``.
- Annotate the algebraic datatype with :ref:`private`, and leave the classes public.

For example, the following code snippet from the CodeQL data-flow library for C# defines classes
for dealing with tainted or untainted values. In this case, it doesn't make sense for 
``TaintType`` to extend a database type. It is part of the taint analysis, not the underlying
program, so it's helpful to extend a new type (namely ``TTaintType``):

.. code-block:: ql

    private newtype TTaintType =
      TExactValue()
      or
      TTaintedValue()
    
    /** Describes how data is tainted. */
    class TaintType extends TTaintType {
      string toString() {
        this = TExactValue() and result = "exact"
        or 
        this = TTaintedValue() and result = "tainted"
      }
    }
    
    /** A taint type where the data is untainted. */
    class Untainted extends TaintType, TExactValue {
    }
    
    /** A taint type where the data is tainted. */
    class Tainted extends TaintType, TTaintedValue {
    }
    
.. _type-unions:

Type unions
***********

Type unions are user-defined types that are declared with the keyword ``class``.
The syntax resembles :ref:`type aliases <type-aliases>`, but with two or more type expressions on the right-hand side.

Type unions are used for creating restricted subsets of an existing :ref:`algebraic datatype <algebraic-datatypes>`, by explicitly
selecting a subset of the branches of that datatype and binding them to a new type.
Type unions of :ref:`database types <database-types>` are also supported.

You can use a type union to give a name to a subset of the branches from an algebraic datatype.
In some cases, using the type union over the whole algebraic datatype can avoid spurious
:ref:`recursion <recursion>` in predicates.
For example, the following construction is legal:

.. code-block:: ql

    newtype InitialValueSource =
      ExplicitInitialization(VarDecl v) { exists(v.getInitializer()) } or
      ParameterPassing(Call c, int pos) { exists(c.getParameter(pos)) } or
      UnknownInitialGarbage(VarDecl v) { not exists(DefiniteInitialization di | v = target(di)) }

    class DefiniteInitialization = ParameterPassing or ExplicitInitialization;

    VarDecl target(DefiniteInitialization di) {
      di = ExplicitInitialization(result) or
      exists(Call c, int pos | di = ParameterPassing(c, pos) and
                                result = c.getCallee().getFormalArg(pos))
    }

However, a similar implementation that restricts ``InitialValueSource`` in a class extension is not valid.
If we had implemented ``DefiniteInitialization`` as a class extension instead, it would trigger a type test for ``InitialValueSource``. This results in an illegal recursion ``DefiniteInitialization -> InitialValueSource -> UnknownInitialGarbage -> ¬DefiniteInitialization`` since ``UnknownInitialGarbage`` relies on ``DefiniteInitialization``:

.. code-block:: ql

    // THIS WON'T WORK: The implicit type check for InitialValueSource involves an illegal recursion 
    // DefiniteInitialization -> InitialValueSource -> UnknownInitialGarbage -> ¬DefiniteInitialization!
    class DefiniteInitialization extends InitialValueSource {
      DefiniteInitialization() {
        this instanceof ParameterPassing or this instanceof ExplicitInitialization
      }
      // ...
    }

Type unions are supported from release 2.2.0 of the CodeQL CLI.

.. _database-types:

Database types
**************

Database types are defined in the database schema. This means that they depend on the database
that you are querying, and vary according to the data you are analyzing.

For example, if you are querying a CodeQL database for a Java project, the database types may
include ``@ifstmt``, representing an if statement in the Java code, and ``@variable``, 
representing a variable.

.. _type-compatibility:

Type compatibility
******************

Not all types are compatible. For example, ``4 < "five"`` doesn't make sense, since you can't
compare an ``int`` to a ``string``.

To decide when types are compatible, there are a number of different "type universes" in QL.

The universes in QL are:
    - One for each primitive type (except ``int`` and ``float``, which are in the same universe
      of "numbers").
    - One for each database type.
    - One for each branch of an algebraic datatype.

For example, when defining a :ref:`class <classes>` this leads to the following restrictions:
    - A class can't extend multiple primitive types.
    - A class can't extend multiple different database types.
    - A class can't extend multiple different branches of an algebraic datatype.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/index.rst
CodeQL query help
-----------------

View the query help for the queries included in the ``default``, ``security-extended``, and ``security-and-quality`` query suites for the languages supported by CodeQL.

- :doc:`CodeQL query help for C and C++ <cpp>`
- :doc:`CodeQL query help for C# <csharp>`
- :doc:`CodeQL query help for Go <go>`
- :doc:`CodeQL query help for Java and Kotlin <java>`
- :doc:`CodeQL query help for JavaScript and TypeScript <javascript>`
- :doc:`CodeQL query help for Python <python>`
- :doc:`CodeQL query help for Ruby <ruby>`
- :doc:`CodeQL query help for Swift <swift>`

.. pull-quote:: Information

   Each query help article includes:

   - A summary of key metadata for the query.
   - Information about which query suites the query is included in.
   - A link to the query in the `CodeQL repository <https://github.com/github/codeql>`__.
   - A description of the potential vulnerability that the query identifies and a recommendation for how to avoid introducing the problem to your code.


For a full list of the CWEs covered by these queries, see ":doc:`CodeQL CWE coverage <codeql-cwe-coverage>`."

.. toctree::
   :hidden:
   :titlesonly:

   cpp
   csharp
   go
   java
   javascript
   python
   ruby
   swift
   codeql-cwe-coverage



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/python.rst
CodeQL query help for Python
============================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/python-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/examples>`__.

.. include:: toc-python.rst


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/ruby.rst
CodeQL query help for Ruby
============================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/ruby-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/examples>`__.

.. include:: toc-ruby.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/cpp.rst
CodeQL query help for C and C++
===============================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/cpp-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/examples>`__.

.. include:: toc-cpp.rst
   


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/cpp-cwe.md
# CWE coverage for C and C++

An overview of CWE coverage for C and C++ in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/ruby-cwe.md
# CWE coverage for Ruby

An overview of CWE coverage for Ruby in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/java-cwe.md
# CWE coverage for Java and Kotlin

An overview of CWE coverage for Java in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/codeql-cwe-coverage.rst
CodeQL CWE coverage
===================

You can view the full coverage of MITRE's Common Weakness Enumeration (CWE) or coverage by language for the latest release of CodeQL.

About CWEs
##########

The CWE categorization contains several types of entity, collectively known as CWEs. The CWEs that we consider in this report are only those of the types:

- Weakness Class
- Weakness Base
- Weakness Variant
- Compound Element

Other types of CWE that do not correspond directly to weaknesses are omitted.

The CWE categorization includes relationships between entities, in particular a parent-child relationship.
These relationships are associated with Views (another kind of CWE entity). For the purposes of coverage claims, we use the "`Research View <https://cwe.mitre.org/data/definitions/1000.html>`_."

Every security query is associated with one or more CWEs, which are the most precise CWEs that are covered by that query.
Overall coverage is claimed for the most-precise CWEs, as well as for any of their ancestors in the View.

Note that the CWE coverage includes both "`supported queries <https://github.com/github/codeql/blob/main/docs/supported-queries.md>`_" and "`experimental queries <https://github.com/github/codeql/blob/main/docs/experimental.md>`_."

.. toctree::
   :titlesonly:

   full-cwe
   cpp-cwe
   csharp-cwe
   go-cwe
   java-cwe
   javascript-cwe
   python-cwe
   ruby-cwe
   swift-cwe




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/javascript.rst
CodeQL query help for JavaScript and TypeScript
===============================================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/javascript-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/examples>`__.

.. include:: toc-javascript.rst


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/full-cwe.md
# CodeQL full CWE coverage

An overview of the full coverage of MITRE's Common Weakness Enumeration (CWE) for the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/java.rst
CodeQL query help for Java and Kotlin
=====================================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/java-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/examples>`__.

.. include:: toc-java.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/readme.md
CodeQL query help Sphinx documentation
--------------------------------------

This project supplies the configuration and some boiler plate
index files for the CodeQL query help and CWE coverage documentation.

The query help itself is automatically generated by the 
"Generate CodeQL query help documentation using Sphinx" workflow.

The CWE coverage tables are generated and appended to pages by the "Docs generate query help" workflow in the `semmle-code` repository.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/go-cwe.md
# CWE coverage for Go

An overview of CWE coverage for Go in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/swift.rst
CodeQL query help for Swift
===========================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/swift-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/examples>`__.

.. include:: toc-swift.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/csharp.rst
CodeQL query help for C#
========================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/csharp-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/examples>`__.

.. include:: toc-csharp.rst


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/go.rst
CodeQL query help for Go
========================

.. include:: ../reusables/query-help-overview.rst

These queries are published in the CodeQL query pack ``codeql/go-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/src>`__).

For shorter queries that you can use as building blocks when writing your own queries, see the `example queries in the CodeQL repository <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/examples>`__.

.. include:: toc-go.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/csharp-cwe.md
# CWE coverage for C#

An overview of CWE coverage for C# in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/swift-cwe.md
# CWE coverage for Swift

An overview of CWE coverage for Swift in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/javascript-cwe.md
# CWE coverage for JavaScript and TypeScript

An overview of CWE coverage for JavaScript and TypeScript in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/query-help/python-cwe.md
# CWE coverage for Python

An overview of CWE coverage for Python in the latest release of CodeQL.

## Overview

<!-- autogenerated CWE coverage table will be added below -->




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/index.rst
CodeQL training and variant analysis examples
=============================================

.. toctree::
   :glob:
   :maxdepth: 1
   :hidden:

   *
   */**


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/template.rst
.. Template for rst slide shows


.. Key points: 
   - Each heading marks the start of a new slide
   - The default slide style is a plain white-ish background with minimal company branding
   - Different slide designs have been preconfigured. To choose a different layout
     use the appropriate .. rst-class:: directive. For examples of the different designs, 
     see the template below. This directive can also be used to create custom classes for individual 
     images and slide backgrounds if necessary. Additional CSS styles may also be required when using custom 
     class directives. Search for 'deck-specific styles for individual images` in default.css for examples
     of how to implement custom class styles.
   - Additional notes can be added to a slide using a .. note:: directive
   - Press P to access the additional notes on the rendered slides.
   - Press F is go into full screen mode when viewing the rendered slides.


.. Title slide. Includes the deck title, subtitles, and the company logo

===================
Template slide deck
===================

.. container:: subheading

   First subheading
   
   Second subheading

.. Set up slide. Include link to CodeQL databases required for examples 

.. rst-class:: setup

Setup
=====

For this example you should download:

- `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__
- A CodeQL database

.. note::

   Some notes about the project.

.. Agenda slide. Explaining what is to be covered in the presentation

.. rst-class:: Agenda

Agenda
======

- Item 1
- Item 2
- Item 3
- Item 4
- Item 5


Text
====

If you don't specify an rst-class, you default to the 'basic' slide design.

You can fit about this much text on a slide:

Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor 
incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis 
nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. 
Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore 
eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, 
sunt in culpa qui officia deserunt mollit anim id est laborum.

Code sample
===========

Use a ``.. code-block::`` directive to include a code snippet. 
Specify the language after the directive to add syntax highlighting.

.. code-block:: ql

   import cpp
   
   from AddExpr a, Variable v, RelationalOperation cmp
   where
     a.getAnOperand() = v.getAnAccess() and
     cmp.getAnOperand() = a and
     cmp.getAnOperand() = v.getAnAccess()
   select cmp, "Overflow check."

Columns and graphs
==================

.. container:: column-left

   ``.. container:: column-left`` sets up a column on the left of the slide.

   ``.. container:: column-right`` sets up a column on the right of the slide.

   Code can be included in columns:

   .. code-block:: ql

      import cpp  
   
      from IfStmt ifstmt, Block block
      where
        block = ifstmt.getThen() and
        block.isEmpty()
      select ifstmt, "This if-statement is redundant."


.. container:: column-right

   Graphs can be built from text using a ``.. graphviz directive``.
   See the source file for details.   

   .. graphviz::
       
      digraph {
      graph [ dpi = 1000 ]
      node [shape=polygon,sides=4,color=blue4,style="filled,rounded",   fontname=consolas,fontcolor=white]
      a [label=<tainted<BR /><FONT POINT-SIZE="10">ParameterNode</FONT>>]
      b [label=<tainted<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]
      c [label=<x<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]
      d [label=<x<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]   
      a -> b
      b -> {c, d}   
      }

.. You can indicate a new concept by using a purple slide background

.. rst-class:: background2

Purple background
=================

Subheading on purple slide

Including snippets
==================

rst snippets can be included using:

.. code-block:: none

   .. include:: path/to/file.rst

Code snippets can be included using:

.. code-block:: none

   .. literalinclude:: path/to/file.ql
      :language: ql
      :emphasize-lines: 3-6

Specify the language to apply syntax highlighting and the lines of the fragment that you want to emphasize.

Further details
===============

- For more information on writing in reStructuredText, see https://docutils.sourceforge.io/rst.html.

- For more information on Sphinx, see https://www.sphinx-doc.org.

- For more information about hieroglpyh, the Sphinx extension used to generate these slides, see https://github.com/nyergler/hieroglyph.

- For more information about creating graphs, see https://build-me-the-docs-please.readthedocs.io/en/latest/Using_Sphinx/UsingGraphicsAndDiagramsInSphinx.html.


.. The final slide with the company details is generated automatically.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/java/data-flow-java.rst
=========================
Introduction to data flow
=========================

Finding SPARQL injection vulnerabilities in Java

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `VIVO Vitro <https://github.com/vivo-project/Vitro>`__ from GitHub.

.. rst-class:: agenda

Agenda
======

- SPARQL injection
- Data flow
- Modules and libraries
- Local data flow
- Local taint tracking

Motivation
==========

`SPARQL <https://en.wikipedia.org/wiki/SPARQL>`__ is a language for querying key-value databases in RDF format, which can suffer from SQL injection-like vulnerabilities:

.. code-block:: none

  sparqlAskQuery("ASK { <" + individualURI + "> ?p ?o }")

``individualURI`` is provided by a user, allowing an attacker to prematurely close the ``>``, and provide additional content.

**Goal**: Find query strings that are created by concatenation.

.. note::

  If you have completed the “Example: Query injection” slide deck which was part of the previous course, this example will look familiar to you.

  To understand the scope of this vulnerability, consider what would happen if a malicious user could provide the following as the content of the ``individualURI`` variable:

  ``“http://vivoweb.org/ontology/core#FacultyMember> ?p ?o . FILTER regex("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!", "(.*a){50}") } #``


Example: SPARQL injection
=========================

We can write a simple query that finds string concatenations that occur in calls to SPARQL query APIs.

.. rst-class:: build

.. literalinclude:: ../query-examples/java/data-flow-java-1.ql
   :language: ql

.. note::

  This is similar, but not identical, to the formulation we had in the previous training deck. It has been rewritten to make it easier for the next step.

Success! But also missing results...
====================================

Query finds a CVE reported by Semmle (CVE-2019-6986), plus one other result, but misses other opportunities where:

  - String concatenation occurs on a different line in the same method.
  - String concatenation occurs in a different method.
  - String concatenation occurs through ``StringBuilders`` or similar.
  - Entirety of user input is provided as the query.

We want to improve our query to catch more of these cases.

.. note::

   For more details of the CVE, see: https://github.com/Semmle/SecurityExploits/tree/master/vivo-project/CVE-2019-6986

   As an example, consider this SPARQL query call:
   
   .. code-block:: none
   
      String queryString = "ASK { <" + individualURI + "> ?p ?o }";
       sparqlAskQuery(queryString);
   
   Here the concatenation occurs before the call, so the existing query would miss this - the string concatenation does not occur *directly* as the first argument of the call.

.. include general data flow slides

.. include:: ../slide-snippets/local-data-flow.rst

.. resume language-specific slides

Exercise: revisiting SPARQL injection
=====================================

Refine the query to find string concatenation that occurs in the same method, but a different line.

**Hint**: Use ``DataFlow::localFlow`` to assert that the result flows to the SPARQL call argument, using ``DataFlow::exprNode`` to get the data flow nodes for the relevant expression nodes.

.. rst-class:: build

.. literalinclude:: ../query-examples/java/data-flow-java-2.ql
  :language: ql

Refinements (take home exercise)
================================

In Java, strings are often created using ``StringBuilder`` and ``StringBuffer`` classes. For example:

    .. code-block:: java
    
       StringBuilder queryBuilder = new StringBuilder();
       queryBuilder.add("ASK { <");
       queryBuilder.add(individualURI);
       queryBuilder.add("> ?p ?o }");
       sparqlAskQuery(queryBuilder);

**Exercise**: Refine the query to consider strings created from ``StringBuilder`` and ``StringBuffer`` classes as sources of concatenation.

Beyond local data flow
======================

- We are still missing possible results.

  - Concatenation that occurs outside the enclosing method.

- Instead, let’s turn the problem around and find user-controlled data that flows into a ``printf`` format argument, potentially through calls.
- This needs :doc:`global data flow <global-data-flow-java>`.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/java/program-representation-java.rst
======================
Program representation
======================

CodeQL for Java

.. rst-class:: agenda

Agenda
======

- Abstract syntax trees
- Database representation
- Program elements
- AST CodeQL classes

.. insert abstract-syntax-tree.rst

.. include:: ../slide-snippets/abstract-syntax-tree.rst

.. resume slides

Program elements
================

- The CodeQL class ``Element`` represents program elements with a name.
- This includes: packages (``Package``), compilation units (``CompilationUnit``), types (``Type``), methods (``Method``), constructors (``Constructor``), and variables (``Variable``).
- It is often convenient to refer to an element that might either be a method or a constructor; the class ``Callable``, which is a common superclass of ``Method`` and ``Constructor``, can be used for this purpose.


AST
===

There are two primary AST CodeQL classes, used within ``Callables``:

   - ``Expr``: expressions such as assignments, variable references, function calls, ...
   - ``Stmt``: statements such as conditionals, loops, try statements, ... 

Operations are provided for exploring the AST:

   - ``Expr.getAChildExpr`` returns a sub-expression of a given expression.
   - ``Stmt.getAChild`` returns a statement or expression that is nested directly inside a given statement.
   - ``Expr.getParent`` and ``Stmt.getParent`` return the parent node of an AST node.

Types
=====

The database also includes information about the types used in a program:

- ``PrimitiveType`` represents a `primitive type <https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html>`__, that is, one of ``boolean``, ``byte``, ``char``, ``double``, ``float``, ``int``, ``long``, ``short``. CodeQL also classifies ``void`` and ``<nulltype>`` (the type of the ``null`` literal) as primitive types.
- ``RefType`` represents a reference type; it has several subclasses:

  - ``Class`` represents a Java class.
  - ``Interface`` represents a Java interface.
  - ``EnumType`` represents a Java enum type.
  - ``Array`` represents a Java array type.

Working with variables
======================

``Variable`` represents program variables, including locally scoped variables (``LocalScopeVariable``), fields (``Fields``), and parameters (``Parameters``):

- ``string Variable.getName()``
- ``Type Variable.getType()``

``Access`` represents references to declared entities such as methods (``MethodAccess``) and variables (``VariableAccess``), including fields (``FieldAccess``).

- ``Declaration Access.getTarget()``

``VariableDeclarationEntry`` represents declarations or definitions of a variable.

- ``Variable VariableDeclarationEntry.getVariable()``

Working with callables
======================

Callables are represented by the ``Callable`` CodeQL class. 

Calls to callables are modeled by the CodeQL class ``Call`` and its subclasses:

- ``Call.getCallee()`` gets the declared target of the call
- ``Call.getAReference()`` gets a call to this function

Typically, callables are identified by name:

- ``string Callable.getName()``
- ``string Callable.getQualifiedName()``

.. rst-class:: java-expression-ast

Example: Java expression AST
============================

.. diagram copied from google slides


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/java/intro-ql-java.rst
================================
Introduction to variant analysis 
================================

CodeQL for Java

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `Apache Struts <https://github.com/apache/struts>`__ from GitHub.

.. Include language-agnostic section here

.. include:: ../slide-snippets/intro-ql-general.rst

Oops
====

.. code-block:: java
  :emphasize-lines: 3

  int write(int[] buf, int size, int loc, int val) {
      if (loc >= size) {
         // return -1;
      }

      buf[loc] = val;

      return 0;
  }

- The return statement has been commented out (during debugging?)
- The ``if`` statement is now dead code
- No explicit bounds checking, will throw ``ArrayIndexOutOfbounds``

.. note::

   Here’s a simple (artificial) bug, which we’ll develop a query to catch.

   This function writes a value to a given location in an array, first trying to do a bounds check to validate that the location is within bounds. However, the return statement has been commented out, leaving a redundant if statement and no bounds checking.

   This case can act as our “patient zero” in the variant analysis game.

A simple CodeQL query
=====================

.. literalinclude:: ../query-examples/java/empty-if-java.ql
   :language: ql

.. note::

   We are going to write a simple query which finds “if statements” with empty “then” blocks, so we can highlight the results like those on the previous slide.

   A `query <https://codeql.github.com/docs/ql-language-reference/queries/>`__ consists of a “select” clause that indicates what results should be returned. Typically it will also provide a “from” clause to declare some variables, and a “where” clause to state conditions over those variables. For more information on the structure of query files (including links to useful topics in the `QL language reference <https://codeql.github.com/docs/ql-language-reference/>`__), see `About CodeQL queries <https://codeql.github.com/docs/writing-codeql-queries/about-codeql-queries/>`__.

   In our example here, the first line of the query imports the `CodeQL library for Java <https://codeql.github.com/codeql-standard-libraries/java/>`__, which defines concepts like ``IfStmt`` and ``Block``.
   The query proper starts by declaring two variables–ifStmt and block. These variables represent sets of values in the database, according to the type of each of the variables. For example, ``ifStmt`` has the type ``IfStmt``, which means it represents the set of all if statements in the program.

   If we simply selected these two variables::

     from IfStmt ifStmt, Block block
     select ifStmt, block

   We would get a result row for every combination of blocks and if statements in the program. This is known as a cross-product, because there is no logical condition linking the two variables. We can use the where clause to specify the condition that we are only interested in rows where the “block” is the “then” part of the if statement. We do this by specifying::

     block = ifStmt.getThen()

   This states that the block is equal to (not assigned!) the “then” part of the ``ifStmt``. ``getThen()`` is an operation which is available on any IfStmt. One way to interpret this is as a filtering operation – starting with every pair of block and if statements, check each one to whether the logical condition holds, and only keep the row if that is the case.
   We can add a second condition that specifies the block must be empty::

     and block.isEmpty()

   The ``isEmpty()`` operation is available on any Block, and is only true if the “block” has no children.

   Finally, we select a location, at which to report the problem, and a message, to explain what the problem is.


Structure of a query
=====================

A **query file** has the extension ``.ql`` and contains a **query clause**, and optionally **predicates**, **classes**, and **modules**.

A **query library** has the extension ``.qll`` and does not contain a query clause, but may contain modules, classes, and predicates.

Each query library also implicitly defines a module.

**Import** statements allow the classes and predicates defined in one module to be used in another.

.. note::

  Queries are always contained in query files with the file extension ``.ql``. 
  
  Parts of queries can be lifted into `library files <https://codeql.github.com/docs/ql-language-reference/modules/#library-modules>`__ with the extension ``.qll``. Definitions within such libraries can be brought into scope using “import” statements, and similarly QLL files can import each other’s definitions using “import” statements.

  Logic can be encapsulated as user-defined `predicates <https://codeql.github.com/docs/ql-language-reference/predicates/>`__ and `classes <https://codeql.github.com/docs/ql-language-reference/types/#classes>`__, and organized into `modules <https://codeql.github.com/docs/ql-language-reference/modules/>`__. Each QLL file implicitly defines a module, but QL and QLL files can also contain explicit module definitions, as we will see later.

Predicates
==========

A predicate allows you to pull out and name parts of a query.

.. container:: column-left

   .. literalinclude:: ../query-examples/java/empty-if-java.ql
      :language: ql
      :emphasize-lines: 6

.. container:: column-right

   .. literalinclude:: ../query-examples/java/empty-if-java-predicate.ql
      :language: ql
      :emphasize-lines: 3-5

.. note::

   A `predicate <https://codeql.github.com/docs/ql-language-reference/predicates/>`__ takes zero or more parameters, and its body is a condition on those parameters. The predicate may (or may not) hold. Predicates may also be `recursive <https://codeql.github.com/docs/ql-language-reference/predicates/#recursive-predicates>`__, simply by referring to themselves (directly or indirectly).

   You can imagine a predicate to be a self-contained from-where-select statement, that produces an intermediate relation, or table. In this case, the ``isEmpty`` predicate will be the set of all blocks which are empty.


Classes in QL
=============

A QL class allows you to name a set of values and define (member) predicates on them.

A class has at least one supertype and optionally a **characteristic predicate**; it contains the values that belong to *all* supertypes *and* satisfy the characteristic predicate, if provided.

Member predicates are inherited and can be overridden.

.. code-block:: ql

   class EmptyBlock extends Block {
     EmptyBlock() {
       this.getNumStmt() = 0
     }
   }

.. note::

  `Classes <https://codeql.github.com/docs/ql-language-reference/types/#classes>`__ model sets of values from the database. A class has one or more supertypes, and inherits `member predicates <https://codeql.github.com/docs/ql-language-reference/types/#member-predicates>`__ (methods) from each of them. Each value in a class must be in every supertype, but additional conditions can be stated in a so-called **characteristic predicate**, which looks a bit like a zero-argument constructor.

  In the example, declaring a variable “EmptyBlock e” will allow it to range over only those blocks that have zero statements.

Classes in QL continued
=======================

.. container:: column-left

   .. literalinclude:: ../query-examples/java/empty-if-java-predicate.ql
      :language: ql
      :emphasize-lines: 3-5

.. container:: column-right

   .. literalinclude:: ../query-examples/java/empty-if-java-class.ql
      :language: ql
      :emphasize-lines: 3-7

.. note::

   As shown in this example, classes behave much like unary predicates, but with ``instanceof`` instead of predicate calls to check membership. Later on, we will see how to define member predicates on classes.

Iterative query refinement
==========================

- **Common workflow**: Start with a simple query, inspect a few results, refine, repeat.

- For example, empty ``then`` branches are not a problem if there is an ``else``.

- **Exercise**: How can we refine the query to take this into account?

**Hints**:

- Use member predicate ``IfStmt.getElse()``
- Use ``not exists(...)``

.. note::

   CodeQL makes it very easy to experiment with analysis ideas. A common workflow is to start with a simple query (like our “redundant if-statement” example), examine a few results, refine the query based on any patterns that emerge and repeat.

   As an exercise, refine the redundant-if query based on the observation that if the if-statement has an “else” clause, then even if the body of the “then” clause is empty, it’s not actually redundant.

Model answer: redundant if-statement
====================================

.. literalinclude:: ../query-examples/java/empty-if-java-model.ql



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/java/apache-struts-java.rst
=======================
Exercise: Apache Struts
=======================

.. container:: subheading

   Unsafe deserialization leading to an RCE

   CVE-2017-9805

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `Apache Struts <https://github.com/apache/struts>`__ from GitHub.

Unsafe deserialization in Struts
================================

Apache Struts provides a ``ContentTypeHandler`` interface, which can be implemented for specific content types. It defines the following interface method:

.. code-block:: java

  void toObject(Reader in, Object target);


which is intended to populate the ``target`` object with data from the reader, usually through deserialization. However, the ``in`` parameter should be considered untrusted, and should not be deserialized without sanitization.

RCE in Apache Struts
====================

- Vulnerable code looked like this:

   .. code-block:: java
   
      public void toObject(Reader in, Object target) {
        XStream xstream = createXStream();
        xstream.fromXML(in, target);
      }

- Xstream allows deserialization of **dynamic proxies**, which permit remote code execution.

- Disclosed as `CVE-2017-9805 <http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-9805>`__

- Blog post: https://securitylab.github.com/research/apache-struts-vulnerability-cve-2017-9805

Finding the RCE yourself
========================

#. Create a class to find the interface ``org.apache.struts2.rest.handler.ContentTypeHandler``

   **Hint**: Use predicate ``hasQualifiedName(...)``

#. Identify methods called ``toObject``, which are defined on direct subtypes of ``ContentTypeHandler``

   **Hint**: Use ``Method.getDeclaringType()`` and ``Type.getASupertype()``

#. Implement a ``DataFlow::ConfigSig``, defining the source as the first parameter of a ``toObject`` method, and the sink as an instance of ``UnsafeDeserializationSink``.

   **Hint**: Use ``Node::asParameter()``

#. Construct the query as a path-problem query, and verify you find one result.

Model answer, step 1
====================

.. code-block:: ql

  import java

  /** The interface `org.apache.struts2.rest.handler.ContentTypeHandler`. */

  class ContentTypeHandler extends RefType {
    ContentTypeHandler() {
      this.hasQualifiedName("org.apache.struts2.rest.handler", "ContentTypeHandler")
    }
  }

Model answer, step 2
====================

.. code-block:: ql

   /** A `toObject` method on a subtype of `org.apache.struts2.rest.handler.ContentTypeHandler`. */
   class ContentTypeHandlerDeserialization extends Method {
     ContentTypeHandlerDeserialization() {
       this.getDeclaringType().getASupertype() instanceof ContentTypeHandler and
       this.hasName("toObject")

Model answer, step 3
====================

.. code-block:: ql

   import UnsafeDeserialization
   import semmle.code.java.dataflow.DataFlow::DataFlow
   /**
    * Configuration that tracks the flow of taint from the first parameter of
    * `ContentTypeHandler.toObject` to an instance of unsafe deserialization.
    */
   module StrutsUnsafeDeserializationConfig implements ConfigSig {
     predicate isSource(Node source) {
       source.asParameter() = any(ContentTypeHandlerDeserialization des).getParameter(0)
     }
     predicate isSink(Node sink) { sink instanceof UnsafeDeserializationSink }
   }
   module StrutsUnsafeDeserializationFlow = Global<StrutsUnsafeDeserializationConfig>;

Model answer, step 4
====================

.. code-block:: ql

   import PathGraph
   ...
   from PathNode source, PathNode sink
   where StrutsUnsafeDeserializationFlow::flowPath(source, sink)
   select sink.getNode().(UnsafeDeserializationSink).getMethodAccess(), source, sink, "Unsafe deserialization of $@.", source, "user input"

More full-featured version: https://github.com/github/securitylab/tree/main/CodeQL_Queries/java/Apache_Struts_CVE-2017-9805



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/java/query-injection-java.rst
========================
Example: Query injection
========================

CodeQL for Java

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `VIVO Vitro <https://github.com/vivo-project/Vitro>`__ from GitHub.

SQL injection
=============

- Occurs when user input is used to construct an SQL query without any sanitization or escaping.

- Classic example involves constructing a query using string concatenation:

  .. code-block:: sql

     runQuery("SELECT * FROM users WHERE id='" + userId + "'");


- If the ``userId`` can be provided by a user, and is not sanitized, then a malicious user can provide input that manipulates the intended query.

- For example, providing the input ``"' OR '1'='1"`` would allow the attacker to return all records in the users table.

.. note::

   `SQL <https://en.wikipedia.org/wiki/SQL>`__ is a database query language, which is often used from within other programming languages to interact with a database. The typical case is that a query is to be executed to find some data, based on some input provided by the user - for example, the user’s ID. However, the interface between the host programming language and SQL is typically implemented by passing a string containing the query to some API.

SPARQL injection
================

- `SPARQL <https://en.wikipedia.org/wiki/SPARQL>`__ is a language for querying key-value databases in RDF format.

- The same type of vulnerability can occur for SPARQL as for SQL: if the SPARQL query is constructed through string concatenation, a malicious user can subvert the query:

  .. code-block:: sql
  
     sparqlAskQuery("ASK { <" + individualURI + "> ?p ?o }");

- SPARQL is used by many projects, but we will be looking at `VIVO Vitro <https://github.com/vivo-project/Vitro/>`__.

.. rst-class:: background2

Developing a query
===================

Finding a query concatenation

CodeQL query: find SPARQL methods
=================================

Let’s start by looking for calls to methods with names of the form ``sparql*Query``, using the classes ``Method`` and ``MethodAccess`` from the Java library.

.. rst-class:: build

.. literalinclude:: ../query-examples/java/query-injection-java-1.ql 

.. note::

  - When performing variant analysis, it is usually helpful to write a simple query that finds the simple syntactic pattern, before trying to go on to describe the cases where it goes wrong.
  - In this case, we start by looking for all the method calls that appear to run, before trying to refine the query to find cases which are vulnerable to query injection.
  - The ``select`` clause defines what this query is looking for:
  
    - a ``MethodAccess``: the call to a SPARQL query method
    - a ``Method``: the SPARQL query method.
  
  - The ``where`` part of the query ties these variables together using `predicates <https://codeql.github.com/docs/ql-language-reference/predicates/>`__ defined in the `standard CodeQL library for Java <https://codeql.github.com/codeql-standard-libraries/java/>`__.

CodeQL query: find string concatenation
=======================================

- We now need to define what would make these API calls unsafe.
- A simple heuristic would be to look for string concatenation used in the query argument. 
- We may want to reuse this logic, so let us create a separate predicate.

Looking at autocomplete suggestions, we see that we can get the type of an expression using the ``getType()`` method.

.. rst-class:: build

.. code-block:: ql

   predicate isStringConcat(AddExpr ae) {
     ae.getType() instanceof TypeString
   }

.. note::

  - An important part of the query is to determine whether a given expression is string concatenation.
  - We therefore write a helper predicate for finding string concatenation.
  - This predicate effectively represents the set of all ``add`` expressions in the database where the type of the expression is ``TypeString`` - that is, the addition produces a ``String``   value.

CodeQL query: SPARQL injection
==============================

We can now combine our predicate with the existing query.
Note that we do not need to specify that the argument of the method access is an ``AddExpr`` - this is implied by the ``isStringConcat`` requirement.

Now our query becomes:

.. rst-class:: build

.. literalinclude:: ../query-examples/java/query-injection-java-2.ql
   :language: ql

The final query
===============

.. literalinclude:: ../query-examples/java/query-injection-java-3.ql
   :language: ql

There are two results, one of which was assigned **CVE-2019-6986**.

.. note::

  Full write up and exploit can be found here: https://github.com/Semmle/SecurityExploits/tree/master/vivo-project/CVE-2019-6986

Follow up
=========

- Our query successfully finds cases where the concatenation occurs in the argument to the SPARQL API.

- However, in general, the concatenation could occur before the method call.

- For this, we would need to use :doc:`local data flow <data-flow-java>`, which is the topic of the next set of training slides.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/java/global-data-flow-java.rst
================================
Introduction to global data flow
================================

CodeQL for Java

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `Apache Struts <https://github.com/apache/struts>`__ from GitHub.

.. rst-class:: agenda

Agenda
======

- Global taint tracking
- Sanitizers
- Path queries
- Data flow models

.. insert common global data flow slides

.. include:: ../slide-snippets/global-data-flow.rst

.. resume language-specific global data flow slides

Code injection in Apache struts
===============================

- In April 2018, Man Yue Mo, a security researcher at Semmle, reported 5 remote code execution (RCE) vulnerabilities (CVE-2018-11776) in Apache Struts.

- These vulnerabilities were caused by untrusted, unsanitized data being evaluated as an OGNL (Object Graph Navigation Library) expression, allowing malicious users to perform remote code execution.

- Conceptually, this is a global taint tracking problem - does untrusted remote input flow to a method call which evaluates OGNL?

.. note::

   More details on the CVE can be found here: https://securitylab.github.com/research/apache-struts-CVE-2018-11776 and 
   https://github.com/github/securitylab/tree/main/CodeQL_Queries/java/Apache_Struts_CVE-2018-11776

   More details on OGNL can be found here: https://commons.apache.org/proper/commons-ognl/

.. rst-class:: java-data-flow-code-example

Code example
============

Finding RCEs (outline)
======================

.. literalinclude:: ../query-examples/java/global-data-flow-java-1.ql
   :language: ql

Defining sources
================

We want to look for method calls where the method name is ``getNamespace()``, and the declaring type of the method is a class called ``ActionProxy``.

.. code-block:: ql

  import semmle.code.java.security.Security

  module TaintedOGNLConfig implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      exists(Method m |
        m.getName() = "getNamespace" and
        m.getDeclaringType().getName() = "ActionProxy" and
        source.asExpr() = m.getAReference()
      )
    }
    ...
  }

.. note::

  We first define what it means to be a *source* of tainted data for this particular problem. In this case, we are interested in the value returned by calls to ``getNamespace()``.


Exercise: Defining sinks
========================

Fill in the definition of ``isSink``.

**Hint**: We want to find the first argument of calls to the method ``compileAndExecute``.

.. code-block:: ql

  import semmle.code.java.security.Security

  module TaintedOGNLConfig implements DataFlow::ConfigSig {
    predicate isSink(DataFlow::Node sink) {
      /* Fill me in */
    }
    ...
  }

.. note::

  The second part is to define what it means to be a sink for this particular problem. The queries from an :doc:`Introduction to data flow <data-flow-java>`  will be useful for this exercise.

Solution: Defining sinks
========================

Find a method access to ``compileAndExecute``, and mark the first argument.

.. code-block:: ql

  import semmle.code.java.security.Security

  module TaintedOGNLConfig implements DataFlow::ConfigSig {
    predicate isSink(DataFlow::Node sink) {
      exists(MethodAccess ma |
        ma.getMethod().getName() = "compileAndExecute" and
        ma.getArgument(0) = sink.asExpr()
      )
    }
    ...
  }

.. insert path queries slides

.. include:: ../slide-snippets/path-queries.rst

.. resume language-specific global data flow slides

Defining sanitizers
===================

A sanitizer allows us to *prevent* flow through a particular node in the graph. For example, flows that go via ``ValueStackShadowMap`` are not particularly interesting, because it is a class that is rarely used in practice. We can exclude them like so:

.. code-block:: ql

  module TaintedOGNLConfig implements DataFlow::ConfigSig {
    predicate isBarrier(DataFlow::Node nd) {
      nd.getEnclosingCallable()
        .getDeclaringType()
        .getName() = "ValueStackShadowMap"
    }
    ...
  }

Defining additional taint steps
===============================

Add an additional taint step that (heuristically) taints a local variable if it is a pointer, and it is passed to a function in a parameter position that taints it.

.. code-block:: ql

  module TaintedOGNLConfig implements DataFlow::ConfigSig {
    predicate isAdditionalFlowStep(DataFlow::Node node1, DataFlow::Node node2) {
      exists(Field f, RefType t |
        node1.asExpr() = f.getAnAssignedValue() and
        node2.asExpr() = f.getAnAccess() and
        node1.asExpr().getEnclosingCallable().getDeclaringType() = t and
        node2.asExpr().getEnclosingCallable().getDeclaringType() = t
      )
    }
    ...
  }


.. rst-class:: end-slide

Extra slides
============

.. include:: ../slide-snippets/global-data-flow-extra-slides.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/snprintf.rst
===============================
Exercise: ``snprintf`` overflow
===============================

CodeQL for C/C++

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `rsyslog <https://github.com/rsyslog/rsyslog>`__ from GitHub.

``snprintf``
============

.. rst-class:: build

- ``printf``: Returns number of characters printed.

  .. code-block:: cpp
  
    printf("Hello %s!", name)

- ``sprintf``: Returns number of characters written to ``buf``.

  .. code-block:: cpp
  
    sprintf(buf, "Hello %s!", name)
  
- ``snprintf``: Returns number of characters it **would have written** to ``buf`` had ``n`` been sufficiently large, **not** the number of characters actually written.

  .. code-block:: cpp
  
    snprintf(buf, n, "Hello %s!", name)

- In pre-C99 versions of glibc ``snprintf`` would return -1 if ``n`` was too small!

RCE in rsyslog
==============

- Vulnerable code looked similar to this (`original <https://github.com/rsyslog/librelp/blob/532aa362f0f7a8d037505b0a27a1df452f9bac9e/src/tcp.c#L1195-L1211>`__):

  .. code-block:: cpp
  
    char buf[1024];
    int pos = 0;
    for (int i = 0; i < n; i++) {
      pos += snprintf(buf + pos, sizeof(buf) - pos, "%s", strs[i]);
    }

- Disclosed as `CVE-2018-1000140 <https://nvd.nist.gov/vuln/detail/CVE-2018-1000140>`__.
- Blog post: https://securitylab.github.com/research/librelp-buffer-overflow-cve-2018-1000140

Finding the RCE yourself
========================

#. Write a query to find calls to ``snprintf``

   **Hint**: Use class ``FunctionCall``

#. Restrict to calls whose result is used

   **Hint**: Use class ``ExprInVoidContext``

#. Restrict to calls where the format string contains “%s”

   **Hint**: Use predicates ``Expr.getValue`` and ``string.regexpMatch``

#. Restrict to calls where the result flows back to the size argument

   **Hint**: Import library ``semmle.code.cpp.dataflow.TaintTracking`` and use predicate ``TaintTracking::localTaint``

Model answer
============

.. literalinclude:: ../query-examples/cpp/snprintf-1.ql
   :language: ql

.. rst-class:: build

.. note::

  The regular expression for matching the format string uses the “(?s)” directive to ensure that “.” also matches any newline characters embedded in the string.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/data-flow-cpp.rst
=========================
Introduction to data flow
=========================

Finding string formatting vulnerabilities in C/C++

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <hhttps://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `dotnet/coreclr <https://github.com/dotnet/coreclr>`__ from GitHub.

.. rst-class:: agenda

Agenda
======

- Non-constant format string
- Data flow
- Modules and libraries
- Local data flow
- Local taint tracking

Motivation
==========

Let’s write a query to identify instances of `CWE-134 <https://cwe.mitre.org/data/definitions/134.html>`__ **Use of externally controlled format string**.

.. code-block:: cpp

  printf(userControlledString, arg1);

**Goal**: Find uses of ``printf`` (or similar) where the format string can be controlled by an attacker.

.. note::

  Formatting functions allow the programmer to construct a string output using a *format string* and an optional set of arguments. The *format string* is specified using a simple template language, where the output string is constructed by processing the format string to find *format specifiers*, and inserting values provided as arguments. For example:

  .. code-block:: cpp

    printf("Name: %s, Age: %d", "Freddie", 2);

  would produce the output ``"Name: Freddie, Age: 2”``. So far, so good. However, problems arise if there is a mismatch between the number of formatting specifiers, and the number of arguments. For example:

  .. code-block:: cpp

    printf("Name: %s, Age: %d", "Freddie");

  In this case, we have one more format specifier than we have arguments. In a managed language such as Java or C#, this simply leads to a runtime exception. However, in C/C++, the formatting functions are typically implemented by reading values from the stack without any validation of the number of arguments. This means a mismatch in the number of format specifiers and format arguments can lead to information disclosure.

  Of course, in practice this happens rarely with *constant* formatting strings. Instead, it’s most problematic when the formatting string can be specified by the user, allowing an attacker to provide a formatting string with the wrong number of format specifiers. Furthermore, if an attacker can control the format string, they may be able to provide the ``%n`` format specifier, which causes ``printf`` to write the number characters in the generated output string to a specified location.

  See https://en.wikipedia.org/wiki/Uncontrolled_format_string for more background.

Exercise: Non-constant format string
====================================

Write a query that flags ``printf`` calls where the format argument is not a ``StringLiteral``. 

**Hint**: Import ``semmle.code.cpp.commons.Printf`` and use class ``FormattingFunction`` and ``getFormatParameterIndex()``.

.. rst-class:: build

.. literalinclude:: ../query-examples/cpp/data-flow-cpp-1.ql
  :language: ql

.. note::

  This first query is about finding places where the format specifier is not a constant string. In the CodeQL libraries for C/C++, constant strings are modeled as ``StringLiteral`` nodes, so we are looking for calls to format functions where the format specifier argument is not a string literal.

  The `C/C++ standard libraries <https://codeql.github.com/codeql-standard-libraries/cpp/>`__ include many different formatting functions that may be vulnerable to this particular attack–including ``printf``, ``snprintf``, and others. Furthermore, each of these different formatting functions may include the format string in a different position in the argument list. Instead of laboriously listing all these different variants, we can make use of the standard CodeQL class ``FormattingFunction``, which provides an interface that models common formatting functions in C/C++.

Meh...
======

Results are unsatisfactory:

- Query flags cases where the format string is a symbolic constant.
- Query flags cases where the format string is itself a format argument.
- Query doesn't recognize wrapper functions around ``printf``-like functions.

We need something better.

.. note::

  For example, consider the results which appear in ``/src/ToolBox/SOS/Strike/util.h``, between lines 965 and 970:

  .. code-block:: cpp

          const char *format = align == AlignLeft ? "%-*.*s" : "%*.*s";
      
                if (IsDMLEnabled())
                    DMLOut(format, width, precision, mValue);
                else
                    ExtOut(format, width, precision, mValue);

  Here, ``DMLOut`` and ``ExtOut`` are macros that expand to formatting calls. The format specifier is not constant, in the sense that the format argument is not a string literal. However, it is clearly one of two possible constants, both with the same number of format specifiers.

  What we need is a way to determine whether the format argument is ever set to something that is not constant.

.. include general data flow slides

.. include:: ../slide-snippets/local-data-flow.rst

.. resume language-specific slides

Exercise: source nodes
======================

Define a subclass of ``DataFlow::Node`` representing “source” nodes, that is, nodes without a (local) data flow predecessor.

**Hint**: use ``not exists()``.

.. rst-class:: build

.. code-block:: ql

  class SourceNode extends DataFlow::Node {
      SourceNode() {
        not DataFlow::localFlowStep(_, this)
      }
    }

.. note::

  Note the scoping of the `don’t-care variable <https://codeql.github.com/docs/ql-language-reference/expressions/#don-t-care-expressions>`__ “_” in this example: the body of the characteristic predicate is equivalent to:
  
  .. code-block:: ql

    not exists(DataFlow::Node pred | DataFlow::localFlowStep(pred, this))
    
  which is not the same as:

  .. code-block:: ql

    exists(DataFlow::Node pred | not DataFlow::localFlowStep(pred, this)).

Revisiting non-constant format strings
======================================

Refine the query to find calls to ``printf``-like functions where the format argument derives from a local source that is not a constant string.

.. rst-class:: build

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.DataFlow
   import semmle.code.cpp.commons.Printf
   
   class SourceNode extends DataFlow::Node { ... }
   
   from FormattingFunction f, Call c, SourceNode src, DataFlow::Node  arg
   where c.getTarget() = f and
         arg.asExpr() = c.getArgument(f.getFormatParameterIndex()) and
         DataFlow::localFlow(src, arg) and
         not src.asExpr() instanceof StringLiteral
   select arg, "Non-constant format string."

Refinements (take home exercise)
================================

Audit the results and apply any refinements you deem necessary.

Suggestions:

- Replace ``DataFlow::localFlowStep`` with a custom predicate that includes steps through global variable definitions.

  **Hint**: Use class ``GlobalVariable`` and its member predicates ``getAnAssignedValue()`` and ``getAnAccess()``.

- Exclude calls in wrapper functions that just forward their format argument to another ``printf``-like function; instead, flag calls to those functions.

Beyond local data flow
======================

- Results are still underwhelming.
- Dealing with parameter passing becomes cumbersome.
- Instead, let’s turn the problem around and find user-controlled data that flows into a ``printf`` format argument, potentially through calls.
- This needs :doc:`global data flow <global-data-flow-cpp>`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/intro-ql-cpp.rst
================================
Introduction to variant analysis
================================

CodeQL for C/C++

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `exiv2 <https://github.com/Exiv2/exiv2>`__ from GitHub.

.. Include language-agnostic section here

.. include:: ../slide-snippets/intro-ql-general.rst

Oops
====

.. code-block:: cpp
  :emphasize-lines: 3

  int write(int buf[], int size, int loc, int val) {
      if (loc >= size) {
         // return -1;
      }

      buf[loc] = val;

      return 0;
  }

- The return statement has been commented out (during debugging?)
- The if statement is now dead code
- No bounds checking!

.. note::

   Here’s a simple (artificial) bug, which we’ll develop a query to catch.

   This function writes a value to a given location in an array, first trying to do a bounds check to validate that the location is within bounds. However, the return statement has been commented out, leaving a redundant if statement and no bounds checking.

   This case can act as our “patient zero” in the variant analysis game.

A simple CodeQL query
=====================

.. literalinclude:: ../query-examples/cpp/empty-if-cpp.ql
   :language: ql

.. note::

   We are going to write a simple query which finds “if statements” with empty “then” blocks, so we can highlight the results like those on the previous slide.

   A `query <https://codeql.github.com/docs/ql-language-reference/queries/>`__ consists of a “select” clause that indicates what results should be returned. Typically it will also provide a “from” clause to declare some variables, and a “where” clause to state conditions over those variables. For more information on the structure of query files (including links to useful topics in the `QL language reference <https://codeql.github.com/docs/ql-language-reference/>`__), see `About CodeQL queries <https://codeql.github.com/docs/writing-codeql-queries/about-codeql-queries/>`__.

   In our example here, the first line of the query imports the `CodeQL library for C/C++ <https://codeql.github.com/codeql-standard-libraries/cpp/>`__, which defines concepts like ``IfStmt`` and ``Block``.
   The query proper starts by declaring two variables–ifStmt and block. These variables represent sets of values in the database, according to the type of each of the variables. For example, ifStmt has the type IfStmt, which means it represents the set of all if statements in the program.

   If we simply selected these two variables::

     from IfStmt ifStmt, Block block
     select ifStmt, block

   We would get a result row for every combination of blocks and if statements in the program. This is known as a cross-product, because there is no logical condition linking the two variables. We can use the where clause to specify the condition that we are only interested in rows where the “block” is the “then” part of the if statement. We do this by specifying::

     block = ifStmt.getThen()

   This states that the block is equal to (not assigned!) the “then” part of the ``ifStmt``. ``getThen()`` is an operation which is available on any IfStmt. One way to interpret this is as a filtering operation – starting with every pair of block and if statements, check each one to whether the logical condition holds, and only keep the row if that is the case.
   We can add a second condition that specifies the block must be empty::

     and block.isEmpty()

   The ``isEmpty()`` operation is available on any Block, and is only true if the “block” has no children.

   Finally, we select a location, at which to report the problem, and a message, to explain what the problem is.



Structure of a query
====================

A **query file** has the extension ``.ql`` and contains a **query clause**, and optionally **predicates**, **classes**, and **modules**.

A **query library** has the extension ``.qll`` and does not contain a query clause, but may contain modules, classes, and predicates.

Each query library also implicitly defines a module.

**Import** statements allow the classes and predicates defined in one module to be used in another.

.. note::

  Queries are always contained in query files with the file extension ``.ql``.

  Parts of queries can be lifted into `library files <https://codeql.github.com/docs/ql-language-reference/modules/#library-modules>`__ with the extension ``.qll``. Definitions within such libraries can be brought into scope using ``import`` statements, and similarly QLL files can import each other’s definitions using “import” statements.

  Logic can be encapsulated as user-defined `predicates <https://codeql.github.com/docs/ql-language-reference/predicates/>`__ and `classes <https://codeql.github.com/docs/ql-language-reference/types/#classes>`__, and organized into `modules <https://codeql.github.com/docs/ql-language-reference/modules/>`__. Each QLL file implicitly defines a module, but QL and QLL files can also contain explicit module definitions, as we will see later.

Predicates
==========

A predicate allows you to pull out and name parts of a query.

.. container:: column-left

  .. literalinclude:: ../query-examples/cpp/empty-if-cpp.ql
     :language: ql
     :emphasize-lines: 6

.. container:: column-right

  .. literalinclude:: ../query-examples/cpp/empty-if-cpp-predicate.ql
     :language: ql
     :emphasize-lines: 3-5

.. note::

   A `predicate <https://codeql.github.com/docs/ql-language-reference/predicates/>`__ takes zero or more parameters, and its body is a condition on those parameters. The predicate may (or may not) hold. Predicates may also be `recursive <https://codeql.github.com/docs/ql-language-reference/predicates/#recursive-predicates>`__, simply by referring to themselves (directly or indirectly).

   You can imagine a predicate to be a self-contained from-where-select statement, that produces an intermediate relation, or table. In this case, the ``isEmpty`` predicate will be the set of all blocks which are empty.

Classes in QL
=============

A QL class allows you to name a set of values and define (member) predicates on them.

A class has at least one supertype and optionally a **characteristic predicate**; it contains the values that belong to *all* supertypes *and* satisfy the characteristic predicate, if provided.

Member predicates are inherited and can be overridden.

.. code-block:: ql

   class EmptyBlock extends Block {
     EmptyBlock() {
       this.getNumStmt() = 0
     }
   }

.. note::

  `Classes <https://codeql.github.com/docs/ql-language-reference/types/#classes>`__ model sets of values from the database. A class has one or more supertypes, and inherits `member predicates <https://codeql.github.com/docs/ql-language-reference/types/#member-predicates>`__ (methods) from each of them. Each value in a class must be in every supertype, but additional conditions can be stated in a so-called **characteristic predicate**, which looks a bit like a zero-argument constructor.

  In the example, declaring a variable “EmptyBlock e” will allow it to range over only those blocks that have zero statements.

Classes in QL continued
=======================

.. container:: column-left

  .. literalinclude:: ../query-examples/cpp/empty-if-cpp-predicate.ql
     :language: ql
     :emphasize-lines: 3-5

.. container:: column-right

  .. literalinclude:: ../query-examples/cpp/empty-if-cpp-class.ql
     :language: ql
     :emphasize-lines: 3-7


.. note::

   As shown in this example, classes behave much like unary predicates, but with ``instanceof`` instead of predicate calls to check membership. Later on, we will see how to define member predicates on classes.

Iterative query refinement
==========================

- **Common workflow**: Start with a simple query, inspect a few results, refine, repeat.

- For example, empty then branches are not a problem if there is an else.

- **Exercise**: How can we refine the query to take this into account?

**Hints**:

- Use member predicate ``IfStmt.getElse()``
- Use ``not exists(...)``

.. note::

   CodeQL makes it very easy to experiment with analysis ideas. A common workflow is to start with a simple query (like our “redundant if-statement” example), examine a few results, refine the query based on any patterns that emerge and repeat.

   As an exercise, refine the redundant-if query based on the observation that if the if-statement has an “else” clause, then even if the body of the “then” clause is empty, it’s not actually redundant.

Model answer: redundant if-statement
=====================================

.. literalinclude:: ../query-examples/cpp/empty-if-cpp-model.ql




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/control-flow-cpp.rst
======================
Analyzing control flow
======================

CodeQL for C/C++

.. Include information slides here

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code/>`__ and download the CodeQL database for `ChakraCore <https://github.com/Chakra-Core/ChakraCore/>`__ from GitHub.


.. rst-class:: agenda

Agenda
======

- Control flow graphs
- Exercise: use after free
- Recursion over the control flow graph
- Basic blocks
- Guard conditions

Control flow graphs
===================

.. container:: column-left

   We frequently want to ask questions about the possible *order of execution* for a program.

   Example:

   .. code-block:: cpp

      if (x) {
        return 1;
      } else {
        return 2;
      }
 
.. container:: column-right

  Possible execution order is usually represented by a *control flow graph*:

   .. graphviz::
      
         digraph {
         graph [ dpi = 1000 ]
         node [shape=polygon,sides=4,color=blue4,style="filled,rounded",fontname=consolas,fontcolor=white]
         a [label=<if<BR /><FONT POINT-SIZE="10">IfStmt</FONT>>]
         b [label=<x<BR /><FONT POINT-SIZE="10">VariableAccess</FONT>>]
         c [label=<1<BR /><FONT POINT-SIZE="10">Literal</FONT>>]
         d [label=<2<BR /><FONT POINT-SIZE="10">Literal</FONT>>]
         e [label=<return<BR /><FONT POINT-SIZE="10">ReturnStmt</FONT>>]
         f [label=<return<BR /><FONT POINT-SIZE="10">ReturnStmt</FONT>>]

         a -> b
         b -> {c, d}
         c -> e
         d -> f
      }

.. note::

   The control flow graph is a static over-approximation of possible control flow at runtime. 
   Its nodes are program elements such as expressions and statements. 
   If there is an edge from one node to another, then it means that the semantic operation corresponding to the first node may be immediately followed by the operation corresponding to the second node. 
   Some nodes (such as conditions of “if” statements or loop conditions) have more than one successor, representing conditional control flow at runtime.

Modeling control flow
=====================

The control flow is modeled with a CodeQL class, ``ControlFlowNode``. Examples of control flow nodes include statements and expressions.

- ``ControlFlowNode`` provides API for traversing the control flow graph:

  - ``ControlFlowNode ControlFlowNode.getASuccessor()``
  - ``ControlFlowNode ControlFlowNode.getAPredecessor()``
  - ``ControlFlowNode ControlFlowNode.getATrueSuccessor()``
  - ``ControlFlowNode ControlFlowNode.getAFalseSuccessor()``

The control-flow graph is *intra-procedural*–in other words, only models paths within a function. To find the associated function, use

- ``Function ControlFlowNode.getControlFlowScope()``

.. note::

   The control flow graph is similar in concept to data flow graphs. In contrast to data flow, however, the AST nodes are directly control flow graph nodes.

   The predecessor/successor predicates are prime examples of member predicates with results that are used in functional syntax, but that are not actually functions. This is because a control flow node may have any number of predecessors and successors (including zero or more than one).

Example: malloc/free pairs
==========================

Find calls to ``free`` that are reachable from an allocation on the same variable:

.. literalinclude:: ../query-examples/cpp/control-flow-cpp-1.ql 
   :language: ql

.. note::

   Predicates ``allocationCall`` and ``freeCall`` are defined in the standard library and model a number of standard alloc/free-like functions.

Exercise: use after free
========================

Based on this query, write a query that finds accesses to the variable that occur after the free.

.. rst-class:: build
  
- What do you find? What problems occur with this approach to detecting use-after-free vulnerabilities?

  .. rst-class:: build

      .. literalinclude:: ../query-examples/cpp/control-flow-cpp-2.ql 
         :language: ql

Utilizing recursion
===================

The main problem we observed in the previous exercise was that the successor's relation is unaware of changes to the variable that would invalidate our results.

We can fix this by writing our own successor predicate that stops traversing the CFG if the variable is re-defined.

Utilizing recursion
===================

.. code-block:: ql

   ControlFlowNode reachesWithoutReassignment(FunctionCall free, LocalScopeVariable v) 
   {
     freeCall(free, v.getAnAccess()) and
     (
       // base case
       result = free
       or 
       // recursive case
       exists(ControlFlowNode mid |
         mid = reachesWithoutReassignment(free, v) and
         result = mid.getASuccessor() and
         // stop tracking when the value may change
         not result = v.getAnAssignedValue() and
         not result.(AddressOfExpr).getOperand() = v.getAnAccess()
       )
     )
   }

Exercise
========

Find local variables that are written to, and then never accessed again.

**Hint**: Use ``LocalVariable.getAnAssignment()``. 

.. rst-class:: build

   .. literalinclude:: ../query-examples/cpp/control-flow-cpp-3.ql 
      :language: ql

.. rst-class:: background2

More control flow
=================

Basic blocks
============

``BasicBlock`` represents basic blocks, that is, straight-line sequences of control flow nodes without branching.

- ``ControlFlowNode BasicBlock.getNode(int)``
- ``BasicBlock BasicBlock.getASuccessor()``
- ``BasicBlock BasicBlock.getAPredecessor()``
- ``BasicBlock BasicBlock.getATrueSuccessor()``
- ``BasicBlock BasicBlock.getAFalseSuccessor()``

Often, queries can be made more efficient by treating basic blocks as a unit instead of reasoning about individual control flow nodes.

Exercise: unreachable blocks
============================

Write a query to find unreachable basic blocks.

**Hint**: First define a recursive predicate to identify reachable blocks. Class ``EntryBasicBlock`` may be useful.

.. rst-class:: build

.. literalinclude:: ../query-examples/cpp/control-flow-cpp-4.ql 
   :language: ql

.. note::

   This query has a good number of false positives on Chakra, many of them to do with templating and macros.

Guard conditions
================

A ``GuardCondition`` is a ``Boolean`` condition that controls one or more basic blocks in the sense that it is known to be true/false at the entry of those blocks.

- ``GuardCondition.controls(BasicBlock bb, boolean outcome):`` the entry of bb can only be reached if the guard evaluates to outcome

- ``GuardCondition.comparesLt, GuardCondition.ensuresLt, GuardCondition.comparesEq:`` auxiliary predicates to identify conditions that guarantee that one expression is less than/equal to another

Further materials
=================

- CodeQL for C/C++: https://codeql.github.com/docs/codeql-language-guides/codeql-for-cpp/ 
- API reference: https://codeql.github.com/codeql-standard-libraries/cpp 

.. rst-class:: end-slide

Extra slides
============

.. rst-class:: background2

Appendix: Library customizations
================================

Call graph customizations
=========================

The default implementation of call target resolution does not handle function pointers, because they are difficult to deal with in general.

We can, however, add support for particular patterns of use by contributing a new override of ``Call.getTarget``.

Exercise: unresolvable calls
============================

Write a query that finds all calls for which no call target can be determined, and run it on libjpeg-turbo.

Examine the results. What do you notice? 

.. rst-class:: build

   .. code-block:: ql
   
      import cpp
   
      from Call c
      where not exists(c.getTarget())
      select c

.. rst-class:: build

- Many results are calls through struct fields emulating virtual dispatch.

Exercise: resolving calls through variables
===========================================

Write a query that resolves the call at `cjpeg.c:640 <https://github.com/libjpeg-turbo/libjpeg-turbo/blob/9bc8eb6449a32f452ab3fc9f94af672a0af13f81/cjpeg.c#L640>`__.

**Hint**: Use classes ``ExprCall``, ``PointerDereferenceExpr``, and ``Access``.

.. rst-class:: build

.. literalinclude:: ../query-examples/cpp/control-flow-cpp-5.ql 
   :language: ql

Exercise: customizing the call graph
====================================

Create a subclass of ``ExprCall`` that uses your query to implement ``getTarget``.

.. rst-class:: build

.. code-block:: ql

   class CallThroughVariable extends ExprCall {
     Variable v;
     CallThroughVariable() {
       exists(PointerDereferenceExpr callee | callee = getExpr() |
         callee.getOperand() = v.getAnAccess()
       )
     }
     override Function getTarget() {
       result = super.getTarget() or
       exists(Access init | init = v.getAnAssignedValue() |
         result = init.getTarget()
       )
     }
   }

Control-flow graph customizations
=================================

The default control-flow graph implementation recognizes a few common patterns for non-returning functions, but sometimes it fails to spot them, which can cause imprecision.

We can add support for new non-returning functions by overriding ``ControlFlowNode.getASuccessor()``.

Exercise: calls to ``error_exit``
=================================

Write a query that finds all calls to a field called ``error_exit``.

**Hint**: Reuse (parts of) the ``CallThroughVariable`` class from before.

.. rst-class:: build

.. code-block:: ql

   class CallThroughVariable extends ExprCall { ... }
   
   class ErrorExitCall extends CallThroughVariable {
     override Field v;
   
     ErrorExitCall() { v.getName() = "error_exit" }
   }
   
   from ErrorExitCall eec
   select eec

Exercise: customizing the control-flow graph
============================================

Override ``ControlFlowNode`` to mark calls to ``error_exit`` as non-returning.

**Hint**: ``ExprCall`` is an indirect subclass of ``ControlFlowNode``. 

.. rst-class:: build

.. code-block:: ql

   class CallThroughVariable extends ExprCall { ... }
   
   class ErrorExitCall extends CallThroughVariable {
     override Field v;
   
     ErrorExitCall() { v.getName() = "error_exit" }
   
     override ControlFlowNode getASuccessor() { none() }
   }

``CustomOptions`` class
=======================

The Options library defines a ``CustomOptions`` class with various member predicates that can be overridden to customize aspects of the analysis.

In particular, it has an ``exprExits`` predicate that can be overridden to more easily perform the customization on the previous slide:

.. code-block:: ql

   import Options
   
   class MyOptions extends CustomOptions {
    override predicate exprExits(Expr e) {
      super.exprExits(e) or ...
    }
   }



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/global-data-flow-cpp.rst
================================
Introduction to global data flow
================================

CodeQL for C/C++
   
.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `dotnet/coreclr <https://github.com/dotnet/coreclr>`__ from GitHub.

.. rst-class:: agenda

Agenda
======

- Global taint tracking
- Sanitizers
- Path queries
- Data flow models

.. insert common global data flow slides

.. include:: ../slide-snippets/global-data-flow.rst

.. resume language-specific global data flow slides


Finding tainted format strings (outline)
========================================

.. literalinclude:: ../query-examples/cpp/global-data-flow-cpp-1.ql
  :language: ql

.. note::

  Here’s the outline for a inter-procedural (that is, “global”) version of the tainted formatting strings query we saw in the previous slide deck. The same template will be applicable for most taint tracking problems.

Defining sources
================

The library class ``SecurityOptions`` provides a (configurable) model of what counts as user-controlled data:

.. code-block:: ql

  import semmle.code.cpp.security.Security

  module TaintedFormatConfig implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      exists (SecurityOptions opts |
        opts.isUserInput(source.asExpr(), _)
      )
    }
    ...
  }

.. note::

  We first define what it means to be a *source* of tainted data for this particular problem. In this case, what we care about is whether the format string can be provided by an external user to our application or service. As there are many such ways external data could be introduced into the system, the standard CodeQL libraries for C/C++ include an extensible API for modeling user input. In this case, we will simply use the predefined set of *user inputs*, which includes arguments provided to command line applications.


Defining sinks (exercise)
=========================

Use the ``FormattingFunction`` class to fill in the definition of ``isSink``.

.. code-block:: ql

  import semmle.code.cpp.security.Security

  module TaintedFormatConfig implements DataFlow::ConfigSig {
    predicate isSink(DataFlow::Node sink) {
      /* Fill me in */
    }
    ...
  }

.. note::

  The second part is to define what it means to be a sink for this particular problem. The queries from the previous slide deck will be useful for this exercise.

Defining sinks (answer)
=======================

Use the ``FormattingFunction`` class, we can write the sink as:

.. code-block:: ql

  import semmle.code.cpp.security.Security

  module TaintedFormatConfig implements DataFlow::ConfigSig {
    predicate isSink(DataFlow::Node sink) {
      exists (FormattingFunction ff, Call c |
        c.getTarget() = ff and
        c.getArgument(ff.getFormatParameterIndex()) = sink.asExpr()
      )
    }
    ...
  }

.. note::

  When we run this query, we should find a single result. However, it is tricky to determine whether this result is a true positive (a “real” result) because our query only reports the source and the sink, and not the path through the graph between the two.

.. insert path queries slides

.. include:: ../slide-snippets/path-queries.rst

.. resume language-specific global data flow slides

Defining additional taint steps
===============================

Add an additional taint step that (heuristically) taints a local variable if it is a pointer, and it is passed to a function in a parameter position that taints it.

.. code-block:: ql

  module TaintedFormatConfig implements DataFlow::ConfigSig {
    predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {
      exists (Call c, Expr arg, LocalVariable lv |
        arg = c.getAnArgument() and
        arg = pred.asExpr() and
        arg.getFullyConverted().getUnderlyingType() instanceof PointerType and
        arg = lv.getAnAccess() and
        succ.asUninitialized() = lv
      )
    }
    ...
  }

Defining sanitizers
===================

Add a sanitizer, stopping propagation at parameters of formatting functions, to avoid double-reporting:

.. code-block:: ql

  module TaintedFormatConfig implements DataFlow::ConfigSig {
    predicate isBarrier(DataFlow::Node nd) {
      exists (FormattingFunction ff, int idx |
        idx = ff.getFormatParameterIndex() and
        nd = DataFlow::parameterNode(ff.getParameter(idx))
      )
    }
    ...
  }

Data flow models
================

- To provide models of data/taint flow through library functions, you can implement subclasses of ``DataFlowFunction`` (from ``semmle.code.cpp.models.interfaces.DataFlow``) and ``TaintFunction`` (from ``semmle.code.cpp.models.interfaces.Taint``), respectively

- Example: model of taint flow from third to first parameter of ``memcpy``

   .. code-block:: ql
   
      class MemcpyFunction extends TaintFunction {
            MemcpyFunction() { this.hasName("memcpy") }
            override predicate hasTaintFlow(FunctionInput i, FunctionOutput o) 
                i.isInParameter(2) and o.isOutParameterPointer(0)
            }
      }
   
.. note::

  See the API documentation for more details about ``FunctionInput`` and ``FunctionOutput``.

.. rst-class:: end-slide

Extra slides
============

.. include:: ../slide-snippets/global-data-flow-extra-slides.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/program-representation-cpp.rst
======================
Program representation 
======================

CodeQL for C/C++

.. rst-class:: agenda

Agenda
======

- Abstract syntax trees
- Database representation
- Symbol tables
- Variables
- Functions

.. insert abstract-syntax-tree.rst

.. include:: ../slide-snippets/abstract-syntax-tree.rst

.. resume slides

AST CodeQL classes
==================

Important AST CodeQL classes include:

- ``Expr``: expressions such as assignments, variable references, function calls, ...
- ``Stmt``: statements such as conditionals, loops, try statements, ... 
- ``DeclarationEntry``: places where functions, variables or types are declared and/or defined

These three (and all other AST CodeQL classes) are subclasses of ``Element``.

Symbol table
============

The database also includes information about the symbol table associated with a program:

- ``Variable``:  all variables, including local variables, global variables, static variables and member variables

- ``Function``: all functions, including member function

- ``Type``: built-in and user-defined types

Working with variables
======================

``Variable`` represents program variables, including locally scoped variables (``LocalScopeVariable``), global variables (``GlobalVariable``), and others:

- ``string Variable.getName()``
- ``Type Variable.getType()``

``Access`` represents references to declared entities such as functions (``FunctionAccess``) and variables (``VariableAccess``), including fields (``FieldAccess``).

- ``Declaration Access.getTarget()``

``VariableDeclarationEntry`` represents declarations or definitions of a variable.

- ``Variable VariableDeclarationEntry.getVariable()``

Working with functions
======================

Functions are represented by the Function class. Each declaration or definition of a function is represented by a ``FunctionDeclarationEntry``.

Calls to functions are modeled by the CodeQL class ``Call`` and its subclasses:

- ``Call.getTarget()`` gets the declared target of the call; undefined for calls through function pointers
- ``Function.getACallToThisFunction()`` gets a call to this function

Typically, functions are identified by name:

- ``string Function.getName()``
- ``string Function.getQualifiedName()``

Working with preprocessor logic
===============================

Macros and other preprocessor directives can easily cause confusion when analyzing programs:

- AST structure reflects the program *after* preprocessing.
- Locations refer to the original source text *before* preprocessing.

For example, in:

  .. code-block:: cpp

    #define square(x) x*x
    y = square(y0), z = square(z0)

there are no AST nodes corresponding to ``square(y0)`` or ``square(z0)``, but there are AST nodes corresponding to ``y0*y0`` and ``z0*z0``.

.. note::

  The C preprocessor poses a dilemma: un-preprocessed code cannot, in general, be parsed and analyzed meaningfully, but showing results in preprocessed code is not useful to developers. Our solution is to base the AST representation on preprocessed source (in the same way as compilers do), but associate AST nodes with locations in the original source text.

Working with macros
===================

  .. code-block:: cpp

    #define square(x) x*x
    y = square(y0), z = square(z0)

is represented in the CodeQL database as:

- A Macro entity representing the text of the *head* and *body* of the macro
- Assignment nodes, representing the two assignments after preprocessing

  - Left-hand sides are ``VariableAccess`` nodes of y and z
  - Right-hand sides are ``MulExpr`` nodes representing ``y0*y0`` and ``z0*z0``

- A ``MacroAccess`` entity, which associates the Macro with the ``MulExprs``

Useful predicates on ``Element``: ``isInMacroExpansion()``, ``isAffectedByMacro()``

.. note::

  The CodeQL database also contains information about macro definitions, which are represented by class ``Macro``. These macro definitions are related to the AST nodes resulting from their uses by the class ``MacroAccess``.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/cpp/bad-overflow-guard.rst
===========================
Example: Bad overflow guard
===========================

CodeQL for C/C++

.. rst-class:: setup

Setup
=====

For this example you need to set up `CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ and download the CodeQL database for `ChakraCore <https://github.com/Chakra-Core/ChakraCore/>`__ from GitHub.

Checking for overflow in C
==========================

- Arithmetic operations overflow if the result is too large for their type.
- Developers sometimes exploit this to write overflow checks:

   .. code-block:: cpp

      if (v + b < v) {
          handle_error("overflow");
      } else {
          result = v + b;
      }
    
   Where might this go wrong?

.. note::

  - In C/C++ we often need to check for whether an operation `overflows <https://en.wikipedia.org/wiki/Integer_overflow>`__.
  - An overflow is when an arithmetic operation, such as an addition, results in a number which is too large to be stored in the type.
  - When an operation overflows, the value “wraps” around.
  - A typical way to check for overflow of an addition, therefore, is whether the result is less than one of the arguments–that is the result has **wrapped**.

Integer promotion
=================

From `https://en.cppreference.com/w/c/language/conversion <https://en.cppreference.com/w/c/language/conversion>`__:

.. rst-class:: quote

  Integer promotion is the implicit conversion of a value of any integer type with rank less or equal to rank of ``int`` ... to the value of type ``int`` or ``unsigned int``.

- The arguments of the following arithmetic operators undergo implicit conversions:

  - binary arithmetic ``* / % + -``
  - relational operators ``< > <= >= == !=``
  - binary bitwise operators ``& ^ |``
  - the conditional operator ``?:``

.. note::

  - Most of the time integer conversion works fine. However, the rules governing addition in C/C++ are complex, and it's easy to get bitten.
  - CPUs generally prefer to perform arithmetic operations on 32-bit or larger integers, as the architectures are optimized to perform those efficiently.
  - The compiler therefore performs “integer promotion” for arguments to arithmetic operations that are smaller than 32-bit.

Checking for overflow in C revisited
====================================

Which branch gets executed in this example? What is the value of ``result``?

   .. code-block:: cpp
   
     uint16_t v = 65535;
     uint16_t b = 1;
     uint16_t result;
     if (v + b < v) {
         handle_error("overflow");
     } else {
         result = v + b;
     }
   
.. note::

  In this example the second branch is executed, even though there is a 16-bit overflow, and ``result`` is set to zero.

Checking for overflow in C revisited
====================================

Here is the example again, with the conversions made explicit:

   .. code-block:: cpp
     :emphasize-lines: 4,7
   
     uint16_t v = 65535;
     uint16_t b = 1;
     uint16_t result;
     if ((int)v + (int)b < (int)v) {
         handle_error("overflow");
     } else {
         result = (uint16_t)((int)v + (int)b);
     }
   
.. note::

  In this example the second branch is executed, even though there is a 16-bit overflow, and result is set to zero.

  Explanation:

  - The two integer arguments to the addition, ``v`` and ``b``, are promoted to 32-bit integers.
  - The comparison (``<``) is also an arithmetic operation, therefore it will also be completed on 32-bit integers.
  - This means that ``v + b < v`` will never be true, because v and b can hold at most 2 :sup:`16`.
  - Therefore, the second branch is executed, but the result of the addition is stored into the result variable. Overflow will still occur as result is a 16-bit integer.

This happens even though the overflow check passed!

.. rst-class:: background2

Developing a CodeQL query
=========================

Finding bad overflow guards

CodeQL query: bad overflow guards
==================================

Let’s look for overflow guards of the form ``v + b < v``, using the classes
``AddExpr``, ``Variable`` and ``RelationalOperation`` from the ``cpp`` library.

.. rst-class:: build

.. literalinclude:: ../query-examples/cpp/bad-overflow-guard-1.ql
   :language: ql

.. note::

  - When performing variant analysis, it is usually helpful to write a simple query that finds the simple syntactic pattern, before trying to go on to describe the cases where it goes wrong.
  - In this case, we start by looking for all the *overflow* checks, before trying to refine the query to find all *bad overflow* checks.
  - The ``select`` clause defines what this query is looking for:

    - an ``AddExpr``: the expression that is being checked for overflow.
    - a ``RelationalOperation``: the overflow comparison check.
    - a ``Variable``: used as an argument to both the addition and comparison.

  - The ``where`` part of the query ties these three variables together using `predicates <https://codeql.github.com/docs/ql-language-reference/predicates/>`__ defined in the `standard CodeQL for C/C++ library <https://codeql.github.com/codeql-standard-libraries/cpp/>`__.

CodeQL query: bad overflow guards
=================================

We want to ensure the operands being added have size less than 4 bytes.

We may want to reuse this logic, so let us create a separate predicate.

Looking at autocomplete suggestions, we see that we can get the type of an expression using the ``getType()`` method.

We can get the size (in bytes) of a type using the ``getSize()`` method.

.. rst-class:: build

.. code-block:: ql

  predicate isSmall(Expr e) {
    e.getType().getSize() < 4
  }

.. note::

  - An important part of the query is to determine whether a given expression has a “small” type that is going to trigger integer promotion.
  - We therefore write a helper predicate for small expressions.
  - This predicate effectively represents the set of all expressions in the database where the size of the type of the expression is less than 4 bytes, that is, less than 32-bits.

CodeQL query: bad overflow guards
==================================

We can ensure the operands being added have size less than 4 bytes, using our new predicate.

QL has logical quantifiers like ``exists`` and ``forall``, allowing us to declare variables and enforce a certain condition on them.

Now our query becomes:

.. rst-class:: build

.. literalinclude:: ../query-examples/cpp/bad-overflow-guard-2.ql
   :language: ql

.. note::

  - Recall from earlier that what makes an overflow check a “bad” check is that all the arguments to the addition are integers smaller than 32-bits.
  - We could write this by using our helper predicate ``isSmall`` to specify that each individual operand to the addition ``isSmall`` (that is under 32-bits):

    .. code-block:: ql
  
      isSmall(a.getLeftOperand()) and
      isSmall(a.getRightOperand())

  - However, this is a little bit repetitive. What we really want to say is that: all the operands of the addition are small. Fortunately, QL provides a ``forall`` formula that we can use in these circumstances.
  - A ``forall`` has three parts:

    - A “declaration” part, where we can introduce variables.
    - A “range” part, which allows us to restrict those variables.
    - A “condition” part. The ``forall`` as a whole holds if the condition holds for each of the values in the range.
  - In our case:

    - The declaration introduces a variable for expressions, called ``op``. At this stage, this variable represents all the expressions in the program.
    - The “range” part, ``op = a.getAnOperand()``,  restricts ``op`` to being one of the two operands to the addition.
    - The “condition” part, ``isSmall(op)``, says that the ``forall`` holds only if the condition (that the ``op`` is small) holds for everything in the range–that is, both the arguments to the addition.

CodeQL query: bad overflow guards
=================================

Sometimes the result of the addition is cast to a small type of size less than 4 bytes, preventing automatic widening. We don’t want our query to flag these instances.

We can use predicate ``Expr.getExplicitlyConverted()`` to reason about casts that are applied to an expression, adding  this restriction to our query:

.. code-block:: ql

   not isSmall(a.getExplicitlyConverted())

The final query
===============

.. literalinclude:: ../query-examples/cpp/bad-overflow-guard-3.ql
   :language: ql

This query finds a single result in our historic database, which was `a genuine bug in ChakraCore <https://github.com/Chakra-Core/ChakraCore//commit/2500e1cdc12cb35af73d5c8c9b85656aba6bab4d>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/slide-snippets/global-data-flow.rst
Information flow
================

- Many security problems can be phrased as an information flow problem:

  Given a (problem-specific) set of sources and sinks, is there a path in the data flow graph from some source to some sink?

- Some examples:

  - SQL injection: sources are user-input, sinks are SQL queries
  - Reflected XSS: sources are HTTP requests, sinks are HTTP responses

- We can solve such problems using the data flow and taint tracking libraries.

Global data flow and taint tracking
===================================

- Recap:

  - Local (“intra-procedural”) data flow models flow within one function; feasible to compute for all functions in a CodeQL database
  - Global (“inter-procedural”) data flow models flow across function calls; not feasible to compute for all functions in a CodeQL database

- For global data flow (and taint tracking), we must therefore provide restrictions to ensure the problem is tractable.
- Typically, this involves specifying the *source* and *sink*.

.. note::

  As we mentioned in the previous slide deck, while local data flow is feasible to compute for all functions in a CodeQL database, global data flow is not. This is because the number of paths becomes exponentially larger for global data flow.

  The global data flow (and taint tracking) avoids this problem by requiring that the query author specifies which ``sources`` and ``sinks`` are applicable. This allows the implementation to compute paths between the restricted set of nodes, rather than the full graph.

Global taint tracking library
=============================

The ``semmle.code.<language>.dataflow.TaintTracking`` library provides a framework for implementing solvers for global taint tracking problems:

  #. Implement ``DataFlow::ConfigSig`` and use ``TaintTracking::Global`` following this template:

     .. code-block:: ql
    
       module Config implements DataFlow::ConfigSig {
         predicate isSource(DataFlow::Node nd) { ... }
         predicate isSink(DataFlow::Node nd) { ... }
       }
       module Flow = TaintTracking::Global<Config>;

  #. Use ``Flow::flow(source, sink)`` to find inter-procedural paths.

.. note::

  In addition to the taint tracking flow configuration described here, there is also an equivalent *data flow* in ``semmle.code.<language>.dataflow.DataFlow``, ``DataFlow::Global<DataFlow::ConfigSig>``. Data flow is used to track whether the exact value produced by a source is used by a sink, whereas taint tracking is used to determine whether the source may influence the value used at the sink. Whether you use taint tracking or data flow depends on the analysis problem you are trying to solve.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/slide-snippets/local-data-flow.rst
Data flow analysis
==================

- Models flow of data through the program.
- Implemented in the module ``semmle.code.<lang>.dataflow.DataFlow``.
- Class ``DataFlow::Node`` represents program elements that have a value, such as expressions and function parameters.

  - Nodes of the data flow graph.

- Various predicates represent flow between these nodes.
  
  - Edges of the data flow graph.

.. note::

  The solution here is to use *data flow*. Data flow is, as the name suggests, about tracking the flow of data through the program. It helps answers questions like: *does this expression ever hold a value that originates from a particular other place in the program*?

  We can visualize the data flow problem as one of finding paths through a directed graph, where the nodes of the graph are elements in program, and the edges represent the flow of data between those elements. If a path exists, then the data flows between those two edges.

Data flow graphs
================

.. container:: column-left

   Example:

   .. code-block:: cpp

      int func(int tainted) {
         int x = tainted;
         if (someCondition) {
           int y = x;
           callFoo(y);
         } else {
           return x;
         }
         return -1;
      }
 
.. container:: column-right

  Data flow graph:
   
      .. graphviz::
         
            digraph {
            graph [ dpi = 1000 ]
            node [shape=polygon,sides=4,color=blue4,style="filled,rounded",   fontname=consolas,fontcolor=white]
            a [label=<tainted<BR /><FONT POINT-SIZE="10">ParameterNode</FONT>>]
            b [label=<tainted<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]
            c [label=<x<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]
            d [label=<x<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]
            e [label=<y<BR /><FONT POINT-SIZE="10">ExprNode</FONT>>]
   
            a -> b
            b -> {c, d}
            c -> e
   
         }

Local vs global data flow
=========================

- Local (“intra-procedural”) data flow models flow within one function; feasible to compute for all functions in a CodeQL database
- Global (“inter-procedural”) data flow models flow across function calls; not feasible to compute for all functions in a CodeQL database
- Different APIs, so discussed separately
- This slide deck focuses on the former

.. note::

  For further information, see:

  - `About data flow analysis <https://codeql.github.com/docs/writing-codeql-queries/about-data-flow-analysis/>`__

.. rst-class:: background2

Local data flow
===============

Importing data flow
===================

To use the data flow library, add the following import:

.. code-block:: ql

   import semmle.code.<language>.dataflow.DataFlow

**Note**: this library contains an explicit “module” declaration:

.. code-block:: ql

   module DataFlow {
     class Node extends ... { ... }
     predicate localFlow(Node source, Node sink) {
               localFlowStep*(source, sink)
            }
     ... 
   }

So all references will need to be qualified (that is, ``DataFlow::Node``)

.. note::

  A **query library** is file with the extension ``.qll``. Query libraries do not contain a query clause, but may contain modules, classes, and predicates. 
  For further information on the data flow libraries, see the following links:

  - `Java data flow library <https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/dataflow/DataFlow.qll/module.DataFlow.html>`__
  - `C/C++ data flow library <https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/dataflow/DataFlow.qll/module.DataFlow.html>`__
  - `C# data flow library <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/dataflow/DataFlow.qll/module.DataFlow.html>`__

  A **module** is a way of organizing QL code by grouping together related predicates, classes, and (sub-)modules. They can be either explicitly declared or implicit. A query library implicitly declares a module with the same name as the QLL file.

  For further information on libraries and modules in QL, see the chapter on `Modules <https://codeql.github.com/docs/ql-language-reference/modules/>`__ in the QL language reference.
  For further information on importing QL libraries and modules, see the chapter on `Name resolution <https://codeql.github.com/docs/ql-language-reference/name-resolution/>`__ in the QL language reference.

Data flow graph
===============

- Class ``DataFlow::Node`` represents data flow graph nodes
- Predicate ``DataFlow::localFlowStep`` represents local data flow graph edges, ``DataFlow::localFlow`` is its transitive closure
- Data flow graph nodes are *not* AST nodes, but they correspond to AST nodes, and there are predicates for mapping between them:

  - ``Expr Node.asExpr()``
  - ``Parameter Node.asParameter()``
  - ``DataFlow::Node DataFlow::exprNode(Expr e)``
  - ``DataFlow::Node DataFlow::parameterNode(Parameter p)``
  - ``etc.``

.. note::

  The ``DataFlow::Node`` class is shared between both the local and global data flow graphs–the primary difference is the edges, which in the “global” case can link different functions.

  ``localFlowStep`` is the “single step” flow relation–that is, it describes single edges in the local data flow graph. ``localFlow`` represents the `transitive <https://codeql.github.com/docs/ql-language-reference/recursion/#transitive-closures>`__ closure of this relation–in other words, it contains every pair of nodes where the second node is reachable from the first in the data flow graph.

  The data flow graph is separate from the `AST <https://en.wikipedia.org/wiki/Abstract_syntax_tree>`__, to allow for flexibility in how data flow is modeled. There are a small number of data flow node types–expression nodes, parameter nodes, uninitialized variable nodes, and definition by reference nodes. Each node provides mapping functions to and from the relevant AST (for example ``Expr``, ``Parameter`` etc.) or symbol table (for example ``Variable``) classes.

Taint tracking
==============

- Usually, we want to generalise slightly by not only considering plain data flow, but also “taint” propagation, that is, whether a value is influenced by or derived from another.

- Examples:

  .. code-block:: java
  
    sink = source;        // source -> sink: data and taint
    strcat(sink, source); // source -> sink: taint, not data

- Library ``semmle.code.<language>.dataflow.TaintTracking`` provides predicates for tracking taint; ``TaintTracking::localTaintStep`` represents one (local) taint step, ``TaintTracking::localTaint`` is its transitive closure.

.. note::

  Taint tracking can be thought of as another type of data flow graph. It usually extends the standard data flow graph for a problem by adding edges between nodes where one one node influences or *taints* another.

  The taint-tracking API is almost identical to that of the local data flow. All we need to do to switch to taint tracking is ``import semmle.code.<language>.dataflow.TaintTracking`` instead of ``semmle.code.<language>.dataflow.DataFlow``, and instead of using ``localFlow``, we use ``localTaint``.
  
  - `Java taint-tracking library <https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/dataflow/TaintTracking.qll/module.TaintTracking.html>`__ 
  - `C/C++ taint-tracking library <https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/dataflow/TaintTracking.qll/module.TaintTracking.html>`__ 
  - `C# taint-tracking library <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/dataflow/TaintTracking.qll/module.TaintTracking.html>`__ 



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/slide-snippets/intro-ql-general.rst
A few years ago, somewhere between Earth and Mars...
====================================================

Crashing bug found in Curiosity’s landing module through routine testing.

Patching is still possible mid-flight, but what if there are more such issues?

.. container:: image-box

   .. image:: ../_static-training/curiosity2.png
   
.. note::

   When the Curiosity Rover was on its way to Mars in 2012, a flight software developer at NASA JPL discovered a mission-critical bug through manual code review. The problem occurred in Curiosity’s Entry, Descent, and Landing software–the software responsible for the Rover’s descent through the Martian atmosphere and landing it safely on the surface. of Mars.

   The bug, which had gone undetected by traditional solutions, was likely to prevent the capsule’s parachutes from opening, resulting in the Rover crashing onto the red planet’s rocky surface.
   
Zoom in on the code...
======================

(For illustration only, not actually NASA code!)

.. code-block:: cpp
   :emphasize-lines: 1,7

   void fire_thrusters(double vectors[12]) {
     for (int i = 0; i < 12 i++) {
       ... vectors[i] ...
     }
   }
   double thruster[3] = ... ;
   fire_thrusters(thruster);

- In C, array types of parameters degrade to pointer types.
- The size is ignored!
- No protection from passing a mismatched array.

.. note::

  The problem stems from a peculiarity of the C language. 
  You can declare parameters to have array types (with stated sizes), but that means nothing: the parameter type “degrades” to a raw pointer type with no size information.

  The pseudocode in the slide illustrates this. 
  The function is declared to take an array of length 12 (presumably three data points for each thruster). 
  However, there’s no bounds checking, and a developer might call it with an array that’s too short, holding direction information for only one of the thrusters. 
  The function will then read past the end of the array, and unpredictable results occur.

Write a query...
================

...to find all instances of the problem.

Complete text of the analysis (nothing left out!):

.. code-block:: ql

  import cpp

  from Function f, FunctionCall c, int i, int a, int b
  where f = c.getTarget()
    and a = c.getArgument(i).getType().(ArrayType).getArraySize()
    and b = f.getParameter(i).getType().(ArrayType).getArraySize()
    and a < b
  select c.getArgument(i), "Array of size " + a
         + " passed to $@, which expects an array of size " + b + ".",
         f, f.getName()

.. note::
 
  Once the mission critical bug was discovered on Curiosity, JPL contacted Semmle for help discovering whether variants of the problem might exist elsewhere in the Curiosity control software.  In 20 minutes, research engineers from Semmle produced a CodeQL query and shared it with the JPL team. It finds all functions that are passed an array as an argument whose size is smaller than expected.

  (The goal here is not to fully understand the query, but to illustrate the power of the language and its standard libraries.)


Find all instances!
===================

- When applied to the code, the query found the original bug and around 30 others.

- Three of those were in the same entry, descent and landing module.

- All were fixed with a mid-flight patch.

.. note::

  The JPL team ran the query across the full Curiosity control software–it identified the original problem, and more than 30 other variants, of which three were in the critical Entry, Descent, and Landing module. 

  The team addressed all issues, and patched the firmware remotely. Not long after, the Curiosity Rover landed safely on Mars.

.. rst-class:: background2

How it all works
================

Analysis overview
=================

.. rst-class:: analysis

   .. image:: ../_static-training/analysis-overview.png
         
.. note::

  CodeQL analysis works by extracting a queryable database from your project. For compiled languages, the tools observe an ordinary build of the source code. Each time a compiler is invoked to process a source file, a copy of that file is made, and all relevant information about the source code (syntactic data about the abstract syntax tree, semantic data like name binding and type information, data on the operation of the C preprocessor, etc.) is collected. For interpreted languages, the extractor gathers similar information by running directly on the source code. Multi-language code bases are analyzed one language at a time.

  Once the extraction finishes, all this information is collected into a single `CodeQL database <https://codeql.github.com/docs/codeql-overview/about-codeql/#about-codeql-databases>`__, which is then ready to query, possibly on a different machine. A copy of the source files, made at the time the database was created, is also included in the CodeQL database so analysis results can be displayed at the correct location in the code. The database schema is (source) language specific.

  Queries are written in QL and usually depend on one or more of the `standard CodeQL libraries <https://github.com/github/codeql>`__ (and of course you can write your own custom libraries). They are compiled into an efficiently executable format by the QL compiler and then run on a CodeQL database by the QL evaluator, either on a remote worker machine or locally on a developer’s machine.

  Query results can be interpreted and presented in a variety of ways, including displaying them in CodeQL for Visual Studio Code.

Introducing QL
==============

QL is the query language running all CodeQL analysis.

QL is:

- a **logic** language based on first-order logic
- a **declarative** language without side effects
- an **object-oriented** language
- a **query** language working on a read-only CodeQL database
- equipped with rich standard libraries **for program analysis**

.. note::

  QL is the high-level, object-oriented logic language that underpins all CodeQL libraries and analyses. You can learn lots more about QL by visiting the `QL language reference <https://codeql.github.com/docs/ql-language-reference/>`__.
  The key features of QL are:
  
  - All common logic connectives are available, including quantifiers like ``exist``, which can also introduce new variables. 
  - The language is declarative–the user focuses on stating what they would like to find, and leaves the details of how to evaluate the query to the engine. 
  - The object-oriented layer allows us to develop rich standard libraries for program analysis. These model the common AST node types, control flow and name lookup, and define further layers on top–for example control flow or data flow analysis. The `standard CodeQL libraries and queries <https://github.com/github/codeql>`__ ship as source and can be inspected by the user, and new abstractions are readily defined.
  - The database generated by the CodeQL tools is treated as read-only; queries cannot insert new data into it, though they can inspect its contents in various ways.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/slide-snippets/abstract-syntax-tree.rst
Abstract syntax trees
=====================

The basic representation of an analyzed program is an *abstract syntax tree (AST)*.

.. container:: column-left

   .. code-block:: java
   
     try {
         ...
     } catch (AnException e) {
     }

.. container:: ast-graph
     
      .. graphviz::
         
            digraph {
            graph [ dpi = 1000 ]
            node [shape=polygon,sides=4,color=blue4,style="filled,rounded",   fontname=consolas,fontcolor=white]
            a [label=<TryStmt>]
            b [label=<CatchClause>]
            c [label=<...>,color=white,fontcolor=black]
            d [label=<LocalVariable<BR />DeclExpr>]
            e [label=<...>,color=white,fontcolor=black]
            f [label=<...>,color=white,fontcolor=black]
            g [label=<...>,color=white,fontcolor=black]
   
            a -> {b, c}
            b -> {d, e}
            d -> {f, g}
         }


.. note::

  When writing queries it is important to have in mind the underlying representation of the program which is stored in the database. Typically queries make use of the “AST” representation of the program - a tree structure where program elements are nested within other program elements.

  The following topics contain overviews of the important AST classes and CodeQL libraries for C/C++, C#, and Java: 
  
  - `CodeQL library for C/C++ <https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-cpp/>`__ 
  - `CodeQL library for C# <https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-csharp/>`__
  - `CodeQL library for Java <https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-java/>`__  


Database representations of ASTs
================================

AST nodes and other program elements are encoded in the database as *entity values*. Entities are implemented as integers, but in QL they are opaque---all one can do with them is to check their equality.

Each entity belongs to an entity type. Entity types have names starting with “@” and are defined in the database schema (not in QL).

Properties of AST nodes and their relationships to each other are encoded by database relations, which are predicates defined in the database (not in QL).

Entity types are rarely used directly, the usual pattern is to define a class that extends the type and exposes properties of its entities through member predicates.

.. note::

  ASTs are a typical example of the kind of data representation one finds in object-oriented programming, with data-carrying nodes that reference each other. At first glance, QL, which can only work with atomic values, does not seem to be well suited for working with this kind of data. However, ultimately all that we require of the nodes in an AST is that they have an identity. The relationships among nodes, usually implemented by reference-valued object fields in other languages, can just as well (and arguably more naturally) be represented as relations over nodes. Attaching data (such as strings or numbers) to nodes can also be represented with relations over nodes and primitive values. All we need is a way for relations to reference nodes. This is achieved in QL (as in other database languages) by means of *entity values* (or entities, for short), which are opaque atomic values, implemented as integers under the hood.

  It is the job of the extractor to create entity values for all AST nodes and populate database relations that encode the relationship between AST nodes and any values associated with them. These relations are *extensional*, that is, explicitly stored in the database, unlike the relations described by predicates, which we also refer to as *intensional* relations. Entity values belong to *entity types*, whose name starts with “@” to set them apart from primitive types and classes.

  The interface between entity types and extensional relations on the one hand and QL predicates and classes on the other hand is provided by the *database schema*, which defines the available entity types and the schema of each extensional relation, that is, how many columns the relation has, and which entity type or primitive type the values in each column come from. QL programs can refer to entity types and extensional relations just as they would refer to QL classes and predicates, with the restriction that entity types cannot be directly selected in a ``select`` clause, since they do not have a well-defined string representation.

  For example, the database schemas for C/++, C#, and Java CodeQL databases are here: 
  
  - https://github.com/github/codeql/blob/main/cpp/ql/lib/semmlecode.cpp.dbscheme 
  - https://github.com/github/codeql/blob/main/csharp/ql/lib/semmlecode.csharp.dbscheme 
  - https://github.com/github/codeql/blob/main/java/ql/lib/config/semmlecode.dbscheme 


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/slide-snippets/path-queries.rst
Path queries
============

Path queries provide information about the identified paths from sources to sinks. Paths can be examined in the Path Explorer view.

Use this template:

.. code-block:: ql

   /**
    * ... 
    * @kind path-problem
    */
   
   import semmle.code.<language>.dataflow.TaintTracking

   ...

   module Flow = TaintTracking::Global<Configuration>;
   import Flow::PathGraph

   from Flow::PathNode source, Flow::PathNode sink
   where Flow::flowPath(source, sink)
   select sink, source, sink, "<message>"

.. note::

  To see the paths between the source and the sinks, we can convert the query to a path problem query. There are a few minor changes that need to be made for this to work–we need an additional import, to specify ``PathNode`` rather than ``Node``, and to add the source/sink to the query output (so that we can automatically determine the paths).



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/ql-training/slide-snippets/global-data-flow-extra-slides.rst
Exercise: How not to do global data flow
========================================

Implement a ``flowStep`` predicate extending ``localFlowStep`` with steps through function calls and returns. Why might we not want to use this?

.. code-block:: ql

   predicate stepIn(Call c, DataFlow::Node arg, DataFlow::ParameterNode parm) {
     exists(int i | arg.asExpr() = c.getArgument(i) |
       parm.asParameter() = c.getTarget().getParameter(i))
   }
   
   predicate stepOut(Call c, DataFlow::Node ret, DataFlow::Node res) {
     exists(ReturnStmt retStmt | retStmt.getEnclosingFunction() = c.getTarget() |
       ret.asExpr() = retStmt.getExpr() and res.asExpr() = c)
   }
   
   predicate flowStep(DataFlow::Node pred, DataFlow::Node succ) {
     DataFlow::localFlowStep(pred, succ) or
     stepIn(_, pred, succ) or
     stepOut(_, pred, succ)
   }

.. rst-class:: mismatched-calls-and-returns

Mismatched calls and returns
============================

.. diagram copied from google slides

Balancing calls and returns
===========================

- If we simply take ``flowStep*``, we might mismatch calls and returns, causing imprecision, which in turn may cause false positives.

- Instead, make sure that matching ``stepIn``/``stepOut`` pairs talk about the same call site:

.. code-block:: ql

   predicate balancedPath(DataFlow::Node src, DataFlow::Node snk) {
     src = snk or DataFlow::localFlowStep(src, snk) or
     exists(DataFlow::Node m | balancedPath(src, m) | balancedPath(m, snk)) or
     exists(Call c, DataFlow::Node parm, DataFlow::Node ret |
       stepIn(c, src, parm) and
       balancedPath(parm, ret) and
       stepOut(c, ret, snk)
     )
   }

Summary-based global data flow
==============================

- To avoid traversing the same paths many times, we compute function summaries that record if a function parameter flows into a return value:

   .. code-block:: ql
   
      predicate returnsParameter(Function f, int i) {
        exists (Parameter p, ReturnStmt retStmt, Expr ret |
          p = f.getParameter(i) and
          retStmt.getEnclosingFunction() = f and
          ret = retStmt.getExpr() and
          balancedPath(DataFlow::parameterNode(p), DataFlow::exprNode(ret))
        )
      }

- Use this predicate in ``balancedPath`` instead of ``stepIn``/``stepOut`` pairs.




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/index.rst
.. _writing-codeql-queries:

Writing CodeQL queries
======================

Get to know more about queries and learn some key query-writing skills by solving puzzles.

- :ref:`CodeQL queries <codeql-queries>`: CodeQL queries are used in code scanning analyses to find problems in source code, including potential security vulnerabilities.

- :ref:`QL tutorials <ql-tutorials>`: Solve puzzles to learn the basics of QL before you analyze code with CodeQL. The tutorials teach you how to write queries and introduce you to key logic concepts along the way.

.. toctree::
   :hidden:

   codeql-queries
   ql-tutorials



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/codeql-queries.rst
.. _codeql-queries:

CodeQL queries
##############

CodeQL queries are used in code scanning analyses to find problems in source code, including potential security vulnerabilities.

.. toctree::
   :hidden:

   about-codeql-queries
   metadata-for-codeql-queries
   query-help-files
   defining-the-results-of-a-query
   providing-locations-in-codeql-queries
   about-data-flow-analysis
   creating-path-queries
   troubleshooting-query-performance
   debugging-data-flow-queries-using-partial-flow

- :doc:`About CodeQL queries <about-codeql-queries>`: CodeQL queries are used to analyze code for issues related to security, correctness, maintainability, and readability. 
- :doc:`Metadata for CodeQL queries <metadata-for-codeql-queries>`: Metadata tells users important information about CodeQL queries. You must include the correct query metadata in a query to be able to view query results in source code.
- :doc:`Query help files <query-help-files>`: Query help files tell users the purpose of a query, and recommend how to solve the potential problem the query finds.
- :doc:`Defining the results of a query <defining-the-results-of-a-query>`: You can control how analysis results are displayed in source code by modifying a query's ``select`` statement.
- :doc:`Providing locations in CodeQL queries <providing-locations-in-codeql-queries>`: CodeQL includes mechanisms for extracting the location of elements in a codebase. Use these mechanisms when writing custom CodeQL queries and libraries to help display information to users.
- :doc:`About data flow analysis <about-data-flow-analysis>`: Data flow analysis is used to compute the possible values that a variable can hold at various points in a program, determining how those values propagate through the program and where they are used. 
- :doc:`Creating path queries <creating-path-queries>`: You can create path queries to visualize the flow of information through a codebase.
- :doc:`Troubleshooting query performance <troubleshooting-query-performance>`: Improve the performance of your CodeQL queries by following a few simple guidelines.
- :doc:`Debugging data-flow queries using partial flow <debugging-data-flow-queries-using-partial-flow>`: If a data-flow query doesn't produce the results you expect to see, you can use partial flow to debug the problem..



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/defining-the-results-of-a-query.rst
.. _defining-the-results-of-a-query:

Defining the results of a query
===============================

You can control how analysis results are displayed in source code by modifying a query's ``select`` statement.

About query results
-------------------

The information contained in the results of a query is controlled by the ``select`` statement. Part of the process of developing a useful query is to make the results clear and easy for other users to understand.
When you write your own queries in the CodeQL `extension for VS Code <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__ there are no constraints on what can be selected.
However, if you want to use a query to create alerts for code scanning or generate valid analysis results using the `CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__, you'll need to make the ``select`` statement report results in the required format. 
You must also ensure that the query has the appropriate metadata properties defined. 
This topic explains how to write your select statement to generate helpful analysis results. 

Overview
--------

Alert queries must have the property ``@kind problem`` defined in their metadata. For more information, see ":doc:`Metadata for CodeQL queries <metadata-for-codeql-queries>`." 
In their most basic form, the ``select`` statement must select two 'columns':

-  **Element**—a code element that's identified by the query. This defines the location of the alert.
-  **String**—a message to display for this code element, describing why the alert was generated.

If you look at some of the existing queries, you'll see that they can select extra element/string pairs, which are combined with ``$@`` placeholder markers in the message to form links. For example, `Dereferenced variable may be null <https://github.com/github/codeql/blob/95e65347cafe502bbd0d9f48d1175fd3d66e0459/java/ql/src/Likely%20Bugs/Nullness/NullMaybe.ql>`__ (Java), or `Duplicate switch case <https://github.com/github/codeql/blob/95e65347cafe502bbd0d9f48d1175fd3d66e0459/javascript/ql/src/Expressions/DuplicateSwitchCase.ql>`__ (JavaScript). 

.. pull-quote::

    Note

    An in-depth discussion of ``select`` statements for path queries is not included in this topic. However, you can develop the string column of the ``select`` statement in the same way as for alert queries. For more specific information about path queries, see ":doc:`Creating path queries <creating-path-queries>`."

Developing a select statement
-----------------------------

Here's a simple query to find Java classes that extend other classes.

Basic select statement
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: ql

    /**
     * @kind problem
     */
    
    import java
    
    from Class c, Class superclass
    where superclass = c.getASupertype()
    select c, "This class extends another class."

This basic select statement has two columns:

#. An element with a location to display the alert on: ``c`` corresponds to ``Class``.
#. String message to display: ``"This class extends another class."``

.. image:: ../images/ql-select-statement-basic.png
   :alt: Results of basic select statement
   :class: border

Including the name of the superclass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The alert message defined by the basic select statement is constant and doesn't give users much information. Since the query identifies the superclass, it's easy to include its name in the string message. For example:

.. code-block:: ql

   select c, "This class extends the class " + superclass.getName()

#. Element: ``c`` as before.
#. String message: ``"This class extends the class "``—the string text is combined with the class name for the ``superclass``, returned by ``getName()``.

.. image:: ../images/ql-select-statement-class-name.png
   :alt: Results of extended select statement
   :class: border

While this is more informative than the original select statement, the user still needs to find the superclass manually.

Adding a link to the superclass
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use placeholders in the text of alert messages to insert additional information, such as links to the superclass. Placeholders are defined using ``$@``, and filled using the information in the next two columns of the select statement. For example, this select statement returns four columns:

.. code-block:: ql

   select c, "This class extends the class $@.", superclass, superclass.getName()

#. Element: ``c`` as before.
#. String message: ``"This class extends the class $@."``—the string text now includes a placeholder, which will display the combined content of the next two columns.
#. Element for placeholder: the ``superclass``.
#. String text for placeholder: the class name returned by ``superclass.getBaseName()``.

When the alert message is displayed, the ``$@`` placeholder is replaced by a link created from the contents of the third and fourth columns defined by the ``select`` statement. In this example, the link target will be the location of the superclass's definition, and the link text will be its name. Note that some superclasses, such as ``Object``, will not be in the database, since they are built in to the Java language. Clicking those links will have no effect.

If you use the ``$@`` placeholder marker multiple times in the description text, then the ``N``\ th use is replaced by a link formed from columns ``2N+2`` and ``2N+3``. If there are more pairs of additional columns than there are placeholder markers, then the trailing columns are ignored. Conversely, if there are fewer pairs of additional columns than there are placeholder markers, then the trailing markers are treated as normal text rather than placeholder markers.

.. image:: ../images/ql-select-statement-link.png
   :alt: Results including links
   :class: border

Further reading
---------------

- `CodeQL repository <https://github.com/github/codeql>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/query-help-files.rst
.. _query-help-files:

Query help files
****************

Query help files tell users the purpose of a query, and recommend how to solve the potential problem the query finds.

This topic provides detailed information on the structure of query help files. 
For more information about how to write useful query help in a style that is consistent with the standard CodeQL queries, see the `Query help style guide <https://github.com/github/codeql/blob/main/docs/query-help-style-guide.md>`__ on GitHub.


.. pull-quote::

   Note
 
   You can access the query help for CodeQL queries by visiting `CodeQL query help <https://codeql.github.com/codeql-query-help>`__.
   You can also access the raw query help files in the `GitHub repository <https://github.com/github/codeql>`__.
   For example, see the `JavaScript/TypeScript security queries <https://github.com/github/codeql/tree/main/javascript/ql/src/Security>`__ and `C/C++ critical queries <https://github.com/github/codeql/tree/main/cpp/ql/src/Critical>`__. 
      
Overview
========

Each query help file provides detailed information about the purpose and use of a query. When you write your own queries, we recommend that you also write query help files so that other users know what the queries do, and how they work.

Structure
=========

Query help files are written using a custom XML format, and stored in a file with a ``.qhelp`` extension. Query help files must have the same base name as the query they describe, and must be located in the same directory. The basic structure is as follows:

.. code-block:: xml

   <!DOCTYPE qhelp SYSTEM "qhelp.dtd">
   <qhelp>
       CONTAINS one or more section-level elements 
   </qhelp>

The header and single top-level ``qhelp`` element are both mandatory. 
The following sections explain additional elements that you may include in your query help files.

.. pull-quote::

   Code scanning does not process ``.qhelp`` files for custom CodeQL queries, so to show 
   query help for custom queries in the code scanning UI you must convert the ``.qhelp`` files to markdown 
   and then include the markdown-rendered query help in SARIF files generated during an analysis.
   For more information, see 
   "`Analyzing databases with the CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/analyzing-databases-with-the-codeql-cli#including-query-help-for-custom-codeql-queries-in-sarif-files>`__." 

Section-level elements
======================

Section-level elements are used to group the information in the help file into sections. Many sections have a heading, either defined by a ``title`` attribute or a default value. The following section-level elements are optional child elements of the ``qhelp`` element.

+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| Element            | Attributes                              | Children               | Purpose of section                                                                                                                            |
+====================+=========================================+========================+===============================================================================================================================================+
| ``example``        | None                                    | Any block element      | Demonstrate an example of code that violates the rule implemented by the query with guidance on how to fix it. Default heading.               |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``fragment``       | None                                    | Any block element      | See ":ref:`Query help inclusion <qhelp-inclusion>`" below. No heading.                                                                        |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``hr``             | None                                    | None                   | A horizontal rule. No heading.                                                                                                                |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``include``        | ``src`` The query help file to include. | None                   | Include a query help file at the location of this element. See ":ref:`Query help inclusion <qhelp-inclusion>`" below. No heading.             |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``overview``       | None                                    | Any block element      | Overview of the purpose of the query. Typically this is the first section in a query document. No heading.                                    |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``recommendation`` | None                                    | Any block element      | Recommend how to address any alerts that this query identifies. Default heading.                                                              |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``references``     | None                                    | ``li`` elements        | Reference list. Typically this is the last section in a query document. Default heading.                                                      |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``section``        | ``title`` Title of the section          | Any block element      | General-purpose section with a heading defined by the ``title`` attribute.                                                                    |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| ``semmleNotes``    | None                                    | Any block element      | Implementation notes about the query. This section is used only for queries that implement a rule defined by a third party. Default heading.  |
+--------------------+-----------------------------------------+------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+

Block elements
==============

The following elements are optional child elements of the ``section``, ``example``, ``fragment``, ``recommendation``, ``overview``, and ``semmleNotes`` elements.

.. table::
   :widths: 7 20 10 25

   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | Element        | Attributes                                               | Children           | Purpose of block                                                                                                                                                                                                                                                                                          |
   +================+==========================================================+====================+===========================================================================================================================================================================================================================================================================================================+
   | ``blockquote`` | None                                                     | Any block element  | Display a quoted paragraph.                                                                                                                                                                                                                                                                               |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``img``        | | ``src`` The image file to include.                     | None               | Display an image. The content of the image is in a separate image file.                                                                                                                                                                                                                                   |
   |                | | ``alt`` Text for the image's alt text.                 |                    |                                                                                                                                                                                                                                                                                                           |
   |                | | ``height`` Optional, height of the image.              |                    |                                                                                                                                                                                                                                                                                                           |
   |                | | ``width`` Optional, the width of the image.            |                    |                                                                                                                                                                                                                                                                                                           |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``include``    | ``src`` The query help file to include.                  | None               | Include a query help file at the location of this element. See :ref:`Query help inclusion <qhelp-inclusion>` below for more information.                                                                                                                                                                  |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``ol``         | None                                                     | ``li``             | Display an ordered list. See List elements below.                                                                                                                                                                                                                                                         |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``p``          | None                                                     | Any inline content | Display a paragraph, used as in HTML files.                                                                                                                                                                                                                                                               |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``pre``        | None                                                     | Text               | Display text in a monospaced font with preformatted whitespace.                                                                                                                                                                                                                                           |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``sample``     | | ``language`` The language of the in-line code sample.  | Text               | Display sample code either defined as nested text in the ``sample`` element or defined in the ``src`` file specified. When ``src`` is specified, the language is inferred from the file extension. If ``src`` is omitted, then language must be provided and the sample code provided as nested text.     |
   |                | | ``src`` Optional, the file containing the sample code. |                    |                                                                                                                                                                                                                                                                                                           |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``table``      | None                                                     | ``tbody``          | Display a table. See Tables below.                                                                                                                                                                                                                                                                        |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``ul``         | None                                                     | ``li``             | Display an unordered list. See List elements below.                                                                                                                                                                                                                                                       |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | ``warning``    | None                                                     | Text               | Display a warning that will be displayed very visibly on the resulting page. Such warnings are sometimes used on queries that are known to have low precision for many code bases; such queries are often disabled by default.                                                                            |
   +----------------+----------------------------------------------------------+--------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   
List elements
=============

Query help files support two types of block elements for lists: ``ul`` and ``ol``. Both block elements support only one child elements of the type ``li``. Each ``li`` element contains either inline content or a block element.

Table elements
==============

The ``table`` block element is used to include a table in a query help file. Each table includes a number of rows, each of which includes a number of cells. The data in the cells will be rendered as a grid.

+-----------+------------+--------------------+-------------------------------------------+
| Element   | Attributes | Children           | Purpose                                   |
+===========+============+====================+===========================================+
| ``tbody`` | None       | ``tr``             | Defines the top-level element of a table. |
+-----------+------------+--------------------+-------------------------------------------+
| ``tr``    | None       | | ``th``           | Defines one row of a table.               |
|           |            | | ``td``           |                                           |
+-----------+------------+--------------------+-------------------------------------------+
| ``td``    | None       | Any inline content | Defines one cell of a table row.          |
+-----------+------------+--------------------+-------------------------------------------+
| ``th``    | None       | Any inline content | Defines one header cell of a table row.   |
+-----------+------------+--------------------+-------------------------------------------+

Inline content
==============

Inline content is used to define the content for paragraphs, list items, table cells, and similar elements. Inline content includes text in addition to the inline elements defined below:

+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| Element    | Attributes                           | Children       | Purpose                                                                                          |
+============+======================================+================+==================================================================================================+
| ``a``      | ``href`` The URL of the link.        | text           | Defines hyperlink. When a user selects the child text, they will be redirected to the given URL. |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``b``      | None                                 | Inline content | Defines content that should be displayed as bold face.                                           |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``code``   | None                                 | Inline content | Defines content representing code. It is typically shown in a monospace font.                    |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``em``     | None                                 | Inline content | Defines content that should be emphasized, typically by italicizing it.                          |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``i``      | None                                 | Inline content | Defines content that should be displayed as italics.                                             |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``img``    | | ``src``                            | None           | Display an image. See the description above in Block elements.                                   |
|            | | ``alt``                            |                |                                                                                                  |
|            | | ``height``                         |                |                                                                                                  |
|            | | ``width``                          |                |                                                                                                  |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``strong`` | None                                 | Inline content | Defines content that should be rendered more strongly, typically using bold face.                |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``sub``    | None                                 | Inline content | Defines content that should be rendered as subscript.                                            |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``sup``    | None                                 | Inline content | Defines content that should be rendered as superscript.                                          |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+
| ``tt``     | None                                 | Inline content | Defines content that should be displayed with a monospace font.                                  |
+------------+--------------------------------------+----------------+--------------------------------------------------------------------------------------------------+

.. _qhelp-inclusion:

Query help inclusion
====================

To reuse content between different help topics, you can store shared content in one query help file and then include it in a number of other query help files using the ``include`` element. The shared content can be stored either in the same directory as the including files, or in ``SEMMLE_DIST/docs/include``.
When a query help file is only included by other help files but does not belong to a specific query, it should have the file extension ``.inc.qhelp``.

The ``include`` element can be used as a section or block element. The content of the query help file defined by the ``src`` attribute must contain elements that are appropriate to the location of the ``include`` element.

Section-level include elements
------------------------------

Section-level ``include`` elements can be located beneath the top-level ``qhelp`` element. For example, in `StoredXSS.qhelp <https://github.com/github/codeql/blob/main/csharp/ql/src/Security%20Features/CWE-079/StoredXSS.qhelp>`__, a full query help file is reused: 

.. code-block:: xml 
   
   <qhelp> 
       <include src="XSS.qhelp" />
   </qhelp>

In this example, the `XSS.qhelp <https://github.com/github/codeql/blob/main/csharp/ql/src/Security%20Features/CWE-079/XSS.qhelp>`__ file must conform to the standard for a full query help file as described above. That is, the ``qhelp`` element may only contain non-``fragment``, section-level elements.

Block-level include elements
----------------------------

Block-level ``include`` elements can be included beneath section-level elements. For example, an ``include`` element is used beneath the ``overview`` section in `ThreadUnsafeICryptoTransform.qhelp <https://github.com/github/codeql/blob/main/csharp/ql/src/Likely%20Bugs/ThreadUnsafeICryptoTransform.qhelp>`__:

.. code-block:: xml 
   
   <qhelp>
       <overview>
           <include src="ThreadUnsafeICryptoTransformOverview.inc.qhelp" />
       </overview>
       ...
   </qhelp>

The included file, `ThreadUnsafeICryptoTransformOverview.inc.qhelp <https://github.com/github/codeql/blob/main/csharp/ql/src/Likely%20Bugs/ThreadUnsafeICryptoTransformOverview.inc.qhelp>`_, may only contain one or more ``fragment`` sections. For example:

.. code-block:: xml 

   <!DOCTYPE qhelp SYSTEM "qhelp.dtd"> 
   <qhelp>
      <fragment>
         <p>
            ...
         </p>
      </fragment>
   </qhelp>




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/about-data-flow-analysis.rst
.. _about-data-flow-analysis:

About data flow analysis
########################

Data flow analysis is used to compute the possible values that a variable can hold at various points in a program, determining how those values propagate through the program and where they are used.

Overview
********

Many CodeQL security queries implement data flow analysis, which can highlight the fate of potentially malicious or insecure data that can cause vulnerabilities in your code base.
These queries help you understand if data is used in an insecure way, whether dangerous arguments are passed to functions, or whether sensitive data can leak.
As well as highlighting potential security issues, you can also use data flow analysis to understand other aspects of how a program behaves, by finding, for example, uses of uninitialized variables and resource leaks.

The following sections provide a brief introduction to data flow analysis with CodeQL.

See the following tutorials for more information about analyzing data flow in specific languages:

- ":ref:`Analyzing data flow in C/C++ <analyzing-data-flow-in-cpp>`"
- ":ref:`Analyzing data flow in C# <analyzing-data-flow-in-csharp>`"
- ":ref:`Analyzing data flow in Java/Kotlin <analyzing-data-flow-in-java>`"
- ":ref:`Analyzing data flow in JavaScript/TypeScript <analyzing-data-flow-in-javascript-and-typescript>`"
- ":ref:`Analyzing data flow in Python <analyzing-data-flow-in-python>`"
- ":ref:`Analyzing data flow in Ruby <analyzing-data-flow-in-ruby>`"

.. pull-quote::

    Note

    Data flow analysis is used extensively in path queries. To learn more about path queries, see ":doc:`Creating path queries <creating-path-queries>`."

.. _data-flow-graph:

Data flow graph
***************

The CodeQL data flow libraries implement data flow analysis on a program or function by modeling its data flow graph.
Unlike the `abstract syntax tree <https://en.wikipedia.org/wiki/Abstract_syntax_tree>`__, the
data flow graph does not reflect the syntactic structure of the program, but models the way data flows through the program at runtime. Nodes in the abstract syntax tree
represent syntactic elements such as statements or expressions. Nodes in the data flow graph, on the other hand, represent semantic elements that carry values at runtime.

Some AST nodes (such as expressions) have corresponding data flow nodes, but others (such as ``if`` statements) do not. This is because expressions are evaluated to a value at runtime, whereas
``if`` statements are purely a control-flow construct and do not carry values. There are also data flow nodes that do not correspond to AST nodes at all.

Edges in the data flow graph represent the way data flows between program elements. For example, in the expression ``x || y`` there are data flow nodes corresponding to the
sub-expressions ``x`` and ``y``, as well as a data flow node corresponding to the entire expression ``x || y``. There is an edge from the node corresponding to ``x`` to the
node corresponding to ``x || y``, representing the fact that data may flow from ``x`` to ``x || y`` (since the expression ``x || y`` may evaluate to ``x``). Similarly, there
is an edge from the node corresponding to ``y`` to the node corresponding to ``x || y``.

Local and global data flow differ in which edges they consider: local data flow only considers edges between data flow nodes belonging to the same function and ignores data
flow between functions and through object properties. Global data flow, however, considers the latter as well. Taint tracking introduces additional edges into the data flow
graph that do not precisely correspond to the flow of values, but model whether some value at runtime may be derived from another, for instance through a string manipulating
operation.

The data flow graph is computed using :ref:`classes <classes>` to model the program elements that represent the graph's nodes.
The flow of data between the nodes is modeled using :ref:`predicates <predicates>` to compute the graph's edges.

Computing an accurate and complete data flow graph presents several challenges:

- It isn't possible to compute data flow through standard library functions, where the source code is unavailable.
- Some behavior isn't determined until run time, which means that the data flow library must take extra steps to find potential call targets.
- Aliasing between variables can result in a single write changing the value that multiple pointers point to.
- The data flow graph can be very large and slow to compute.

To overcome these potential problems, two kinds of data flow are modeled in the libraries:

- Local data flow, concerning the data flow within a single function. When reasoning about local data flow, you only consider edges between data flow nodes belonging to the same function. It is generally sufficiently fast, efficient and precise for many queries, and it is usually possible to compute the local data flow for all functions in a CodeQL database.

- Global data flow, effectively considers the data flow within an entire program, by calculating data flow between functions and through object properties. Computing global data flow is typically more time and energy intensive than local data flow, therefore queries should be refined to look for more specific sources and sinks.

Many CodeQL queries contain examples of both local and global data flow analysis. For more information, see `CodeQL query help <https://codeql.github.com/codeql-query-help>`__.

Normal data flow vs taint tracking
**********************************

In the standard libraries, we make a distinction between 'normal' data flow and taint tracking.
The normal data flow libraries are used to analyze the information flow in which data values are preserved at each step.

For example, if you are tracking an insecure object ``x`` (which might be some untrusted or potentially malicious data), a step in the program may 'change' its value. So, in a simple process such as ``y = x + 1``, a normal data flow analysis will highlight the use of ``x``, but not ``y``.
However, since ``y`` is derived from ``x``, it is influenced by the untrusted or 'tainted' information, and therefore it is also tainted. Analyzing the flow of the taint from ``x`` to ``y`` is known as taint tracking.

In QL, taint tracking extends data flow analysis by including steps in which the data values are not necessarily preserved, but the potentially insecure object is still propagated.
These flow steps are modeled in the taint-tracking library using predicates that hold if taint is propagated between nodes.

Further reading
***************

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/providing-locations-in-codeql-queries.rst
.. _providing-locations-in-codeql-queries:

Providing locations in CodeQL queries
=====================================

.. Not sure how much of this topic needs to change, and what the title should be

CodeQL includes mechanisms for extracting the location of elements in a codebase. Use these mechanisms when writing custom CodeQL queries and libraries to help display information to users.


About locations
---------------

When displaying information to the user, applications need to be able to extract location information from the results of a query. In order to do this, all QL classes which can provide location information should do this by using one of the following mechanisms:

-  `Providing URLs <#providing-urls>`__
-  `Providing location information <#providing-location-information>`__
-  `Using extracted location information <#using-extracted-location-information>`__

This list is in priority order, so that the first available mechanism is used.

.. pull-quote::

   Note

   Since QL is a relational language, there is nothing to enforce that each entity of a QL class is mapped to precisely one location. This is the responsibility of the designer of the library (or the extractor, in the case of the third option below). If entities are assigned no location at all, users will not be able to click through from query results to the source code viewer. If multiple locations are assigned, results may be duplicated.

Providing URLs
~~~~~~~~~~~~~~

A custom URL can be provided by defining a QL predicate returning ``string`` with the name ``getURL`` – note that capitalization matters, and no arguments are allowed. For example:

.. code-block:: ql

   class JiraIssue extends ExternalData {
       JiraIssue() {
           getDataPath() = "JiraIssues.csv"
       }

       string getKey() {
           result = getField(0)
       }

       string getURL() {
           result = "http://mycompany.com/jira/" + getKey()
       }
   }

File URLs
^^^^^^^^^

The CodeQL extension for Visual Studio Code and the code scanning views in GitHub support the display of URLs which define a line and column in a source file.

The schema is ``file://``, which is followed by the absolute path to a file, followed by four numbers separated by colons. The numbers denote start line, start column, end line and end column. Both line and column numbers are **1-based**, for example:

-  ``file://opt/src/my/file.java:0:0:0:0`` is used to link to an entire file.
-  ``file:///opt/src/my/file.java:1:1:2:1`` denotes the location that starts at the beginning of the file and extends to the first character of the second line (the range is inclusive).
-  ``file:///opt/src/my/file.java:1:0:1:0`` is taken, by convention, to denote the entire first line of the file.

By convention, the location of an entire file may also be denoted by a ``file://`` URL without trailing numbers. Optionally, the location within a file can be denoted using three numbers to define the start line number, character offset and character length of the location respectively. Results of these types are not displayed as code scanning alerts.

Other types of URL
^^^^^^^^^^^^^^^^^^

The following, less-common types of URL are valid but are not interpreted as code scanning alerts and will be omitted from any results:

-  **HTTP URLs** are supported in some client applications. For an example, see the code snippet above.
-  **Folder URLs** can be useful, for example to provide folder-level metrics. They may use a file URL, for example ``file:///opt/src:0:0:0:0``, but they may also start with a scheme of ``folder://``, and no trailing numbers, for example ``folder:///opt/src``.
-  **Relative file URLs** are like normal file URLs, but start with the scheme ``relative://``. They are typically only meaningful in the context of a particular database, and are taken to be implicitly prefixed by the database's source location. Note that, in particular, the relative URL of a file will stay constant regardless of where the database is analyzed. It is often most convenient to produce these URLs as input when importing external information; selecting one from a QL class would be unusual, and client applications may not handle it appropriately.

Providing location information
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If no ``getURL()`` member predicate is defined, a QL class is checked for the presence of a member predicate called ``hasLocationInfo(..)``. This can be understood as a convenient way of providing file URLs (see above) without constructing the long URL string in QL. ``hasLocationInfo(..)`` should be a predicate, its first column must be ``string``-typed (it corresponds to the "path" portion of a file URL), and it must have an additional 3 or 4 ``int``-typed columns, which are interpreted like a trailing group of three or four numbers on a file URL.

For example, let us imagine that the locations for methods provided by the extractor extend from the first character of the method name to the closing curly brace of the method body, and we want to "fix" them to ensure that only the method name is selected. The following code shows two ways of achieving this:

.. code-block:: ql

   class MyMethod extends Method {
       // The locations from the database, which we want to modify.
       Location getLocation() { result = super.getLocation() }

       /* First member predicate: Construct a URL for the desired location. */
       string getURL() {
           exists(Location loc | loc = this.getLocation() |
               result = "file://" + loc.getFile().getFullName() +
                   ":" + loc.getStartLine() +
                   ":" + loc.getStartColumn() +
                   ":" + loc.getStartLine() +
                   ":" + (loc.getStartColumn() + getName().length() - 1)
           )
       }

       /* Second member predicate: Define hasLocationInfo. This will be more
          efficient (it avoids constructing long strings), and will
          only be used if getURL() is not defined. */
       predicate hasLocationInfo(string path, int sl, int sc, int el, int ec) {
           exists(Location loc | loc = this.getLocation() |
               path = loc.getFile().getFullName() and
               sl = loc.getStartLine() and
               sc = loc.getStartColumn() and
               el = sl and
               ec = sc + getName().length() - 1
           )
       }
   }

Using extracted location information
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Finally, if the above two predicates fail, client applications will attempt to call a predicate called ``getLocation()`` with no parameters, and try to apply one of the above two predicates to the result. This allows certain locations to be put into the database, assigned identifiers, and picked up.

By convention, the return value of the ``getLocation()`` predicate should be a class called ``Location``, and it should define a version of ``hasLocationInfo(..)`` (or ``getURL()``, though the former is preferable). If the ``Location`` class does not provide either of these member predicates, then no location information will be available.

The ``toString()`` predicate
----------------------------

All classes except those that extend primitive types, must provide a ``string toString()`` member predicate. The query compiler will complain if you don't. The uniqueness warning, noted above for locations, applies here too.

Further reading
---------------

- `CodeQL repository <https://github.com/github/codeql>`__


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/debugging-data-flow-queries-using-partial-flow.rst
.. _debugging-data-flow-queries-using-partial-flow:

Debugging data-flow queries using partial flow
==============================================

.. include:: ../reusables/new-data-flow-api.rst

If a data-flow query doesn't produce the results you expect to see, you can use partial flow to debug the problem.

In CodeQL, you can use :ref:`data flow analysis <about-data-flow-analysis>` to compute the possible values that a variable can hold at various points in a program.
A typical data-flow query looks like this:

.. code-block:: ql


    module MyConfig implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node node) { node instanceof MySource }

      predicate isSink(DataFlow::Node node) { node instanceof MySink }
    }

    module MyFlow = TaintTracking::Global<MyConfig>;

    from MyFlow::PathNode source, MyFlow::PathNode sink
    where MyFlow::flowPath(source, sink)
    select sink.getNode(), source, sink, "Sink is reached from $@.", source.getNode(), "here"

The same query can be slightly simplified by rewriting it without :ref:`path explanations <creating-path-queries>`:

.. code-block:: ql

    from DataFlow::Node source, DataFlow::Node sink
    where MyFlow::flow(source, sink)
    select sink, "Sink is reached from $@.", source.getNode(), "here"

If a data-flow query that you have written doesn't produce the results you expect it to, there may be a problem with your query.
You can try to debug the potential problem by following the steps described below.

Checking sources and sinks
--------------------------

Initially, you should make sure that the source and sink definitions contain what you expect. If either the source or sink is empty then there can never be any data flow. The easiest way to check this is using quick evaluation in CodeQL for VS Code. Select the text ``node instanceof MySource``, right-click, and choose "CodeQL: Quick Evaluation". This will evaluate the highlighted text, which in this case means the set of sources. For more information, see `Running CodeQL queries <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries#running-a-specific-part-of-a-query-or-library>`__ in the GitHub documentation.

If both source and sink definitions look good then we will need to look for missing flow steps.

``fieldFlowBranchLimit``
------------------------

Data-flow configurations contain a parameter called ``fieldFlowBranchLimit``. If the value is set too high, you may experience performance degradation, but if it's too low you may miss results. When debugging data flow try setting ``fieldFlowBranchLimit`` to a high value and see whether your query generates more results. For example, try adding the following to your configuration:

.. code-block:: ql

    int fieldFlowBranchLimit() { result = 5000 }

If there are still no results and performance is still useable, then it is best to leave this set to a high value while doing further debugging.

Partial flow
------------

A naive next step could be to change the sink definition to ``any()``. This would mean that we would get a lot of flow to all the places that are reachable from the sources. While this approach may work in some cases, you might find that it produces so many results that it's very hard to explore the findings. It can also dramatically affect query performance. More importantly, you might not even see all the partial flow paths. This is because the data-flow library tries very hard to prune impossible paths and, since field stores and reads must be evenly matched along a path, we will never see paths going through a store that fail to reach a corresponding read. This can make it hard to see where flow actually stops.

To avoid these problems, the data-flow library comes with a mechanism for exploring partial flow that tries to deal with these caveats. This is the ``MyFlow::FlowExplorationFwd<explorationLimit/0>::partialFlow`` predicate:

.. code-block:: ql

      /**
       * Holds if there is a partial data flow path from `source` to `node`. The
       * approximate distance between `node` and the closest source is `dist` and
       * is restricted to be less than or equal to `explorationLimit()`. This
       * predicate completely disregards sink definitions.
       *
       * This predicate is intended for dataflow exploration and debugging and may
       * perform poorly if the number of sources is too big and/or the exploration
       * limit is set too high without using barriers.
       *
       * To use this in a `path-problem` query, import the module `PartialPathGraph`.
       */
      predicate partialFlow(PartialPathNode source, PartialPathNode node, int dist) {

There is also a ``MyFlow::FlowExplorationRev<explorationLimit/0>::partialFlow`` for exploring flow backwards from a sink.

To get access to these predicates you must instantiate the ``MyFlow::FlowExplorationFwd<>`` module with an exploration limit (or the ``MyFlow::FlowExplorationRev<>`` module for reverse flow). For example:

.. code-block:: ql

    int explorationLimit() { result = 5 }

    module MyPartialFlow = MyFlow::FlowExplorationFwd<explorationLimit/0>;

This defines the exploration radius within which ``partialFlow`` returns results.

It is useful to focus on a single source at a time as the starting point for the flow exploration. This is most easily done by adding a temporary restriction in the ``isSource`` predicate.

To do quick evaluations of partial flow it is often easiest to add a predicate to the query that is solely intended for quick evaluation (right-click the predicate name and choose "CodeQL: Quick Evaluation"). A good starting point is something like:

.. code-block:: ql

    predicate adhocPartialFlow(Callable c, MyPartialFlow::PartialPathNode n, DataFlow::Node src, int dist) {
      exists(MyPartialFlow::PartialPathNode source |
        MyPartialFlow::partialFlow(source, n, dist) and
        src = source.getNode() and
        c = n.getNode().getEnclosingCallable()
      )
    }

If you are focusing on a single source then the ``src`` column is superfluous. You may of course also add other columns of interest based on ``n``, but including the enclosing callable and the distance to the source at the very least is generally recommended, as they can be useful columns to sort on to better inspect the results.


If you see a large number of partial flow results, you can focus them in a couple of ways:

- If flow travels a long distance following an expected path, that can result in a lot of uninteresting flow being included in the exploration radius. To reduce the amount of uninteresting flow, you can replace the source definition with a suitable ``node`` that appears along the path and restart the partial flow exploration from that point.
- Creative use of barriers can be used to cut off flow paths that are uninteresting. This also reduces the number of partial flow results to explore while debugging.

Further reading
----------------

- :ref:`About data flow analysis <about-data-flow-analysis>`
- :ref:`Creating path queries <creating-path-queries>`



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/crown-the-rightful-heir.rst
.. _crown-the-rightful-heir:

Crown the rightful heir
=======================

This is a QL detective puzzle that shows you how to use recursion in QL to write more complex queries.

King Basil's heir
-----------------

Phew! No more crimes in the village—you can finally leave the village and go home.

But then... During your last night in the village, the old king—the great King Basil—dies in his sleep and there is chaos everywhere!

The king never married and he had no children, so nobody knows who should inherit the king's castle and fortune. Immediately, lots of villagers claim that they are somehow descended from the king's family and that they are the true heir. People argue and fight and the situation seems hopeless.

Eventually you decide to stay in the village to resolve the argument and find the true heir to the throne.

You want to find out if anyone in the village is actually related to the king. This seems like a difficult task at first, but you start work confidently. You know the villagers quite well by now, and you have a list of all the parents in the village and their children.

To find out more about the king and his family, you get access to the castle and find some old family trees. You also include these relations in your database to see if anyone in the king's family is still alive.

The following predicate is useful to help you access the data:

+------------------------+---------------------------+
| Predicate              | Description               |
+========================+===========================+
| ``parentOf(Person p)`` | returns a parent of ``p`` |
+------------------------+---------------------------+

For example, you can list all children ``p`` together with their parents:

.. code-block:: ql

   from Person p
   select parentOf(p) + " is a parent of " + p

There is too much information to search through by hand, so you write a QL query to help you find the king's heir.

We know that the king has no children himself, but perhaps he has siblings. Write a query to find out:

.. code-block:: ql

   from Person p
   where parentOf(p) = parentOf("King Basil") and
     not p = "King Basil"
   select p

He does indeed have siblings! But you need to check if any of them are alive... Here is one more predicate you might need:

+------------------+---------------------------------+
| Predicate        | Description                     |
+==================+=================================+
| ``isDeceased()`` | holds if the person is deceased |
+------------------+---------------------------------+

Use this predicate to see if the any of the king's siblings are alive.

.. code-block:: ql

   from Person p
   where parentOf(p) = parentOf("King Basil") and
     not p = "King Basil"
     and not p.isDeceased()
   select p

Unfortunately, none of King Basil's siblings are alive. Time to investigate further. It might be helpful to define a predicate ``childOf()`` which returns a child of the person. To do this, the ``parentOf()`` predicate can be used inside the definition of ``childOf()``. Remember that someone is a child of ``p`` if and only if ``p`` is their parent:

.. code-block:: ql

   Person childOf(Person p) {
     p = parentOf(result)
   }

.. pull-quote::

   Note

   As illustrated by the example above, you don't have to directly write ``result = <expression involving p>`` in the predicate definition. Instead you can also express the relation between ``p`` and ``result`` "backwards" by writing ``p`` in terms of ``result``.

Try to write a query to find out if any of the king's siblings have children:

.. code-block:: ql

   from Person p
   where parentOf(p) = parentOf("King Basil") and
     not p = "King Basil"
   select childOf(p)

The query returns no results, so they have no children. But perhaps King Basil has a cousin who is alive or has children, or a second cousin, or...

This is getting complicated. Ideally, you want to define a predicate ``relativeOf(Person p)`` that lists all the relatives of ``p``.

How could you do that?

It helps to think of a precise definition of *relative*. A possible definition is that two people are related if they have a common ancestor.

You can introduce a predicate ``ancestorOf(Person p)`` that lists all ancestors of ``p``. An ancestor of ``p`` is just a parent of ``p``, or a parent of a parent of ``p``, or a parent of a parent of a parent of ``p``, and so on. Unfortunately, this leads to an endless list of parents. You can't write an infinite QL query, so there must be an easier approach.

Aha, you have an idea! You can say that an ancestor is either a parent, or a parent of someone you already know to be an ancestor.

You can translate this into QL as follows:

.. code-block:: ql

   Person ancestorOf(Person p) {
     result = parentOf(p) or
     result = parentOf(ancestorOf(p))
   }

As you can see, you have used the predicate ``ancestorOf()`` inside its own definition. This is an example of :ref:`recursion <recursion>`.

This kind of recursion, where the same operation (in this case ``parentOf()``) is applied multiple times, is very common in QL, and is known as the *transitive closure* of the operation. There are two special symbols ``+`` and ``*`` that are extremely useful when working with transitive closures:

-  ``parentOf+(p)`` applies the ``parentOf()`` predicate to ``p`` one or more times. This is equivalent to ``ancestorOf(p)``.
-  ``parentOf*(p)`` applies the ``parentOf()`` predicate to ``p`` zero or more times, so it returns an ancestor of ``p`` or ``p`` itself.

Try using this new notation to define a predicate ``relativeOf()`` and use it to list all living relatives of the king.

Hint:

Here is one way to define ``relativeOf()``:

.. code-block:: ql

   Person relativeOf(Person p) {
     parentOf*(result) = parentOf*(p)
   }

Don't forget to use the predicate ``isDeceased()`` to find relatives that are still alive.

➤ `Check your answer <#exercise-1>`__

Select the true heir
--------------------

At the next village meeting, you announce that there are two living relatives.

To decide who should inherit the king's fortune, the villagers carefully read through the village constitution:

*"The heir to the throne is the closest living relative of the king. Any person with a criminal record will not be considered. If there are multiple candidates, the oldest person is the heir."*

As your final challenge, define a predicate ``hasCriminalRecord`` so that ``hasCriminalRecord(p)`` holds if ``p`` is any of the criminals you unmasked earlier (in the ":doc:`Find the thief <find-the-thief>`" and ":doc:`Catch the fire starter <catch-the-fire-starter>`" tutorials).

➤ `Check your answer <#exercise-2>`__

Experimental explorations
-------------------------

Congratulations! You have found the heir to the throne and restored peace to the village. However, you don't have to leave the villagers just yet. There are still a couple more questions about the village constitution that you could answer for the villagers, by writing QL queries:

-  Which villager is next in line to the throne? Could you write a predicate to determine how closely related the remaining villagers are to the new monarch?
-  How would you select the oldest candidate using a QL query, if multiple villagers have the same relationship to the monarch?

You could also try writing more of your own QL queries to find interesting facts about the villagers. You are free to investigate whatever you like, but here are some suggestions:

-  What is the most common hair color in the village? And in each region?
-  Which villager has the most children? Who has the most descendants?
-  How many people live in each region of the village?
-  Do all villagers live in the same region of the village as their parents?
-  Find out whether there are any time travelers in the village! (Hint: Look for "impossible" family relations.)

Further reading
---------------

.. include:: ../reusables/codeql-ref-tools-further-reading.rst

--------------

Answers
-------

In these answers, we use ``/*`` and ``*/`` to label the different parts of the query. Any text surrounded by ``/*`` and ``*/`` is not evaluated as part of the QL code, but is treated as a *comment*.

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   import tutorial

   Person relativeOf(Person p) { parentOf*(result) = parentOf*(p) }

   from Person p
   where
     not p.isDeceased() and
     p = relativeOf("King Basil")
   select p

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   import tutorial

   Person relativeOf(Person p) { parentOf*(result) = parentOf*(p) }

   predicate hasCriminalRecord(Person p) {
     p = "Hester" or
     p = "Hugh" or
     p = "Charlie"
   }

   from Person p
   where
     not p.isDeceased() and
     p = relativeOf("King Basil") and
     not hasCriminalRecord(p)
   select p



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/ql-tutorials.rst
.. _ql-tutorials:

QL tutorials
============

Solve puzzles to learn the basics of QL before you analyze code with CodeQL. The tutorials teach you how to write queries and introduce you to key logic concepts along the way.

.. toctree::
   :hidden:

   introduction-to-ql
   find-the-thief
   catch-the-fire-starter
   crown-the-rightful-heir
   cross-the-river

-  :doc:`Introduction to QL <introduction-to-ql>`: Work through some simple exercises and examples to learn about the basics of QL and CodeQL.
-  :doc:`Find the thief <find-the-thief>`: Take on the role of a detective to find the thief in this fictional village. You will learn how to use logical connectives, quantifiers, and aggregates in QL along the way.
-  :doc:`Catch the fire starter <catch-the-fire-starter>`: Learn about QL predicates and classes to solve your second mystery as a QL detective.
-  :doc:`Crown the rightful heir <crown-the-rightful-heir>`: This is a QL detective puzzle that shows you how to use recursion in QL to write more complex queries.
-  :doc:`Cross the river <cross-the-river>`: Use common QL features to write a query that finds a solution to the "River crossing" logic puzzle.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/cross-the-river.rst
.. _cross-the-river:

Cross the river
===============

Use common QL features to write a query that finds a solution to the "River crossing" logic puzzle.

Introduction
------------

.. pull-quote::

   River crossing puzzle

   A man is trying to ferry a goat, a cabbage, and a wolf across a river.
   His boat can only take himself and at most one item as cargo.
   His problem is that if the goat is left alone with the cabbage, it will eat it.
   And if the wolf is left alone with the goat, it will eat it.
   How does he get everything across the river?

A solution should be a set of instructions for how to ferry the items, such as "First ferry the goat
across the river, and come back with nothing. Then ferry the cabbage across, and come back with ..."

There are lots of ways to approach this problem and implement it in QL. Before you start, make
sure that you are familiar with how to define :ref:`classes <classes>`
and :ref:`predicates <predicates>` in QL.
The following walkthrough is just one of many possible implementations, so have a go at writing your
own query too! To find more example queries, see the list :ref:`below <alternatives>`.

Walkthrough
-----------

Model the elements of the puzzle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The basic components of the puzzle are the cargo items and the shores on either side of the river.
Start by modeling these as classes.

First, define a class ``Cargo`` containing the different cargo items.
Note that the man can also travel on his own, so it helps to explicitly include ``"Nothing"`` as
a piece of cargo.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 15-23

Second, any item can be on one of two shores. Let's call these the "left shore" and the "right shore".
Define a class ``Shore`` containing ``"Left"`` and ``"Right"``.

It would be helpful to express "the other shore" to model moving from one side of the river to the other.
You can do this by defining a member predicate
``other`` in the class ``Shore`` such that ``"Left".other()`` returns ``"Right"`` and vice versa.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 25-38

We also want a way to keep track of where the man, the goat, the cabbage, and the wolf are at any point. We can call this combined
information the "state". Define a class ``State`` that encodes the location of each piece of cargo.
For example, if the man is on the left shore, the goat on the right shore, and the cabbage and wolf on the left
shore, the state should be ``Left, Right, Left, Left``.

You may find it helpful to introduce some variables that refer to the shore on which the man and the cargo items are. These
temporary variables in the body of a class are called :ref:`fields <fields>`.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing-1.ql
      :language: ql
      :lines: 33-40,87

We are interested in two particular states, namely the initial state and the goal state,
which we have to achieve to solve the puzzle.
Assuming that all items start on the left shore and end up on the right shore, define
``InitialState`` and ``GoalState`` as subclasses of ``State``.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing-1.ql
      :language: ql
      :lines: 89-97

.. pull-quote::

   Note

   To avoid typing out the lengthy string concatenations, you could introduce a helper predicate
   ``renderState`` that renders the state in the required form.

Using the above note, the QL code so far looks like this:

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 15-52,103-113

Model the action of "ferrying"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The basic act of ferrying moves the man and one cargo item to the other shore,
resulting in a new state.

Write a member predicate (of ``State``) called ``ferry``, that specifies what happens to the state
after ferrying a particular cargo. (Hint: Use the predicate ``other``.)

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 54-67

Of course, not all ferrying actions are possible. Add some extra conditions to describe when a ferrying
action is "safe". That is, it doesn't lead to a state where the goat or the cabbage get eaten.
For example, follow these steps:

   #. Define a predicate ``isSafe`` that holds when the state itself is safe. Use this to encode the
      conditions for when nothing gets eaten.
   #. Define a predicate ``safeFerry`` that restricts ``ferry`` to only include safe ferrying actions.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 69-81

Find paths from one state to another
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The main aim of this query is to find a path, that is, a list of successive ferrying actions, to get
from the initial state to the goal state. You could write this "list" by separating each item by a
newline (``"\n"``).

When finding the solution, you should be careful to avoid "infinite" paths. For example, the man
could ferry the goat back and forth any number of times without ever reaching an unsafe state.
Such a path would have an infinite number of river crossings without ever solving the puzzle.

One way to restrict our paths to a finite number of river crossings is to define a 
:ref:`member predicate <member-predicates>`
``State reachesVia(string path, int steps)``.
The result of this predicate is any state that is reachable from the current state (``this``) via
the given path in a specified finite number of steps.

You can write this as a :ref:`recursive predicate <recursion>`,
with the following base case and recursion step:

  - If ``this`` *is* the result state, then it (trivially) reaches the result state via an
    empty path in zero steps.
  - Any other state is reachable if ``this`` can reach an intermediate state (for some value of
    ``path`` and ``steps``), and there is a ``safeFerry`` action from that intermediate
    state to the result state.

To ensure that the predicate is finite, you should restrict ``steps`` to a particular value,
for example ``steps <= 7``.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing-1.ql
      :language: ql
      :lines: 70-86

However, although this ensures that the solution is finite, it can still contain loops if the upper bound
for ``steps`` is large. In other words, you could get an inefficient solution by revisiting the same state
multiple times.

Instead of picking an arbitrary upper bound for the number of steps, you can avoid
counting steps altogether. If you keep track of states that have already been visited and ensure
that each ferrying action leads to a new state, the solution certainly won't contain any loops.

To do this, change the member predicate to ``State reachesVia(string path, string visitedStates)``.
The result of this predicate is any state that is reachable from the current state (``this``) via
the given path without revisiting any previously visited states.

  - As before, if ``this`` *is* the result state, then it (trivially) reaches the result state via an
    empty path and an empty string of visited states.
  - Any other state is reachable if  ``this`` can reach an intermediate state via some path, without
    revisiting any previous states, and there is a ``safeFerry`` action from the intermediate state to
    the result state.
    (Hint: To check whether a state has previously been visited, you could check if
    there is an `index of <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string>`__
    ``visitedStates`` at which the state occurs.)

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 83-102

Display the results
~~~~~~~~~~~~~~~~~~~

Once you've defined all the necessary classes and predicates, write a :ref:`select clause <select-clauses>`
that returns the resulting path.

.. container:: toggle

   .. container:: name

      *Show/hide code*

   .. literalinclude:: river-crossing.ql
      :language: ql
      :lines: 115-117

The :ref:`don't-care expression <don-t-care-expressions>` (``_``),
as the second argument to the ``reachesVia`` predicate, represents any value of ``visitedStates``.

For now, the path defined in ``reachesVia`` just lists the order of cargo items to ferry.
You could tweak the predicate and the select clause to make the solution clearer. Here are some suggestions:

  - Display more information, such as the direction in which the cargo is ferried, for example
    ``"Goat to the left shore"``.
  - Fully describe the state at every step, for example ``"Goat: Left, Man: Left, Cabbage: Right, Wolf: Right"``.
  - Display the path in a more "visual" way, for example by using arrows to display the transitions between states.

.. _alternatives:

Alternative solutions
---------------------

Here are some more example queries that solve the river crossing puzzle:

.. container:: toggle

   .. container:: name

      *Show/hide example query - modified path*

   .. literalinclude:: river-answer-1-path.ql
      :language: ql


.. container:: toggle

   .. container:: name

      *Show/hide example query - abstract class*

   .. literalinclude:: river-answer-2-abstract-class.ql
      :language: ql


.. container:: toggle

   .. container:: name

      *Show/hide example query - datatypes*

   .. literalinclude:: river-answer-3-datatypes.ql
      :language: ql

Further reading
---------------

.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/metadata-for-codeql-queries.rst
.. _metadata-for-codeql-queries:

Metadata for CodeQL queries
===========================

Metadata tells users important information about CodeQL queries. You must include the correct query metadata in a query to be able to view query results in source code.

About query metadata
--------------------

Any query that is run as part of an analysis includes a number of properties, known as query metadata. Metadata is included at the top of each query file as the content of a QLDoc comment.
This metadata tells the CodeQL `extension for VS Code <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__ and the `Code scanning feature in GitHub <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql>`__ how to handle the query and display its results correctly.
It also gives other users information about what the query results mean. For more information on query metadata, see the `query metadata style guide <https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md>`__ in our `open source repository <https://github.com/github/codeql>`__ on GitHub.

.. pull-quote::

    Note

    The exact metadata requirement depends on how you are going to run your query. For more information, see the section on query metadata in ":doc:`About CodeQL queries <about-codeql-queries>`."

Metadata properties
-------------------

The following properties are supported by all query files:

+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Property              | Value                     | Description                                                                                                                                                                                                                                                                                                                                                           |
+=======================+===========================+=======================================================================================================================================================================================================================================================================================================================================================================+
| ``@description``      | ``<text>``                | A sentence or short paragraph to describe the purpose of the query and *why* the result is useful or important. The description is written in plain text, and uses single quotes (``'``) to enclose code elements.                                                                                                                                                    |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@id``               | ``<text>``                | A sequence of words composed of lowercase letters or digits, delimited by ``/`` or ``-``, identifying and classifying the query. Each query must have a **unique** ID. To ensure this, it may be helpful to use a fixed structure for each ID. For example, the standard CodeQL queries have the following format: ``<language>/<brief-description>``.                |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@kind``             | | ``problem``             | Identifies the query is an alert (``@kind problem``) or a path (``@kind path-problem``). For more information on these query types, see ":doc:`About CodeQL queries <about-codeql-queries>`."                                                                                                                                                                         |
|                       | | ``path-problem``        |                                                                                                                                                                                                                                                                                                                                                                       |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@name``             | ``<text>``                | A statement that defines the label of the query. The name is written in plain text, and uses single quotes (``'``) to enclose code elements.                                                                                                                                                                                                                          |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@tags``             | | ``correctness``         | These tags group queries together in broad categories to make it easier to search for them and identify them. In addition to the common tags listed here, there are also a number of more specific categories. For more information, see the                                                                                                                          |
|                       | | ``maintainability``     | `Query metadata style guide <https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md>`__.                                                                                                                                                                                                                                                       |
|                       | | ``readability``         |                                                                                                                                                                                                                                                                                                                                                                       |
|                       | | ``security``            |                                                                                                                                                                                                                                                                                                                                                                       |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@precision``        | | ``low``                 | Indicates the percentage of query results that are true positives (as opposed to false positive results). This, along with the ``@problem.severity`` property, determines how the results are displayed on GitHub.                                                                                                                                                    |
|                       | | ``medium``              |                                                                                                                                                                                                                                                                                                                                                                       |
|                       | | ``high``                |                                                                                                                                                                                                                                                                                                                                                                       |
|                       | | ``very-high``           |                                                                                                                                                                                                                                                                                                                                                                       |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@problem.severity`` | | ``error``               | Defines the level of severity of any alerts generated by a non-security query. This, along with the ``@precision`` property, determines how the results are displayed on GitHub. For more information, see the `Query metadata style guide <https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md>`__.                                        |
|                       | | ``warning``             |                                                                                                                                                                                                                                                                                                                                                                       |
|                       | | ``recommendation``      |                                                                                                                                                                                                                                                                                                                                                                       |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``@security-severity``| ``<score>``               | Defines the level of severity, between 0.0 and 10.0, for queries with ``@tags security``. For more information, see the `GitHub user documentation <https://docs.github.com/code-security/code-scanning/managing-code-scanning-alerts/about-code-scanning-alerts#about-alert-severity-and-security-severity-levels>`__.                                               |
+-----------------------+---------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Example
-------

Here is the metadata for one of the standard Java queries:

|image0|

.. |image0| image:: ../images/query-metadata.png

For more examples of query metadata, see the standard CodeQL queries in our `GitHub repository <https://github.com/github/codeql>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/find-the-thief.rst
.. _find-the-thief:

Find the thief
==============

Take on the role of a detective to find the thief in this fictional village. You will learn how to use logical connectives, quantifiers, and aggregates in QL along the way.

Introduction
------------

There is a small village hidden away in the mountains. The village is divided into four parts—north, south, east, and west—and in the center stands a dark and mysterious castle... Inside the castle, locked away in the highest tower, lies the king's valuable golden crown. One night, a terrible crime is committed. A thief breaks into the tower and steals the crown!

You know that the thief must live in the village, since nobody else knew about the crown. After some expert detective work, you obtain a list of all the people in the village and some of their personal details.

+------+-----+------------+--------+----------+
| Name | Age | Hair color | Height | Location |
+======+=====+============+========+==========+
| ...  | ... | ...        | ...    | ...      |
+------+-----+------------+--------+----------+

Sadly, you still have no idea who could have stolen the crown so you walk around the village to find clues. The villagers act very suspiciously and you are convinced they have information about the thief. They refuse to share their knowledge with you directly, but they reluctantly agree to answer questions. They are still not very talkative and **only answer questions with 'yes' or 'no'**.

You start asking some creative questions and making notes of the answers so you can compare them with your information later:

+------+--------------------------------------------------------------------+--------+
|      | Question                                                           | Answer |
+======+====================================================================+========+
| (1)  | Is the thief taller than 150 cm?                                   | yes    |
+------+--------------------------------------------------------------------+--------+
| (2)  | Does the thief have blond hair?                                    | no     |
+------+--------------------------------------------------------------------+--------+
| (3)  | Is the thief bald?                                                 | no     |
+------+--------------------------------------------------------------------+--------+
| (4)  | Is the thief younger than 30?                                      | no     |
+------+--------------------------------------------------------------------+--------+
| (5)  | Does the thief live east of the castle?                            | yes    |
+------+--------------------------------------------------------------------+--------+
| (6)  | Does the thief have black or brown hair?                           | yes    |
+------+--------------------------------------------------------------------+--------+
| (7)  | Is the thief taller than 180cm and shorter than 190cm?             | no     |
+------+--------------------------------------------------------------------+--------+
| (8)  | Is the thief the oldest person in the village?                     | no     |
+------+--------------------------------------------------------------------+--------+
| (9)  | Is the thief the tallest person in the village?                    | no     |
+------+--------------------------------------------------------------------+--------+
| (10) | Is the thief shorter than the average villager?                    | yes    |
+------+--------------------------------------------------------------------+--------+
| (11) | Is the thief the oldest person in the eastern part of the village? | yes    |
+------+--------------------------------------------------------------------+--------+

There is too much information to search through by hand, so you decide to use your newly acquired QL skills to help you with your investigation...

.. include:: ../reusables/codespaces-template-note.rst

QL libraries
------------

We've defined a number of QL :ref:`predicates <predicates>` to help you extract data from your table. A QL predicate is a mini-query that expresses a relation between various pieces of data and describes some of their properties. In this case, the predicates give you information about a person, for example their height or age.

+--------------------+----------------------------------------------------------------------------------------+
| Predicate          | Description                                                                            |
+====================+========================================================================================+
| ``getAge()``       | returns the age of the person (in years) as an ``int``                                 |
+--------------------+----------------------------------------------------------------------------------------+
| ``getHairColor()`` | returns the hair color of the person as a ``string``                                   |
+--------------------+----------------------------------------------------------------------------------------+
| ``getHeight()``    | returns the height of the person (in cm) as a ``float``                                |
+--------------------+----------------------------------------------------------------------------------------+
| ``getLocation()``  | returns the location of the person's home (north, south, east or west) as a ``string`` |
+--------------------+----------------------------------------------------------------------------------------+

We've stored these predicates in the QL library ``tutorial.qll``. To access this library, type ``import tutorial`` in the query console.

Libraries are convenient for storing commonly used predicates. This saves you from defining a predicate every time you need it. Instead you can just ``import`` the library and use the predicate directly. Once you have imported the library, you can apply any of these predicates to an expression by appending it.

For example, ``t.getHeight()`` applies ``getHeight()`` to ``t`` and returns the height of ``t``.

Start the search
-----------------

The villagers answered "yes" to the question "Is the thief taller than 150cm?" To use this information, you can write the following query to list all villagers taller than 150cm. These are all possible suspects.

.. code-block:: ql

   from Person t
   where t.getHeight() > 150
   select t

The first line, ``from Person t``, declares that ``t`` must be a ``Person``. We say that the :ref:`type <types>` of ``t`` is ``Person``.

Before you use the rest of your answers in your QL search, here are some more tools and examples to help you write your own QL queries:

Logical connectives
-------------------

Using :ref:`logical connectives <logical-connectives>`, you can write more complex queries that combine different pieces of information.

For example, if you know that the thief is older than 30 *and* has brown hair, you can use the following ``where`` clause to link two predicates:

.. code-block:: ql

   where t.getAge() > 30 and t.getHairColor() = "brown"

.. pull-quote::

   Note

   The predicate ``getHairColor()`` returns a ``string``, so we need to include quotation marks around the result ``"brown"``.

If the thief does *not* live north of the castle, you can use:

.. code-block:: ql

   where not t.getLocation() = "north"

If the thief has brown hair *or* black hair, you can use:

.. code-block:: ql

   where t.getHairColor() = "brown" or t.getHairColor() = "black"

You can also combine these connectives into longer statements:

.. code-block:: ql

   where t.getAge() > 30
     and (t.getHairColor() = "brown" or t.getHairColor() = "black")
     and not t.getLocation() = "north"

.. pull-quote::

   Note

   We've placed parentheses around the ``or`` clause to make sure that the query is evaluated as intended. Without parentheses, the connective ``and`` takes precedence over ``or``.

Predicates don't always return exactly one value. For example, if a person ``p`` has black hair which is turning gray, ``p.getHairColor()`` will return two values: black and gray.

What if the thief is bald? In that case, the thief has no hair, so the ``getHairColor()`` predicate simply doesn't return any results!

If you know that the thief definitely isn't bald, then there must be a color that matches the thief's hair color. One way to express this in QL is to introduce a new variable ``c`` of type ``string`` and select those ``t`` where ``t.getHairColor()`` matches a value of ``c``.

.. code-block:: ql

   from Person t, string c
   where t.getHairColor() = c
   select t

Notice that we have only temporarily introduced the variable ``c`` and we didn't need it at all in the ``select`` clause. In this case, it is better to use ``exists``:

.. code-block:: ql

   from Person t
   where exists(string c | t.getHairColor() = c)
   select t

``exists`` introduces a temporary variable ``c`` of type ``string`` and holds only if there is at least one ``string c`` that satisfies ``t.getHairColor() = c``.

.. pull-quote::

   Note

   If you are familiar with logic, you may notice that ``exists`` in QL corresponds to the existential :ref:`quantifier <quantified-formulas>` in logic. QL also has a universal quantifier ``forall(vars | formula 1 | formula 2)`` which is logically equivalent to ``not exists(vars | formula 1 | not formula 2)``.

The real investigation
----------------------

You are now ready to track down the thief! Using the examples above, write a query to find the people who satisfy the answers to the first eight questions:

+---+--------------------------------------------------------+--------+
|   | Question                                               | Answer |
+===+========================================================+========+
| 1 | Is the thief taller than 150 cm?                       | yes    |
+---+--------------------------------------------------------+--------+
| 2 | Does the thief have blond hair?                        | no     |
+---+--------------------------------------------------------+--------+
| 3 | Is the thief bald?                                     | no     |
+---+--------------------------------------------------------+--------+
| 4 | Is the thief younger than 30?                          | no     |
+---+--------------------------------------------------------+--------+
| 5 | Does the thief live east of the castle?                | yes    |
+---+--------------------------------------------------------+--------+
| 6 | Does the thief have black or brown hair?               | yes    |
+---+--------------------------------------------------------+--------+
| 7 | Is the thief taller than 180cm and shorter than 190cm? | no     |
+---+--------------------------------------------------------+--------+
| 8 | Is the thief the oldest person in the village?         | no     |
+---+--------------------------------------------------------+--------+

Hints
^^^^^

#. Don't forget to ``import tutorial``!
#. Translate each question into QL separately. Look at the examples above if you get stuck.
#. For question 3, remember that a bald person does not have a hair color.
#. For question 8, note that if a person is *not* the oldest, then there is at least one person who is older than them.
#. Combine the conditions using logical connectives to get a query of the form:

.. code-block:: ql

   import tutorial

   from Person t
   where <condition 1> and
     not <condition 2> and
     ...
   select t

Once you have finished, you will have a list of possible suspects. One of those people must be the thief!

➤ `Check your answer <#exercise-1>`__

You are getting closer to solving the mystery! Unfortunately, you still have quite a long list of suspects... To find out which of your suspects is the thief, you must gather more information and refine your query in the next step.

More advanced queries
---------------------

What if you want to find the oldest, youngest, tallest, or shortest person in the village? As mentioned in the previous topic, you can do this using ``exists``. However, there is also a more efficient way to do this in QL using functions like ``max`` and ``min``. These are examples of :ref:`aggregates <aggregations>`.

In general, an aggregate is a function that performs an operation on multiple pieces of data and returns a single value as its output. Common aggregates are ``count``, ``max``, ``min``, ``avg`` (average) and ``sum``. The general way to use an aggregate is:

.. code-block:: ql

   <aggregate>(<variable declarations> | <logical formula> | <expression>)

For example, you can use the ``max`` aggregate to find the age of the oldest person in the village:

.. code-block:: ql

   max(int i | exists(Person p | p.getAge() = i) | i)

This aggregate considers all integers ``i``, limits ``i`` to values that match the ages of people in the village, and then returns the largest matching integer.

But how can you use this in an actual query?

If the thief is the oldest person in the village, then you know that the thief's age is equal to the maximum age of the villagers:

.. code-block:: ql

   from Person t
   where t.getAge() = max(int i | exists(Person p | p.getAge() = i) | i)
   select t

This general aggregate syntax is quite long and inconvenient. In most cases, you can omit certain parts of the aggregate. A particularly helpful QL feature is *ordered aggregation*. This allows you to order the expression using ``order by``.

For example, selecting the oldest villager becomes much simpler if you use an ordered aggregate.

.. code-block:: ql

   select max(Person p | | p order by p.getAge())

The ordered aggregate considers every person ``p`` and selects the person with the maximum age. In this case, there are no restrictions on what people to consider, so the ``<logical formula>`` clause is empty. Note that if there are several people with the same maximum age, the query lists all of them.

Here are some more examples of aggregates:

+-------------------------------------------------------------------------+---------------------------------------------------+
| Example                                                                 | Result                                            |
+=========================================================================+===================================================+
| ``min(Person p | p.getLocation() = "east" | p order by p.getHeight())`` | shortest person in the east of the village        |
+-------------------------------------------------------------------------+---------------------------------------------------+
| ``count(Person p | p.getLocation() = "south" | p)``                     | number of people in the south of the village      |
+-------------------------------------------------------------------------+---------------------------------------------------+
| ``avg(Person p | | p.getHeight())``                                     | average height of the villagers                   |
+-------------------------------------------------------------------------+---------------------------------------------------+
| ``sum(Person p | p.getHairColor() = "brown" | p.getAge())``             | combined age of all the villagers with brown hair |
+-------------------------------------------------------------------------+---------------------------------------------------+

Capture the culprit
-------------------

You can now translate the remaining questions into QL:

+-----+--------------------------------------------------------------------+--------+
|     | Question                                                           | Answer |
+=====+====================================================================+========+
| ... | ...                                                                | ...    |
+-----+--------------------------------------------------------------------+--------+
| 9   | Is the thief the tallest person in the village?                    | no     |
+-----+--------------------------------------------------------------------+--------+
| 10  | Is the thief shorter than the average villager?                    | yes    |
+-----+--------------------------------------------------------------------+--------+
| 11  | Is the thief the oldest person in the eastern part of the village? | yes    |
+-----+--------------------------------------------------------------------+--------+

Have you found the thief?

➤ `Check your answer <#exercise-2>`__

Further reading
---------------

.. include:: ../reusables/codeql-ref-tools-further-reading.rst


--------------

Answers
-------

In these answers, we use ``/*`` and ``*/`` to label the different parts of the query. Any text surrounded by ``/*`` and ``*/`` is not evaluated as part of the QL code, but is treated as a *comment*.

Exercise 1
^^^^^^^^^^

.. code-block:: ql

   import tutorial

   from Person t
   where
     /* 1 */ t.getHeight() > 150 and
     /* 2 */ not t.getHairColor() = "blond" and
     /* 3 */ exists (string c | t.getHairColor() = c) and
     /* 4 */ not t.getAge() < 30 and
     /* 5 */ t.getLocation() = "east" and
     /* 6 */ (t.getHairColor() = "black" or t.getHairColor() = "brown") and
     /* 7 */ not (t.getHeight() > 180 and t.getHeight() < 190) and
     /* 8 */ exists(Person p | p.getAge() > t.getAge())
   select t

Exercise 2
^^^^^^^^^^

.. code-block:: ql

   import tutorial

   from Person t
   where
     /* 1 */ t.getHeight() > 150 and
     /* 2 */ not t.getHairColor() = "blond" and
     /* 3 */ exists (string c | t.getHairColor() = c) and
     /* 4 */ not t.getAge() < 30 and
     /* 5 */ t.getLocation() = "east" and
     /* 6 */ (t.getHairColor() = "black" or t.getHairColor() = "brown") and
     /* 7 */ not (t.getHeight() > 180 and t.getHeight() < 190) and
     /* 8 */ exists(Person p | p.getAge() > t.getAge()) and
     /* 9 */ not t = max(Person p | | p order by p.getHeight()) and
     /* 10 */ t.getHeight() < avg(float i | exists(Person p | p.getHeight() = i) | i) and
     /* 11 */ t = max(Person p | p.getLocation() = "east" | p order by p.getAge())
   select "The thief is " + t + "!"
   


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/creating-path-queries.rst
.. _creating-path-queries:

Creating path queries
#####################

You can create path queries to visualize the flow of information through a codebase.

.. include:: ../reusables/new-data-flow-api.rst

Overview
========

Security researchers are particularly interested in the way that information flows in a program. Many vulnerabilities are caused by seemingly benign data flowing to unexpected locations, and being used in a malicious way.
Path queries written with CodeQL are particularly useful for analyzing data flow as they can be used to track the path taken by a variable from its possible starting points (``source``) to its possible end points (``sink``).
To model paths, your query must provide information about the ``source`` and the ``sink``, as well as the data flow steps that link them.

This topic provides information on how to structure a path query file so you can explore the paths associated with the results of data flow analysis.

.. pull-quote::

    Note

    The alerts generated by path queries are included in the results generated using the `CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__ and in `code scanning <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-alerts#about-alert-details>`__. You can also view the path explanations generated by your path query in the `CodeQL extension for VS Code <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__.


To learn more about modeling data flow with CodeQL, see ":doc:`About data flow analysis <about-data-flow-analysis>`."
For more language-specific information on analyzing data flow, see:

- ":ref:`Analyzing data flow in C/C++ <analyzing-data-flow-in-cpp>`"
- ":ref:`Analyzing data flow in C# <analyzing-data-flow-in-csharp>`"
- ":ref:`Analyzing data flow in Java/Kotlin <analyzing-data-flow-in-java>`"
- ":ref:`Analyzing data flow in JavaScript/TypeScript <analyzing-data-flow-in-javascript-and-typescript>`"
- ":ref:`Analyzing data flow in Python <analyzing-data-flow-in-python>`"
- ":ref:`Analyzing data flow in Ruby <analyzing-data-flow-in-ruby>`"
- ":ref:`Analyzing data flow in Swift <analyzing-data-flow-in-swift>`"

Path query examples
*******************

The easiest way to get started writing your own path query is to modify one of the existing queries. For more information, see the `CodeQL query help <https://codeql.github.com/codeql-query-help>`__.

The Security Lab researchers have used path queries to find security vulnerabilities in various open source projects. To see articles describing how these queries were written, as well as other posts describing other aspects of security research such as exploiting vulnerabilities, see the `GitHub Security Lab website <https://securitylab.github.com/research>`__.

Constructing a path query
=========================

Path queries require certain metadata, query predicates, and ``select`` statement structures.
Many of the built-in path queries included in CodeQL follow a simple structure, which depends on how the language you are analyzing is modeled with CodeQL.

You should use the following template:

.. code-block:: ql

    /**
     * ...
     * @kind path-problem
     * ...
     */

    import <language>
    // For some languages (Java/C++/Python/Swift) you need to explicitly import the data flow library, such as
    // import semmle.code.java.dataflow.DataFlow or import codeql.swift.dataflow.DataFlow
    ...

    module Flow = DataFlow::Global<MyConfiguration>;
    import Flow::PathGraph

    from Flow::PathNode source, Flow::PathNode sink
    where Flow::flowPath(source, sink)
    select sink.getNode(), source, sink, "<message>"

Where:

- ``MyConfiguration`` is a module containing the predicates that define how data may flow between the ``source`` and the ``sink``.
- ``Flow`` is the result of the data flow computation based on ``MyConfiguration``.
- ``Flow::Pathgraph`` is the resulting data flow graph module you need to import in order to include path explanations in the query.
- ``source`` and ``sink`` are nodes in the graph as defined in the configuration, and ``Flow::PathNode`` is their type.
- ``DataFlow::Global<..>`` is an invocation of data flow. ``TaintTracking::Global<..>`` can be used instead to include a default set of additional taint steps.


The following sections describe the main requirements for a valid path query.

Path query metadata
*******************

Path query metadata must contain the property ``@kind path-problem``–this ensures that query results are interpreted and displayed correctly.
The other metadata requirements depend on how you intend to run the query. For more information, see ":doc:`Metadata for CodeQL queries <metadata-for-codeql-queries>`."

Generating path explanations
****************************

In order to generate path explanations, your query needs to compute a graph.
To do this you need to define a :ref:`query predicate <query-predicates>` called ``edges`` in your query.
This predicate defines the edge relations of the graph you are computing, and it is used to compute the paths related to each result that your query generates.
You can import a predefined ``edges`` predicate from a path graph module in one of the standard data flow libraries. In addition to the path graph module, the data flow libraries contain the other ``classes``, ``predicates``, and ``modules`` that are commonly used in data flow analysis.

.. code-block:: ql

    import MyFlow::PathGraph

This statement imports the ``PathGraph`` module from the data flow library (``DataFlow.qll``), in which ``edges`` is defined.

You can also import libraries specifically designed to implement data flow analysis in various common frameworks and environments, and many additional libraries are included with CodeQL. To see examples of the different libraries used in data flow analysis, see the links to the built-in queries above or browse the `standard libraries <https://codeql.github.com/codeql-standard-libraries>`__.

For all languages, you can also optionally define a ``nodes`` query predicate, which specifies the nodes of the path graph that you are interested in. If ``nodes`` is defined, only edges with endpoints defined by these nodes are selected. If ``nodes`` is not defined, you select all possible endpoints of ``edges``.

Defining your own ``edges`` predicate
-------------------------------------

You can also define your own ``edges`` predicate in the body of your query. It should take the following form:

.. code-block:: ql

    query predicate edges(PathNode a, PathNode b) {
      /* Logical conditions which hold if `(a,b)` is an edge in the data flow graph */
    }

For more examples of how to define an ``edges`` predicate, visit the `standard CodeQL libraries <https://codeql.github.com/codeql-standard-libraries>`__ and search for ``edges``.

Declaring sources and sinks
***************************

You must provide information about the ``source`` and ``sink`` in your path query. These are objects that correspond to the nodes of the paths that you are exploring.
The name and the type of the ``source`` and the ``sink`` must be declared in the ``from`` statement of the query, and the types must be compatible with the nodes of the graph computed by the ``edges`` predicate.

If you are querying C/C++, C#, Go, Java/Kotlin, JavaScript/TypeScript, Python, or Ruby code (and you have used ``import MyFlow::PathGraph`` in your query), the definitions of the ``source`` and ``sink`` are accessed via the module resulting from the application of the ``Global<..>`` module in the data flow library. You should declare both of these objects in the ``from`` statement.
For example:

.. code-block:: ql

    module MyFlow = DataFlow::Global<MyConfiguration>;

    from MyFlow::PathNode source, MyFlow::PathNode sink

The configuration module must be defined to include definitions of sources and sinks. For example:

.. code-block:: ql

    module MyConfiguration implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node source) { ... }
      predicate isSink(DataFlow::Node source) { ... }
    }

- ``isSource()`` defines where data may flow from.
- ``isSink()`` defines where data may flow to.

For more information on using the configuration class in your analysis see the sections on global data flow in ":ref:`Analyzing data flow in C/C++ <analyzing-data-flow-in-cpp>`," ":ref:`Analyzing data flow in C# <analyzing-data-flow-in-csharp>`," and ":ref:`Analyzing data flow in Python <analyzing-data-flow-in-python>`."

You can also create a configuration for different frameworks and environments by extending the ``Configuration`` class. For more information, see ":ref:`Types <defining-a-class>`" in the QL language reference.

Defining flow conditions
************************

The ``where`` clause defines the logical conditions to apply to the variables declared in the ``from`` clause to generate your results.
This clause can use :ref:`aggregations <aggregations>`, :ref:`predicates <predicates>`, and logical :ref:`formulas <formulas>` to limit the variables of interest to a smaller set which meet the defined conditions.

When writing a path queries, you would typically include a predicate that holds only if data flows from the ``source`` to the ``sink``.

You can use the ``flowPath`` predicate to specify flow from the ``source`` to the ``sink`` for a given ``Configuration``:

.. code-block:: ql

    where MyFlow::flowPath(source, sink)


Select clause
*************

Select clauses for path queries consist of four 'columns', with the following structure::

    select element, source, sink, string

The ``element`` and ``string`` columns represent the location of the alert and the alert message respectively, as explained in ":doc:`About CodeQL queries <about-codeql-queries>`." The second and third columns, ``source`` and ``sink``, are nodes on the path graph selected by the query.
Each result generated by your query is displayed at a single location in the same way as an alert query. Additionally, each result also has an associated path, which can be viewed in the `CodeQL extension for VS Code <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__.

The ``element`` that you select in the first column depends on the purpose of the query and the type of issue that it is designed to find. This is particularly important for security issues. For example, if you believe the ``source`` value to be globally invalid or malicious it may be best to display the alert at the ``source``. In contrast, you should consider displaying the alert at the ``sink`` if you believe it is the element that requires sanitization.

The alert message defined in the final column in the ``select`` statement can be developed to give more detail about the alert or path found by the query using links and placeholders. For more information, see ":doc:`Defining the results of a query <defining-the-results-of-a-query>`."

Further reading
***************

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.
- `CodeQL repository <https://github.com/github/codeql>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/troubleshooting-query-performance.rst
.. _troubleshooting-query-performance:

Troubleshooting query performance
=================================

Improve the performance of your CodeQL queries by following a few simple guidelines.

About query performance
-----------------------

This topic offers some simple tips on how to avoid common problems that can affect the performance of your queries.
Before reading the tips below, it is worth reiterating a few important points about CodeQL and the QL language:

- CodeQL :ref:`predicates <predicates>` and :ref:`classes <classes>` are evaluated to database `tables <https://en.wikipedia.org/wiki/Table_(database)>`__. Large predicates generate large tables with many rows, and are therefore expensive to compute.
- The QL language is implemented using standard database operations and `relational algebra <https://en.wikipedia.org/wiki/Relational_algebra>`__ (such as join, projection, and union). For more information about query languages and databases, see ":ref:`About the QL language <about-the-ql-language>`."
- Queries are evaluated *bottom-up*, which means that a predicate is not evaluated until *all* of the predicates that it depends on are evaluated. For more information on query evaluation, see ":ref:`Evaluation of QL programs <evaluation-of-ql-programs>`." 

Performance tips
----------------

Follow the guidelines below to ensure that you don't get tripped up by the most common CodeQL performance pitfalls.

Eliminate cartesian products
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The performance of a predicate can often be judged by considering roughly how many results it has. 
One way of creating badly performing predicates is by using two variables without relating them in any way, or only relating them using a negation.
This leads to computing the `Cartesian product <https://en.wikipedia.org/wiki/Cartesian_product>`__ between the sets of possible values for each variable, potentially generating a huge table of results.
This can occur if you don't specify restrictions on your variables. 
For instance, consider the following predicate that checks whether a Java method ``m`` may access a field ``f``:

.. code-block:: ql

   predicate mayAccess(Method m, Field f) {
     f.getAnAccess().getEnclosingCallable() = m
     or
     not exists(m.getBody())
   }

The predicate holds if ``m`` contains an access to ``f``, but also conservatively assumes that methods without bodies (for example, native methods) may access *any* field.

However, if ``m`` is a native method, the table computed by ``mayAccess`` will contain a row ``m, f`` for *all* fields ``f`` in the codebase, making it potentially very large.

This example shows a similar mistake in a member predicate:

.. code-block:: ql

     class Foo extends Class {
       ...
       // BAD! Does not use ‘this’ 
       Method getToString() {
         result.getName() = "ToString"
       }
       ...
     }

Note that while ``getToString()`` does not declare any parameters, it has two implicit parameters, ``result`` and ``this``, which it fails to relate. Therefore, the table computed by ``getToString()`` contains a row for every combination of ``result`` and ``this``. That is, a row for every combination of a method named ``"ToString"`` and an instance of ``Foo``.
To avoid making this mistake, ``this`` should be restricted in the member predicate ``getToString()`` on the class ``Foo``.

Use specific types
~~~~~~~~~~~~~~~~~~

":ref:`Types <types>`" provide an upper bound on the size of a relation. 
This helps the query optimizer be more effective, so it's generally good to use the most specific types possible. For example:

.. code-block:: ql

  predicate foo(LoggingCall e)

is preferred over:

.. code-block:: ql

  predicate foo(Expr e)

From the type context, the query optimizer deduces that some parts of the program are redundant and removes them, or *specializes* them.

Determine the most specific types of a variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you are unfamiliar with the library used in a query, you can use CodeQL to determine what types an entity has. There is a predicate called ``getAQlClass()``, which returns the most specific QL types of the entity that it is called on.

For example, if you were working with a Java database, you might use ``getAQlClass()`` on every ``Expr`` in a callable called ``c``:

.. code-block:: ql

   import java

   from Expr e, Callable c
   where
       c.getDeclaringType().hasQualifiedName("my.namespace.name", "MyClass")
       and c.getName() = "c"
       and e.getEnclosingCallable() = c
   select e, e.getAQlClass()

The result of this query is a list of the most specific types of every ``Expr`` in that function. You will see multiple results for expressions that are represented by more than one type, so it will likely return a very large table of results.

Use ``getAQlClass()`` as a debugging tool, but don't include it in the final version of your query, as it slows down performance.

Avoid complex recursion
~~~~~~~~~~~~~~~~~~~~~~~

":ref:`Recursion <recursion>`" is about self-referencing definitions.
It can be extremely powerful as long as it is used appropriately.
On the whole, you should try to make recursive predicates as simple as possible.
That is, you should define a *base case* that allows the predicate to *bottom out*, along with a single *recursive call*:

.. code-block:: ql

  int depth(Stmt s) {
    exists(Callable c | c.getBody() = s | result = 0) // base case
    or
    result = depth(s.getParent()) + 1 // recursive call
  }

.. pull-quote:: Note

   The query optimizer has special data structures for dealing with :ref:`transitive closures <transitive-closures>`.
   If possible, use a transitive closure over a simple recursive predicate, as it is likely to be computed faster.

Fold predicates
~~~~~~~~~~~~~~~~~~

Sometimes you can assist the query optimizer by "folding" parts of large predicates out into smaller predicates.

The general principle is to split off chunks of work that are:

- **linear**, so that there is not too much branching.
- **tightly bound**, so that the chunks join with each other on as many variables as possible.


In the following example, we explore some lookups on two ``Element``\ s:

.. code-block:: ql

   predicate similar(Element e1, Element e2) {
     e1.getName() = e2.getName() and
     e1.getFile() = e2.getFile() and
     e1.getLocation().getStartLine() = e2.getLocation().getStartLine()
   }

Going from ``Element -> File`` and ``Element -> Location -> StartLine`` is linear--that is, there is only one ``File``, ``Location``, etc. for each ``Element``. 

However, as written it is difficult for the optimizer to pick out the best ordering. Joining first and then doing the linear lookups later would likely result in poor performance. Generally, we want to do the quick, linear parts first, and then join on the resultant larger tables. We can initiate this kind of ordering by splitting the above predicate as follows:

.. code-block:: ql

   predicate locInfo(Element e, string name, File f, int startLine) {
     name = e.getName() and
     f = e.getFile() and
     startLine = e.getLocation().getStartLine()
   }
   
   predicate sameLoc(Element e1, Element e2) {
     exists(string name, File f, int startLine |
       locInfo(e1, name, f, startLine) and
       locInfo(e2, name, f, startLine)
     )
   }

Now the structure we want is clearer. We've separated out the easy part into its own predicate ``locInfo``, and the main predicate ``sameLoc`` is just a larger join.

Further reading
---------------

.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/about-codeql-queries.rst
.. _about-codeql-queries:

About CodeQL queries
####################

CodeQL queries are used to analyze code for issues related to security, correctness, maintainability, and readability.

Overview
********

CodeQL includes queries to find the most relevant and interesting problems for each supported language. You can also write custom queries to find specific issues relevant to your own project. The important types of query are:

- **Alert queries**: queries that highlight issues in specific locations in your code.
- **Path queries**: queries that describe the flow of information between a source and a sink in your code.

You can add custom queries to `CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs>`__ to analyze your projects with "`Code scanning <https://docs.github.com/en/code-security/secure-coding/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning>`__", use them to analyze a database with the "`CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__," or you can contribute to the standard CodeQL queries in our `open source repository on GitHub <https://github.com/github/codeql>`__.

This topic is a basic introduction to query files. You can find more information on writing queries for specific programming languages in the ":ref:`CodeQL language guides <codeql-language-guides>`," and detailed technical information about QL in the ":ref:`QL language reference <ql-language-reference>`."
For more information on how to format your code when contributing queries to the GitHub repository, see the `CodeQL style guide <https://github.com/github/codeql/blob/main/docs/ql-style-guide.md>`__.

Basic query structure
*********************

:ref:`Queries <queries>` written with CodeQL have the file extension ``.ql``, and contain a ``select`` clause. Many of the existing queries include additional optional information, and have the following structure:

.. code-block:: ql

    /**
     *
     * Query metadata
     *
     */

    import /* ... CodeQL libraries or modules ... */

    /* ... Optional, define CodeQL classes and predicates ... */

    from /* ... variable declarations ... */
    where /* ... logical formula ... */
    select /* ... expressions ... */

The following sections describe the information that is typically included in a query file for alerts. Path queries are discussed in more detail in ":doc:`Creating path queries <creating-path-queries>`."

Query metadata
==============

Query metadata is used to identify your custom queries when they are added to the GitHub repository or used in your analysis. Metadata provides information about the query's purpose, and also specifies how to interpret and display the query results. For a full list of metadata properties, see ":doc:`Metadata for CodeQL queries <metadata-for-codeql-queries>`." The exact metadata requirement depends on how you are going to run your query:

- If you are contributing a query to the GitHub repository, please read the `query metadata style guide <https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md>`__.
- If you are analyzing a database using the `CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__, your query metadata must contain ``@kind``.
- If you are running a query with the CodeQL extension for VS Code, metadata is not mandatory. However, if you want your results to be displayed as either an 'alert' or a 'path', you must specify the correct ``@kind`` property, as explained below. For more information, see `Running CodeQL queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries>`__ in the GitHub documentation.

.. pull-quote::

    Note

    Queries that are contributed to the open source repository, or used to analyze a database with the CodeQL CLI must have a query type (``@kind``) specified. The ``@kind`` property indicates how to interpret and display the results of the query analysis:

    - Alert query metadata must contain ``@kind problem`` to identify the results as a simple alert.
    - Path query metadata must contain ``@kind path-problem`` to identify the results as an alert documented by a sequence of code locations.
    - Diagnostic query metadata must contain ``@kind diagnostic`` to identify the results as troubleshooting data about the extraction process.
    - Summary query metadata must contain ``@kind metric`` and ``@tags summary`` to identify the results as summary metrics for the CodeQL database.

    When you define the ``@kind`` property of a custom query you must also ensure that the rest of your query has the correct structure in order to be valid, as described below.

Import statements
=================

Each query generally contains one or more ``import`` statements, which define the :ref:`libraries <library-modules>` or :ref:`modules <modules>` to import into the query. Libraries and modules provide a way of grouping together related :ref:`types <types>`, :ref:`predicates <predicates>`, and other modules. The contents of each library or module that you import can then be accessed by the query.
Our `open source repository on GitHub <https://github.com/github/codeql>`__ contains the standard CodeQL libraries for each supported language.

When writing your own alert queries, you would typically import the standard library for the language of the project that you are querying. For more information about importing the standard CodeQL libraries, see the CodeQL library guides:

- :ref:`CodeQL library guide for C and C++ <codeql-library-for-cpp>`
- :ref:`CodeQL library guide for C# <codeql-library-for-csharp>`
- :ref:`CodeQL library guide for Go <codeql-library-for-go>`
- :ref:`CodeQL library guide for Java and Kotlin <codeql-library-for-java>`
- :ref:`CodeQL library guide for JavaScript <codeql-library-for-javascript>`
- :ref:`CodeQL library guide for Python <codeql-library-for-python>`
- :ref:`CodeQL library guide for Ruby <codeql-library-for-ruby>`
- :ref:`CodeQL library guide for TypeScript <codeql-library-for-typescript>`

There are also libraries containing commonly used predicates, types, and other modules associated with different analyses, including data flow, control flow, and taint-tracking. In order to calculate path graphs, path queries require you to import a data flow library into the query file. For more information, see ":doc:`Creating path queries <creating-path-queries>`."

You can explore the contents of all the standard libraries in the `CodeQL library reference documentation <https://codeql.github.com/codeql-standard-libraries/>`__ or in the `GitHub repository <https://github.com/github/codeql>`__.

Optional CodeQL classes and predicates
--------------------------------------

You can customize your analysis by defining your own predicates and classes in the query. For further information, see :ref:`Defining a predicate <defining-a-predicate>` and :ref:`Defining a class <defining-a-class>`.

From clause
===========

The ``from`` clause declares the variables that are used in the query. Each declaration must be of the form ``<type> <variable name>``.
For more information on the available :ref:`types <types>`, and to learn how to define your own types using :ref:`classes <classes>`, see the :ref:`QL language reference <ql-language-reference>`.

Where clause
============

The ``where`` clause defines the logical conditions to apply to the variables declared in the ``from`` clause to generate your results. This clause uses :ref:`aggregations <aggregations>`, :ref:`predicates <predicates>`, and logical :ref:`formulas <formulas>` to limit the variables of interest to a smaller set, which meet the defined conditions.
The CodeQL libraries group commonly used predicates for specific languages and frameworks. You can also define your own predicates in the body of the query file or in your own custom modules, as described above.

Select clause
=============

The ``select`` clause specifies the results to display for the variables that meet the conditions defined in the ``where`` clause. The valid structure for the select clause is defined by the ``@kind`` property specified in the metadata.

Select clauses for alert queries (``@kind problem``) consist of two 'columns', with the following structure::

    select element, string

- ``element``: a code element that is identified by the query, which defines where the alert is displayed.
- ``string``: a message, which can also include links and placeholders, explaining why the alert was generated.

You can modify the alert message defined in the final column of the ``select`` statement to give more detail about the alert or path found by the query using links and placeholders. For more information, see ":doc:`Defining the results of a query <defining-the-results-of-a-query>`."

Select clauses for path queries (``@kind path-problem``) are crafted to display both an alert and the source and sink of an associated path graph. For more information, see ":doc:`Creating path queries <creating-path-queries>`."

Select clauses for diagnostic queries (``@kind diagnostic``) and summary metric queries (``@kind metric`` and ``@tags summary``) have different requirements. For examples, see the `diagnostic queries <https://github.com/github/codeql/search?q=%22%40kind+diagnostic%22>`__ and the `summary metric queries <https://github.com/github/codeql/search?q=%22%40kind+metric%22+%22%40tags+summary%22>`__  in the CodeQL repository.

Viewing the standard CodeQL queries
***********************************

One of the easiest ways to get started writing your own queries is to modify an existing query. To view the standard CodeQL queries, or to try out other examples, visit the `CodeQL <https://github.com/github/codeql>`__ repository on GitHub.

You can also find examples of queries developed to find security vulnerabilities and bugs in open source software projects on the `GitHub Security Lab website <https://securitylab.github.com/research>`__ and in the associated `repository <https://github.com/github/securitylab>`__.

Contributing queries
********************

Contributions to the standard queries and libraries are very welcome. For more information, see our `contributing guidelines <https://github.com/github/codeql/blob/main/CONTRIBUTING.md>`__.
If you are contributing a query to the open source GitHub repository or using a custom query in an analysis with the CodeQL CLI, then you need to include extra metadata in your query to ensure that the query results are interpreted and displayed correctly. See the following topics for more information on query metadata:

-  ":doc:`Metadata for CodeQL queries <metadata-for-codeql-queries>`"
-  `Query metadata style guide on GitHub <https://github.com/github/codeql/blob/main/docs/query-metadata-style-guide.md>`__

Query contributions to the open source GitHub repository may also have an accompanying query help file to provide information about their purpose for other users. For more information on writing query help, see the `Query help style guide on GitHub <https://github.com/github/codeql/blob/main/docs/query-help-style-guide.md>`__ and the ":doc:`Query help files <query-help-files>`."

Query help files
****************

When you write a custom query, we also recommend that you write a query help file to explain the purpose of the query to other users. For more information, see the `Query help style guide <https://github.com/github/codeql/blob/main/docs/query-help-style-guide.md>`__ on GitHub, and the ":doc:`Query help files <query-help-files>`."



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/catch-the-fire-starter.rst
.. _catch-the-fire-starter:

Catch the fire starter
======================

Learn about QL predicates and classes to solve your second mystery as a QL detective.

Just as you've successfully found the thief and returned the golden crown to the castle, another terrible crime is committed. Early in the morning, a few people start a fire in a field in the north of the village and destroy all the crops!

You now have the reputation of being an expert QL detective, so you are once again asked to find the culprits.

This time, you have some additional information. There is a strong rivalry between the north and south of the village and you know that the criminals live in the south.

Read the examples below to learn how to define predicates and classes in QL. These make the logic of your queries easier to understand and will help simplify your detective work.

Select the southerners
----------------------

This time you only need to consider a specific group of villagers, namely those living in the south of the village. Instead of writing ``getLocation() = "south"`` in all your queries, you could define a new :ref:`predicate <predicates>` ``isSouthern``:

.. code-block:: ql

   predicate isSouthern(Person p) {
     p.getLocation() = "south"
   }

The predicate ``isSouthern(p)`` takes a single parameter ``p`` and checks if ``p`` satisfies the property ``p.getLocation() = "south"``.

.. pull-quote::

   Note

   -  The name of a predicate always starts with a lowercase letter.
   -  You can also define predicates with a result. In that case, the keyword ``predicate`` is replaced with the type of the result. This is like introducing a new argument, the special variable ``result``. For example, ``int getAge() { result = ... }`` returns an ``int``.

You can now list all southerners using:

.. code-block:: ql

   /* define predicate `isSouthern` as above */

   from Person p
   where isSouthern(p)
   select p

This is already a nice way to simplify the logic, but we could be more efficient. Currently, the query looks at every ``Person p``, and then restricts to those who satisfy ``isSouthern(p)``. Instead, we could define a new :ref:`class <classes>` ``Southerner`` containing precisely the people we want to consider.

.. code-block:: ql

   class Southerner extends Person {
     Southerner() { isSouthern(this) }
   }

A class in QL represents a logical property: when a value satisfies that property, it is a member of the class. This means that a value can be in many classes—being in a particular class doesn't stop it from being in other classes too.

The expression ``isSouthern(this)`` defines the logical property represented by the class, called its *characteristic predicate*. It uses a special variable ``this`` and indicates that a ``Person`` "``this``" is a ``Southerner`` if the property ``isSouthern(this)`` holds.

.. pull-quote::

   Note

   If you are familiar with object-oriented programming languages, you might be tempted to think of the characteristic predicate as a *constructor*. However, this is **not** the case—it is a logical property which does not create any objects.

You always need to define a class in QL in terms of an existing (larger) class. In our example, a ``Southerner`` is a special kind of ``Person``, so we say that ``Southerner`` *extends* ("is a subset of") ``Person``.

Using this class you can now list all people living in the south simply as:

.. code-block:: ql

   from Southerner s
   select s

You may have noticed that some predicates are appended, for example ``p.getAge()``, while others are not, for example ``isSouthern(p)``. This is because ``getAge()`` is a member predicate, that is, a predicate that only applies to members of a class. You define such a member predicate inside a class. In this case, ``getAge()`` is defined inside the class ``Person``. In contrast, ``isSouthern`` is defined separately and is not inside any classes. Member predicates are especially useful because you can chain them together easily. For example, ``p.getAge().sqrt()`` first gets the age of ``p`` and then calculates the square root of that number.

Travel restrictions
-------------------

Another factor you want to consider is the travel restrictions imposed following the theft of the crown. Originally there were no restrictions on where villagers could travel within the village. Consequently the predicate ``isAllowedIn(string region)`` held for any person and any region. The following query lists all villagers, since they could all travel to the north:

.. code-block:: ql

   from Person p
   where p.isAllowedIn("north")
   select p

However, after the recent theft, the villagers have become more anxious of criminals lurking around the village and they no longer allow children under the age of 10 to travel out of their home region.

This means that ``isAllowedIn(string region)`` no longer holds for all people and all regions, so you should temporarily *override* the original predicate if ``p`` is a child.

Start by defining a class ``Child`` containing all villagers under 10 years old. Then you can redefine ``isAllowedIn(string region)`` as a member predicate of ``Child`` to allow children only to move within their own region. This is expressed by ``region = this.getLocation()``.

.. code-block:: ql

   class Child extends Person {
     /* the characteristic predicate */
     Child() { this.getAge() < 10 }

     /* a member predicate */
     override predicate isAllowedIn(string region) {
       region = this.getLocation()
     }
   }

Now try applying ``isAllowedIn(string region)`` to a person ``p``. If ``p`` is not a child, the original definition is used, but if ``p`` is a child, the new predicate definition overrides the original.

You know that the fire starters live in the south *and* that they must have been able to travel to the north. Write a query to find the possible suspects. You could also extend the ``select`` clause to list the age of the suspects. That way you can clearly see that all the children have been excluded from the list.

➤ `Check your answer <#exercise-1>`__

You can now continue to gather more clues and find out which of your suspects started the fire...

Identify the bald bandits
-------------------------

You ask the northerners if they have any more information about the fire starters. Luckily, you have a witness! The farmer living next to the field saw two people run away just after the fire started. He only saw the tops of their heads, and noticed that they were both bald.

This is a very helpful clue. Remember that you wrote a QL query to select all bald people:

.. code-block:: ql

   from Person p
   where not exists (string c | p.getHairColor() = c)
   select p

To avoid having to type ``not exists (string c | p.getHairColor() = c)`` every time you want to select a bald person, you can instead define another new predicate ``isBald``.

.. code-block:: ql

   predicate isBald(Person p) {
     not exists (string c | p.getHairColor() = c)
   }

The property ``isBald(p)`` holds whenever ``p`` is bald, so you can replace the previous query with:

.. code-block:: ql

   from Person p
   where isBald(p)
   select p

The predicate ``isBald`` is defined to take a ``Person``, so it can also take a ``Southerner``, as ``Southerner`` is a subtype of ``Person``. It can't take an ``int`` for example—that would cause an error.

You can now write a query to select the bald southerners who are allowed into the north.

➤ `Check your answer <#exercise-2>`__

You have found the two fire starters! They are arrested and the villagers are once again impressed with your work.

Further reading
---------------

.. include:: ../reusables/codeql-ref-tools-further-reading.rst

--------------

Answers
-------

In these answers, we use ``/*`` and ``*/`` to label the different parts of the query. Any text surrounded by ``/*`` and ``*/`` is not evaluated as part of the QL code, but is treated as a *comment*.

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   import tutorial

   predicate isSouthern(Person p) { p.getLocation() = "south" }

   class Southerner extends Person {
     /* the characteristic predicate */
     Southerner() { isSouthern(this) }
   }

   class Child extends Person {
     /* the characteristic predicate */
     Child() { this.getAge() < 10 }

     /* a member predicate */
     override predicate isAllowedIn(string region) { region = this.getLocation() }
   }

   from Southerner s
   where s.isAllowedIn("north")
   select s, s.getAge()

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   import tutorial

   predicate isSouthern(Person p) { p.getLocation() = "south" }

   class Southerner extends Person {
     /* the characteristic predicate */
     Southerner() { isSouthern(this) }
   }

   class Child extends Person {
     /* the characteristic predicate */
     Child() { this.getAge() < 10 }

     /* a member predicate */
     override predicate isAllowedIn(string region) { region = this.getLocation() }
   }

   predicate isBald(Person p) { not exists(string c | p.getHairColor() = c) }

   from Southerner s
   where s.isAllowedIn("north") and isBald(s)
   select s




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/writing-codeql-queries/introduction-to-ql.rst
.. _introduction-to-ql:

Introduction to QL
==================

Work through some simple exercises and examples to learn about the basics of QL and CodeQL.

Basic syntax
------------

The basic syntax of QL will look familiar to anyone who has used SQL, but it is used somewhat differently.

QL is a logic programming language, so it is built up of logical formulas. QL uses common logical connectives (such as ``and``, ``or``, and ``not``), quantifiers (such as ``forall`` and ``exists``), and other important logical concepts such as predicates.

QL also supports recursion and aggregates. This allows you to write complex recursive queries using simple QL syntax and directly use aggregates such as ``count``, ``sum``, and ``average``.

.. include:: ../reusables/codespaces-template-note.rst

Running a query
---------------

You can try out the following examples and exercises using `CodeQL for VS Code <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__ or the `CodeQL template <https://github.com/codespaces/new?template_repository=github/codespaces-codeql>`__ on GitHub Codespaces.

Here is an example of a basic query:

.. code-block:: ql

   select "hello world"

This query returns the string ``"hello world"``.

More complicated queries typically look like this:

.. code-block:: ql

   from /* ... variable declarations ... */
   where /* ... logical formulas ... */
   select /* ... expressions ... */

For example, the result of this query is the number 42:

.. code-block:: ql

   from int x, int y
   where x = 6 and y = 7
   select x * y

Note that ``int`` specifies that the **type** of ``x`` and ``y`` is 'integer'. This means that ``x`` and ``y`` are restricted to integer values. Some other common types are: ``boolean`` (``true`` or ``false``), ``date``, ``float``, and ``string``.

Simple exercises
----------------

You can write simple queries using the some of the basic functions that are available for the ``int``, ``date``, ``float``, ``boolean`` and ``string`` types. To apply a function, append it to the argument. For example, ``1.toString()`` converts the value ``1`` to a string. Notice that as you start typing a function, a pop-up is displayed making it easy to select the function that you want. Also note that you can apply multiple functions in succession. For example, ``100.log().sqrt()`` first takes the natural logarithm of 100 and then computes the square root of the result.

Exercise 1 - Strings
~~~~~~~~~~~~~~~~~~~~

Write a query which returns the length of the string ``"lgtm"``. (Hint: `here <https://codeql.github.com/docs/ql-language-reference/ql-language-specification/#built-ins-for-string>`__ is the list of the functions that can be applied to strings.)

➤ `Check your answer <#exercise-1>`__

Exercise 2 - Numbers
~~~~~~~~~~~~~~~~~~~~

Write a query which returns the sine of the minimum of ``3^5`` (``3`` raised to the power ``5``) and ``245.6``.

➤ `Check your answer <#exercise-2>`__

Exercise 3 - Booleans
~~~~~~~~~~~~~~~~~~~~~

Write a query which returns the opposite of the boolean ``false``.

➤ `Check your answer <#exercise-3>`__

Exercise 4 - Dates
~~~~~~~~~~~~~~~~~~

Write a query which computes the number of days between June 10 and September 28, 2017.

➤ `Check your answer <#exercise-4>`__

Example query with multiple results
-----------------------------------

The exercises above all show queries with exactly one result, but in fact many queries have multiple results. For example, the following query computes all `Pythagorean triples <https://en.wikipedia.org/wiki/Pythagorean_triple>`__ between 1 and 10:

.. code-block:: ql

   from int x, int y, int z
   where x in [1..10] and y in [1..10] and z in [1..10] and
         x*x + y*y = z*z
   select x, y, z

To simplify the query, we can introduce a class ``SmallInt`` representing the integers between 1 and 10. We can also define a predicate ``square()`` on integers in that class. Defining classes and predicates in this way makes it easy to reuse code without having to repeat it every time.

.. code-block:: ql

   class SmallInt extends int {
     SmallInt() { this in [1..10] }
     int square() { result = this*this }
   }

   from SmallInt x, SmallInt y, SmallInt z
   where x.square() + y.square() = z.square()
   select x, y, z

Example CodeQL queries
----------------------

The previous examples used the primitive types built in to QL. Although we chose a project to query, we didn't use the information in that project's database.
The following example queries *do* use these databases and give you an idea of how to use CodeQL to analyze projects.

Queries using the CodeQL libraries can find errors and uncover variants of important security vulnerabilities in codebases.
Visit `GitHub Security Lab <https://securitylab.github.com/>`__ to read about examples of vulnerabilities that we have recently found in open source projects.

Before you can run the following examples, you will need to install the CodeQL extension for Visual Studio Code. For more information, see `Installing CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ in the GitHub documentation. You will also need to import and select a database in the corresponding programming language.

To import the CodeQL library for a specific programming language, type ``import <language>`` at the start of the query.

.. code-block:: ql

   import python

   from Function f
   where count(f.getAnArg()) > 7
   select f

The ``from`` clause defines a variable ``f`` representing a Python function. The ``where`` part limits the functions ``f`` to those with more than 7 arguments. Finally, the ``select`` clause lists these functions.

.. code-block:: ql

   import javascript

   from Comment c
   where c.getText().regexpMatch("(?si).*\\bTODO\\b.*")
   select c

The ``from`` clause defines a variable ``c`` representing a JavaScript comment. The ``where`` part limits the comments ``c`` to those containing the word ``"TODO"``. The ``select`` clause lists these comments.

.. code-block:: ql

   import java

   from Parameter p
   where not exists(p.getAnAccess())
   select p

The ``from`` clause defines a variable ``p`` representing a Java parameter. The ``where`` clause finds unused parameters by limiting the parameters ``p`` to those which are not accessed. Finally, the ``select`` clause lists these parameters.

Further reading
---------------

-  For a more technical description of the underlying language, see the ":ref:`QL language reference <ql-language-reference>`."

--------------

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   from string s
   where s = "lgtm"
   select s.length()

There is often more than one way to define a query. For example, we can also write the above query in the shorter form:

.. code-block:: ql

   select "lgtm".length()

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   from float x, float y
   where x = 3.pow(5) and y = 245.6
   select x.minimum(y).sin()

Exercise 3
~~~~~~~~~~

.. code-block:: ql

   from boolean b
   where b = false
   select b.booleanNot()

Exercise 4
~~~~~~~~~~

.. code-block:: ql

   from date start, date end
   where start = "10/06/2017".toDate() and end = "28/09/2017".toDate()
   select start.daysTo(end)



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/running-queries-debug.rst
If you want to examine query performance, enable the **Running Queries: Debug** setting to include timing and tuple counts. This is shown in the logs in the CodeQL Query Server tab of the Output view. The tuple count is useful because it indicates the size of the :ref:`predicates <predicates>` computed by the query.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/supported-versions-compilers.rst
.. csv-table::
   :header-rows: 1
   :widths: auto
   :stub-columns: 1

   Language,Variants,Compilers,Extensions
   C/C++,"C89, C99, C11, C17, C++98, C++03, C++11, C++14, C++17, C++20 [1]_ [2]_","Clang (including clang-cl [3]_ and armclang) extensions (up to Clang 17.0),

   GNU extensions (up to GCC 13.2),

   Microsoft extensions (up to VS 2022),

   Arm Compiler 5 [4]_","``.cpp``, ``.c++``, ``.cxx``, ``.hpp``, ``.hh``, ``.h++``, ``.hxx``, ``.c``, ``.cc``, ``.h``"
   C#,C# up to 12,"Microsoft Visual Studio up to 2019 with .NET up to 4.8,

   .NET Core up to 3.1

   .NET 5, .NET 6, .NET 7, .NET 8","``.sln``, ``.csproj``, ``.cs``, ``.cshtml``, ``.xaml``"
   Go (aka Golang), "Go up to 1.22", "Go 1.11 or more recent", ``.go``
   Java,"Java 7 to 22 [5]_","javac (OpenJDK and Oracle JDK),

   Eclipse compiler for Java (ECJ) [6]_",``.java``
   Kotlin,"Kotlin 1.5.0 to 2.0.2\ *x*","kotlinc",``.kt``
   JavaScript,ECMAScript 2022 or lower,Not applicable,"``.js``, ``.jsx``, ``.mjs``, ``.es``, ``.es6``, ``.htm``, ``.html``, ``.xhtm``, ``.xhtml``, ``.vue``, ``.hbs``, ``.ejs``, ``.njk``, ``.json``, ``.yaml``, ``.yml``, ``.raml``, ``.xml`` [7]_"
   Python [8]_,"2.7, 3.5, 3.6, 3.7, 3.8, 3.9, 3.10, 3.11, 3.12",Not applicable,``.py``
   Ruby [9]_,"up to 3.3",Not applicable,"``.rb``, ``.erb``, ``.gemspec``, ``Gemfile``"
   Swift [10]_,"Swift 5.4-5.10","Swift compiler","``.swift``"
   TypeScript [11]_,"2.6-5.5",Standard TypeScript compiler,"``.ts``, ``.tsx``, ``.mts``, ``.cts``"

.. container:: footnote-group

    .. [1] C++20 support is currently in beta. Modules are *not* supported.
    .. [2] Objective-C, Objective-C++, C++/CLI, and C++/CX are not supported.
    .. [3] Support for the clang-cl compiler is preliminary.
    .. [4] Support for the Arm Compiler (armcc) is preliminary.
    .. [5] Builds that execute on Java 7 to 22 can be analyzed. The analysis understands Java 22 standard language features.
    .. [6] ECJ is supported when the build invokes it via the Maven Compiler plugin or the Takari Lifecycle plugin.
    .. [7] JSX and Flow code, YAML, JSON, HTML, and XML files may also be analyzed with JavaScript files.
    .. [8] The extractor requires Python 3 to run. To analyze Python 2.7 you should install both versions of Python.
    .. [9] Requires glibc 2.17.
    .. [10] Support for the analysis of Swift requires macOS or Linux.
    .. [11] TypeScript analysis is performed by running the JavaScript extractor with TypeScript enabled. This is the default.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/threads-query-execution.rst
``--threads``: optionally, the number of threads to use when running queries.
The default option is ``1``. You can specify more threads to speed up query
execution. Specifying ``0`` matches the number of threads to the number of logical processors.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/ruby-further-reading.rst
- `CodeQL queries for Ruby <https://github.com/github/codeql/tree/main/ruby/ql/src>`__
- `Example queries for Ruby <https://github.com/github/codeql/tree/main/ruby/ql/examples>`__
- `CodeQL library reference for Ruby <https://codeql.github.com/codeql-standard-libraries/ruby/>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/license-note.rst
.. pull-quote:: License notice

   If you don't have an Enterprise license then, by installing this product, you are agreeing to the 
   `GitHub CodeQL Terms and Conditions <https://securitylab.github.com/tools/codeql/license>`__.
   
   GitHub CodeQL is licensed on a per-user basis. Under the license restrictions,
   you can use CodeQL to perform the following tasks:
   
   - To perform academic research.
   - To demonstrate the software.
   - To test CodeQL queries that are released under an OSI-approved
     License to confirm that new versions of those queries continue to
     find the right vulnerabilities.
   
   where "OSI-approved License" means an Open Source Initiative
   (OSI)-approved open source software license.
   
   If you are working with an Open Source Codebase (that is, a codebase that is 
   released under an OSI-approved License) you can also use CodeQL for the following tasks:

   - To perform analysis of the Open Source Codebase.
   - If the Open Source Codebase is hosted and maintained on
     GitHub.com, to generate CodeQL databases for or during automated
     analysis, continuous integration, or continuous delivery.
   
   CodeQL can't be used for automated analysis, continuous integration or
   continuous delivery, whether as part of normal software engineering processes
   or otherwise, except in the express cases set forth herein. For these uses,
   contact the `sales team <https://enterprise.github.com/contact>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/kotlin-java-differences.rst
Writing CodeQL queries for Kotlin versus Java analysis
------------------------------------------------------

Generally you use the same classes to write queries for Kotlin and for Java. You use the same libraries such as DataFlow, TaintTracking, or SSA, and the same classes such as ``MethodAccess`` or ``Class`` for both languages. When you want to access Kotlin-specific elements (such as a ``WhenExpr``) you’ll need to use Kotlin-specific CodeQL classes.

There are however some important cases where writing queries for Kotlin can produce surprising results compared to writing queries for Java, as CodeQL works with the JVM bytecode representation of the Kotlin source code. 

Be careful when you model code elements that don’t exist in Java, such as ``NotNullExpr (expr!!)``, because they could interact in unexpected ways with common predicates. For example, ``MethodAccess.getQualifier()`` returns a ``NotNullExpr`` instead of a ``VarAccess`` in the following Kotlin code:

.. code-block:: kotlin
   
   someVar!!.someMethodCall()

In that specific case, you can use the predicate ``Expr.getUnderlyingExpr()``. This goes directly to the underlying ``VarAccess`` to produce a more similar behavior to that in Java.

Nullable elements (``?``) can also produce unexpected behavior. To avoid a ``NullPointerException``, Kotlin may inline calls like ``expr.toString()`` to ``String.valueOf(expr)`` when ``expr`` is nullable. Make sure that you write CodeQL around the extracted code, which may not exactly match the code as written in the codebase.

Another example is that if-else expressions in Kotlin are translated into ``WhenExprs`` in CodeQL, instead of the more typical ``IfStmt`` seen in Java.

In general, you can debug these issues with the AST (you can use the ``CodeQL: View AST`` command from Visual Studio Code’s CodeQL extension, or run the ``PrintAst.ql`` query) and see exactly what CodeQL is extracting from your code.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/supported-frameworks.rst
C and C++ built-in support
================================

Provided by the current versions of the
CodeQL query pack ``codeql/cpp-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/src>`__)
and the CodeQL library pack ``codeql/cpp-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   `Berkeley socket API library <https://en.wikipedia.org/wiki/Berkeley_sockets#Socket_API_functions>`__, Network communicator
   `Bloomberg Standard Library <https://github.com/bloomberg/bde>`__, Utility library
   string.h, String library

C# built-in support
================================

Provided by the current versions of the
CodeQL query pack ``codeql/csharp-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/src>`__)
and the CodeQL library pack ``codeql/csharp-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   ASP.NET, Web application framework
   ASP.NET Core, Web application framework
   ASP.NET Razor templates, Web application framework
   Dapper, Database ORM
   EntityFramework, Database ORM
   EntityFramework Core, Database ORM
   Json.NET, Serialization
   NHibernate, Database ORM
   WinForms, User interface

Go built-in support
================================

Provided by the current versions of the
CodeQL query pack ``codeql/go-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/src>`__)
and the CodeQL library pack ``codeql/go-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   `AWS Lambda <https://docs.aws.amazon.com/lambda/latest/dg/lambda-golang.html>`_, Serverless framework
   `beego <https://beego.me/>`_, Web/logging/database framework
   `Chi <https://github.com/go-chi/chi>`_, Web framework
   Couchbase (`gocb <https://github.com/couchbase/gocb>`_ and `go-couchbase <http://www.github.com/couchbase/go-couchbase>`_), Database
   `Echo <https://echo.labstack.com/>`_, Web framework
   `Gin <https://github.com/gin-gonic/gin>`_, Web framework
   `glog <https://github.com/golang/glog>`_, Logging library
   `go-pg <https://pg.uptrace.dev/>`_, Database
   `go-restful <https://github.com/emicklei/go-restful>`_, Web application framework
   `go-sh <https://github.com/codeskyblue/go-sh>`_, Utility library
   `go-spew <https://github.com/davecgh/go-spew>`_, Logging library
   `GoKit <https://github.com/go-kit/kit>`_, Microservice toolkit
   `Gokogiri <https://github.com/jbowtie/gokogiri>`_, XPath library
   `golang.org/x/crypto/ssh <https://pkg.go.dev/golang.org/x/crypto/ssh>`_, Network communicator
   `golang.org/x/net/websocket <https://pkg.go.dev/golang.org/x/net/websocket>`_, Network communicator
   `goproxy <https://github.com/elazarl/goproxy>`_, HTTP proxy library
   `Gorilla mux <http://www.gorillatoolkit.org/pkg/mux>`_, HTTP request router and dispatcher
   `Gorilla websocket <https://github.com/gorilla/websocket>`_, Network communicator
   `GORM <https://gorm.io/>`_, Database
   `GoWebsocket <https://github.com/sacOO7/gowebsocket>`_, Network communicator
   `goxpath <https://github.com/ChrisTrenkamp/goxpath>`_, XPath library
   `htmlquery <https://github.com/antchfx/htmlquery>`_, XPath library
   `json-iterator <https://github.com/json-iterator/go>`_, Serialization
   `jsonpatch <https://github.com/evanphx/json-patch>`_, Serialization
   `jsonquery <https://github.com/antchfx/jsonquery>`_, XPath library
   `klog <https://github.com/kubernetes/klog>`_, Logging library
   `Logrus <https://github.com/sirupsen/logrus>`_, Logging library
   `Macaron <https://gopkg.in/macaron.v1>`_, Web framework
   `mongo <https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo>`_, Database
   `nhooyr.io/websocket <http://nhooyr.io/websocket>`_, Network communicator
   `protobuf <https://pkg.go.dev/google.golang.org/protobuf>`_, Serialization
   `Revel <http://revel.github.io/>`_, Web framework
   `SendGrid <https://github.com/sendgrid/sendgrid-go>`_, Email library
   `sqlx <http://jmoiron.github.io/sqlx/>`_, Database
   `Squirrel <https://github.com/Masterminds/squirrel>`_, Database
   `ws <https://github.com/gobwas/ws>`_, Network communicator
   `xmlpath <https://gopkg.in/xmlpath.v2>`_, XPath library
   `xmlquery <https://github.com/antchfx/xmlquery>`_, XPath library
   `xpath <https://github.com/antchfx/xpath>`_, XPath library
   `xpathparser <https://github.com/santhosh-tekuri/xpathparser>`_, XPath library
   `yaml <https://gopkg.in/yaml.v3>`_, Serialization
   `zap <https://go.uber.org/zap>`_, Logging library

Java and Kotlin built-in support
==================================

Provided by the current versions of the
CodeQL query pack ``codeql/java-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/src>`__)
and the CodeQL library pack ``codeql/java-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   Apache Commons Collections, Data structure utility library
   Apache Commons Lang, Utility library
   Apache HTTP components, Network communicator
   Guava, Utility and collections library
   Hibernate, Database
   iBatis / MyBatis, Database
   Jackson, Serialization
   Java Persistence API (JPA), Database
   JaxRS, Jakarta EE API specification
   JDBC, Database
   JSON-java, Serialization
   Kryo deserialization, Serialization
   Project Lombok, Utility library
   Protobuf, Serialization
   SnakeYaml, Serialization
   Spring JDBC, Database
   Spring MVC, Web application framework
   Struts, Web application framework
   Thrift, RPC framework
   XStream, Serialization

JavaScript and TypeScript built-in support
=======================================================

Provided by the current versions of the
CodeQL query pack ``codeql/javascript-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/src>`__)
and the CodeQL library pack ``codeql/javascript-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   angular (modern version), HTML framework
   angular.js (legacy version), HTML framework
   AWS Lambda, Serverless framework
   axios, Network communicator
   browser, Runtime environment
   EJS, templating language
   electron, Runtime environment
   express, Server
   Fastify, Server
   handlebars, templating language
   hapi, Server
   hogan, templating language
   jquery, Utility library
   koa, Server
   lodash, Utility library
   mongodb, Database
   mssql, Database
   mustache, templating language
   mysql, Database
   nest.js, Server
   node, Runtime environment
   nunjucks, templating language
   postgres, Database
   ramda, Utility library
   react, HTML framework
   react native, HTML framework
   request, Network communicator
   restify, Server
   sequelize, Database
   socket.io, Network communicator
   sqlite3, Database
   superagent, Network communicator
   swig, templating language
   underscore, Utility library
   vue, HTML framework


Python built-in support
====================================

Provided by the current versions of the
CodeQL query pack ``codeql/python-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/src>`__)
and the CodeQL library pack ``codeql/python-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   AWS Lambda, Serverless framework
   aiohttp.web, Web framework
   Django, Web framework
   djangorestframework, Web framework
   FastAPI, Web framework
   Flask, Web framework
   Flask-Admin, Web framework
   Tornado, Web framework
   Twisted, Web framework
   Gradio, Web framework
   starlette, Asynchronous Server Gateway Interface (ASGI)
   ldap3, Lightweight Directory Access Protocol (LDAP)
   python-ldap, Lightweight Directory Access Protocol (LDAP)
   httpx, HTTP client
   pycurl, HTTP client
   requests, HTTP client
   urllib, HTTP client
   urllib2, HTTP client
   urllib3, HTTP client
   dill, Serialization
   PyYAML, Serialization
   ruamel.yaml, Serialization
   simplejson, Serialization
   toml, Serialization
   ujson, Serialization
   fabric, Utility library
   idna, Utility library
   invoke, Utility library
   jmespath, Utility library
   multidict, Utility library
   pydantic, Utility library
   yarl, Utility library
   aioch, Database
   aiomysql, Database
   aiopg, Database
   aiosqlite, Database
   asyncpg, Database
   cassandra-driver, Database
   clickhouse-driver, Database
   cx_Oracle, Database
   mysql-connector, Database
   mysql-connector-python, Database
   MySQL-python, Database
   mysqlclient, Database
   oracledb, Database
   phoenixdb, Database
   psycopg2, Database
   pymssql, Database
   PyMySQL, Database
   pyodbc, Database
   sqlite3, Database
   Flask-SQLAlchemy, Database ORM
   peewee, Database ORM
   SQLAlchemy, Database ORM
   cryptography, Cryptography library
   pycryptodome, Cryptography library
   pycryptodomex, Cryptography library
   rsa, Cryptography library
   MarkupSafe, Escaping Library
   libtaxii, TAXII utility library
   libxml2, XML processing library
   lxml, XML processing library
   xmltodict, XML processing library


Ruby built-in support
====================================

Provided by the current versions of the
CodeQL query pack ``codeql/ruby-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/src>`__)
and the CodeQL library pack ``codeql/ruby-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   excon, HTTP client
   faraday, HTTP client
   http_client, HTTP client
   httparty, HTTP client
   libxml-ruby, XML processing library
   nokogiri, XML processing library
   open-uri, HTTP client
   posix-spawn, Utility library
   rest-client, HTTP client
   Ruby on Rails, Web framework
   rubyzip, Compression library
   typhoeus, HTTP client

Swift built-in support
================================

Provided by the current versions of the
CodeQL query pack ``codeql/swift-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/src>`__)
and the CodeQL library pack ``codeql/swift-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/swift/ql/lib>`__).

.. csv-table::
   :header-rows: 1
   :class: fullWidthTable
   :widths: auto

   Name, Category
   `AEXML <https://github.com/tadija/AEXML>`__, XML processing library
   `Alamofire <https://github.com/Alamofire/Alamofire>`__, Network communicator
   `Core Data <https://developer.apple.com/documentation/coredata/>`__, Database
   `CryptoKit <https://developer.apple.com/documentation/cryptokit/>`__, Cryptography library
   `CryptoSwift <https://github.com/krzyzanowskim/CryptoSwift>`__, Cryptography library
   `Foundation <https://developer.apple.com/documentation/foundation>`__, Utility library
   `GRDB <https://github.com/groue/GRDB.swift>`__, Database
   `JavaScriptCore <https://developer.apple.com/documentation/javascriptcore>`__, Scripting library
   `Libxml2 <https://gitlab.gnome.org/GNOME/libxml2>`__, XML processing library
   `Network <https://developer.apple.com/documentation/network>`__, Network communicator
   `Realm Swift <https://realm.io/realm-swift/>`__, Database
   `RNCryptor <https://github.com/RNCryptor/RNCryptor>`__, Cryptography library
   `SQLite3 <https://sqlite.org/index.html>`__, Database
   `SQLite.swift <https://github.com/stephencelis/SQLite.swift>`__, Database
   `UIKit <https://developer.apple.com/documentation/uikit>`__, User interface library
   `WebKit <https://developer.apple.com/documentation/webkit>`__, User interface library



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/beta-note-customizing-library-models.rst
.. pull-quote::

   Beta Notice - Unstable API

   Library customization using data extensions is currently in beta and subject to change.

   Breaking changes to this format may occur while in beta.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/extractors.rst
.. list-table::
   :header-rows: 1
   :widths: 50 50

   * - Language
     - Identifier
   * - C/C++ 
     - ``cpp``
   * - C# 
     - ``csharp``
   * - Go
     - ``go``
   * - Java/Kotlin
     - ``java``
   * - JavaScript/TypeScript
     - ``javascript``
   * - Python
     - ``python``
   * - Ruby
     - ``ruby``
   * - Swift
     - ``swift``


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/cpp-further-reading.rst
- `CodeQL queries for C and C++ <https://github.com/github/codeql/tree/main/cpp/ql/src>`__
- `Example queries for C and C++ <https://github.com/github/codeql/tree/main/cpp/ql/examples>`__
- `CodeQL library reference for C and C++ <https://codeql.github.com/codeql-standard-libraries/cpp/>`__




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/cpp-new-dataflow-api-note.rst
.. pull-quote:: Note

   The data flow library described here is available from CodeQL 2.12.5 onwards. With the release of CodeQL 2.13.0 the library uses the new modular API for data flow. For information on the previous version of the library, see :ref:`Analyzing data flow in C and C++ <analyzing-data-flow-in-cpp>` and for information about the new modular API and how to migrate any existing queries to the updated data flow library, see `New dataflow API for CodeQL query writing <https://gh.io/codeql-new-dataflow-api>`__.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/supported-platforms.rst
.. csv-table::
   :header-rows: 1
   :widths: auto
   :stub-columns: 1

   Operating system,Supported versions,Supported CPU architectures
   Linux,"Ubuntu 18.04

   Ubuntu 20.04

   Ubuntu 21.04

   Ubuntu 22.04","x86-64"
   Windows,"Windows 10 / Windows Server 2019

   Windows 11 / Windows Server 2022","x86-64"
   macOS,"macOS 12 Monterey

   macOS 13 Ventura

   macOS 14 Sonoma","x86-64, arm64 (Apple Silicon)

   x86-64, arm64 (Apple Silicon)

   x86-64, arm64 (Apple Silicon) [1]_"

.. container:: footnote-group

    .. [1] Support for Apple Silicon is currently in beta.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/beta-note-package-management.rst
.. pull-quote::

    Note

    The CodeQL package management functionality, including all types of CodeQL pack, is currently available as a beta release and is subject to change. During the beta release, CodeQL packs are available only using GitHub Packages - the GitHub Container registry. To use this beta functionality, install the latest version of the CodeQL CLI bundle from: https://github.com/github/codeql-action/releases.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/codeql-ref-tools-further-reading.rst
- ":ref:`QL language reference <ql-language-reference>`"
- ":ref:`CodeQL tools <codeql-tools>`"


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/csharp-further-reading.rst
- `CodeQL queries for C# <https://github.com/github/codeql/tree/main/csharp/ql/src>`__
- `Example queries for C# <https://github.com/github/codeql/tree/main/csharp/ql/examples>`__
- `CodeQL library reference for C# <https://codeql.github.com/codeql-standard-libraries/csharp/>`__




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/beta-note-threat-models.rst
.. pull-quote::

    Note

    Threat models are currently in beta and subject to change. During the beta, threat models are supported only by Java and C# analysis.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/new-data-flow-api.rst
.. pull-quote:: Note

   The new modular API for data flow described here is available alongside the previous library from CodeQL 2.13.0 onwards. For information about how the library has changed and how to migrate any existing queries to the modular API, see `New dataflow API for CodeQL query writing <https://gh.io/codeql-new-dataflow-api>`__.
   


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/codeql-cli-migration-toc-note.rst
If you want to go to a specific subsection in the new location, see the TOC links below.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/vs-code-deprecation-note.rst
.. pull-quote::

    Note

    This documentation `was migrated <https://github.blog/changelog/2024-04-18-codeql-for-visual-studio-code-documentation-is-now-on-docs-github-com/>`__ to ``docs.github.com/en/code-security/codeql-for-vs-code`` on 2024/05/08, and this version is no longer maintained.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/download-github-database.rst
GitHub stores CodeQL databases for over 200,000 repos on GitHub.com, which you can download using the REST API. The list of repos is constantly growing and evolving to make sure that it includes the most interesting codebases for security research.

You can check if a repository has any CodeQL databases available for download using the ``/repos/<owner>/<repo>/code-scanning/codeql/databases`` endpoint.
For example, to check for CodeQL databases using the `GitHub CLI <https://cli.github.com/manual/gh_api>`__ you would run::

   gh api /repos/<owner>/<repo>/code-scanning/codeql/databases

This command returns information about any CodeQL databases that are available for a repository, including the language the database represents, and when the database was last updated. If no CodeQL databases are available, the response is empty.

When you have confirmed that a CodeQL database exists for the language you are interested in, you can download it using the following command::

   gh api /repos/<owner>/<repo>/code-scanning/codeql/databases/<language> -H 'Accept: application/zip' > path/to/local/database.zip

For more information, see the documentation for the `Get CodeQL database <https://docs.github.com/en/rest/code-scanning#get-a-codeql-database-for-a-repository>`__ endpoint in the GitHub REST API documentation.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/java-further-reading.rst
- `CodeQL queries for Java <https://github.com/github/codeql/tree/main/java/ql/src>`__
- `Example queries for Java <https://github.com/github/codeql/tree/main/java/ql/examples>`__
- `CodeQL library reference for Java <https://codeql.github.com/codeql-standard-libraries/java/>`__




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/path-problem.rst
You can model data flow paths in CodeQL by creating path queries. To view data flow paths generated by a path query in CodeQL for VS Code, you need to make sure that it has the correct metadata and ``select`` clause. For more information, see :ref:`Creating path queries <creating-path-queries>`. 


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/data-extensions.rst
.. _data-extensions:

Data Extensions
===============

.. pull-quote::

   Beta Notice - Internal documentation

   Data extensions are documented internally in a `Google doc <https://docs.google.com/document/d/14IYCHX8wWuU-HTvJ2gPSdXQKHKYbWCHQKOgn8oLaa80>`_.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/go-further-reading.rst
- `CodeQL queries for Go <https://github.com/github/codeql/tree/main/go/ql/src>`__
- `Example queries for Go <https://github.com/github/codeql/tree/main/go/ql/examples>`__
- `CodeQL library reference for Go <https://codeql.github.com/codeql-standard-libraries/go/>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/codespaces-template-note.rst
.. pull-quote::

   Note

   You can use the CodeQL template (beta) in `GitHub Codespaces <https://github.com/codespaces/new?template_repository=github/codespaces-codeql>`__ to try out the QL concepts and programming-language-agnostic examples in these tutorials. The template includes a guided introduction to working with QL, and makes it easy to get started.

   When you're ready to run CodeQL queries on actual codebases, you will need to install the CodeQL extension in Visual Studio Code. For instructions, see `Installing CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ in the GitHub documentation.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/javascript-further-reading.rst
- `CodeQL queries for JavaScript <https://github.com/github/codeql/tree/main/javascript/ql/src>`__
- `Example queries for JavaScript <https://github.com/github/codeql/tree/main/javascript/ql/examples>`__
- `CodeQL library reference for JavaScript <https://codeql.github.com/codeql-standard-libraries/javascript/>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/beta-note-model-pack-editor-vsc.rst
.. pull-quote::

    Note

    The CodeQL model editor and CodeQL model packs are currently in beta and subject to change. During the beta, model packs are supported only by Java/Kotlin and C# analysis. To use this beta functionality, install the latest version of the CodeQL extension for Visual Studio Code.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/swift-further-reading.rst
- `CodeQL queries for Swift <https://github.com/github/codeql/tree/main/swift/ql/src/queries>`__
- `Example queries for Swift <https://github.com/github/codeql/tree/main/swift/ql/examples>`__
- `CodeQL library reference for Swift <https://codeql.github.com/codeql-standard-libraries/swift/>`__




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/abstract-syntax-tree.rst
The `abstract syntax tree (AST) <https://en.wikipedia.org/wiki/Abstract_syntax_tree>`__ represents the syntactic structure of a program. Nodes on the AST represent elements such as statements and expressions.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/threat-model-description.rst
.. include:: ../reusables/beta-note-threat-models.rst

A threat model is a named class of dataflow sources that can be enabled or disabled independently. Threat models allow you to control the set of dataflow sources that you want to consider unsafe. For example, one codebase may only consider remote HTTP requests to be tainted, whereas another may also consider data from local files to be unsafe. You can use threat models to ensure that the relevant taint sources are used in a CodeQL analysis.

The ``kind`` property of the ``sourceModel`` determines which threat model a source is associated with. There are two main categories:

- ``remote`` which represents requests and responses from the network.
- ``local`` which represents data from local files (``file``), command-line arguments (``commandargs``), database reads (``database``), environment variables(``environment``) and Windows registry values ("windows-registry"). Currently, Windows registry values are used by C# only.

Note that subcategories can be turned included or excluded separately, so you can specify ``local`` without ``database``, or just ``commandargs`` and ``environment`` without the rest of ``local``.

The less commonly used categories are:

- ``android`` which represents reads from external files in Android (``android-external-storage-dir``) and parameter of an entry-point method declared in a ``ContentProvider`` class (``contentprovider``). Currently only used by Java/Kotlin.
- ``database-access-result`` which represents a database access. Currently only used by JavaScript.
- ``file-write`` which represents opening a file in write mode. Currently only used in C#.
- ``reverse-dns`` which represents reverse DNS lookups. Currently only used in Java.

When running a CodeQL analysis, the ``remote`` threat model is included by default. You can optionally include other threat models as appropriate when using the CodeQL CLI and in GitHub code scanning. For more information, see `Analyzing your code with CodeQL queries <https://docs.github.com/code-security/codeql-cli/getting-started-with-the-codeql-cli/analyzing-your-code-with-codeql-queries#including-model-packs-to-add-potential-sources-of-tainted-data>`__ and `Customizing your advanced setup for code scanning <https://docs.github.com/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#extending-codeql-coverage-with-threat-models>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/codeql-cli-articles-migration-note.rst
The source file now exists in the public, open-source `docs <https://github.com/github/docs/tree/main/content/code-security/codeql-cli>`__ repository. If you would like to contribute, you can consult the `GitHub docs contributing guide <https://github.com/github/docs/blob/main/CONTRIBUTING.md>`__. 


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/beta-note-mrva.rst
.. pull-quote::

    Note

    Multi-repository variant analysis is currently available as a beta release and is subject to change. To use this feature, you must upgrade the CodeQL extension for Visual Studio Code to a minimum of version 1.8.0.
    
    You can report your feedback in the community discussion for the beta release: https://gh.io/mrva-public-beta-discussion.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/setup-to-run-tutorials.rst
For information about installing the CodeQL extension for Visual Studio code, see `Installing CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code>`__ in the GitHub documentation.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/codeql-cli-overview.rst
The CodeQL command-line interface (CLI) is used to create databases for 
security research. You can query CodeQL databases directly from the command line 
or using the Visual Studio Code extension.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/python-further-reading.rst
- `CodeQL queries for Python <https://github.com/github/codeql/tree/main/python/ql/src>`__
- `Example queries for Python <https://github.com/github/codeql/tree/main/python/ql/examples>`__
- `CodeQL library reference for Python <https://codeql.github.com/codeql-standard-libraries/python/>`__




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/query-help-overview.rst
Visit the articles below to see the documentation for the queries included in the following query suites:

- ``default``: queries run by default in CodeQL code scanning on GitHub.
- ``security-extended``: queries from ``default``, plus extra security queries with slightly lower precision and severity.
- ``security-and-quality``: queries from ``default``, ``security-extended``, plus extra maintainability and reliability queries.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/test-qlpack.rst
.. code-block:: yaml

   name: my-github-user/my-query-tests
   dependencies:
     my-github-user/my-custom-queries: ^1.2.3
   extractor: java
   tests: .

This ``qlpack.yml`` file states that ``my-github-user/my-query-tests`` depends on ``my-github-user/my-custom-queries`` at a version greater than or equal to 1.2.3 and less than 2.0.0. It also declares that the CLI should use the Java ``extractor`` when creating test databases. The ``tests: .`` line declares that all ``.ql`` files in the pack should be run as tests when ``codeql test run`` is run with the ``--strict-test-discovery`` option. Typically, test packs do not contain a ``version`` property. This prevents you from accidentally publishing them.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/vs-code-basic-instructions/find-database.rst
Finding a CodeQL database to experiment with
--------------------------------------------

Before you start writing queries for |language-text| code, you need a CodeQL database to run them against. The simplest way to do this is to download a database for a repository that uses |language-text| directly from GitHub.com.

#. In Visual Studio Code, click the **QL** icon |codeql-ext-icon| in the left sidebar to display the CodeQL extension. 

#. Click **From GitHub** or the GitHub logo |github-db| at the top of the CodeQL extension to open an entry field.

#. Copy the URL for the repository into the field and press the keyboard **Enter** key. For example, |example-url|.

#. Optionally, if the repository has more than one CodeQL database available, select |language-code| to download the database created from the |language-text| code. 

Information about the download progress for the database is shown in the bottom right corner of Visual Studio Code. When the download is complete, the database is shown with a check mark in the **Databases** section of the CodeQL extension (see screenshot below).

.. |codeql-ext-icon| image:: ../images/codeql-for-visual-studio-code/codeql-extension-icon.png
  :width: 20
  :alt: Icon for the CodeQL extension.

.. |github-db| image:: ../images/codeql-for-visual-studio-code/add-codeql-db-github.png
  :width: 20
  :alt: Icon for the CodeQL extension option to download a CodeQL database from GitHub.




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/vs-code-basic-instructions/note-store-quick-query.rst
.. pull-quote::

   Note

   If you want to move your experimental query somewhere more permanent, you need to move the whole ``Quick Queries`` directory. The directory is a CodeQL pack with a ``qlpack.yml`` file that defines the content as queries for |language-text| CodeQL databases. For more information about CodeQL packs, see "`Managing CodeQL query packs and library packs <https://docs.github.com/en/code-security/codeql-for-vs-code/using-the-advanced-functionality-of-the-codeql-for-vs-code-extension/managing-codeql-packs/>`__."



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/vs-code-basic-instructions/setup-to-run-queries.rst
For information about installing the CodeQL extension for Visual Studio code, see "`Installing CodeQL for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/installing-codeql-for-vs-code/>`__."



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/vs-code-basic-instructions/run-quick-query-2.rst
4. Save the query in its default location (a temporary "Quick Queries" directory under the workspace for ``GitHub.vscode-codeql/quick-queries``).

#. Right-click in the query tab and select **CodeQL: Run Query on Selected Database**. (Alternatively, run the command from the Command Palette.)

   The query will take a few moments to return results. When the query completes, the results are displayed in a CodeQL Query Results view, next to the main editor view.

   The query results are listed in two columns, corresponding to the expressions in the ``select`` clause of the query. |result-col-1| The second column is the alert message.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/reusables/vs-code-basic-instructions/run-quick-query-1.rst
The CodeQL extension for Visual Studio Code adds several **CodeQL:** commands to the command palette including **Quick Query**, which you can use to run a query without any set up.

#. From the command palette in Visual Studio Code, select **CodeQL: Quick Query**.

#. After a moment, a new tab *quick-query.ql* is opened, ready for you to write a query for your currently selected CodeQL database (here a |language-code| database). If you are prompted to reload your workspace as a multi-folder workspace to allow Quick queries, accept or create a new workspace using the starter workflow.

   |image-quick-query|


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/vale-styles/README.md
# Vale styles for testing QL documentation

The styles stored in these subdirectories are used by the [Vale](https://github.com/errata-ai/vale) application.
This is used to test QL documentation.

The styles in the `Microsoft` directory are installed from the [Microsoft style guide](https://github.com/errata-ai/Microsoft).
The styles are used to test documentation before it's merged into Git.
They are not distributed as part of any of our products.
For the license information, see [LICENSE](https://github.com/errata-ai/Microsoft/blob/master/LICENSE).

## Upgrading the Microsoft styles

To upgrade the Microsoft styles:

1. Download the [latest release](https://github.com/errata-ai/Microsoft/releases).
1. Unzip the archive over the `vale-styles` directory.
1. We use Semmle-customized versions of a few of these rules, check whether any of the following rules have changes:
    * `Headings.yaml`
1. Update the `Semmle` version of the rule of the same name with those changes.
1. Commit your changes and test the new versions of the rules.
1. Open a pull request.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/index.rst
.. _codeql-overview:

CodeQL overview
===============

Learn more about how CodeQL works, the languages and libraries supported by CodeQL analysis, and the tools you can use to run CodeQL on open source projects.

- :doc:`About CodeQL <about-codeql>`: CodeQL is the analysis engine used by developers to automate security checks, and by security researchers to perform variant analysis.

- :doc:`Supported languages and frameworks <supported-languages-and-frameworks>`: View the languages, libraries, and frameworks supported in the latest version of CodeQL.

- :doc:`System requirements <system-requirements>`: View the system requirements for running the latest version of CodeQL.

- :doc:`CodeQL change logs <codeql-changelog/index>`: Display a list of the CodeQL change logs.

- :doc:`CodeQL tools <codeql-tools>`: GitHub provides the CodeQL command-line interface and CodeQL for Visual Studio Code for performing CodeQL analysis on open source codebases.

- :doc:`CodeQL glossary <codeql-glossary>`: An overview of the technical terms and concepts in CodeQL.

.. toctree::
   :maxdepth: 1
   :hidden:

   about-codeql
   supported-languages-and-frameworks
   system-requirements
   codeql-changelog/index
   codeql-tools
   codeql-glossary



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-tools.rst
:tocdepth: 1

.. _codeql-tools:

CodeQL tools
============

GitHub provides the CodeQL command-line interface and CodeQL for Visual Studio
Code for performing CodeQL analysis on open source codebases.

CodeQL command-line interface
-----------------------------

The CodeQL command-line interface (CLI) is primarily used to create databases for 
security research. You can also query CodeQL databases directly from the command line 
or using the Visual Studio Code extension.
The CodeQL CLI can be downloaded from `GitHub releases <https://github.com/github/codeql-cli-binaries/releases>`__.
For more information, see "`CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__" and the `CLI changelog <https://github.com/github/codeql-cli-binaries/blob/main/CHANGELOG.md>`__.

CodeQL packs
-----------------------------

The standard CodeQL query and library packs
(`source <https://github.com/github/codeql/tree/codeql-cli/latest>`__)
maintained by GitHub are:

- ``codeql/cpp-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/src>`__)
- ``codeql/cpp-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/cpp/ql/lib>`__)
- ``codeql/csharp-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/src>`__)
- ``codeql/csharp-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/csharp/ql/lib>`__)
- ``codeql/go-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/src>`__)
- ``codeql/go-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/go/ql/lib>`__)
- ``codeql/java-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/src>`__)
- ``codeql/java-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/java/ql/lib>`__)
- ``codeql/javascript-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/src>`__)
- ``codeql/javascript-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/javascript/ql/lib>`__)
- ``codeql/python-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/src>`__)
- ``codeql/python-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/python/ql/lib>`__)
- ``codeql/ruby-queries`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/src/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/src>`__)
- ``codeql/ruby-all`` (`changelog <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/lib/CHANGELOG.md>`__, `source <https://github.com/github/codeql/tree/codeql-cli/latest/ruby/ql/lib>`__)

For more information, see "`About CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs>`__."

CodeQL bundle
-----------------------------

The CodeQL bundle consists of the CodeQL CLI together with the standard CodeQL query and library packs
maintained by GitHub. The bundle can be downloaded from `GitHub releases <https://github.com/github/codeql-action/releases>`__.
Use this when running `code scanning with CodeQL <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning-with-codeql>`__ on GitHub Actions or in another CI system.

CodeQL for Visual Studio Code
-----------------------------

You can analyze CodeQL databases in Visual Studio Code using the CodeQL
extension, which provides an enhanced environment for writing and running custom
queries and viewing the results. For more information, see "`CodeQL
for Visual Studio Code <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__."


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/supported-languages-and-frameworks.rst
:tocdepth: 1

.. _supported-languages-and-frameworks:

Supported languages and frameworks
----------------------------------

View the languages, libraries, and frameworks supported in the latest version of
CodeQL.

Languages and compilers
#######################

The current versions of the CodeQL CLI (`changelog <https://github.com/github/codeql-cli-binaries/blob/main/CHANGELOG.md>`__, `releases <https://github.com/github/codeql-cli-binaries/releases>`__),
CodeQL library packs (`source <https://github.com/github/codeql/tree/codeql-cli/latest>`__),
and CodeQL bundle (`releases <https://github.com/github/codeql-action/releases>`__)
support the following languages and compilers.

.. include:: ../reusables/supported-versions-compilers.rst

Frameworks and libraries
########################

The current versions of the CodeQL library and query packs (`source <https://github.com/github/codeql/tree/codeql-cli/latest>`__) have been explicitly checked against the libraries and frameworks listed below.

.. pull-quote::

    Tip
    
    If you're interested in other libraries or frameworks, you can extend the analysis to cover them. 
    For example, by extending the data flow libraries to include data sources
    and sinks for additional libraries or frameworks.
    
.. include:: ../reusables/supported-frameworks.rst


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/system-requirements.rst
:tocdepth: 1

.. _system-requirements:

System requirements
-------------------

System requirements for running the latest version of CodeQL.

Supported platforms
#######################

.. include:: ../reusables/supported-platforms.rst

Additional software requirements
################################

To generate a CodeQL database for a compiled language, you must ensure that the system can successfully build and compile your code, independently of CodeQL.

In addition, CodeQL extraction has the following requirements.

For extraction of compiled languages (C/C++, C#, Go, Java) and Ruby on Linux:

- ``glibc`` version 2.17 or greater must be installed.
- ``musl-c``-based Linux distributions, such as Alpine Linux, are not supported.

For extraction of compiled languages on Windows:

- The ``PowerShell.exe`` executable must be available on the ``PATH``.

For TypeScript extraction on all platforms:

- Node.js 14 or higher must be installed and available on the ``PATH`` as ``node``.

For Python extraction:

- On Linux and macOS, Python 3 must be installed and available on the ``PATH`` as ``python3`` or ``python``.
- For Python 2 extraction on Linux and macOS, we also recommend having Python 2 installed and available on the ``PATH`` as ``python2``.
- On Windows, the Python launcher must be installed and available on the ``PATH`` as ``py.exe``.

For Ruby extraction:

- On Windows, the ``msvcp140.dll`` must be installed and available on the system. This can be installed by downloading the appropriate Microsoft Visual C++ Redistributable for Visual Studio.

For Java extraction:

- There must be a ``java`` or ``java.exe`` executable available on the ``PATH``, and the ``JAVA_HOME`` environment variable must point to the corresponding JDK's home directory.
- If you need to analyse projects using varying JDK versions, it may be useful to supply alternate JDK versions using environment variables of the form ``JAVA_HOME_$VERSION_$PLATFORM``, following the example of `the GitHub Actions runner images <https://github.com/actions/runner-images/blob/main/images/ubuntu/Ubuntu2404-Readme.md#java>`__. An Apache Maven `toolchains.xml file <https://maven.apache.org/guides/mini/guide-using-toolchains.html#using-toolchains-in-your-project>`__ can also be used for the same purpose.
- Having a ``mvn`` or ``mvn.exe`` executable available on the ``PATH`` is recommended if your project uses Apache Maven and does not use the ``mvnw`` wrapper script.
- Having a ``gradle`` or ``gradle.exe`` executable available on the ``PATH`` is recommended if your project uses Gradle and does not use the ``gradlew`` wrapper script.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-glossary.rst
:tocdepth: 1

.. _codeql-glossary:

CodeQL glossary
===============

An overview of the technical terms and concepts in CodeQL.

.. _bqrs-file:

``.bqrs`` file
--------------

A binary query result set (BQRS) file. BQRS is the binary representation of the raw
result of a query, with the extension ``.bqrs``. A BQRS file can be
interpreted into meaningful results and related to your source code. For
example, alert query results are interpreted to display a string at the
location in the source code where the alert occurs, as specified in the query.
Similarly, path query results are interpreted as pairs of locations
(sources and sinks) between which information can flow. These results can be
exported as a variety of different formats, including SARIF.

.. _codeql-database:

CodeQL database
---------------

A database (or CodeQL database) is a directory containing:

- queryable data, extracted from the code.
- a source reference, for displaying query results directly in the code.
- query results.
- log files generated during database creation, query
  execution, and other operations.

.. _codeql-packs:

CodeQL packs
------------

CodeQL packs are used to create, share, depend on, and run CodeQL queries, libraries, and models. You can publish your own CodeQL packs and download packs created by others. CodeQL query packs may contain queries, library files, query suites, and metadata. CodeQL library packs include one or more CodeQL libraries. CodeQL model packs include one or more data extension files that extend the core libraries by modeling additional libraries and frameworks (dependencies of your code base).

.. _data-extensions:

Data extensions
---------------
When you want to model the sources and sinks of a custom dependency, you can create a CodeQL library (``.qll`` file) and write queries that use it, but it's usually much simpler to create a data extension file. If you model the sources and sinks in data extension, you can use this information to expand the standard queries to cover your custom dependencies. You don't need to write any new queries.

.. _dil:

DIL
---

DIL stands for Datalog Intermediary Language. It is an intermediate
representation between QL and relation algebra (RA) that is generated
during query compilation. DIL is useful for advanced users as an aid
for debugging query performance.
The DIL format may change without warning between CLI releases.

When you specify the ``--dump-dil`` option for ``codeql query compile``, CodeQL
prints DIL to standard output for the queries it compiles. You can also
view results in DIL format when you run queries in VS Code.
For more information, see `Running CodeQL queries <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/running-codeql-queries#understanding-your-query-results>`__ in the GitHub documentation.

.. _extractor:

Extractor
---------

An extractor is a tool that produces the relational data and source
reference for each input file, from which a CodeQL database can be built.

.. _codeql-database-schema:

QL database schema
------------------

A QL database schema is a file describing the column types and
extensional relations that make up a raw QL dataset. It is a text file
with the ``.dbscheme`` extension.

The extractor and core CodeQL pack for a language each declare the database
schema that they use. This defines the database layout they create or
expect. When you create a CodeQL database, the extractor copies
its schema into the database. The CLI uses this to check whether the
CodeQL database is compatible with a particular CodeQL library.
If they aren't compatible you can use ``database upgrade`` to upgrade
the schema for the CodeQL database.

There is currently no public-facing specification for the syntax of schemas.

.. _qlo:

``.qlo`` files
--------------

``.qlo`` files are optionally generated during query compilation.
If you specify the ``--dump-qlo`` option for ``codeql query compile``,
CodeQL writes ``.qlo`` files for the queries it compiles. They can be used
as an aid for debugging and performance tuning for advanced users.

``.qlo`` is a binary format that represents a compiled
and optimized query in terms of relational algebra (RA) or the
intermediate :ref:`DIL <dil>` format. ``.qlo`` files can be expanded to
readable text using ``codeql query decompile``.

The exact details of the ``.qlo`` format may change without warning between CLI releases.

.. _sarif-file:

SARIF file
----------

Static analysis results interchange format (SARIF) is an output format used for
sharing static analysis results. For more information, see "`SARIF <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/sarif-output>`__."

.. _source-reference:

Source reference
----------------

A source reference is a mechanism that allows the retrieval of the
contents of a source file, given an absolute filename at which that file
resided during extraction. Specific examples include:

- A source archive directory, within which the requested absolute
  filename maps to a UTF8-encoded file.
- A source archive, typically in ZIP format, which contains the UTF8-encoded
  content of all source files.
- A source archive repository, typically in ``git`` format, typically bare,
  which contains the UTF8-encoded content of all source files.

Source references are typically included in CodeQL databases.

.. _trap-file:

TRAP file
---------

A TRAP file is a UTF-8 encoded file generated by a CodeQL extractor
with the extension ``.trap``. To save space, they are usually archived. They
contain the information that, when interpreted relative to a QL database
schema, is used to create a QL dataset.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/about-codeql.rst
:tocdepth: 1

.. _about-codeql:

About CodeQL
============

CodeQL is the analysis engine used by developers to automate security checks, and by
security researchers to perform variant analysis. 

In CodeQL, code is treated like data. Security vulnerabilities, bugs, 
and other errors are modeled as queries that can be executed against databases
extracted from code. You can run the standard CodeQL queries, written by GitHub
researchers and community contributors, or write your own to use in custom
analyses. Queries that find potential bugs highlight the result directly in the
source file.

About variant analysis
----------------------

Variant analysis is the process of using a known security vulnerability as a
seed to find similar problems in your code. It's a technique that security
engineers use to identify potential vulnerabilities, and ensure these threats
are properly fixed across multiple codebases.

Querying code using CodeQL is the most efficient way to perform variant
analysis. You can use the standard CodeQL queries to identify seed
vulnerabilities, or find new vulnerabilities by writing your own custom CodeQL
queries. Then, develop or iterate over the query to automatically find logical
variants of the same bug that could be missed using traditional manual
techniques.

CodeQL analysis
---------------

CodeQL analysis consists of three steps:

#. Preparing the code, by creating a CodeQL database
#. Running CodeQL queries against the database
#. Interpreting the query results

Database creation
~~~~~~~~~~~~~~~~~

To create a database, CodeQL first extracts a single relational representation
of each source file in the codebase. 

For compiled languages, extraction works by monitoring the normal build process.
Each time a compiler is invoked to process a source file, a copy of that file is
made, and all relevant information about the source code is collected. This includes
syntactic data about the abstract syntax tree and semantic data about name
binding and type information.

For interpreted languages, the extractor runs directly on the source code,
resolving dependencies to give an accurate representation of the codebase. 

There is one :ref:`extractor <extractor>` for each language supported by CodeQL
to ensure that the extraction process is as accurate as possible. For
multi-language codebases, databases are generated one language at a time.

After extraction, all the data required for analysis (relational data, copied
source files, and a language-specific :ref:`database schema
<codeql-database-schema>`, which specifies the mutual relations in the data) is
imported into a single directory, known as a :ref:`CodeQL database
<codeql-database>`.

Query execution
~~~~~~~~~~~~~~~

After you've created a CodeQL database, one or more queries are executed
against it. CodeQL queries are written in a specially-designed object-oriented
query language called QL. You can run the queries checked out from the CodeQL
repo (or custom queries that you've written yourself) using the `CodeQL
for VS Code extension <https://docs.github.com/en/code-security/codeql-for-vs-code/>`__ or the `CodeQL CLI
<https://docs.github.com/en/code-security/codeql-cli>`__. For more information about queries, see ":ref:`About CodeQL queries <about-codeql-queries>`." 

.. _interpret-query-results:

Query results
~~~~~~~~~~~~~

The final step converts results produced during query execution into a form that
is more meaningful in the context of the source code. That is, the results are
interpreted in a way that highlights the potential issue that the queries are
designed to find.

Queries contain metadata properties that indicate how the results should be
interpreted. For instance, some queries display a simple message at a single
location in the code. Others display a series of locations that represent steps
along a data-flow or control-flow path, along with a message explaining the
significance of the result. Queries that don't have metadata are not
interpreted---their results are output as a table and not displayed in the source
code.

Following interpretation, results are output for code review and triaging. In
CodeQL for Visual Studio Code, interpreted query results are automatically
displayed in the source code. Results generated by the CodeQL CLI can be output
into a number of different formats for use with different tools. 


About CodeQL databases
----------------------

CodeQL databases contain queryable data extracted from a codebase, for a single
language at a particular point in time. The database contains a full,
hierarchical representation of the code, including a representation of the
abstract syntax tree, the data flow graph, and the control flow graph. 

Each language has its own unique database schema that defines the relations used
to create a database. The schema provides an interface between the initial
lexical analysis during the extraction process, and the actual complex analysis
using CodeQL. The schema specifies, for instance, that there is a table for
every language construct.

For each language, the CodeQL libraries define classes to provide a layer of
abstraction over the database tables. This provides an object-oriented view of
the data which makes it easier to write queries. 

For example, in a CodeQL database for a Java program, two key tables are:

-  The ``expressions`` table containing a row for every single expression in the
   source code that was analyzed during the build process. 
-  The ``statements`` table containing a row for every single statement in the 
   source code that was analyzed during the build process.

The CodeQL library defines classes to provide a layer of abstraction over each
of these tables (and the related auxiliary tables): ``Expr`` and ``Stmt``.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.8.5.rst
.. _codeql-cli-2.8.5:

=========================
CodeQL 2.8.5 (2022-04-07)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.8.5 runs a total of 315 security queries when configured with the Default suite (covering 140 CWE). The Extended suite enables an additional 99 queries (covering 29 more CWE).

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.8.4.rst
.. _codeql-cli-2.8.4:

=========================
CodeQL 2.8.4 (2022-03-29)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.8.4 runs a total of 315 security queries when configured with the Default suite (covering 140 CWE). The Extended suite enables an additional 99 queries (covering 29 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed an error where running out of memory during query evaluation would cause :code:`codeql` to exit with status 34 instead of the 99 that is documented for this condition.
    
*   Fixed a bug in our handling of Clang's header maps, which caused missing files for Xcode-based projects on macOS (e.g. WebKit).

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/overflow-destination`, :code:`cpp/unclear-array-index-validation`, and :code:`cpp/uncontrolled-allocation-size` queries have been modernized and converted to :code:`path-problem` queries and provide more true positive results.
*   The :code:`cpp/system-data-exposure` query has been increased from :code:`medium` to :code:`high` precision, following a number of improvements to the query logic.

Java
""""

*   Updated "Local information disclosure in a temporary directory" (:code:`java/local-temp-file-or-directory-information-disclosure`) to remove false-positives when OS is properly used as logical guard.

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed an issue that would sometimes prevent the data-flow analysis from finding flow paths through a function that stores its result on an object.
    This may lead to more results for the security queries.

New Queries
~~~~~~~~~~~

Java
""""

*   The query "Insertion of sensitive information into log files" (:code:`java/sensitive-logging`) has been promoted from experimental to the main query pack. This query was originally `submitted as an experimental query by @luchua-bc <https://github.com/github/codeql/pull/3090>`__.

Ruby
""""

*   Added a new query, :code:`rb/clear-text-storage-sensitive-data`. The query finds cases where sensitive information, such as user credentials, are stored as cleartext.
*   Added a new query, :code:`rb/incomplete-hostname-regexp`. The query finds instances where a hostname is incompletely sanitized due to an unescaped character in a regular expression.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The flow state variants of :code:`isBarrier` and :code:`isAdditionalFlowStep` are no longer exposed in the taint tracking library. The :code:`isSanitizer` and :code:`isAdditionalTaintStep` predicates should be used instead.

C#
""

*   The flow state variants of :code:`isBarrier` and :code:`isAdditionalFlowStep` are no longer exposed in the taint tracking library. The :code:`isSanitizer` and :code:`isAdditionalTaintStep` predicates should be used instead.

Java
""""

*   The flow state variants of :code:`isBarrier` and :code:`isAdditionalFlowStep` are no longer exposed in the taint tracking library. The :code:`isSanitizer` and :code:`isAdditionalTaintStep` predicates should be used instead.

Python
""""""

*   The flow state variants of :code:`isBarrier` and :code:`isAdditionalFlowStep` are no longer exposed in the taint tracking library. The :code:`isSanitizer` and :code:`isAdditionalTaintStep` predicates should be used instead.

Ruby
""""

*   The flow state variants of :code:`isBarrier` and :code:`isAdditionalFlowStep` are no longer exposed in the taint tracking library. The :code:`isSanitizer` and :code:`isAdditionalTaintStep` predicates should be used instead.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   :code:`DefaultOptions::exits` now holds for C11 functions with the :code:`_Noreturn` or :code:`noreturn` specifier.
*   :code:`hasImplicitCopyConstructor` and :code:`hasImplicitCopyAssignmentOperator` now correctly handle implicitly-deleted operators in templates.
*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

C#
""

*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

Java
""""

*   Added new guards :code:`IsWindowsGuard`, :code:`IsSpecificWindowsVariant`, :code:`IsUnixGuard`, and :code:`IsSpecificUnixVariant` to detect OS specific guards.
*   Added a new predicate :code:`getSystemProperty` that gets all expressions that retrieve system properties from a variety of sources (eg. alternative JDK API's, Google Guava, Apache Commons, Apache IO, etc.).
*   Added support for detection of SSRF via JDBC database URLs, including connections made using the standard library (:code:`java.sql`), Hikari Connection Pool, JDBI and Spring JDBC.
*   Re-removed support for :code:`CharacterLiteral` from :code:`CompileTimeConstantExpr.getStringValue()` to restore the convention that that predicate only applies to :code:`String`\ -typed constants.
*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

JavaScript/TypeScript
"""""""""""""""""""""

*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

Python
""""""

*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

Ruby
""""

*   :code:`getConstantValue()` now returns the contents of strings and symbols after escape sequences have been interpreted. For example, for the Ruby string literal :code:`"\n"`, :code:`getConstantValue().getString()` previously returned a QL string with two characters, a backslash followed by :code:`n`\ ; now it returns the single-character string "\n" (U+000A, known as newline).
*   :code:`getConstantValue().getInt()` previously returned incorrect values for integers larger than 2\ :sup:`31`-1 (the largest value that can be represented by the QL :code:`int` type). It now returns no result in those cases.
*   Added :code:`OrmWriteAccess` concept to model data written to a database using an object-relational mapping (ORM) library.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   Many classes/predicates/modules that had upper-case acronyms have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

C#
""

*   Many classes/predicates/modules that had upper-case acronyms have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Java
""""

*   Many classes/predicates/modules that had upper-case acronyms have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

JavaScript/TypeScript
"""""""""""""""""""""

*   Some predicates from :code:`DefUse.qll`, :code:`DataFlow.qll`, :code:`TaintTracking.qll`, :code:`DOM.qll`, :code:`Definitions.qll` that weren't used by any query have been deprecated.
    The documentation for each predicate points to an alternative.
*   Many classes/predicates/modules that had upper-case acronyms have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.
*   Some modules that started with a lowercase letter have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Python
""""""

*   Many classes/predicates/modules that had upper-case acronyms have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.
*   Some modules that started with a lowercase letter have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Ruby
""""

*   Many classes/predicates/modules that had upper-case acronyms have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   The data flow and taint tracking libraries have been extended with versions of :code:`isBarrierIn`, :code:`isBarrierOut`, and :code:`isBarrierGuard`, respectively :code:`isSanitizerIn`, :code:`isSanitizerOut`, and :code:`isSanitizerGuard`, that support flow states.

C#
""

*   The data flow and taint tracking libraries have been extended with versions of :code:`isBarrierIn`, :code:`isBarrierOut`, and :code:`isBarrierGuard`, respectively :code:`isSanitizerIn`, :code:`isSanitizerOut`, and :code:`isSanitizerGuard`, that support flow states.

Java
""""

*   The data flow and taint tracking libraries have been extended with versions of :code:`isBarrierIn`, :code:`isBarrierOut`, and :code:`isBarrierGuard`, respectively :code:`isSanitizerIn`, :code:`isSanitizerOut`, and :code:`isSanitizerGuard`, that support flow states.

Python
""""""

*   The data flow and taint tracking libraries have been extended with versions of :code:`isBarrierIn`, :code:`isBarrierOut`, and :code:`isBarrierGuard`, respectively :code:`isSanitizerIn`, :code:`isSanitizerOut`, and :code:`isSanitizerGuard`, that support flow states.

Ruby
""""

*   The data flow and taint tracking libraries have been extended with versions of :code:`isBarrierIn`, :code:`isBarrierOut`, and :code:`isBarrierGuard`, respectively :code:`isSanitizerIn`, :code:`isSanitizerOut`, and :code:`isSanitizerGuard`, that support flow states.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/index.rst
.. _codeql-changes:

==================
CodeQL change logs
==================

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

A list of queries for each suite and language `is available here <https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/codeql-query-suites#queries-included-in-the-default-and-security-extended-query-suites>`__.

.. toctree::
   :maxdepth: 1

   codeql-cli-2.18.1
   codeql-cli-2.18.0
   codeql-cli-2.17.6
   codeql-cli-2.17.5
   codeql-cli-2.17.4
   codeql-cli-2.17.3
   codeql-cli-2.17.2
   codeql-cli-2.17.1
   codeql-cli-2.17.0
   codeql-cli-2.16.6
   codeql-cli-2.16.5
   codeql-cli-2.16.4
   codeql-cli-2.16.3
   codeql-cli-2.16.2
   codeql-cli-2.16.1
   codeql-cli-2.16.0
   codeql-cli-2.15.5
   codeql-cli-2.15.4
   codeql-cli-2.15.3
   codeql-cli-2.15.2
   codeql-cli-2.15.1
   codeql-cli-2.15.0
   codeql-cli-2.14.6
   codeql-cli-2.14.5
   codeql-cli-2.14.4
   codeql-cli-2.14.3
   codeql-cli-2.14.2
   codeql-cli-2.14.1
   codeql-cli-2.14.0
   codeql-cli-2.13.5
   codeql-cli-2.13.4
   codeql-cli-2.13.3
   codeql-cli-2.13.1
   codeql-cli-2.13.0
   codeql-cli-2.12.7
   codeql-cli-2.12.6
   codeql-cli-2.12.5
   codeql-cli-2.12.4
   codeql-cli-2.12.3
   codeql-cli-2.12.2
   codeql-cli-2.12.1
   codeql-cli-2.12.0
   codeql-cli-2.11.6
   codeql-cli-2.11.5
   codeql-cli-2.11.4
   codeql-cli-2.11.3
   codeql-cli-2.11.2
   codeql-cli-2.11.1
   codeql-cli-2.11.0
   codeql-cli-2.10.5
   codeql-cli-2.10.4
   codeql-cli-2.10.3
   codeql-cli-2.10.2
   codeql-cli-2.10.1
   codeql-cli-2.10.0
   codeql-cli-2.9.4
   codeql-cli-2.9.3
   codeql-cli-2.9.2
   codeql-cli-2.9.1
   codeql-cli-2.9.0
   codeql-cli-2.8.5
   codeql-cli-2.8.4
   codeql-cli-2.8.3
   codeql-cli-2.8.2
   codeql-cli-2.8.1
   codeql-cli-2.8.0
   codeql-cli-2.7.6
   codeql-cli-2.7.5
   codeql-cli-2.7.3
   codeql-cli-2.7.2
   codeql-cli-2.7.1
   codeql-cli-2.7.0
   codeql-cli-2.6.3
   codeql-cli-2.6.2
   codeql-cli-2.6.1
   codeql-cli-2.6.0
   codeql-cli-2.5.9
   codeql-cli-2.5.8
   codeql-cli-2.5.7
   codeql-cli-2.5.6
   codeql-cli-2.5.5
   codeql-cli-2.5.4
   codeql-cli-2.5.3
   codeql-cli-2.5.2
   codeql-cli-2.5.1
   codeql-cli-2.5.0
   codeql-cli-2.4.6
   codeql-cli-2.4.5
   codeql-cli-2.4.4
   codeql-cli-2.4.3
   codeql-cli-2.4.2
   codeql-cli-2.4.1



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.18.1.rst
.. _codeql-cli-2.18.1:

==========================
CodeQL 2.18.1 (2024-07-25)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.18.1 runs a total of 419 security queries when configured with the Default suite (covering 164 CWE). The Extended suite enables an additional 129 queries (covering 34 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   The *experimental* type :code:`QlBuiltins::BigInt` of arbitrary-precision integers has been introduced. To opt in to this API, compile your queries with
    :code:`--allow-experimental=bigint`. Big integers can be constructed using the
    :code:`.toBigInt()` methods of :code:`int` and :code:`string`. The built-in operations are:

    *   comparisons: :code:`=`, :code:`!=`, :code:`<`, :code:`<=`, :code:`>`, :code:`>=`,
    *   conversions: :code:`.toString()`, :code:`.toInt()`,
    *   arithmetic: binary :code:`+`, :code:`-`, :code:`*`, :code:`/`, :code:`%`, unary :code:`-`,
    *   bitwise operations: :code:`.bitAnd(BigInt)`, :code:`.bitOr(BigInt)`,
        :code:`.bitXor(BigInt)`, :code:`.bitShiftLeft(int)`, :code:`.bitShiftRightSigned(int)`,
        :code:`.bitNot()`,
    *   aggregates: :code:`min`, :code:`max`, (:code:`strict`):code:`sum`, (:code:`strict`):code:`count`, :code:`avg`,
        :code:`rank`, :code:`unique`, :code:`any`.
    *   other: :code:`.pow(int)`, :code:`.abs()`, :code:`.gcd(BigInt)`, :code:`.minimum(BigInt)`,
        :code:`.maximum(BigInt)`.
    
*   :code:`codeql test run` now supports postprocessing of test results. When .qlref files specify a path to a :code:`postprocess` query, then this is evaluated after the test query to transform the test outputs prior to concatenating them into the :code:`actual` results.

Improvements
~~~~~~~~~~~~

*   The 30% QL query compilation slowdown noted in 2.18.0 has been fixed.

Security Updates
~~~~~~~~~~~~~~~~

*   Resolves CVE-2023-4759, an arbitrary file overwrite in Eclipse JGit that can be triggered when using untrusted third-party queries from a git repository. See the
    \ `security advisory <https://github.com/github/codeql-cli-binaries/security/advisories/GHSA-x4gx-f2xv-6wj9>`__ for more information.
*   The following dependencies have been updated. These updates include security fixes in the respective libraries that prevent out-of-bounds accesses or denial-of-service in scenarios where untrusted files are processed. These scenarios are not likely to be encountered in most uses of CodeQL and code scanning, and only apply to advanced use cases where precompiled query packs,
    database ZIP files, or database TRAP files are obtained from untrusted sources and then processed on a trusted machine.

    *   airlift/aircompressor is updated to version 0.27.
    *   Apache Ant is updated to version 1.10.11.
    *   Apache Commons Compress is updated to version 1.26.0.
    *   Apache Commons IO is updated to version 2.15.1.
    *   Apache Commons Lang3 is updated to version 3.14.0.
    *   jsoup is updated to version 1.15.3.
    *   Logback is updated to version 1.2.13.
    *   Snappy is updated to version 0.5.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/unsigned-difference-expression-compared-zero` ("Unsigned difference expression compared to zero") query now produces fewer false positives.

Java
""""

*   The heuristic to enable certain Android queries has been improved. Now it ignores Android Manifests which don't define an activity, content provider or service. We also only consider files which are under a folder containing such an Android Manifest for these queries. This should remove some false positive alerts.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added a new query, :code:`js/functionality-from-untrusted-domain`, which detects uses in HTML and JavaScript scripts from untrusted domains, including the :code:`polyfill.io` content delivery network

    *   it can be extended to detect other compromised scripts using user-provided data extensions of the :code:`untrustedDomain` predicate, which takes one string argument with the domain to warn on (and will warn on any subdomains too).
    
*   Modified existing query, :code:`js/functionality-from-untrusted-source`, to allow adding this new query, but reusing the same logic

    *   Added the ability to use data extensions to require SRI on CDN hostnames using the :code:`isCdnDomainWithCheckingRequired` predicate, which takes one string argument of the full hostname to require SRI for.
    
*   Created a new library, :code:`semmle.javascript.security.FunctionalityFromUntrustedSource`, to support both queries.

New Queries
~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added a new query, :code:`js/insecure-helmet-configuration`, to detect instances where Helmet middleware is configured with important security features disabled.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The precision of :code:`cpp/iterator-to-expired-container` ("Iterator to expired container") has been increased to :code:`high`. As a result, it will be run by default as part of the Code Scanning suite.
*   The precision of :code:`cpp/unsafe-strncat` ("Potentially unsafe call to strncat") has been increased to :code:`high`. As a result, it will be run by default as part of the Code Scanning suite.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

Java
""""

*   The Java extractor no longer supports the :code:`SEMMLE_DIST` legacy environment variable.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   There was a bug which meant that the built-in function :code:`clear` was considered as a sanitizer in some cases when it shouldn't have been. This has now been fixed, which may lead to more alerts.

Java
""""

*   Added a path-injection sink for :code:`hudson.FilePath.exists()`.
*   Added summary models for :code:`org.apache.commons.io.IOUtils.toByteArray`.
*   Java build-mode :code:`none` analyses now only report a warning on the CodeQL status page when there are significant analysis problems-- defined as 5% of expressions lacking a type, or 5% of call targets being unknown. Other messages reported on the status page are downgraded from warnings to notes and so are less prominent, but are still available for review.

Python
""""""

*   Additional modelling to detect direct writes to the :code:`Set-Cookie` header has been added for several web frameworks.

Swift
"""""

*   Additional heuristics for sensitive private information have been added to the :code:`SensitiveExprs.qll` library, improving coverage for credit card and social security numbers. This may result in additional results for queries that use sensitive data such as :code:`swift/cleartext-transmission`.

Deprecated APIs
~~~~~~~~~~~~~~~

Java
""""

*   The predicate :code:`isAndroid` from the module :code:`semmle.code.java.security.AndroidCertificatePinningQuery` has been deprecated. Use :code:`semmle.code.java.frameworks.android.Android::inAndroidApplication(File)` instead.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Models-as-data alert provenance information has been extended to the C/C++ language. Any qltests that include the edges relation in their output (for example, :code:`.qlref`\ s that reference path-problem queries) will need to be have their expected output updated accordingly.
*   Added subclasses of :code:`BuiltInOperations` for :code:`__builtin_has_attribute`, :code:`__builtin_is_corresponding_member`, :code:`__builtin_is_pointer_interconvertible_with_class`, :code:`__is_assignable_no_precondition_check`, :code:`__is_bounded_array`, :code:`__is_convertible`, :code:`__is_corresponding_member`, :code:`__is_nothrow_convertible`, :code:`__is_pointer_interconvertible_with_class`, :code:`__is_referenceable`, :code:`__is_same_as`, :code:`__is_trivially_copy_assignable`, :code:`__is_unbounded_array`, :code:`__is_valid_winrt_type`, :code:`_is_win_class`, :code:`__is_win_interface`, :code:`__reference_binds_to_temporary`, :code:`__reference_constructs_from_temporary`, and :code:`__reference_converts_from_temporary`.
*   The class :code:`NewArrayExpr` adds a predicate :code:`getArraySize()` to allow a more convenient way to access the static size of the array when the extent is missing.

Java and Kotlin
"""""""""""""""

*   Kotlin support is now out of beta, and generally available
*   Kotlin versions up to 2.0.2*x* are now supported.

Swift
"""""

*   Swift support is now out of beta, and generally available.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.18.0.rst
.. _codeql-cli-2.18.0:

==========================
CodeQL 2.18.0 (2024-07-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.18.0 runs a total of 415 security queries when configured with the Default suite (covering 161 CWE). The Extended suite enables an additional 131 queries (covering 35 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   A number of breaking changes have been made to the C and C++ CodeQL environment:

    *   The environment no longer defines any GNU-specific builtin macros.
        If these macros are still needed, please define them via
        :code:`semmle-extractor-options`.
        
    *   The :code:`--force-recompute` option is no longer directly supported by
        :code:`semmle-extractor-options`. Instead, :code:`--edg --force-recompute` should be specified.
        
    *   The :code:`--gnu_version` and :code:`--microsoft_version` options that can be specified via :code:`semmle-extractor-options` are now synonyms, and only one should be specified as part of :code:`semmle-extractor-options`.
        Furthermore,  is also no longer possible to specify these options via the following syntax.

        *   :code:`--edg --gnu_version --edg <version number>`, and
        *   :code:`--edg --microsoft_version --edg <version number>`
        
        The shorter :code:`--gnu_version <version number>` and
        :code:`--microsoft_version <version number>` should be used.

*   The :code:`--build_error_dir` and :code:`--predefined_macros` command line options have been removed from the C/C++ extractor. It has never been possible to pass these options through the CLI, but some customers with advanced setups may have been passing them through internal undocumented interfaces.
    Passing the option :code:`--build_error_dir` did not have any effect, and it is safe to remove the option. The :code:`--predefined_macros` option should have been unnecessary, as long as the extractor was invoked with the
    :code:`--mimic` option.

Bug Fixes
~~~~~~~~~

*   Where a MacOS unsigned binary cannot be signed, CodeQL will now continue trying to trace compiler invocations created by that process and its children. In particular this means that Bazel builds on MacOS are now traceable.
*   Fixed a bug where test discovery would fail if there is a syntax error in a qlpack file. Now, a warning message will be printed and discovery will continue.

Improvements
~~~~~~~~~~~~

*   Introduced the :code:`--include-logs` option to the :code:`codeql database bundle` command. This new feature allows users to include logs in the generated database bundle, allowing for a more complete treatment of the bundle, and bringing the tool capabilities up-to-speed with the documentation.
*   :code:`codeql database init` and :code:`codeql database create` now support the
    :code:`--force-overwrite` option. When this option is specified, the command will delete the specified database directory even if it does not look like a database directory. This option is only recommended for automation. For directcommand line commands, it is recommended to use the :code:`--overwrite` option, which includes extra protection and will refuse to delete a directory that does not look like a database directory.
*   Extract :code:`.xsaccess`, :code:`*.xsjs` and :code:`*.xsjslib` files for SAP HANA XS as Javascript.
*   We have updated many compiler error messages and warnings to improve their readability and standardize their grammar.
    Where necessary, please use the :code:`--learn` option for the :code:`codeql test run` command.

Known Issues
~~~~~~~~~~~~

*   Compilation of QL queries is about 30% slower than in previous releases. This only affects users who write custom queries, and only at compilation time, not at run time. This regression will be fixed in the upcoming 2.18.1 release.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The query :code:`java/weak-cryptographic-algorithm` no longer alerts about :code:`RSA/ECB` algorithm strings.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The query :code:`java/tainted-permissions-check` now uses threat models. This means that :code:`local` sources are no longer included by default for this query, but can be added by enabling the :code:`local` threat model.
*   Added more :code:`org.apache.commons.io.FileUtils`\ -related sinks to the path injection query.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added a new experimental query, :code:`js/cors-misconfiguration`, which detects misconfigured CORS HTTP headers in the :code:`cors` and :code:`apollo` libraries.

Python
""""""

*   Adding Python support for Hardcoded Credentials as Models as Data
*   Additional sanitizers have been added to the :code:`py/full-ssrf` and :code:`py/partial-ssrf` queries for methods that verify a string contains only a certain set of characters, such as :code:`.isalnum()` as well as regular expression tests.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   Fixed dataflow via global variables other than via a direct write: for example, via a side-effect on a global, such as :code:`io.copy(SomeGlobal, ...)` or via assignment to a field or array or slice cell of a global. This means that any data-flow query may return more results where global variables are involved.

Java
""""

*   Support for :code:`codeql test run` for Kotlin sources has been fixed.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 5.5.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The queries "Potential double free" (:code:`cpp/double-free`) and "Potential use after free" (:code:`cpp/use-after-free`) now produce fewer false positives.
*   The "Guards" library (:code:`semmle.code.cpp.controlflow.Guards`) now also infers guards from calls to the builtin operation :code:`__builtin_expect`. As a result, some queries may produce fewer false positives.

Golang
""""""

*   DataFlow queries which previously used :code:`RemoteFlowSource` to define their sources have been modified to instead use :code:`ThreatModelFlowSource`. This means these queries will now respect threat model configurations. The default threat model configuration is equivalent to :code:`RemoteFlowSource`, so there should be no change in results for users using the default.
*   Added the :code:`ThreatModelFlowSource` class to :code:`FlowSources.qll`. The :code:`ThreatModelFlowSource` class can be used to include sources which match the current *threat model* configuration. This is the first step in supporting threat modeling for Go.

Java
""""

*   Added models for the following packages:

    *   io.undertow.server.handlers.resource
    *   jakarta.faces.context
    *   javax.faces.context
    *   javax.servlet
    *   org.jboss.vfs
    *   org.springframework.core.io
    
*   A bug has been fixed in the heuristic identification of uncertain control flow, which is used to filter data flow in order to improve performance and reduce false positives. This fix means that slightly more code is identified and hence pruned from data flow.
    
*   Excluded reverse DNS from the loopback address as a source of untrusted data.

JavaScript/TypeScript
"""""""""""""""""""""

*   Enabled type-tracking to follow content through array methods
*   Improved modeling of :code:`Array.prototype.splice` for when it is called with more than two arguments

Python
""""""

*   A number of Python queries now support sinks defined using data extensions. The format of data extensions for Python has been documented.

Ruby
""""

*   Element references with blocks, such as :code:`foo[:bar] { |x| puts x}`, are now parsed correctly.
*   The :code:`CleartextSources.qll` library, used by :code:`rb/clear-text-logging-sensitive-data` and :code:`rb/clear-text-logging-sensitive-data`, has been updated to consider heuristics for additional categories of sensitive data.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   The syntax for models-as-data rows has been extended to make it easier to select sources, sinks, and summaries that involve templated functions and classes. Additionally, the syntax has also been extended to make it easier to specify models with arbitrary levels of indirection. See :code:`dataflow/ExternalFlow.qll` for the updated documentation and specification for the model format.
*   It is now possible to extend the classes :code:`AllocationFunction` and :code:`DeallocationFunction` via data extensions. Extensions of these classes should be added to the :code:`lib/ext/allocation` and :code:`lib/ext/deallocation` directories respectively.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.8.3.rst
.. _codeql-cli-2.8.3:

=========================
CodeQL 2.8.3 (2022-03-14)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.8.3 runs a total of 312 security queries when configured with the Default suite (covering 140 CWE). The Extended suite enables an additional 99 queries (covering 29 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Executable binaries for Windows are now digitally signed by a GitHub certificate.

Miscellaneous
~~~~~~~~~~~~~

*   The evaluator logs produced by :code:`--evaluator-log` now default to the maximum verbosity level and will therefore contain more information
    (and, accordingly, grow larger). The verbosity level can still be configured with :code:`--evaluator-log-level`. In particular,
    :code:`--evaluator-log-level=1` will restore the previous default behavior.

Query Packs
-----------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The deprecated queries :code:`cpp/duplicate-block`, :code:`cpp/duplicate-function`, :code:`cpp/duplicate-class`, :code:`cpp/duplicate-file`, :code:`cpp/mostly-duplicate-function`,:code:`cpp/similar-file`, :code:`cpp/duplicated-lines-in-files` have been removed.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Failure to use HTTPS URLs" (:code:`cpp/non-https-url`) has been improved reducing false positive results, and its precision has been increased to 'high'.
*   The :code:`cpp/system-data-exposure` query has been modernized and has converted to a :code:`path-problem` query. There are now fewer false positive results.

C#
""

*   Casts to :code:`dynamic` are excluded from the useless upcasts check (:code:`cs/useless-upcast`).
*   The C# extractor now accepts an extractor option :code:`buildless`, which is used to decide what type of extraction that should be performed. If :code:`true` then buildless (standalone) extraction will be performed. Otherwise tracing extraction will be performed (default).
    The option is added via :code:`codeql database create --language=csharp -Obuildless=true ...`.
*   The C# extractor now accepts an extractor option :code:`trap.compression`, which is used to decide the compression format for TRAP files. The legal values are :code:`brotli` (default), :code:`gzip` or :code:`none`.
    The option is added via :code:`codeql database create --language=csharp -Otrap.compression=value ...`.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   A new query titled "Use of expired stack-address" (:code:`cpp/using-expired-stack-address`) has been added.
    This query finds accesses to expired stack-allocated memory that escaped via a global variable.
*   A new :code:`cpp/insufficient-key-size` query has been added to the default query suite for C/C++. The query finds uses of certain cryptographic algorithms where the key size is too small to provide adequate encryption strength.

Python
""""""

*   The query "XPath query built from user-controlled sources" (:code:`py/xpath-injection`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @porcupineyhairs <https://github.com/github/codeql/pull/6331>`__.

Deprecated Predicates and Classes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The predicates and classes in the :code:`CodeDuplication` library have been deprecated.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

C#
""

*   The C# extractor no longer supports the following legacy environment variables:

    ..  code-block:: text
    
        ODASA_BUILD_ERROR_DIR
        ODASA_CSHARP_LAYOUT
        ODASA_SNAPSHOT
        SEMMLE_DIST
        SEMMLE_EXTRACTOR_OPTIONS
        SEMMLE_PLATFORM_TOOLS
        SEMMLE_PRESERVE_SYMLINKS
        SOURCE_ARCHIVE
        TRAP_FOLDER

*   :code:`codeql test run` now extracts source code recursively from sub folders. This may break existing tests that have other tests in nested sub folders, as those will now get the nested test code included.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 4.6.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Many queries now support structured bindings, as structured bindings are now handled in the IR translation.

Java
""""

*   Add support for :code:`CharacterLiteral` in :code:`CompileTimeConstantExpr.getStringValue()`

JavaScript/TypeScript
"""""""""""""""""""""

*   Added sources from the |link-code-jszip-1|_ library to the :code:`js/zipslip` query.

Python
""""""

*   Added new SSRF sinks for :code:`httpx`, :code:`pycurl`, :code:`urllib`, :code:`urllib2`, :code:`urllib3`, and :code:`libtaxii`. This improvement was `submitted by @haby0 <https://github.com/github/codeql/pull/8275>`__.
*   The regular expression parser now groups sequences of normal characters. This reduces the number of instances of :code:`RegExpNormalChar`.
*   Fixed taint propagation for attribute assignment. In the assignment :code:`x.foo = tainted` we no longer treat the entire object :code:`x` as tainted, just because the attribute :code:`foo` contains tainted data. This leads to slightly fewer false positives.
*   Improved analysis of attributes for data-flow and taint tracking queries, so :code:`getattr`\ /\ :code:`setattr` are supported, and a write to an attribute properly stops flow for the old value in that attribute.
*   Added post-update nodes (:code:`DataFlow::PostUpdateNode`) for arguments in calls that can't be resolved.

Ruby
""""

*   The :code:`Regex` class is now an abstract class that extends :code:`StringlikeLiteral` with implementations for :code:`RegExpLiteral` and string literals that 'flow' into functions that are known to interpret string arguments as regular expressions such as :code:`Regex.new` and :code:`String.match`.
*   The regular expression parser now groups sequences of normal characters. This reduces the number of instances of :code:`RegExpNormalChar`.

New Features
~~~~~~~~~~~~

Java
""""

*   Added :code:`hasDescendant(RefType anc, Type sub)`
*   Added :code:`RefType.getADescendant()`
*   Added :code:`RefType.getAStrictAncestor()`

.. |link-code-jszip-1| replace:: :code:`jszip`\ 
.. _link-code-jszip-1: https://www.npmjs.com/package/jszip




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.8.2.rst
.. _codeql-cli-2.8.2:

=========================
CodeQL 2.8.2 (2022-02-28)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.8.2 runs a total of 308 security queries when configured with the Default suite (covering 139 CWE). The Extended suite enables an additional 99 queries (covering 30 more CWE). 6 security queries have been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The support for the output formats SARIF v1.0.0 and SARIF v2.0.0
    (Committee Specification Draft 1) that were deprecated in 2.7.1 has been removed. If you need this functionality, please file a public issue against https://github.com/github/codeql-cli-binaries, or open a private ticket with GitHub Support and request an escalation to engineering.

New Features
~~~~~~~~~~~~

*   The CodeQL CLI is now compatible with Windows 11 and Windows Server 2022, including building databases for compiled languages.

Query Packs
-----------

Breaking Changes
~~~~~~~~~~~~~~~~

Java
""""

*   Add more classes to Netty request/response splitting. Change identification to :code:`java/netty-http-request-or-response-splitting`.
    Identify request splitting differently from response splitting in query results.
    Support additional classes:

    *   :code:`io.netty.handler.codec.http.CombinedHttpHeaders`
    *   :code:`io.netty.handler.codec.http.DefaultHttpRequest`
    *   :code:`io.netty.handler.codec.http.DefaultFullHttpRequest`

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added dataflow through the |link-code-snapdragon-1|_ library.

New Queries
~~~~~~~~~~~

Java
""""

*   A new query titled "Local information disclosure in a temporary directory" (:code:`java/local-temp-file-or-directory-information-disclosure`) has been added.
    This query finds uses of APIs that leak potentially sensitive information to other local users via the system temporary directory.
    This query was originally `submitted as query by @JLLeitschuh <https://github.com/github/codeql/pull/4388>`__.

JavaScript/TypeScript
"""""""""""""""""""""

*   A new query, :code:`js/functionality-from-untrusted-source`, has been added to the query suite. It finds DOM elements that load functionality from untrusted sources, like :code:`script` or :code:`iframe` elements using :code:`http` links.
    The query is run by default.

Python
""""""

*   The query "LDAP query built from user-controlled sources" (:code:`py/ldap-injection`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @jorgectf <https://github.com/github/codeql/pull/5443>`__.
*   The query "Log Injection" (:code:`py/log-injection`) has been promoted from experimental to the main query pack. Its results will now appear when :code:`security-extended` is used. This query was originally `submitted as an experimental query by @haby0 <https://github.com/github/codeql/pull/6182>`__.

Ruby
""""

*   Added a new query, :code:`rb/clear-text-logging-sensitive-data`. The query finds cases where sensitive information, such as user credentials, are logged as cleartext.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The precision of hardcoded credentials queries (:code:`cs/hardcoded-credentials` and
    :code:`cs/hardcoded-connection-string-credentials`) have been downgraded to medium.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/request-forgery` query previously flagged both server-side and client-side request forgery,
    but these are now handled by two different queries:

    *   :code:`js/request-forgery` is now specific to server-side request forgery. Its precision has been raised to
        :code:`high` and is now shown by default (it was previously in the :code:`security-extended` suite).
    *   :code:`js/client-side-request-forgery` is specific to client-side request forgery. This is technically a new query but simply flags a subset of what the old query did.
        This has precision :code:`medium` and is part of the :code:`security-extended` suite.

Deprecated Classes
~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`CodeDuplication.Copy`, :code:`CodeDuplication.DuplicateBlock`, and :code:`CodeDuplication.SimilarBlock` classes have been deprecated.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ruby
""""

*   Added :code:`FileSystemWriteAccess` concept to model data written to the filesystem.

Deprecated APIs
~~~~~~~~~~~~~~~

Python
""""""

*   The old points-to based modeling has been deprecated. Use the new type-tracking/API-graphs based modeling instead.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added a :code:`isStructuredBinding` predicate to the :code:`Variable` class which holds when the variable is declared as part of a structured binding declaration.

Java
""""

*   Added predicates :code:`ClassOrInterface.getAPermittedSubtype` and :code:`isSealed` exposing information about sealed classes.

.. |link-code-snapdragon-1| replace:: :code:`snapdragon`\ 
.. _link-code-snapdragon-1: https://npmjs.com/package/snapdragon




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.8.0.rst
.. _codeql-cli-2.8.0:

=========================
CodeQL 2.8.0 (2022-02-04)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.8.0 runs a total of 298 security queries when configured with the Default suite (covering 136 CWE). The Extended suite enables an additional 93 queries (covering 30 more CWE). 14 security queries have been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The CodeQL Action versions up to and including version 1.0.22 are not compatible with the CodeQL CLI 2.8.0 and later. The CLI will emit an error if it detects that it is being used by an incompatible version of the codeql-action.

Bug Fixes
~~~~~~~~~

*   Fixed a bug where :code:`codeql resolve upgrades` ignores the
    :code:`--target-dbscheme` option.

New Features
~~~~~~~~~~~~

*   A new extractor option has been added to the Java extractor. The flag :code:`--extractor-option exclude='<glob>'` allows specifying a glob that describes which paths need to be excluded from extraction but still need to be compiled. This is useful when some files are necessary for a successful build but are uninteresting for analysis.
    
    See also: https://codeql.github.com/docs/codeql-cli/extractor-options/
    
*   Summary metrics can now associate messages with their results, for instance to report the name and number of uses of a particular API endpoint within a repository. To associate messages with summary metrics, define a query with :code:`@kind metric` and :code:`@tags summary` metadata and use either the :code:`location, message, value` or the :code:`message, value` results pattern.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   User names and other account information is no longer considered to be sensitive data for the queries :code:`py/clear-text-logging-sensitive-data` and :code:`py/clear-text-storage-sensitive-data`, since this lead to many false positives.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Fix an issue with the :code:`cpp/declaration-hides-variable` query where it would report variables that are unnamed in a database.
*   The :code:`cpp/cleartext-storage-file` query has been upgraded with non-local taint flow and has been converted to a :code:`path-problem` query.
*   The :code:`cpp/return-stack-allocated-memory` query has been improved to produce fewer false positives. The query has also been converted to a :code:`path-problem` query.
*   The "Cleartext transmission of sensitive information" (:code:`cpp/cleartext-transmission`) query has been improved in several ways to reduce false positive results.
*   The "Potential improper null termination" (:code:`cpp/improper-null-termination`) query now produces fewer false positive results around control flow branches and loops.
*   Added exception for GLib's gboolean to cpp/ambiguously-signed-bit-field.
    This change reduces the number of false positives in the query.

Ruby
""""

*   The query :code:`rb/csrf-protection-disabled` has been extended to find calls to the Rails method :code:`protect_from_forgery` that may weaken CSRF protection.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   The :code:`security` tag has been added to the :code:`cpp/return-stack-allocated-memory` query. As a result, its results will now appear by default.
*   The "Uncontrolled data in arithmetic expression" (cpp/uncontrolled-arithmetic) query has been enhanced to reduce false positive results and its @precision increased to high.
*   A new :code:`cpp/very-likely-overrunning-write` query has been added to the default query suite for C/C++. The query reports some results that were formerly flagged by :code:`cpp/overrunning-write`.

Java
""""

*   A new query "Use of implicit PendingIntents" (:code:`java/android/pending-intents`) has been added.
    This query finds implicit and mutable :code:`PendingIntents` sent to an unspecified third party component, which may provide an attacker with access to internal components of the application or cause other unintended effects.
*   Two new queries, "Android fragment injection" (:code:`java/android/fragment-injection`) and "Android fragment injection in PreferenceActivity" (:code:`java/android/fragment-injection-preference-activity`) have been added.
    These queries find exported Android activities that instantiate and host fragments created from user-provided data. Such activities are vulnerable to access control bypass and expose the Android application to unintended effects.
*   The query "\ :code:`TrustManager` that accepts all certificates" (:code:`java/insecure-trustmanager`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @intrigus-lgtm <https://github.com/github/codeql/pull/4879>`__.
*   The query "Log Injection" (:code:`java/log-injection`) has been promoted from experimental to the main query pack. Its results will now appear by default. The query was originally `submitted as an experimental query by @porcupineyhairs and @dellalibera <https://github.com/github/codeql/pull/5099>`__.
*   A new query "Intent URI permission manipulation" (:code:`java/android/intent-uri-permission-manipulation`) has been added.
    This query finds Android components that return unmodified, received Intents to the calling applications, which can provide unintended access to internal content providers of the victim application.
*   A new query "Cleartext storage of sensitive information in the Android filesystem" (:code:`java/android/cleartext-storage-filesystem`) has been added. This query finds instances of sensitive data being stored in local files without encryption, which may expose it to attackers or malicious applications.
*   The query "Cleartext storage of sensitive information using :code:`SharedPreferences` on Android" (:code:`java/android/cleartext-storage-shared-prefs`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @luchua-bc <https://github.com/github/codeql/pull/4675>`__.
*   The query "Unsafe certificate trust" (:code:`java/unsafe-cert-trust`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @luchua-bc <https://github.com/github/codeql/pull/3550>`__.

JavaScript/TypeScript
"""""""""""""""""""""

*   A new query :code:`js/samesite-none-cookie` has been added. The query detects when the SameSite attribute is set to None on a sensitive cookie.
*   A new query :code:`js/empty-password-in-configuration-file` has been added. The query detects empty passwords in configuration files. The query is not run by default.

Ruby
""""

*   Added a new query, :code:`rb/weak-cookie-configuration`. The query finds cases where cookie configuration options are set to values that may make an application more vulnerable to certain attacks.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The "Random used only once" (:code:`java/random-used-once`) query no longer has a :code:`security-severity` score. This has been causing some tools to categorise it as a security query, when it is more useful as a code-quality query.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Added support for the following C# 10 features.
*   \ `Record structs <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#record-structs>`__.
*   \ `Improvements of structure types <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#improvements-of-structure-types>`__.

    *   Instance parameterless constructor in a structure type.
    *   Enhance :code:`WithExpr` in QL to support :code:`structs` and anonymous classes.
    
*   \ `Global using directives <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#global-using-directives>`__.
*   \ `File-scoped namespace declaration <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#file-scoped-namespace-declaration>`__.
*   \ `Enhanced #line pragma <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#enhanced-line-pragma>`__.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   :code:`FormatLiteral::getMaxConvertedLength` now uses range analysis to provide a more accurate length for integers formatted with :code:`%x`

C#
""

*   The query :code:`cs/local-shadows-member` no longer highlights parameters of :code:`record` types.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`codeql/cpp-upgrades` CodeQL pack has been removed. All upgrades scripts have been merged into the :code:`codeql/cpp-all` CodeQL pack.

C#
""

*   The :code:`codeql/csharp-upgrades` CodeQL pack has been removed. All upgrades scripts have been merged into the :code:`codeql/csharp-all` CodeQL pack.

Java
""""

*   The :code:`codeql/java-upgrades` CodeQL pack has been removed. All upgrades scripts have been merged into the :code:`codeql/java-all` CodeQL pack.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`codeql/javascript-upgrades` CodeQL pack has been removed. All upgrades scripts have been merged into the :code:`codeql/javascript-all` CodeQL pack.

Python
""""""

*   Moved the files defining regex injection configuration and customization, instead of :code:`import semmle.python.security.injection.RegexInjection` please use :code:`import semmle.python.security.dataflow.RegexInjection` (the same for :code:`RegexInjectionCustomizations`).
*   The :code:`codeql/python-upgrades` CodeQL pack has been removed. All upgrades scripts have been merged into the :code:`codeql/python-all` CodeQL pack.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.8.1.rst
.. _codeql-cli-2.8.1:

=========================
CodeQL 2.8.1 (2022-02-15)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.8.1 runs a total of 306 security queries when configured with the Default suite (covering 137 CWE). The Extended suite enables an additional 95 queries (covering 30 more CWE). 10 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug that would sometimes lead to query evaluation on M1-based Macs to crash with :code:`Did not preallocate enough memory` error.

New Features
~~~~~~~~~~~~

*   Commands that find or run queries now allow you to refer to queries within a named CodeQL pack. For example:

    ..  code-block:: sh
    
        # Analyze a database using all queries in the experimental/Security folder within the codeql/cpp-queries
        # CodeQL query pack.
        codeql database analyze --format=sarif-latest --output=results <db> \
            codeql/cpp-queries:experimental/Security
        
        # Analyse using only the RedundantNullCheckParam.ql query in the codeql/cpp-queries CodeQL query pack.
        codeql database analyze --format=sarif-latest --output=results <db> \
            'codeql/cpp-queries:experimental/Likely Bugs/RedundantNullCheckParam.ql'
        
        # Analyse using the cpp-security-and-quality.qls query suite in the codeql/cpp-queries CodeQL query pack.
        codeql database analyze --format=sarif-latest --output=results <db> \
            'codeql/cpp-queries:codeql-suites/cpp-security-and-quality.qls'
        
        # Analyse using the cpp-security-and-quality.qls query suite from a version of the codeql/cpp-queries pack
        # that is >= 0.0.3 and < 0.1.0 (the highest compatible version will be chosen).
        # All valid semver ranges are allowed. See https://docs.npmjs.com/cli/v6/using-npm/semver#ranges
        codeql database analyze --format=sarif-latest --output=results <db> \
            'codeql/cpp-queries@~0.0.3:codeql-suites/cpp-security-and-quality.qls'
        
    The complete way to specify a set of queries is in the form
    :code:`scope/name@range:path`, where:

    *   :code:`scope/name` is the qualified name of a CodeQL pack.
        
    *   :code:`range` is a `semver range <https://docs.npmjs.com/cli/v6/using-npm/semver#ranges>`__.
        
    *   :code:`path` is a file system path
        
        If a :code:`scope/name` is specified, the :code:`range` and :code:`path` are optional. A missing :code:`range` implies the latest version of the specified pack. A missing :code:`path` implies the default query suite of the specified pack.
        
        The :code:`path` can be one of a :code:`*.ql` query file, a directory containing one or more queries, or a :code:`.qls` query suite file. If there is no pack name specified, then a :code:`path` must be provided,
        and will be interpreted relative to the current working directory of the current process.
        
        If a :code:`scope/name` and :code:`path` are specified, then the :code:`path` cannot be absolute. It is considered relative to the root of the CodeQL pack.
        
        The relevant commands are:

        *   :code:`codeql database analyze`
        *   :code:`codeql database run-queries`
        *   :code:`codeql execute queries`
        *   :code:`codeql resolve queries`

Query Packs
-----------

Bug Fixes
~~~~~~~~~

Python
""""""

*   The `View AST functionality <https://docs.github.com/en/code-security/codeql-for-vs-code/using-the-advanced-functionality-of-the-codeql-for-vs-code-extension/exploring-the-structure-of-your-source-code>`__ no longer prints detailed information about regular expressions, greatly improving performance.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Cleartext transmission of sensitive information" (:code:`cpp/cleartext-transmission`) query has been further improved to reduce false positive results, and upgraded from :code:`medium` to :code:`high` precision.
*   The "Cleartext transmission of sensitive information" (:code:`cpp/cleartext-transmission`) query now finds more results, where a password is stored in a struct field or class member variable.
*   The :code:`cpp/cleartext-storage-file` query has been improved, removing false positives where data is written to a standard output stream.
*   The :code:`cpp/cleartext-storage-buffer` query has been updated to use the :code:`semmle.code.cpp.dataflow.TaintTracking` library.
*   The :code:`cpp/world-writable-file-creation` query now only detects :code:`open` and :code:`openat` calls with the :code:`O_CREAT` or :code:`O_TMPFILE` flag.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/open-call-with-mode-argument`, to detect when :code:`open` or :code:`openat` is called with the :code:`O_CREAT` or :code:`O_TMPFILE` flag but when the :code:`mode` argument is omitted.

Java
""""

*   A new query "Cleartext storage of sensitive information using a local database on Android" (:code:`java/android/cleartext-storage-database`) has been added. This query finds instances of sensitive data being stored in local databases without encryption, which may expose it to attackers or malicious applications.

JavaScript/TypeScript
"""""""""""""""""""""

*   A new query, :code:`js/unsafe-code-construction`, has been added to the query suite, highlighting libraries that may leave clients vulnerable to arbitrary code execution.
    The query is not run by default.
*   A new query :code:`js/file-system-race` has been added. The query detects when there is time between a file being checked and used. The query is not run by default.
*   A new query :code:`js/jwt-missing-verification` has been added. The query detects applications that don't verify JWT tokens.
*   The :code:`js/insecure-dependency` query has been added. It detects dependencies that are downloaded using an unencrypted connection.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Added support for C# 10 lambda improvements

    *   Explicit return types on lambda expressions.
    *   Lambda expression can be tagged with method and return value attributes.
    
*   Added support for C# 10 `Extended property patterns <https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-10#extended-property-patterns>`__.
*   Return value attributes are extracted.
*   The QL :code:`Attribute` class now has subclasses for each kind of attribute.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.8.rst
.. _codeql-cli-2.5.8:

=========================
CodeQL 2.5.8 (2021-07-26)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.8 runs a total of 268 security queries when configured with the Default suite (covering 114 CWE). The Extended suite enables an additional 79 queries (covering 28 more CWE). 23 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The QL compiler now verifies that :code:`@security-severity` query metadata is numeric. You can disable this verification by passing the :code:`--no-metadata-verification` flag.

New Features
~~~~~~~~~~~~

*   The :code:`database index-files` and :code:`database trace-command` CLI commands now support :code:`--threads` and :code:`--ram` options, which are passed to extractors as suggestions.
    
*   The :code:`database finalize` CLI command now supports the :code:`--ram` option,
    which controls memory usage for finalization.
    
*   The :code:`database create` CLI command now supports the :code:`--ram` option,
    which controls memory usage for database creation.  - The :code:`generate query-help` CLI command now support rendering query help in SARIF format.
    



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.9.4.rst
.. _codeql-cli-2.9.4:

=========================
CodeQL 2.9.4 (2022-06-20)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.9.4 runs a total of 335 security queries when configured with the Default suite (covering 142 CWE). The Extended suite enables an additional 104 queries (covering 30 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Users of CodeQL Packaging Beta can now optionally authenticate to Container registries on GitHub Enterprise Server (GHES) versions 3.6 and later using standard input instead of the :code:`CODEQL_REGISTRIES_AUTH` environment variable. To authenticate via standard input, pass
    :code:`--registries-auth-stdin`. The value you provide will override the value of the :code:`CODEQL_REGISTRIES_AUTH` environment variable.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ruby
""""

*   Calls to :code:`Zip::File.open` and :code:`Zip::File.new` have been added as :code:`FileSystemAccess` sinks. As a result queries like :code:`rb/path-injection` now flag up cases where users may access arbitrary archive files.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   An :code:`isBraced` predicate was added to the :code:`Initializer` class which holds when a C++ braced initializer was used in the initialization.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.9.rst
.. _codeql-cli-2.5.9:

=========================
CodeQL 2.5.9 (2021-08-09)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.9 runs a total of 268 security queries when configured with the Default suite (covering 114 CWE). The Extended suite enables an additional 79 queries (covering 28 more CWE).

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.9.0.rst
.. _codeql-cli-2.9.0:

=========================
CodeQL 2.9.0 (2022-04-26)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.9.0 runs a total of 325 security queries when configured with the Default suite (covering 140 CWE). The Extended suite enables an additional 102 queries (covering 29 more CWE). 13 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug that would prevent resolution of a query suite in a published CodeQL query pack that has a reference to the pack itself.
    
*   Fixed inaccurate documentation of what the :code:`--include-extension` option to :code:`codeql resolve files` and :code:`codeql database index-files` does. The actual behavior is unchanged.

New Features
~~~~~~~~~~~~

*   :code:`codeql database create` now supports the :code:`--[no-]-count-lines` option, which was previously only available with :code:`codeql database init`.
    
*   :code:`codeql resolve files` and :code:`codeql database index-files` has a new
    :code:`--also-match` option, which allows users to specify glob patterns that are applied in conjunction with the existing :code:`--include` option.

QL Language
~~~~~~~~~~~

*   This release introduces experimental support for parameterized QL modules. This language feature is still subject to change and should not be used in production yet.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/cleartext-transmission` query now recognizes additional sources, for sensitive private data such as e-mail addresses and credit card numbers.
*   The :code:`cpp/unused-local-variable` no longer ignores functions that include lambda expressions capturing trivially copyable objects.
*   The :code:`cpp/command-line-injection` query now takes into account calling contexts across string concatenations. This removes false positives due to mismatched calling contexts before and after string concatenations.
*   A new query, "Potential exposure of sensitive system data to an unauthorized control sphere" (:code:`cpp/potential-system-data-exposure`) has been added. This query is focused on exposure of information that is highly likely to be sensitive, whereas the similar query "Exposure of system data to an unauthorized control sphere" (:code:`cpp/system-data-exposure`) is focused on exposure of information on a channel that is more likely to be intercepted by an attacker.

Java
""""

*   Fixed "Local information disclosure in a temporary directory" (:code:`java/local-temp-file-or-directory-information-disclosure`) to resolve false-negatives when OS isn't properly used as logical guard.
*   The :code:`SwitchCase.getRuleExpression()` predicate now gets expressions for case rules with an expression on the right-hand side of the arrow belonging to both :code:`SwitchStmt` and :code:`SwitchExpr`, and the corresponding :code:`getRuleStatement()` no longer returns an :code:`ExprStmt` in either case. Previously :code:`SwitchStmt` and :code:`SwitchExpr` behaved differently in
    this respect.

JavaScript/TypeScript
"""""""""""""""""""""

*   Improved handling of custom DOM elements, potentially leading to more alerts for the XSS queries.
*   Improved taint tracking through calls to the :code:`Array.prototype.reduce` function.

New Queries
~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/resource-exhaustion` query has been added. It highlights locations where an attacker can cause a large amount of resources to be consumed.
    The query previously existed as an experimental query.

Ruby
""""

*   Added a new query, :code:`rb/insecure-dependency`. The query finds cases where Ruby gems may be downloaded over an insecure communication channel.
*   Added a new query, :code:`rb/weak-cryptographic-algorithm`. The query finds uses of cryptographic algorithms that are known to be weak, such as DES.
*   Added a new query, :code:`rb/http-tainted-format-string`. The query finds cases where data from remote user input is used in a string formatting method in a way that allows arbitrary format specifiers to be inserted.
*   Added a new query, :code:`rb/http-to-file-access`. The query finds cases where data from remote user input is written to a file.
*   Added a new query, :code:`rb/incomplete-url-substring-sanitization`. The query finds instances where a URL is incompletely sanitized due to insufficient checks.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Added the :code:`security-severity` tag to several queries.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The following predicates on :code:`API::Node` have been changed so as not to include the receiver. The receiver should now only be accessed via :code:`getReceiver()`.

    *   :code:`getParameter(int i)` previously included the receiver when :code:`i = -1`
    *   :code:`getAParameter()` previously included the receiver
    *   :code:`getLastParameter()` previously included the receiver for calls with no arguments

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The recently added flow-state versions of :code:`isBarrierIn`, :code:`isBarrierOut`, :code:`isSanitizerIn`, and :code:`isSanitizerOut` in the data flow and taint tracking libraries have been removed.

C#
""

*   The recently added flow-state versions of :code:`isBarrierIn`, :code:`isBarrierOut`, :code:`isSanitizerIn`, and :code:`isSanitizerOut` in the data flow and taint tracking libraries have been removed.

Java
""""

*   The recently added flow-state versions of :code:`isBarrierIn`, :code:`isBarrierOut`, :code:`isSanitizerIn`, and :code:`isSanitizerOut` in the data flow and taint tracking libraries have been removed.
*   The :code:`getUrl` predicate of :code:`DeclaredRepository` in :code:`MavenPom.qll` has been renamed to :code:`getRepositoryUrl`.

Python
""""""

*   The recently added flow-state versions of :code:`isBarrierIn`, :code:`isBarrierOut`, :code:`isSanitizerIn`, and :code:`isSanitizerOut` in the data flow and taint tracking libraries have been removed.

Ruby
""""

*   The recently added flow-state versions of :code:`isBarrierIn`, :code:`isBarrierOut`, :code:`isSanitizerIn`, and :code:`isSanitizerOut` in the data flow and taint tracking libraries have been removed.
*   The :code:`getURL` member-predicates of the :code:`HTTP::Client::Request` and :code:`HTTP::Client::Request::Range` classes from :code:`Concepts.qll` have been renamed to :code:`getAUrlPart`.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Added data-flow for Django ORM models that are saved in a database (no :code:`models.ForeignKey` support).

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`semmle.code.cpp.security.SensitiveExprs` library has been enhanced with some additional rules for detecting credentials.

Java
""""

*   Added guard precondition support for assertion methods for popular testing libraries (e.g. Junit 4, Junit 5, TestNG).

Python
""""""

*   Improved modeling of Flask :code:`Response` objects, so passing a response body with the keyword argument :code:`response` is now recognized.

Ruby
""""

*   Whereas :code:`ConstantValue::getString()` previously returned both string and regular-expression values, it now returns only string values. The same applies to :code:`ConstantValue::isString(value)`.
*   Regular-expression values can now be accessed with the new predicates :code:`ConstantValue::getRegExp()`, :code:`ConstantValue::isRegExp(value)`, and :code:`ConstantValue::isRegExpWithFlags(value, flags)`.
*   The :code:`ParseRegExp` and :code:`RegExpTreeView` modules are now "internal" modules. Users should use :code:`codeql.ruby.Regexp` instead.

Deprecated APIs
~~~~~~~~~~~~~~~

Python
""""""

*   Queries importing a data-flow configuration from :code:`semmle.python.security.dataflow` should ensure that the imported file ends with :code:`Query`, and only import its top-level module. For example, a query that used :code:`CommandInjection::Configuration` from
    :code:`semmle.python.security.dataflow.CommandInjection` should from now use :code:`Configuration` from :code:`semmle.python.security.dataflow.CommandInjectionQuery` instead.

Ruby
""""

*   :code:`ConstantValue::getStringOrSymbol` and :code:`ConstantValue::isStringOrSymbol`, which return/hold for all string-like values (strings, symbols, and regular expressions), have been renamed to :code:`ConstantValue::getStringlikeValue` and :code:`ConstantValue::isStringlikeValue`, respectively. The old names have been marked as :code:`deprecated`.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   A new library :code:`semmle.code.cpp.security.PrivateData` has been added. The new library heuristically detects variables and functions dealing with sensitive private data, such as e-mail addresses and credit card numbers.

Java
""""

*   There are now QL classes ErrorExpr and ErrorStmt. These may be generated by upgrade or downgrade scripts when databases cannot be fully converted.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.9.1.rst
.. _codeql-cli-2.9.1:

=========================
CodeQL 2.9.1 (2022-05-05)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.9.1 runs a total of 327 security queries when configured with the Default suite (covering 140 CWE). The Extended suite enables an additional 103 queries (covering 29 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

There are no user-facing CLI changes in this release.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Query :code:`java/insecure-cookie` no longer produces a false positive if :code:`cookie.setSecure(...)` is called passing a constant that always equals :code:`true`.

JavaScript/TypeScript
"""""""""""""""""""""

*   The call graph now deals more precisely with calls to accessors (getters and setters).
    Previously, calls to static accessors were not resolved, and some method calls were incorrectly seen as calls to an accessor. Both issues have been fixed.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   An new query :code:`cpp/external-entity-expansion` has been added. The query detects XML objects that are vulnerable to external entity expansion (XXE) attacks.

Ruby
""""

*   Added a new query, :code:`rb/insecure-download`. The query finds cases where executables and other sensitive files are downloaded over an insecure connection, which may allow for man-in-the-middle attacks.
*   Added a new query, :code:`rb/regex/missing-regexp-anchor`, which finds regular expressions which are improperly anchored. Validations using such expressions are at risk of being bypassed.
*   Added a new query, :code:`rb/incomplete-sanitization`. The query finds string transformations that do not replace or escape all occurrences of a meta-character.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Java
""""

*   The QL class :code:`JumpStmt` has been made the superclass of :code:`BreakStmt`, :code:`ContinueStmt` and :code:`YieldStmt`. This allows directly using its inherited predicates without having to explicitly cast to :code:`JumpStmt` first.

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The signature of :code:`allowImplicitRead` on :code:`DataFlow::Configuration` and :code:`TaintTracking::Configuration` has changed from :code:`allowImplicitRead(DataFlow::Node node, DataFlow::Content c)` to :code:`allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c)`.

C#
""

*   The signature of :code:`allowImplicitRead` on :code:`DataFlow::Configuration` and :code:`TaintTracking::Configuration` has changed from :code:`allowImplicitRead(DataFlow::Node node, DataFlow::Content c)` to :code:`allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c)`.

Java
""""

*   The signature of :code:`allowImplicitRead` on :code:`DataFlow::Configuration` and :code:`TaintTracking::Configuration` has changed from :code:`allowImplicitRead(DataFlow::Node node, DataFlow::Content c)` to :code:`allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c)`.

Python
""""""

*   The signature of :code:`allowImplicitRead` on :code:`DataFlow::Configuration` and :code:`TaintTracking::Configuration` has changed from :code:`allowImplicitRead(DataFlow::Node node, DataFlow::Content c)` to :code:`allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c)`.

Ruby
""""

*   The signature of :code:`allowImplicitRead` on :code:`DataFlow::Configuration` and :code:`TaintTracking::Configuration` has changed from :code:`allowImplicitRead(DataFlow::Node node, DataFlow::Content c)` to :code:`allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c)`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   More Windows pool allocation functions are now detected as :code:`AllocationFunction`\ s.
*   The :code:`semmle.code.cpp.commons.Buffer` library has been enhanced to handle array members of classes that do not specify a size.

Java
""""

*   Improved the data flow support for the Android class :code:`SharedPreferences$Editor`. Specifically, the fluent logic of some of its methods is now taken into account when calculating data flow.

    *   Added flow sources and steps for JMS versions 1 and 2.
    *   Added flow sources and steps for RabbitMQ.
    *   Added flow steps for :code:`java.io.DataInput` and :code:`java.io.ObjectInput` implementations.
    
*   Added data-flow models for the Spring Framework component :code:`spring-beans`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.9.3.rst
.. _codeql-cli-2.9.3:

=========================
CodeQL 2.9.3 (2022-05-31)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.9.3 runs a total of 335 security queries when configured with the Default suite (covering 142 CWE). The Extended suite enables an additional 104 queries (covering 30 more CWE). 5 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug where precompiled CodeQL packages in the CodeQL bundle were being recompiled if they were in a read-only directory.
    
*   Fixed a bug where new versions of the VS Code extension wouldn't run two queries in parallel against one database.

New Features
~~~~~~~~~~~~

*   Users can now use CodeQL Packaging Beta to publish and download CodeQL packs on GitHub Enterprise Server (GHES) versions 3.6 and later.
    
    To authenticate to a package registry on GHES 3.6+, first create a
    :code:`~/.codeql/qlconfig.yml` file. For example, the following file specifies that all CodeQL packages should be uploaded to the GHES instance with the hostname :code:`GHE_HOSTNAME`\ :

    ..  code-block:: yaml
    
        registries:
        - packages: '*'
          url: https://containers.GHE_HOSTNAME/v2/
        
    You can now download public packages from GHES using
    :code:`codeql pack download`.
    
    To publish any package or download private packages, authenticate to GHES by specifying registry/token pairs in the
    :code:`CODEQL_REGISTRIES_AUTH` environment variable. You can authenticate using either a GitHub Apps token or a personal access token. For example,
    :code:`https://containers.GHEHOSTNAME1/v2/=TOKEN1,https://containers.GHEHOSTNAME2/v2/=TOKEN2` will authenticate the CLI to the :code:`GHEHOSTNAME1` and :code:`GHEHOSTNAME2` GHES instances.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   The query "Incorrect conversion between integer types" has been improved to treat :code:`math.MaxUint` and :code:`math.MaxInt` as the values they would be on a 32-bit architecture. This should lead to fewer false positive results.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "XML external entity expansion" (:code:`cpp/external-entity-expansion`) query precision has been increased to :code:`high`.
*   The :code:`cpp/unused-local-variable` no longer ignores functions that include :code:`if` and :code:`switch` statements with C++17-style initializers.

Golang
""""""

*   Fixed sanitization by calls to :code:`strings.Replace` and :code:`strings.ReplaceAll` in queries :code:`go/log-injection` and :code:`go/unsafe-quoting`.

Java
""""

*   Query :code:`java/sensitive-log` has received several improvements.

    *   It no longer considers usernames as sensitive information.
    *   The conditions to consider a variable a constant (and therefore exclude it as user-provided sensitive information) have been tightened.
    *   A sanitizer has been added to handle certain elements introduced by a Kotlin compiler plugin that have deceptive names.

New Queries
~~~~~~~~~~~

Golang
""""""

*   A new query "Log entries created from user input" (:code:`go/log-injection`) has been added. The query reports user-provided data reaching calls to logging methods.
*   A new query *Log entries created from user input* (:code:`go/log-injection`) has been added. The query reports user-provided data reaching calls to logging methods.
*   Added a new query, :code:`go/unexpected-nil-value`, to find calls to :code:`Wrap` from :code:`pkg/errors` where the error argument is always nil.

Java
""""

*   Two new queries "Inefficient regular expression" (:code:`java/redos`) and "Polynomial regular expression used on uncontrolled data" (:code:`java/polynomial-redos`) have been added.
    These queries help find instances of Regular Expression Denial of Service vulnerabilities.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/actions/command-injection` query has been added. It highlights GitHub Actions workflows that may allow an
    attacker to execute arbitrary code in the workflow.
    The query previously existed an experimental query.
*   A new query :code:`js/insecure-temporary-file` has been added. The query detects the creation of temporary files that may be accessible by others users. The query is not run by default.

Python
""""""

*   The query "PAM authorization bypass due to incorrect usage" (:code:`py/pam-auth-bypass`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @porcupineyhairs <https://github.com/github/codeql/pull/8595>`__.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   :code:`Function`\ 's predicate :code:`getACall` now returns more results in some situations. It now always returns callers that may call a method indirectly via an interface method that it implements. Previously this only happened if the method was in the source code being analysed.

Breaking Changes
~~~~~~~~~~~~~~~~

Python
""""""

*   :code:`API::moduleImport` no longer has any results for dotted names, such as :code:`API::moduleImport("foo.bar")`. Using :code:`API::moduleImport("foo.bar").getMember("baz").getACall()` previously worked if the Python code was :code:`from foo.bar import baz; baz()`, but not if the code was :code:`import foo.bar; foo.bar.baz()` -- we are making this change to ensure the approach that can handle all cases is always used.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ruby
""""

*   Added data-flow support for `hashes <https://docs.ruby-lang.org/en/3.1/Hash.html>`__.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   Fixed a bug where dataflow steps were ignored if both ends were inside the initialiser routine of a file-level variable.
*   The method predicate :code:`getACalleeIncludingExternals` on :code:`DataFlow::CallNode` and the function :code:`viableCallable` in :code:`DataFlowDispatch` now also work for calls to functions via a variable, where the function can be determined using local flow.

Java
""""

*   Fixed a sanitizer of the query :code:`java/android/intent-redirection`. Now, for an intent to be considered safe against intent redirection, both its package name and class name must be checked.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`isLibaryFile` predicate from :code:`ClassifyFiles.qll` has been renamed to :code:`isLibraryFile` to fix a typo.

Ruby
""""

*   Support for data flow through instance variables has been added.
*   Support of the safe navigation operator (:code:`&.`) has been added; there is a new predicate :code:`MethodCall.isSafeNavigation()`.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`AnalysedString` class in the :code:`StringAnalysis` module has been replaced with :code:`AnalyzedString`, to follow our style guide. The old name still exists as a deprecated alias.

Golang
""""""

*   The :code:`codeql/go-upgrades` CodeQL pack has been removed. All database upgrade scripts have been merged into the :code:`codeql/go-all` CodeQL pack.

Java
""""

*   The QL class :code:`FloatingPointLiteral` has been renamed to :code:`FloatLiteral`.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   A :code:`getInitialization` predicate was added to the :code:`ConstexprIfStmt`, :code:`IfStmt`, and :code:`SwitchStmt` classes that yields the C++17-style initializer of the :code:`if` or :code:`switch` statement when it exists.

Golang
""""""

*   Go 1.18 generics are now extracted and can be explored using the new CodeQL classes :code:`TypeParamDecl`, :code:`GenericFunctionInstantiationExpr`, :code:`GenericTypeInstantiationExpr`, :code:`TypeSetTerm`, and :code:`TypeSetLiteralType`, as well as using new predicates defined on the existing :code:`InterfaceType`. Class- and predicate-level documentation can be found in the `Go CodeQL library reference <https://codeql.github.com/codeql-standard-libraries/go/>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.9.2.rst
.. _codeql-cli-2.9.2:

=========================
CodeQL 2.9.2 (2022-05-16)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.9.2 runs a total of 330 security queries when configured with the Default suite (covering 141 CWE). The Extended suite enables an additional 104 queries (covering 29 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug that could make it unpredictable whether the QL compiler reports problems about query metadata tags, and thereby make :code:`codeql test run` fail spuriously in some cases.

New Features
~~~~~~~~~~~~

*   The tables produced by :code:`codeql database analyze` summarizing the results of any diagnostic and metric queries that were run now exclude the results of queries tagged :code:`telemetry`.
    
*   Uploading SARIF results using the :code:`codeql github upload-results` command now has a timeout of 5 minutes.
    
*   Downloading CodeQL packs using the :code:`codeql pack download`,
    :code:`codeql pack install` and related commands now have a timeout of 5 minutes and will retry 3 times before failing. Similar behavior has been added to the :code:`codeql pack publish` command.
    
*   The :code:`codeql generate log-summary` command will now print progress updates to :code:`stderr`.

Removed Features
~~~~~~~~~~~~~~~~

*   The table printed by :code:`codeql database analyze` to summarize the results of metric queries that were part of the analysis now reports a single row per metric name independently of the verbosity level of the command. Previously, at higher verbosity levels, this table would contain multiple rows for metric names with multiple values.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "XML external entity expansion" (:code:`cpp/external-entity-expansion`) query has been extended to support a broader selection of XML libraries and interfaces.

Java
""""

*   Query :code:`java/insecure-cookie` now tolerates setting a cookie's secure flag to :code:`request.isSecure()`. This means servlets that intentionally accept unencrypted connections will no longer raise an alert.
*   The query :code:`java/non-https-urls` has been simplified and no longer requires its sinks to be :code:`MethodAccess`\ es.
*   The logic to detect :code:`WebView`\ s with JavaScript (and optionally file access) enabled in the query :code:`java/android/unsafe-android-webview-fetch` has been improved.

New Queries
~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/missing-origin-check` query has been added. It highlights "message" event handlers that do not check the origin of the event.
    
    The query previously existed as the experimental :code:`js/missing-postmessageorigin-verification` query.

Python
""""""

*   "XML external entity expansion" (:code:`py/xxe`). Results will appear by default. This query was based on `an experimental query by @jorgectf <https://github.com/github/codeql/pull/6112>`__.
*   "XML internal entity expansion" (:code:`py/xml-bomb`). Results will appear by default. This query was based on `an experimental query by @jorgectf <https://github.com/github/codeql/pull/6112>`__.
*   The query "CSRF protection weakened or disabled" (:code:`py/csrf-protection-disabled`) has been implemented. Its results will now appear by default.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Query :code:`java/predictable-seed` now has a tag for CWE-337.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Ruby
""""

*   The Tree-sitter Ruby grammar has been updated; this fixes several issues where Ruby code was parsed incorrectly.

Breaking Changes
~~~~~~~~~~~~~~~~

Python
""""""

*   The imports made available from :code:`import python` are no longer exposed under :code:`DataFlow::` after doing :code:`import semmle.python.dataflow.new.DataFlow`, for example using :code:`DataFlow::Add` will now cause a compile error.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Added models for the libraries OkHttp and Retrofit.
*   Add taint models for the following :code:`File` methods:

    *   :code:`File::getAbsoluteFile`
    *   :code:`File::getCanonicalFile`
    *   :code:`File::getAbsolutePath`
    *   :code:`File::getCanonicalPath`
    
*   Added a flow step for :code:`toString` calls on tainted :code:`android.text.Editable` objects.
*   Added a data flow step for tainted Android intents that are sent to other activities and accessed there via :code:`getIntent()`.
*   Added modeling of MyBatis (:code:`org.apache.ibatis`) Providers, resulting in additional sinks for the queries :code:`java/ognl-injection`, :code:`java/sql-injection`, :code:`java/sql-injection-local` and :code:`java/concatenated-sql-query`.

JavaScript/TypeScript
"""""""""""""""""""""

*   The `cash <https://github.com/fabiospampinato/cash>`__ library is now modelled as an alias for JQuery.
    
    Sinks and sources from cash should now be handled by all XSS queries.
*   Added the :code:`Selection` api as a DOM text source in the :code:`js/xss-through-dom` query.
*   The security queries now recognize drag and drop data as a source, enabling the queries to flag additional alerts.
*   The security queries now recognize ClipboardEvent function parameters as a source, enabling the queries to flag additional alerts.

Python
""""""

*   The modeling of :code:`request.files` in Flask has been fixed, so we now properly handle assignments to local variables (such as :code:`files = request.files; files['key'].filename`).
*   Added taint propagation for :code:`io.StringIO` and :code:`io.BytesIO`. This addition was originally `submitted as part of an experimental query by @jorgectf <https://github.com/github/codeql/pull/6112>`__.

Deprecated APIs
~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`ReflectedXss`, :code:`StoredXss`, :code:`XssThroughDom`, and :code:`ExceptionXss` modules from :code:`Xss.qll` have been deprecated.
    
    Use the :code:`Customizations.qll` file belonging to the query instead.

New Features
~~~~~~~~~~~~

Java
""""

*   A number of new classes and methods related to the upcoming Kotlin support have been added. These are not yet stable, as Kotlin support is still under development.

    *   :code:`File::isSourceFile`
    *   :code:`File::isJavaSourceFile`
    *   :code:`File::isKotlinSourceFile`
    *   :code:`Member::getKotlinType`
    *   :code:`Element::isCompilerGenerated`
    *   :code:`Expr::getKotlinType`
    *   :code:`LambdaExpr::isKotlinFunctionN`
    *   :code:`Callable::getReturnKotlinType`
    *   :code:`Callable::getParameterKotlinType`
    *   :code:`Method::isLocal`
    *   :code:`Method::getKotlinName`
    *   :code:`Field::getKotlinType`
    *   :code:`Modifiable::isSealedKotlin`
    *   :code:`Modifiable::isInternal`
    *   :code:`Variable::getKotlinType`
    *   :code:`LocalVariableDecl::getKotlinType`
    *   :code:`Parameter::getKotlinType`
    *   :code:`Parameter::isExtensionParameter`
    *   :code:`Compilation` class
    *   :code:`Diagnostic` class
    *   :code:`KtInitializerAssignExpr` class
    *   :code:`ValueEQExpr` class
    *   :code:`ValueNEExpr` class
    *   :code:`ValueOrReferenceEqualsExpr` class
    *   :code:`ValueOrReferenceNotEqualsExpr` class
    *   :code:`ReferenceEqualityTest` class
    *   :code:`CastingExpr` class
    *   :code:`SafeCastExpr` class
    *   :code:`ImplicitCastExpr` class
    *   :code:`ImplicitNotNullExpr` class
    *   :code:`ImplicitCoercionToUnitExpr` class
    *   :code:`UnsafeCoerceExpr` class
    *   :code:`PropertyRefExpr` class
    *   :code:`NotInstanceOfExpr` class
    *   :code:`ExtensionReceiverAccess` class
    *   :code:`WhenExpr` class
    *   :code:`WhenBranch` class
    *   :code:`ClassExpr` class
    *   :code:`StmtExpr` class
    *   :code:`StringTemplateExpr` class
    *   :code:`NotNullExpr` class
    *   :code:`TypeNullPointerException` class
    *   :code:`KtComment` class
    *   :code:`KtCommentSection` class
    *   :code:`KotlinType` class
    *   :code:`KotlinNullableType` class
    *   :code:`KotlinNotnullType` class
    *   :code:`KotlinTypeAlias` class
    *   :code:`Property` class
    *   :code:`DelegatedProperty` class
    *   :code:`ExtensionMethod` class
    *   :code:`KtInitializerNode` class
    *   :code:`KtLoopStmt` class
    *   :code:`KtBreakContinueStmt` class
    *   :code:`KtBreakStmt` class
    *   :code:`KtContinueStmt` class
    *   :code:`ClassObject` class
    *   :code:`CompanionObject` class
    *   :code:`LiveLiteral` class
    *   :code:`LiveLiteralMethod` class
    *   :code:`CastConversionContext` renamed to :code:`CastingConversionContext`
    
*   The QL class :code:`ValueDiscardingExpr` has been added, representing expressions for which the value of the expression as a whole is discarded.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.15.5.rst
.. _codeql-cli-2.15.5:

==========================
CodeQL 2.15.5 (2023-12-20)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.15.5 runs a total of 401 security queries when configured with the Default suite (covering 159 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed an issue where CodeQL would sometimes incorrectly report that no files were scanned when running on Windows.
    This affected the human-readable summary produced by :code:`codeql database analyze` and :code:`codeql database interpret-results`, but did not impact the file coverage information produced in the SARIF output and displayed on the tool status page.
*   When analyzing Swift codebases, CodeQL build tracing will now ignore the
    :code:`codesign` tool. This prevents errors in build commands or workflows on macOS that include both CodeQL and code signing.

New Features
~~~~~~~~~~~~

*   A new extractor option has been added to the JavaScript/TypeScript extractor.
    Set the environment variable :code:`CODEQL_EXTRACTOR_JAVASCRIPT_OPTION_SKIP_TYPES` to :code:`true` to skip the extraction of types in TypeScript files.
    Use this to speed up extraction if your codebase has a high volume of TypeScript type information that causes a noticeable bottleneck for TypeScript extraction. The majority of analysis results should be preserved even when no types are extracted.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.2.rst
.. _codeql-cli-2.5.2:

=========================
CodeQL 2.5.2 (2021-04-21)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.2 runs a total of 239 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE).

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.7.0.rst
.. _codeql-cli-2.7.0:

=========================
CodeQL 2.7.0 (2021-10-27)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.7.0 runs a total of 268 security queries when configured with the Default suite (covering 117 CWE). The Extended suite enables an additional 80 queries (covering 28 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug where indirect tracing would sometimes not manage to observe build processes if certain environment variables were unset during the build.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.1.rst
.. _codeql-cli-2.11.1:

==========================
CodeQL 2.11.1 (2022-10-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.1 runs a total of 354 security queries when configured with the Default suite (covering 148 CWE). The Extended suite enables an additional 109 queries (covering 30 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   Pack installation using the CodeQL Packaging beta will now fail if a compatible version cannot be found. This replaces the previous behavior where :code:`codeql pack download` and related commands would instead install the latest version of the pack in this situation.

Bug Fixes
~~~~~~~~~

*   It is no longer an error to call :code:`codeql pack create <path>` with a :code:`<path>` option pointing to a file name. The CLI will walk up the directory tree and run the command in the first directory containing the :code:`qlpack.yml` or :code:`codeql-pack.yml` file.
*   Fixed a concurrency error observed when using :code:`codeql database import` or
    :code:`codeql database finalize` with multiple threads and multiple additional databases on a C++ codebase.

Deprecations
~~~~~~~~~~~~

*   The :code:`--[no-]count-lines` option to :code:`codeql database create` and related commands is now deprecated and will be removed in a future release of the CodeQL CLI (earliest 2.12.0). It is replaced by
    :code:`--[no-]calculate-baseline` to reflect the additional baseline information that is now captured as of this release.

New Features
~~~~~~~~~~~~

*   Subcommands that compile QL accept a new :code:`--no-release-compatibility` option. It does nothing for now, but in the future it will be used to control a trade-off between query performance and compatibility with older/newer releases of the QL evaluator.
*   :code:`codeql database analyze` and related commands now support absolute paths containing the :code:`@` or :code:`:` characters when specifying which queries to run. To reference a query file, directory, or suite whose path contains a literal :code:`@` or :code:`:`, prefix the query specifier with :code:`path:`, for example:

    ..  code-block:: shell
    
            codeql database analyze --format=sarif-latest --output=results <db> path:C:/Users/ci/workspace@2/security/query.ql

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The alert message of many queries have been changed to better follow the style guide and make the message consistent with other languages.

C#
""

*   The alert message of many queries have been changed to better follow the style guide and make the message consistent with other languages.

Java
""""

*   The alert message of many queries have been changed to better follow the style guide and make the message consistent with other languages.
*   :code:`PathSanitizer.qll` has been promoted from experimental to the main query pack. This sanitizer was originally `submitted as part of an experimental query by @luchua-bc <https://github.com/github/codeql/pull/7286>`__.
*   The queries :code:`java/path-injection`, :code:`java/path-injection-local` and :code:`java/zipslip` now use the sanitizers provided by :code:`PathSanitizer.qll`.

Ruby
""""

*   The :code:`rb/xxe` query has been updated to add the following sinks for XML external entity expansion:

    #.  Calls to parse XML using :code:`LibXML` when its :code:`default_substitute_entities` option is enabled.
    #.  Uses of the Rails methods :code:`ActiveSupport::XmlMini.parse`, :code:`Hash.from_xml`, and :code:`Hash.from_trusted_xml` when :code:`ActiveSupport::XmlMini` is configured to use :code:`LibXML` as its backend, and its :code:`default_substitute_entities` option is enabled.

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query, :code:`java/android/webview-debugging-enabled`, to detect instances of WebView debugging being enabled in production builds.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   :code:`DateTime` expressions are now considered simple type sanitizers. This affects a wide range of security queries.
*   ASP.NET Core controller definition has been made more precise. The amount of introduced taint sources or eliminated false positives should be low though, since the most common pattern is to derive all user defined ASP.NET Core controllers from the standard Controller class, which is not affected.

Golang
""""""

*   Added support for :code:`BeegoInput.RequestBody` as a source of untrusted data.

Java
""""

*   Added external flow sources for the intents received in exported Android services.

JavaScript/TypeScript
"""""""""""""""""""""

*   Several of the SQL and NoSQL library models have improved, leading to more results for the :code:`js/sql-injection` query,
    and in some cases the :code:`js/missing-rate-limiting` query.

Python
""""""

*   Added the ability to refer to subscript operations in the API graph. It is now possible to write :code:`response().getMember("cookies").getASubscript()` to find code like :code:`resp.cookies["key"]` (assuming :code:`response` returns an API node for response objects).
*   Added modeling of creating Flask responses with :code:`flask.jsonify`.

Ruby
""""

*   The following classes have been moved from :code:`codeql.ruby.frameworks.ActionController` to :code:`codeql.ruby.frameworks.Rails`\ :

    *   :code:`ParamsCall`, now accessed as :code:`Rails::ParamsCall`.
    *   :code:`CookieCall`, now accessed as :code:`Rails::CookieCall`.
    
*   The following classes have been moved from :code:`codeql.ruby.frameworks.ActionView` to :code:`codeql.ruby.frameworks.Rails`\ :

    *   :code:`HtmlSafeCall`, now accessed as :code:`Rails::HtmlSafeCall`.
    *   :code:`HtmlEscapeCall`, now accessed as :code:`Rails::HtmlEscapeCall`.
    *   :code:`RenderCall`, now accessed as :code:`Rails::RenderCall`.
    *   :code:`RenderToCall`, now accessed as :code:`Rails::RenderToCall`.
    
*   Subclasses of :code:`ActionController::Metal` are now recognised as controllers.
*   :code:`ActionController::DataStreaming::send_file` is now recognized as a
    :code:`FileSystemAccess`.
*   Various XSS sinks in the ActionView library are now recognized.
*   Calls to :code:`ActiveRecord::Base.create` are now recognized as model instantiations.
*   Various code executions, command executions and HTTP requests in the ActiveStorage library are now recognized.
*   :code:`MethodBase` now has two new predicates related to visibility: :code:`isPublic` and
    :code:`isProtected`. These hold, respectively, if the method is public or protected.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.13.3.rst
.. _codeql-cli-2.13.3:

==========================
CodeQL 2.13.3 (2023-05-31)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.13.3 runs a total of 389 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 125 queries (covering 32 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug that could cause the compiler to infer incorrect binding sets for non-direct calls to overriding member predicates that have stronger binding sets than their root definitions.
    
*   Fixed a bug that could have caused the compiler to incorrectly infer that a class matched a type signature. The bug only affected classes with overriding member predicates that had stronger binding sets than their root definitions.
    
*   Fixed a bug where a query could not be run from VS Code when there were packs nested within sibling directories of the query.

New Features
~~~~~~~~~~~~

*   This release enhances our preliminary Swift support, setting the stage for the upcoming public beta.
    
*   The :code:`codeql database bundle` command now supports the :code:`--[no]-include-temp` option. When enabled, this option will include the :code:`temp` folder of the database directory in the zip file of the bundled database. This folder includes generated packages and queries, and query suites.
    
*   The structured log produced by :code:`codeql generate log-summary` now includes a Boolean :code:`isCached` field for predicate events, where a :code:`true` value indicates the predicate is a wrapper implementing the :code:`cached` annotation on another predicate. The wrapper depends on the underlying predicate that the annotation was found on, and will usually have the same name, but it has a separate :code:`raHash`.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed a spurious diagnostic warning about comments in JSON files being illegal.
    Comments in JSON files are in fact fully supported, and the diagnostic message was misleading.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added taint sources from the :code:`@actions/core` and :code:`@actions/github` packages.
*   Added command-injection sinks from the :code:`@actions/exec` package.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The query :code:`java/groovy-injection` now recognizes :code:`groovy.text.TemplateEngine.createTemplate` as a sink.
*   The queries :code:`java/xxe` and :code:`java/xxe-local` now recognize the second argument of calls to :code:`XPath.evaluate` as a sink.
*   Experimental sinks for the query "Resolving XML external entity in user-controlled data" (:code:`java/xxe`) have been promoted to the main query pack. These sinks were originally `submitted as part of an experimental query by @haby0 <https://github.com/github/codeql/pull/6564>`__.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/indirect-command-line-injection` query no longer flags command arguments that cannot be interpreted as a shell string.
*   The :code:`js/unsafe-deserialization` query no longer flags deserialization through the :code:`js-yaml` library, except when it is used with an unsafe schema.
*   The Forge module in :code:`CryptoLibraries.qll` now correctly classifies SHA-512/224,
    SHA-512/256, and SHA-512/384 hashes used in message digests as NonKeyCiphers.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   In the intermediate representation, handling of control flow after non-returning calls has been improved. This should remove false positives in queries that use the intermedite representation or libraries based on it, including the new data flow library.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`StdNamespace` class now also includes all inline namespaces that are children of :code:`std` namespace.
*   The new dataflow (:code:`semmle.code.cpp.dataflow.new.DataFlow`) and taint-tracking libraries (:code:`semmle.code.cpp.dataflow.new.TaintTracking`) now support tracking flow through static local variables.

C#
""

*   The :code:`cs/log-forging`, :code:`cs/cleartext-storage`, and :code:`cs/exposure-of-sensitive-information` queries now correctly handle unsanitized arguments to :code:`ILogger` extension methods.
*   Updated the :code:`neutralModel` extensible predicate to include a :code:`kind` column.

Golang
""""""

*   Fixed data flow through variadic function parameters. The arguments corresponding to a variadic parameter are no longer returned by :code:`CallNode.getArgument(int i)` and :code:`CallNode.getAnArgument()`, and hence aren't :code:`ArgumentNode`\ s. They now have one result, which is an :code:`ImplicitVarargsSlice` node. For example, a call :code:`f(a, b, c)` to a function :code:`f(T...)` is treated like :code:`f([]T{a, b, c})`. The old behaviour is preserved by :code:`CallNode.getSyntacticArgument(int i)` and :code:`CallNode.getASyntacticArgument()`. :code:`CallExpr.getArgument(int i)` and :code:`CallExpr.getAnArgument()` are unchanged, and will still have three results in the example given.

Java
""""

*   Added SQL injection sinks for Spring JDBC's :code:`NamedParameterJdbcOperations`.
    
*   Added models for the following packages:

    *   org.apache.hadoop.fs
    
*   Added the :code:`ArithmeticCommon.qll` library to provide predicates for reasoning about arithmetic operations.
    
*   Added the :code:`ArithmeticTaintedLocalQuery.qll` library to provide the :code:`ArithmeticTaintedLocalOverflowFlow` and :code:`ArithmeticTaintedLocalUnderflowFlow` taint-tracking modules to reason about arithmetic with unvalidated user input.
    
*   Added the :code:`ArithmeticTaintedQuery.qll` library to provide the :code:`RemoteUserInputOverflow` and :code:`RemoteUserInputUnderflow` taint-tracking modules to reason about arithmetic with unvalidated user input.
    
*   Added the :code:`ArithmeticUncontrolledQuery.qll` library to provide the :code:`ArithmeticUncontrolledOverflowFlow`  and :code:`ArithmeticUncontrolledUnderflowFlow` taint-tracking modules to reason about arithmetic with uncontrolled user input.
    
*   Added the :code:`ArithmeticWithExtremeValuesQuery.qll` library to provide the :code:`MaxValueFlow` and :code:`MinValueFlow` dataflow modules to reason about arithmetic with extreme values.
    
*   Added the :code:`BrokenCryptoAlgorithmQuery.qll` library to provide the :code:`InsecureCryptoFlow` taint-tracking module to reason about broken cryptographic algorithm vulnerabilities.
    
*   Added the :code:`ExecTaintedLocalQuery.qll` library to provide the :code:`LocalUserInputToArgumentToExecFlow` taint-tracking module to reason about command injection vulnerabilities caused by local data flow.
    
*   Added the :code:`ExternallyControlledFormatStringLocalQuery.qll` library to provide the :code:`ExternallyControlledFormatStringLocalFlow` taint-tracking module to reason about format string vulnerabilities caused by local data flow.
    
*   Added the :code:`ImproperValidationOfArrayConstructionCodeSpecifiedQuery.qll` library to provide the :code:`BoundedFlowSourceFlow` dataflow module to reason about improper validation of code-specified sizes used for array construction.
    
*   Added the :code:`ImproperValidationOfArrayConstructionLocalQuery.qll` library to provide the :code:`ImproperValidationOfArrayConstructionLocalFlow` taint-tracking module to reason about improper validation of local user-provided sizes used for array construction caused by local data flow.
    
*   Added the :code:`ImproperValidationOfArrayConstructionQuery.qll` library to provide the :code:`ImproperValidationOfArrayConstructionFlow` taint-tracking module to reason about improper validation of user-provided size used for array construction.
    
*   Added the :code:`ImproperValidationOfArrayIndexCodeSpecifiedQuery.qll` library to provide the :code:`BoundedFlowSourceFlow` data flow module to reason about about improper validation of code-specified array index.
    
*   Added the :code:`ImproperValidationOfArrayIndexLocalQuery.qll` library to provide the :code:`ImproperValidationOfArrayIndexLocalFlow` taint-tracking module to reason about improper validation of a local user-provided array index.
    
*   Added the :code:`ImproperValidationOfArrayIndexQuery.qll` library to provide the :code:`ImproperValidationOfArrayIndexFlow` taint-tracking module to reason about improper validation of user-provided array index.
    
*   Added the :code:`InsecureCookieQuery.qll` library to provide the :code:`SecureCookieFlow` taint-tracking module to reason about insecure cookie vulnerabilities.
    
*   Added the :code:`MaybeBrokenCryptoAlgorithmQuery.qll` library to provide the :code:`InsecureCryptoFlow` taint-tracking module to reason about broken cryptographic algorithm vulnerabilities.
    
*   Added the :code:`NumericCastTaintedQuery.qll` library to provide the :code:`NumericCastTaintedFlow` taint-tracking module to reason about numeric cast vulnerabilities.
    
*   Added the :code:`ResponseSplittingLocalQuery.qll` library to provide the :code:`ResponseSplittingLocalFlow` taint-tracking module to reason about response splitting vulnerabilities caused by local data flow.
    
*   Added the :code:`SqlConcatenatedQuery.qll` library to provide the :code:`UncontrolledStringBuilderSourceFlow` taint-tracking module to reason about SQL injection vulnerabilities caused by concatenating untrusted strings.
    
*   Added the :code:`SqlTaintedLocalQuery.qll` library to provide the :code:`LocalUserInputToArgumentToSqlFlow` taint-tracking module to reason about SQL injection vulnerabilities caused by local data flow.
    
*   Added the :code:`StackTraceExposureQuery.qll` library to provide the :code:`printsStackExternally`, :code:`stringifiedStackFlowsExternally`, and :code:`getMessageFlowsExternally` predicates to reason about stack trace exposure vulnerabilities.
    
*   Added the :code:`TaintedPermissionQuery.qll` library to provide the :code:`TaintedPermissionFlow` taint-tracking module to reason about tainted permission vulnerabilities.
    
*   Added the :code:`TempDirLocalInformationDisclosureQuery.qll` library to provide the :code:`TempDirSystemGetPropertyToCreate` taint-tracking module to reason about local information disclosure vulnerabilities caused by local data flow.
    
*   Added the :code:`UnsafeHostnameVerificationQuery.qll` library to provide the :code:`TrustAllHostnameVerifierFlow` taint-tracking module to reason about insecure hostname verification vulnerabilities.
    
*   Added the :code:`UrlRedirectLocalQuery.qll` library to provide the :code:`UrlRedirectLocalFlow` taint-tracking module to reason about URL redirection vulnerabilities caused by local data flow.
    
*   Added the :code:`UrlRedirectQuery.qll` library to provide the :code:`UrlRedirectFlow` taint-tracking module to reason about URL redirection vulnerabilities.
    
*   Added the :code:`XPathInjectionQuery.qll` library to provide the :code:`XPathInjectionFlow` taint-tracking module to reason about XPath injection vulnerabilities.
    
*   Added the :code:`XssLocalQuery.qll` library to provide the :code:`XssLocalFlow` taint-tracking module to reason about XSS vulnerabilities caused by local data flow.
    
*   Moved the :code:`url-open-stream` sink models to experimental and removed :code:`url-open-stream` as a sink option from the `Customizing Library Models for Java <https://github.com/github/codeql/blob/733a00039efdb39c3dd76ddffad5e6d6c85e6774/docs/codeql/codeql-language-guides/customizing-library-models-for-java.rst#customizing-library-models-for-java>`__ documentation.
    
*   Added models for the Apache Commons Net library.
    
*   Updated the :code:`neutralModel` extensible predicate to include a :code:`kind` column.
    
*   Added models for the :code:`io.jsonwebtoken` library.

JavaScript/TypeScript
"""""""""""""""""""""

*   Improved the queries for injection vulnerabilities in GitHub Actions workflows (:code:`js/actions/command-injection` and :code:`js/actions/pull-request-target`) and the associated library :code:`semmle.javascript.Actions`. These now support steps defined in composite actions, in addition to steps defined in Actions workflow files. It supports more potentially untrusted input values. Additionally to the shell injections it now also detects injections in :code:`actions/github-script`. It also detects simple injections from user controlled :code:`${{ env.name }}`. Additionally to the :code:`yml` extension now it also supports workflows with the :code:`yaml` extension.

Python
""""""

*   Type tracking is now aware of reads of captured variables (variables defined in an outer scope). This leads to a richer API graph, and may lead to more results in some queries.
*   Added more content-flow/field-flow for dictionaries, by adding support for reads through :code:`mydict.get("key")` and :code:`mydict.setdefault("key", value)`, and store steps through :code:`dict["key"] = value` and :code:`mydict.setdefault("key", value)`.

Ruby
""""

*   Support for the :code:`sqlite3` gem has been added. Method calls that execute queries against an SQLite3 database that may be vulnerable to injection attacks will now be recognized.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added an AST-based interface (:code:`semmle.code.cpp.rangeanalysis.new.RangeAnalysis`) for the relative range analysis library.
*   A new predicate :code:`BarrierGuard::getAnIndirectBarrierNode` has been added to the new dataflow library (:code:`semmle.code.cpp.dataflow.new.DataFlow`) to mark indirect expressions as barrier nodes using the :code:`BarrierGuard` API.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.0.rst
.. _codeql-cli-2.11.0:

==========================
CodeQL 2.11.0 (2022-09-28)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.0 runs a total of 353 security queries when configured with the Default suite (covering 148 CWE). The Extended suite enables an additional 109 queries (covering 30 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

Deprecations
~~~~~~~~~~~~

*   The CodeQL CLI now uses Python 3 to extract both Python 2 and Python 3 databases. Correspondingly, support for using Python 2 to extract Python databases is now deprecated. Starting with version 2.11.3, you will need to install Python 3 to extract Python databases.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.4.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed a bug in the :code:`js/type-confusion-through-parameter-tampering` query that would cause it to ignore sanitizers in branching conditions. The query should now report fewer false positives.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Modernizations from "Cleartext storage of sensitive information in buffer" (:code:`cpp/cleartext-storage-buffer`) have been ported to the "Cleartext storage of sensitive information in file" (:code:`cpp/cleartext-storage-file`), "Cleartext transmission of sensitive information" (:code:`cpp/cleartext-transmission`) and "Cleartext storage of sensitive information in an SQLite database" (:code:`cpp/cleartext-storage-database`) queries. These changes may result in more correct results and fewer false positive results from these queries.
*   The alert message of many queries have been changed to make the message consistent with other languages.

C#
""

*   A new extractor option has been introduced for disabling CIL extraction. Either pass :code:`-Ocil=false` to the :code:`codeql` CLI or set the environment variable :code:`CODEQL_EXTRACTOR_CSHARP_OPTION_CIL=false`.
*   The alert message of many queries have been changed to make the message consistent with other languages.

Golang
""""""

*   The alert message of many queries have been changed to make the message consistent with other languages.

Java
""""

*   The Java extractor now populates the :code:`Method` relating to a :code:`MethodAccess` consistently for calls using an explicit and implicit :code:`this` qualifier. Previously if the method :code:`foo` was inherited from a specialised generic type :code:`ParentType<String>`, then an explicit call :code:`this.foo()` would yield a :code:`MethodAccess` whose :code:`getMethod()` accessor returned the bound method :code:`ParentType<String>.foo`, whereas an implicitly-qualified :code:`foo()` :code:`MethodAccess`\ 's :code:`getMethod()` would return the unbound method :code:`ParentType.foo`. Now both scenarios produce a bound method. This means that all data-flow queries may return more results where a relevant path transits a call to such an implicitly-qualified call to a member method with a bound generic type, while queries that inspect the result of :code:`MethodAccess.getMethod()` may need to tolerate bound generic methods in more circumstances. The queries :code:`java/iterator-remove-failure`, :code:`java/non-static-nested-class`, :code:`java/internal-representation-exposure`, :code:`java/subtle-inherited-call` and :code:`java/deprecated-call` have been amended to properly handle calls to bound generic methods, and in some instances may now produce more results in the explicit-\ :code:`this` case as well.
*   Added taint model for arguments of :code:`java.net.URI` constructors to the queries :code:`java/path-injection` and :code:`java/path-injection-local`.
*   Added new sinks related to Android's :code:`AlarmManager` to the query :code:`java/android/implicit-pendingintents`.
*   The alert message of many queries have been changed to make the message consistent with other languages.

JavaScript/TypeScript
"""""""""""""""""""""

*   Improved how the JavaScript parser handles ambiguities between plain JavaScript and dialects such as Flow and E4X that use the same file extension. The parser now prefers plain JavaScript if possible, falling back to dialects only if the source code can not be parsed as plain JavaScript. Previously, there were rare cases where parsing would fail because the parser would erroneously attempt to parse dialect-specific syntax in a regular JavaScript file.
*   The :code:`js/regexp/always-matches` query will no longer report an empty regular expression as always matching, as this is often the intended behavior.
*   The alert message of many queries have been changed to make the message consistent with other languages.

Python
""""""

*   The alert message of many queries have been changed to make the message consistent with other languages.

Ruby
""""

*   The :code:`rb/unsafe-deserialization` query now includes alerts for user-controlled data passed to :code:`Hash.from_trusted_xml`, since that method can deserialize YAML embedded in the XML, which in turn can result in deserialization of arbitrary objects.
*   The alert message of many queries have been changed to make the message consistent with other languages.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new medium-precision query, :code:`cpp/missing-check-scanf`, which detects :code:`scanf` output variables that are used without a proper return-value check to see that they were actually written. A variation of this query was originally contributed as an `experimental query by @ihsinme <https://github.com/github/codeql/pull/8246>`__.

Java
""""

*   The query "Server-side template injection" (:code:`java/server-side-template-injection`) has been promoted from experimental to the main query pack. This query was originally `submitted as an experimental query by @porcupineyhairs <https://github.com/github/codeql/pull/5935>`__.
*   Added a new query, :code:`java/android/backup-enabled`, to detect if Android applications allow backups.

Ruby
""""

*   Added a new query, :code:`rb/hardcoded-data-interpreted-as-code`, to detect cases where hardcoded data is executed as code, a technique associated with backdoors.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   Added the :code:`security-severity` tag and CWE tag to the :code:`go/insecure-hostkeycallback` query.

Java
""""

*   Removed the :code:`@security-severity` tag from several queries not in the :code:`Security/` folder that also had missing :code:`security` tags.

Python
""""""

*   Added the :code:`security-severity` tag the :code:`py/redos`, :code:`py/polynomial-redos`, and :code:`py/regex-injection` queries.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

C/C++
"""""

*   Fixed an issue in the taint tracking analysis where implicit reads were not allowed by default in sinks or additional taint steps that used flow states.

C#
""

*   Fixed an issue in the taint tracking analysis where implicit reads were not allowed by default in sinks or additional taint steps that used flow states.

Java
""""

*   Fixed an issue in the taint tracking analysis where implicit reads were not allowed by default in sinks or additional taint steps that used flow states.

Python
""""""

*   Fixed an issue in the taint tracking analysis where implicit reads were not allowed by default in sinks or additional taint steps that used flow states.

Ruby
""""

*   Fixed an issue in the taint tracking analysis where implicit reads were not allowed by default in sinks or additional taint steps that used flow states.

Breaking Changes
~~~~~~~~~~~~~~~~

Java
""""

*   The :code:`Member.getQualifiedName()` predicate result now includes the qualified name of the declaring type.

JavaScript/TypeScript
"""""""""""""""""""""

*   Many library models have been rewritten to use dataflow nodes instead of the AST.
    The types of some classes have been changed, and these changes may break existing code.
    Other classes and predicates have been renamed, in these cases the old name is still available as a deprecated feature.
*   The basetype of the following list of classes has changed from an expression to a dataflow node, and thus code using these classes might break.
    The fix to these breakages is usually to use :code:`asExpr()` to get an expression from a dataflow node, or to use :code:`.flow()` to get a dataflow node from an expression.

    *   DOM.qll#WebStorageWrite
    *   CryptoLibraries.qll#CryptographicOperation
    *   Express.qll#Express::RequestBodyAccess
    *   HTTP.qll#HTTP::ResponseBody
    *   HTTP.qll#HTTP::CookieDefinition
    *   HTTP.qll#HTTP::ServerDefinition
    *   HTTP.qll#HTTP::RouteSetup
    *   NoSQL.qll#NoSql::Query
    *   SQL.qll#SQL::SqlString
    *   SQL.qll#SQL::SqlSanitizer
    *   HTTP.qll#ResponseBody
    *   HTTP.qll#CookieDefinition
    *   HTTP.qll#ServerDefinition
    *   HTTP.qll#RouteSetup
    *   HTTP.qll#HTTP::RedirectInvocation
    *   HTTP.qll#RedirectInvocation
    *   Express.qll#Express::RouterDefinition
    *   AngularJSCore.qll#LinkFunction
    *   Connect.qll#Connect::StandardRouteHandler
    *   CryptoLibraries.qll#CryptographicKeyCredentialsExpr
    *   AWS.qll#AWS::Credentials
    *   Azure.qll#Azure::Credentials
    *   Connect.qll#Connect::Credentials
    *   DigitalOcean.qll#DigitalOcean::Credentials
    *   Express.qll#Express::Credentials
    *   NodeJSLib.qll#NodeJSLib::Credentials
    *   PkgCloud.qll#PkgCloud::Credentials
    *   Request.qll#Request::Credentials
    *   ServiceDefinitions.qll#InjectableFunctionServiceRequest
    *   SensitiveActions.qll#SensitiveVariableAccess
    *   SensitiveActions.qll#CleartextPasswordExpr
    *   Connect.qll#Connect::ServerDefinition
    *   Restify.qll#Restify::ServerDefinition
    *   Connect.qll#Connect::RouteSetup
    *   Express.qll#Express::RouteSetup
    *   Fastify.qll#Fastify::RouteSetup
    *   Hapi.qll#Hapi::RouteSetup
    *   Koa.qll#Koa::RouteSetup
    *   Restify.qll#Restify::RouteSetup
    *   NodeJSLib.qll#NodeJSLib::RouteSetup
    *   Express.qll#Express::StandardRouteHandler
    *   Express.qll#Express::SetCookie
    *   Hapi.qll#Hapi::RouteHandler
    *   HTTP.qll#HTTP::Servers::StandardHeaderDefinition
    *   HTTP.qll#Servers::StandardHeaderDefinition
    *   Hapi.qll#Hapi::ServerDefinition
    *   Koa.qll#Koa::AppDefinition
    *   SensitiveActions.qll#SensitiveCall

Ruby
""""

*   :code:`import ruby` no longer brings the standard Ruby AST library into scope; it instead brings a module :code:`Ast` into scope, which must be imported. Alternatively, it is also possible to import :code:`codeql.ruby.AST`.
*   Changed the :code:`HTTP::Client::Request` concept from using :code:`MethodCall` as base class, to using :code:`DataFlow::Node` as base class. Any class that extends :code:`HTTP::Client::Request::Range` must be changed, but if you only use the member predicates of :code:`HTTP::Client::Request`, no changes are required.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The virtual dispatch relation used in data flow now favors summary models over source code for dispatch to interface methods from :code:`java.util` unless there is evidence that a specific source implementation is reachable. This should provide increased precision for any projects that include, for example, custom :code:`List` or :code:`Map` implementations.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 4.8.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Added new sinks to the query :code:`java/android/implicit-pendingintents` to take into account the classes :code:`androidx.core.app.NotificationManagerCompat` and :code:`androidx.core.app.AlarmManagerCompat`.
*   Added new flow steps for :code:`androidx.core.app.NotificationCompat` and its inner classes.
*   Added flow sinks, sources and summaries for the Kotlin standard library.
*   Added flow summary for :code:`org.springframework.data.repository.CrudRepository.save()`.
*   Added new flow steps for the following Android classes:

    *   :code:`android.content.ContentResolver`
    *   :code:`android.content.ContentProviderClient`
    *   :code:`android.content.ContentProviderOperation`
    *   :code:`android.content.ContentProviderOperation$Builder`
    *   :code:`android.content.ContentProviderResult`
    *   :code:`android.database.Cursor`
    
*   Added taint flow models for the :code:`java.lang.String.(charAt|getBytes)` methods.
*   Improved taint flow models for the :code:`java.lang.String.(replace|replaceFirst|replaceAll)` methods. Additional results may be found where users do not properly sanitize their inputs.

JavaScript/TypeScript
"""""""""""""""""""""

*   A model for the :code:`mermaid` library has been added. XSS queries can now detect flow through the :code:`render` method of the :code:`mermaid` library.

Python
""""""

*   Changed :code:`CallNode.getArgByName` such that it has results for keyword arguments given after a dictionary unpacking argument, as the :code:`bar=2` argument in :code:`func(foo=1, **kwargs, bar=2)`.
*   :code:`getStarArg` member-predicate on :code:`Call` and :code:`CallNode` has been changed for calls that have multiple :code:`*args` arguments (for example :code:`func(42, *my_args, *other_args)`): Instead of producing no results, it will always have a result for the *first* such :code:`*args` argument.
*   Reads of global/non-local variables (without annotations) inside functions defined on classes now works properly in the case where the class had an attribute defined with the same name as the non-local variable.

Ruby
""""

*   Uses of :code:`ActionView::FileSystemResolver` are now recognized as filesystem accesses.
*   Accesses of ActiveResource models are now recognized as HTTP requests.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   Some classes/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

C#
""

*   Some classes/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Golang
""""""

*   Some classes/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Java
""""

*   The predicate :code:`Annotation.getAValue()` has been deprecated because it might lead to obtaining the value of the wrong annotation element by accident. :code:`getValue(string)` (or one of the value type specific predicates) should be used to explicitly specify the name of the annotation element.
*   The predicate :code:`Annotation.getAValue(string)` has been renamed to :code:`getAnArrayValue(string)`.
*   The predicate :code:`SuppressWarningsAnnotation.getASuppressedWarningLiteral()` has been deprecated because it unnecessarily restricts the result type; :code:`getASuppressedWarning()` should be used instead.
*   The predicates :code:`TargetAnnotation.getATargetExpression()` and :code:`RetentionAnnotation.getRetentionPolicyExpression()` have been deprecated because getting the enum constant read expression is rarely useful, instead the corresponding predicates for getting the name of the referenced enum constants should be used.

JavaScript/TypeScript
"""""""""""""""""""""

*   Some classes/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Python
""""""

*   Some unused predicates in :code:`SsaDefinitions.qll`, :code:`TObject.qll`, :code:`protocols.qll`, and the :code:`pointsto/` folder have been deprecated.
*   Some classes/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Ruby
""""

*   Some classes/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added subclasses of :code:`BuiltInOperations` for :code:`__is_same`, :code:`__is_function`, :code:`__is_layout_compatible`, :code:`__is_pointer_interconvertible_base_of`, :code:`__is_array`, :code:`__array_rank`, :code:`__array_extent`, :code:`__is_arithmetic`, :code:`__is_complete_type`, :code:`__is_compound`, :code:`__is_const`, :code:`__is_floating_point`, :code:`__is_fundamental`, :code:`__is_integral`, :code:`__is_lvalue_reference`, :code:`__is_member_function_pointer`, :code:`__is_member_object_pointer`, :code:`__is_member_pointer`, :code:`__is_object`, :code:`__is_pointer`, :code:`__is_reference`, :code:`__is_rvalue_reference`, :code:`__is_scalar`, :code:`__is_signed`, :code:`__is_unsigned`, :code:`__is_void`, and :code:`__is_volatile`.

Java
""""

*   Added a new predicate, :code:`allowsBackup`, in the :code:`AndroidApplicationXmlElement` class. This predicate detects if the application element does not disable the :code:`android:allowBackup` attribute.
*   The predicates of the CodeQL class :code:`Annotation` have been improved:

    *   Convenience value type specific predicates have been added, such as :code:`getEnumConstantValue(string)` or :code:`getStringValue(string)`.
    *   Convenience predicates for elements with array values have been added, such as :code:`getAnEnumConstantArrayValue(string)`. While the behavior of the existing predicates has not changed, usage of them should be reviewed (or replaced with the newly added predicate) to make sure they work correctly for elements with array values.
    *   Some internal CodeQL usage of the :code:`Annotation` predicates has been adjusted and corrected; this might affect the results of some queries.
    
*   New predicates have been added to the CodeQL class :code:`Annotatable` to support getting declared and associated annotations. As part of that, :code:`hasAnnotation()` has been changed to also consider inherited annotations, to be consistent with :code:`hasAnnotation(string, string)` and :code:`getAnAnnotation()`. The newly added predicate :code:`hasDeclaredAnnotation()` can be used as replacement for the old functionality.
*   New predicates have been added to the CodeQL class :code:`AnnotationType` to simplify getting information about usage of JDK meta-annotations, such as :code:`@Retention`.

Shared Libraries
----------------

Initial Release
~~~~~~~~~~~~~~~

Static Single Assignment (SSA)
""""""""""""""""""""""""""""""

*   Initial release. Extracted common SSA code into a library pack to share code between languages.

Database of Common Typographical Errors
"""""""""""""""""""""""""""""""""""""""

*   Initial release. Share the database of common typographical errors between languages.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.7.1.rst
.. _codeql-cli-2.7.1:

=========================
CodeQL 2.7.1 (2021-11-15)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.7.1 runs a total of 276 security queries when configured with the Default suite (covering 120 CWE). The Extended suite enables an additional 82 queries (covering 31 more CWE). 10 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   Previously, :code:`codeql test run` would fall back to looking for an accompanying :code:`queries.xml` file if it found a :code:`qlpack.yml` that did not declare an extractor to use when extracting a test database.
    This has been removed because the internal use case that neccessitated the fallback are now removed. If you suddenly encounter errors that complain of missing extractor declarations,
    check whether you had a :code:`queries.xml` you were inadvertently relying on.
    
*   When queries are specified by naming a directory to scan for :code:`*.ql` files, subdirectories named :code:`.codeql` will now be ignored.  The new QL packaging support uses subdirectories with this name of various scratch and caching purposes, so they may contain :code:`*.ql` files that are not intended to be directly user-visible.
    
*   When copying dependencies for CodeQL packages into a query pack bundle, :code:`*.ql` files in these dependencies will now be included inside of the query pack's :code:`.codeql` directory.
    
*   The tables printed by :code:`codeql database analyze` to summarize the results of diagnostic and metric queries that were part of the analysis have a new format and contains less (but hopefully more pertinent) information. We recommend against attempting to parse this human-readable output programmatically. Instead, use the
    :code:`runs[].tool.driver.invocations[].toolExecutionNotifications` property in the SARIF output.
    
*   The experimental plumbing command :code:`codeql pack packlist` has a new format for its JSON results. Previously, the results were a list of paths. Now, the results are an object with a single property :code:`paths` that contains the list of paths.
    
*   The internal :code:`qlpacks` directory of the CodeQL bundle available on the
    \ `CodeQL Action releases page <https://github.com/github/codeql-action/releases/>`__ has a new structure. This directory is internal to the CLI and can change without notice in future releases.
    
    The currently-shipped :code:`qlpacks` directory mirrors the structure of `CodeQL package <https://github.blog/changelog/2021-07-28-introducing-the-codeql-package-manager-public-beta/>`__ caches and looks like this:

    ..  code-block:: text
    
        qlpacks
          - codeql
            - {lang}-all
              - {version}
                - qlpack contents
            - {lang}-examples
              - {version}
                - qlpack contents
            - {lang}-queries
              - {version}
                - qlpack contents
            - {lang}-upgrades
              - {version}
                - qlpack contents
            - ... and so on for all languages

Bug Fixes
~~~~~~~~~

*   Fixed a bug where the :code:`paths` and :code:`paths-ignore` properties of a Code Scanning config file specified using :code:`--codescanning-config` were being interpreted the wrong way around.
    
*   Fixed a bug where queries specified using the
    :code:`--codescanning-config` option could not be run after an explicit call to :code:`codeql database finalize`.
    
*   Fixed a bug where :code:`-J` options would erroneously be recognized even after :code:`--` on the command line.
    
*   When running :code:`codeql database analyze` and :code:`codeql database interpret-results` without the :code:`--sarif-group-rules-by-pack` flag,
    the SARIF output did not include baseline lines-of-code counts. This is now fixed.
    
*   Fixed a bug where expansion of query suites would sometimes fail if a query suite in a compiled query pack referenced that pack itself explicitly.

Deprecations
~~~~~~~~~~~~

*   The output formats SARIF v1.0.0 and SARIF v2.0.0 (Committee Specification Draft 1) have been deprecated.  They will be removed in a later version (earliest 2.8.0).  If you need this functionality, please file a public issue against https://github.com/github/codeql-cli-binaries, or open a private ticket with GitHub Support and request an escalation to engineering.
    
*   The :code:`qlpack:` instruction in query suite definitions has been deprecated due to uncertainty about whether it is intended to include *all* the :code:`*.ql` files in the named pack, or only the pack's
    "default query suite".  The behavior of the instruction is determined by whether the named pack declares any default query suite, but this means that a pack *starting* to declare such a suite may break the behavior of existing query suites that reference the pack from outside.
    
    We recommend replacing :code:`qlpack:` by one of

    ..  code-block:: yaml
    
        - queries: '.' # import all *.ql files
          from: some/pack-name
          version: 1.2.3 # optional
        
    or

    ..  code-block:: yaml
    
        - import: path/to/actual/suite.ql # just that suite
          from: some/pack-name
          version: 1.2.3 # optional
        
    A warning will now be printed when a :code:`qlpack:` instruction resolves to a default suite, because that is the case where the effect may not be what the query suite author intended.

New Features
~~~~~~~~~~~~

*   Beta support for database creation on Apple Silicon has been added.
    It depends on the following requirements:

    *   \ `Rosetta 2 <https://developer.apple.com/documentation/apple-silicon/about-the-rosetta-translation-environment>`__ needs to be installed
        
    *   Developer tools need to be installed. CodeQL requires the :code:`lipo`,
        :code:`codesign`, and :code:`install_name_tool` tools to be present.
        
    *   Build systems invoking :code:`csh` may experience `intermittent crashes <https://openradar.appspot.com/radar?id=4936797431791616>`__.

*   :code:`codeql database analyze` can now include query-specific help texts for alerts in the SARIF output (for SARIF v2.1.0 or later). The help text must be located in an :code:`.md` file next to (and with the same basename as) the :code:`.ql` file for each query. Since this can significantly increase SARIF file size, the feature is not enabled by default; give a :code:`--sarif-add-query-help` option to enable it.
    
*   The query metadata validator now knows about queries that produce alert scores, so these queries no longer need to be run with a
    :code:`--no-metadata-verification` flag.
    
*   :code:`codeql database create` and :code:`codeql-finalize` have a new flag
    :code:`--skip-empty` that will cause a language with no extracted source code to be ignored with a warning instead of treated like a fatal error. This can be useful with :code:`--db-cluster` where not all of the languages may exist in the source tree.  It will not be possible to run queries against the skipped database.
    
*   :code:`codeql resolve extractor` and :code:`codeql resolve languages` now support an extended output format :code:`--format=betterjson` wich includes information about each extractor's language-specific options.
    
*   This release introduces rudimentary support for parallelizing database creation by importing unfinished databases (or database clusters) into another unfinished database (or cluster) under creation. This is implemented by the new flag :code:`--additional-dbs` for
    :code:`codeql database finalize`, or the new plumbing command :code:`codeql database import`.
    
*   :code:`codeql database create`, :code:`codeql database index-files`, and :code:`codeql database trace-command` support a `unified syntax for passing language-specific options <https://codeql.github.com/docs/codeql-cli/extractor-options>`__ to the extractor with the new
    :code:`--extractor-option` and :code:`--extractor-options-file` options.
    (The extractors do not make use of this yet, though).

QL Language
~~~~~~~~~~~

*   \ `Set literal expressions <https://codeql.github.com/docs/ql-language-reference/expressions/#set-literal-expressions>`__ can now optionally contain a trailing comma after the last element.
    



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.6.rst
.. _codeql-cli-2.17.6:

==========================
CodeQL 2.17.6 (2024-06-27)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.6 runs a total of 414 security queries when configured with the Default suite (covering 161 CWE). The Extended suite enables an additional 131 queries (covering 35 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Beta support is now available for analyzing C# codebases without needing a working build. To use this, pass the :code:`--build-mode none` option to :code:`codeql database create`.

Improvements
~~~~~~~~~~~~

*   The :code:`--model-packs` option is now publicly available. This option allows commands like :code:`codeql database analyze` to accept a list of model packs that are used to augment the analysis of all queries involved in the analysis.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.3.rst
.. _codeql-cli-2.5.3:

=========================
CodeQL 2.5.3 (2021-04-30)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.3 runs a total of 239 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Ensure the correct URL is generated during :code:`codeql github upload-results` for GitHub Enterprise Server.

New Features
~~~~~~~~~~~~

*   When tracing a C/C++ build, the C compiler entries in compiler-settings must now specify :code:`order compiler,extractor`. The default configuration already does this, so no change is necessary if using the default configuration.
    
*   :code:`codeql database analyze` and :code:`codeql database interpret-results` now report the results of summary metric queries in the
    :code:`<run>.properties.metricResults` property of the SARIF output.
    Summary metric queries describe metrics about the code analyzed by CodeQL. They are identified by the query metadata :code:`@kind metric` and
    :code:`@tag summary`.
    For example, see the `lines of code summary metric query for C++ <https://github.com/github/codeql/blob/main/cpp/ql/src/Summary/LinesOfCode.ql>`__.
    
*   :code:`codeql database analyze` and :code:`codeql database interpret-results` now calculate an
    \ `automation ID <https://docs.oasis-open.org/sarif/sarif/v2.1.0/cs01/sarif-v2.1.0-cs01.html#_Toc16012482>`__ and add it to the resulting SARIF. In SARIF v2.1.0, this field is
    :code:`runs[].automationDetails.id`.  In SARIF v2, this field is
    :code:`runs[].automationLogicalId`. In SARIF v1, this field is
    :code:`runs[].automationId`. By default, this automation ID will be derived from the database language and the operating system of the machine that performed the run. It can be set explicitly using a new
    :code:`--sarif-category` option.
    
*   In query metadata, :code:`@kind alert` and :code:`@kind path-alert` are now recognized as (more accurate) synonyms of :code:`@kind problem` and
    :code:`@kind path-problem`, respectively.
    
*   Diagnostic queries are now permitted by the metadata verifier. They are identified by :code:`@kind diagnostic` metadata. Currently the result patterns of diagnostic queries are not verified. This will change in a future CLI release.
    



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.15.4.rst
.. _codeql-cli-2.15.4:

==========================
CodeQL 2.15.4 (2023-12-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.15.4 runs a total of 401 security queries when configured with the Default suite (covering 159 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Java 21 is now fully supported, including support for new language features such as pattern switches and record patterns.

Improvements
~~~~~~~~~~~~

*   Parallelism in the evaluator has been improved, resulting in faster analysis when running with many threads, particularly for large databases.

Query Packs
-----------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/tainted-format-string-through-global` query has been deleted. This does not lead to a loss of relevant alerts, as the query duplicated a subset of the alerts from :code:`cpp/tainted-format-string`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Modelled additional flow steps to track flow from a :code:`View` call in an MVC controller to the corresponding Razor View (:code:`.cshtml`) file, which may result in additional results for queries such as :code:`cs/web/xss`.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added django URLs to detected "safe" URL patterns in :code:`js/unsafe-external-link`.

Swift
"""""

*   Added additional sinks for the "Uncontrolled format string" (:code:`swift/uncontrolled-format-string`) query. Some of these sinks are heuristic (imprecise) in nature.
*   Added heuristic (imprecise) sinks for the "Database query built from user-controlled sources" (:code:`swift/sql-injection`) query.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/use-of-string-after-lifetime-ends`, to detect calls to :code:`c_str` on strings that will be destroyed immediately.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   A bug has been fixed that meant that value flow through a slice expression was not tracked correctly. Taint flow was tracked correctly.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The diagnostic query :code:`java/diagnostics/successfully-extracted-files`, and therefore the Code Scanning UI measure of scanned Java files, now considers any Java file seen during extraction, even one with some errors, to be extracted / scanned.
*   Switch cases using binding patterns and :code:`case null[, default]` are now supported. Classes :code:`PatternCase` and :code:`NullDefaultCase` are introduced to represent new kinds of case statement.
*   Both switch cases and instanceof expressions using record patterns are now supported. The new class :code:`RecordPatternExpr` is introduced to represent record patterns, and :code:`InstanceOfExpr` gains :code:`getPattern` to replace :code:`getLocalVariableDeclExpr`.
*   The control-flow graph and therefore dominance information regarding switch blocks in statement context but with an expression rule (e.g. :code:`switch(...) { case 1 -> System.out.println("Hello world!") }`) has been fixed. This reduces false positives and negatives from various queries relating to functions featuring such statements.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added models for the :code:`sqlite` and :code:`better-sqlite3` npm packages.
*   TypeScript 5.3 is now supported.

Python
""""""

*   Added support for tarfile extraction filters as defined in `PEP-706 <https://peps.python.org/pep-0706>`__. In particular, calls to :code:`TarFile.extract`, and :code:`TarFile.extractall` are no longer considered to be sinks for the :code:`py/tarslip` query if a sufficiently safe filter is provided.
*   Added modeling of :code:`*args` and :code:`**kwargs` as routed-parameters in request handlers for django/flask/FastAPI/tornado.
*   Added support for type parameters in function and class definitions, as well as the new Python 3.12 type alias statement.
*   Added taint-flow modeling for regular expressions with :code:`re` module from the standard library.

Ruby
""""

*   Improved modeling for :code:`ActiveRecord`\ s :code:`update_all` method

Swift
"""""

*   Extracts Swift's :code:`DiscardStmt` and :code:`MaterizliePackExpr`
*   Expanded and improved flow models for :code:`Set` and :code:`Sequence`.
*   Added imprecise flow sources matching initializers such as :code:`init(contentsOfFile:)`.
*   Extracts :code:`MacroDecl` and some related information

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added an :code:`isPrototyped` predicate to :code:`Function` that holds when the function has a prototype.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.1.rst
.. _codeql-cli-2.5.1:

=========================
CodeQL 2.5.1 (2021-04-19)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.1 runs a total of 239 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE).

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The QL compiler will now reject queries where the query metadata (if present) at the top of the :code:`.ql` file is inconsistent with the output format of the query.  This check can be disabled by giving the :code:`--no-metadata-verification` flag.  (The flag already existed but has not had any effect until now.)

Bug Fixes
~~~~~~~~~

*   Environment variables required for Java extraction are now propagated by the tracer. This may resolve issues with tracing and extraction in the context of certain build systems such as Bazel.
    
*   A number of :code:`--check-CONDITION` options to :code:`codeql database finalize` and :code:`codeql dataset import` designed to look for consistency errors in the intermediate "TRAP" output from extractors erroneously did nothing. They will now actually print warnings if errors are found.  The warnings become fatal errors if the new
    :code:`--fail-on-trap-errors` option is also given.

New Features
~~~~~~~~~~~~

*   :code:`codeql resolve qlref` is a new command that takes in a :code:`.qlref` file for a CodeQL test case and returns the path of the :code:`.ql` file it references.
    
*   :code:`codeql database analyze` and :code:`codeql database interpret-results` have a new :code:`--sarif-group-rules-by-pack` option which will place the SARIF rule object for each query underneath its corresponding query pack in :code:`runs[].tool.extensions`.
    
*   :code:`codeql database finalize` and :code:`codeql dataset import` have a new
    :code:`--fail-on-trap-errors` option that will make database creation fail if extractors produce ill-formatted "TRAP" data for inclusion into a database. This is not enabled by default because some of the existing extractors have minor output bugs that cause the check to fail.
    
*   :code:`codeql database finalize` and :code:`codeql dataset import` have a new
    :code:`--check-undefined-labels` option that enables stricter consistency checks on the "TRAP" output from extractors.

QL Language
~~~~~~~~~~~

*   :code:`super` may now be used unqualified, e.g. :code:`super.predicateName()`,
    when the declaring class has multiple super types, as long as the call itself is unambiguous.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.4.rst
.. _codeql-cli-2.17.4:

==========================
CodeQL 2.17.4 (2024-06-03)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.4 runs a total of 414 security queries when configured with the Default suite (covering 161 CWE). The Extended suite enables an additional 131 queries (covering 35 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   CodeQL package management is now generally available, and all GitHub-produced CodeQL packages have had their version numbers increased to 1.0.0.

Query Packs
-----------

Breaking Changes
~~~~~~~~~~~~~~~~

Java
""""

*   Removed :code:`local` query variants. The results pertaining to local sources can be found using the non-local counterpart query. As an example, the results previously found by :code:`java/unvalidated-url-redirection-local` can be found by :code:`java/unvalidated-url-redirection`, if the :code:`local` threat model is enabled. The removed queries are :code:`java/path-injection-local`, :code:`java/command-line-injection-local`, :code:`java/xss-local`, :code:`java/sql-injection-local`, :code:`java/http-response-splitting-local`, :code:`java/improper-validation-of-array-construction-local`, :code:`java/improper-validation-of-array-index-local`, :code:`java/tainted-format-string-local`, :code:`java/tainted-arithmetic-local`, :code:`java/unvalidated-url-redirection-local`, :code:`java/xxe-local` and :code:`java/tainted-numeric-cast-local`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Use of unique pointer after lifetime ends" query (:code:`cpp/use-of-unique-pointer-after-lifetime-ends`) no longer reports an alert when the pointer is converted to a boolean
*   The "Variable not initialized before use" query (:code:`cpp/not-initialised`) no longer reports an alert on static variables.

Golang
""""""

*   The query :code:`go/incorrect-integer-conversion` has now been restricted to only use flow through value-preserving steps. This reduces false positives, especially around type switches.

Java
""""

*   The alert message for the query "Trust boundary violation" (:code:`java/trust-boundary-violation`) has been updated to include a link to the remote source.
*   The sanitizer of the query :code:`java/zipslip` has been improved to include nodes that are safe due to having certain safe types. This reduces false positives.

Python
""""""

*   Added models of :code:`gradio` PyPI package.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed a bug where very large TypeScript files would cause database creation to crash. Large files over 10MB were already excluded from analysis, but the file size check was not applied to TypeScript files.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Added support for data flow through side-effects on static fields. For example, when a static field containing an array is updated.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   A bug has been fixed which meant that the query :code:`go/incorrect-integer-conversion` did not consider type assertions and type switches which use a defined type whose underlying type is an integer type. This may lead to fewer false positive alerts.
*   A bug has been fixed which meant flow was not followed through some ranged for loops. This may lead to more alerts being found.
*   Added value flow models for the built-in functions :code:`append`, :code:`copy`, :code:`max` and :code:`min` using Models-as-Data. Removed the old-style models for :code:`max` and :code:`min`.

Java
""""

*   JDK version detection based on Gradle projects has been improved. Java extraction using build-modes :code:`autobuild` or :code:`none` is more likely to pick an appropriate JDK version, particularly when the Android Gradle Plugin or Spring Boot Plugin are in use.

JavaScript/TypeScript
"""""""""""""""""""""

*   Additional heuristics for a new sensitive data classification for private information (e.g. credit card numbers) have been added to the shared :code:`SensitiveDataHeuristics.qll` library. This may result in additional results for queries that use sensitive data such as :code:`js/clear-text-storage-sensitive-data` and :code:`js/clear-text-logging`.

Python
""""""

*   The :code:`request` parameter of Flask :code:`SessionInterface.open_session` method is now modeled as a remote flow source.
*   Additional heuristics for a new sensitive data classification for private information (e.g. credit card numbers) have been added to the shared :code:`SensitiveDataHeuristics.qll` library. This may result in additional results for queries that use sensitive data such as :code:`py/clear-text-storage-sensitive-data` and :code:`py/clear-text-logging-sensitive-data`.

Ruby
""""

*   Additional heuristics for a new sensitive data classification for private information (e.g. credit card numbers) have been added to the shared :code:`SensitiveDataHeuristics.qll` library. This may result in additional results for queries that use sensitive data such as :code:`rb/sensitive-get-query`.

New Features
~~~~~~~~~~~~

Python
""""""

*   A Python MaD (Models as Data) row may now contain a dotted path in the :code:`type` column. Like in Ruby, a path to a class will refer to instances of that class. This means that the summary :code:`["foo", "Member[MyClass].Instance.Member[instance_method]", "Argument[0]", "ReturnValue", "value"]` can now be written :code:`["foo.MS_Class", "Member[instance_method]", "Argument[0]", "ReturnValue", "value"]`. To refer to an actual class, one may add a :code:`!` at the end of the path.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The data flow library now adds intermediate nodes when data flows out of a function via a parameter, in order to make path explanations easier to follow. The intermediate nodes have the same location as the underlying parameter, but must be accessed via :code:`PathNode.asParameterReturnNode` instead of :code:`PathNode.asNode`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.7.3.rst
.. _codeql-cli-2.7.3:

=========================
CodeQL 2.7.3 (2021-12-06)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.7.3 runs a total of 288 security queries when configured with the Default suite (covering 124 CWE). The Extended suite enables an additional 85 queries (covering 32 more CWE). 10 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The experimental command-line option :code:`--ml-model-path` that was introduced to support internal experiments has been removed.

Bug Fixes
~~~~~~~~~

*   Editing support (content assist, code navigation, etc.) in files under the :code:`.github` directory will now work properly. This is because files under the :code:`.github` directory will now be indexed and processed by the CodeQL language server. Other hidden directories that start with :code:`.` will remain un-indexed. This affects the vscode-codeql extension and any other IDE extension that uses the CodeQL language server.
    
*   Fixed authentication with GitHub package registries via the
    :code:`GITHUB_TOKEN` environment variable and the :code:`--github-auth-stdin` flag when downloading and publishing packs.
    
*   Fixed an incompatibility with glibc version 2.34 on Linux, where build tracing failed with an error message.
    
*   Fixed a bug where :code:`codeql generate log-summary` could sometimes fail with a :code:`JsonMappingException`.

New Features
~~~~~~~~~~~~

*   The CodeQL CLI for Mac OS now ships with a native Java virtual machine for M1 Macs,
    and this will be used by default where applicable to run the CodeQL engine, thus improving performance.
    \ `Rosetta 2 <https://support.apple.com/en-us/HT211861>`__ is still required as not all components of the CodeQL CLI are natively compiled.
    
*   Commands that execute queries will now exit with status code 34 if certain errors that prevent the evaluation of one or more individual queries are detected. Previously some of these errors would crash the evaluator and exit with status code 100.
    
    (This is currently used for "external predicate not found" errors).

Query Packs
-----------

New Queries
~~~~~~~~~~~

C/C++
"""""

*   A new query :code:`cpp/non-https-url` has been added for C/C++. The query flags uses of :code:`http` URLs that might be better replaced with :code:`https`.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/sensitive-get-query` query has been added. It highlights GET requests that read sensitive information from the query string.
*   The :code:`js/insufficient-key-size` query has been added. It highlights the creation of cryptographic keys with a short key size.
*   The :code:`js/session-fixation` query has been added. It highlights servers that reuse a session after a user has logged in.

Ruby
""""

*   A new query (:code:`rb/request-forgery`) has been added. The query finds HTTP requests made with user-controlled URLs.
*   A new query (:code:`rb/csrf-protection-disabled`) has been added. The query finds cases where cross-site forgery protection is explicitly disabled.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Fixed the query ids of two queries that are meant for manual exploration: :code:`python/count-untrusted-data-external-api` and :code:`python/untrusted-data-to-external-api` have been changed to :code:`py/count-untrusted-data-external-api` and :code:`py/untrusted-data-to-external-api`.

Ruby
""""

*   The precision of "Hard-coded credentials" (:code:`rb/hardcoded-credentials`) has been decreased from "high" to "medium". This query will no longer be run and displayed by default on Code Scanning and LGTM.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Java
""""

*   :code:`CharacterLiteral`\ 's :code:`getCodePointValue` predicate now returns the correct value for UTF-16 surrogates.
*   The :code:`RangeAnalysis` module and the :code:`java/constant-comparison` queries no longer raise false alerts regarding comparisons with Unicode surrogate character literals.
*   The predicate :code:`Method.overrides(Method)` was accidentally transitive. This has been fixed. This fix also affects :code:`Method.overridesOrInstantiates(Method)` and :code:`Method.getASourceOverriddenMethod()`.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Added modeling of :code:`os.stat`, :code:`os.lstat`, :code:`os.statvfs`, :code:`os.fstat`, and :code:`os.fstatvfs`, which are new sinks for the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.
*   Added modeling of the :code:`posixpath`, :code:`ntpath`, and :code:`genericpath` modules for path operations (although these are not supposed to be used), resulting in new sinks for the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.
*   Added modeling of :code:`wsgiref.simple_server` applications, leading to new remote flow sources.
*   Added modeling of :code:`aiopg` for sinks executing SQL.
*   Added modeling of HTTP requests and responses when using :code:`flask_admin` (:code:`Flask-Admin` PyPI package), which leads to additional remote flow sources.
*   Added modeling of the PyPI package :code:`toml`, which provides encoding/decoding of TOML documents, leading to new taint-tracking steps.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   The QL library :code:`semmle.code.cpp.commons.Exclusions` now contains a predicate
    :code:`isFromSystemMacroDefinition` for identifying code that originates from a macro outside the project being analyzed.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.2.rst
.. _codeql-cli-2.11.2:

==========================
CodeQL 2.11.2 (2022-10-25)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.2 runs a total of 357 security queries when configured with the Default suite (covering 150 CWE). The Extended suite enables an additional 111 queries (covering 31 more CWE). 5 security queries have been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   Bundling and publishing a CodeQL pack will no longer include nested CodeQL packs. If you want to include a nested pack in your published pack,
    then you must explicitly include it using the :code:`include` property in the top-level :code:`qlpack.yml` file.
    
    For example, if your package structure looks like this:

    ..  code-block:: text
    
        qlpack.yml
        nested-pack
           ∟ qlpack.yml
             query.ql
        
    then the contents of :code:`nested-pack` will not be included by default within the published package. To include :code:`nested-pack`, add an entry like this to the top level :code:`qlpack.yml` file:

    ..  code-block:: yaml
    
        include:
          - nested-pack/**

Bug Fixes
~~~~~~~~~

*   Using the :code:`--codescanning-config=<file>` option in
    :code:`codeql database init` will now correctly process the :code:`paths` and
    :code:`pathsIgnore` properties of the configuration file in a way that is identical to the behavior of the :code:`codeql-action`. Previously, :code:`paths` or :code:`pathsIgnore` entries that end in :code:`/**` or start with :code:`/`  were incorrectly rejected by the CLI.
    
*   Fixed a bug where the :code:`--compilation-cache` option to
    :code:`codeql pack publish` and :code:`codeql pack create` was being ignored when creating a query pack.  Now, the indicated cache is used when pre-compiling the queries in it.
    
*   Fixed a bug that would make the "Show DIL" command in the VSCode extension display nothing.

Miscellaneous
~~~~~~~~~~~~~

*   Emit a detailed warning if package resolution fails, the legacy
    :code:`--search-path` option is provided, *and* there is at least one referenced pack that does not use legacy package resolution.
    In this case, :code:`--additional-packs` should be used to extend the search to additional directories, instead of :code:`--search-path`.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

Python
""""""

*   Fixed how :code:`flask.request` is modeled as a RemoteFlowSource, such that we show fewer duplicated alert messages for Code Scanning alerts. The import, such as :code:`from flask import request`, will now be shown as the first step in a path explanation.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Unterminated variadic call" (:code:`cpp/unterminated-variadic-call`) query has been tuned to produce fewer false positive results.
*   Fixed false positives from the "Unused static function" (:code:`cpp/unused-static-function`) query in files that had errors during compilation.

Golang
""""""

*   The alert messages of many queries were changed to better follow the style guide and make the messages consistent with other languages.

JavaScript/TypeScript
"""""""""""""""""""""

*   Removed some false positives from the :code:`js/file-system-race` query by requiring that the file-check dominates the file-access.
*   Improved taint tracking through :code:`JSON.stringify` in cases where a tainted value is stored somewhere in the input object.

Python
""""""

*   Added model of :code:`cx_Oracle`, :code:`oracledb`, :code:`phonenixdb` and :code:`pyodbc` PyPI packages as a SQL interface following PEP249, resulting in additional sinks for :code:`py/sql-injection`.
*   Added model of :code:`executemany` calls on PEP-249 compliant database APIs, resulting in additional sinks for :code:`py/sql-injection`.
*   Added model of :code:`pymssql` PyPI package as a SQL interface following PEP249, resulting in additional sinks for :code:`py/sql-injection`.
*   The alert messages of many queries were changed to better follow the style guide and make the messages consistent with other languages.

Ruby
""""

*   HTTP response header and body writes via :code:`ActionDispatch::Response` are now recognized.
*   The :code:`rb/path-injection` query now treats the :code:`file:` argument of the Rails :code:`render` method as a sink.
*   The alert messages of many queries were changed to better follow the style guide and make the messages consistent with other languages.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new medium-precision query, :code:`cpp/comma-before-misleading-indentation`, which detects instances of whitespace that have readability issues.

Java
""""

*   Added a new query, :code:`java/android/incomplete-provider-permissions`, to detect if an Android ContentProvider is not protected with a correct set of permissions.
*   A new query "Uncontrolled data used in content resolution" (:code:`java/androd/unsafe-content-uri-resolution`) has been added. This query finds paths from user-provided data to URI resolution operations in Android's :code:`ContentResolver` without previous validation or sanitization.

Ruby
""""

*   Added a new query, :code:`rb/non-constant-kernel-open`, to detect uses of Kernel.open and related methods with non-constant values.
*   Added a new query, :code:`rb/sensitive-get-query`, to detect cases where sensitive data is read from the query parameters of an HTTP :code:`GET` request.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Added support for common patterns involving :code:`Stream.collect` and common collectors like :code:`Collectors.toList()`.
*   The class :code:`TypeVariable` now also extends :code:`Modifiable`.
*   Added data flow steps for tainted Android intents that are sent to services and receivers.
*   Improved the data flow step for tainted Android intents that are sent to activities so that more cases are covered.

Python
""""""

*   Fixed labels in the API graph pertaining to definitions of subscripts. Previously, these were found by :code:`getMember` rather than :code:`getASubscript`.
*   Added edges for indices of subscripts to the API graph. Now a subscripted API node will have an edge to the API node for the index expression. So if :code:`foo` is matched by API node :code:`A`, then :code:`"key"` in :code:`foo["key"]` will be matched by the API node :code:`A.getIndex()`. This can be used to track the origin of the index.
*   Added member predicate :code:`getSubscriptAt(API::Node index)` to :code:`API::Node`. Like :code:`getASubscript()`, this will return an API node that matches a subscript of the node, but here it will be restricted to subscripts where the index matches the :code:`index` parameter.
*   Added convenience predicate :code:`getSubscript("key")` to obtain a subscript at a specific index, when the index happens to be a statically known string.

Ruby
""""

*   The hashing algorithms from :code:`Digest` and :code:`OpenSSL::Digest` are now recognized and can be flagged by the :code:`rb/weak-cryptographic-algorithm` query.
*   More sources of remote input arising from methods on :code:`ActionDispatch::Request` are now recognized.
*   The response value returned by the :code:`Faraday#run_request` method is now also considered a source of remote input.
*   :code:`ActiveJob::Serializers.deserialize` is considered to be a code execution sink.
*   Calls to :code:`params` in :code:`ActionMailer` classes are now treated as sources of remote user input.
*   Taint flow through :code:`ActionController::Parameters` is tracked more accurately.

Deprecated APIs
~~~~~~~~~~~~~~~

Java
""""

*   Deprecated :code:`ContextStartActivityMethod`. Use :code:`StartActivityMethod` instead.

New Features
~~~~~~~~~~~~

Java
""""

*   Added a new predicate, :code:`hasIncompletePermissions`, in the :code:`AndroidProviderXmlElement` class. This predicate detects if a provider element does not provide both read and write permissions.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.13.0.rst
.. _codeql-cli-2.13.0:

==========================
CodeQL 2.13.0 (2023-04-20)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.13.0 runs a total of 388 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 124 queries (covering 30 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   In :code:`codeql pack add`, the dependency that is added to the :code:`qlpack.yml` file will now allow any version of the pack that is compatible with the specified version (:code:`^version`) in the following cases:

    *   When no version is specified (:code:`codeql pack add codeql/cpp-all`).
    *   When the version is specified as :code:`latest` (:code:`codeql pack add codeql/cpp-all@latest`).
    *   When a single version is specified (:code:`codeql pack add codeql/cpp-all@1.0.0`).
    
    The :code:`^version` dependency allows any version of that pack with no breaking changes since :code:`version`.
    For example, :code:`^1.2.3` would allow versions :code:`1.2.3`, :code:`1.2.5`, and :code:`1.4.0`, but not :code:`2.0.0`, because changing the major version number to :code:`2` indicates a breaking change.
    
    Using :code:`^version` ensures that the added pack is not needlessly constrained to an exact version by default.
    
*   Upper-case variable names are no longer accepted by the QL compiler.
    
    Such variable names have produced a deprecation warning since release 2.9.2 (released 2022-05-16), so QL code that compiles without warnings with a recent release of the CLI should still work.

Deprecations
~~~~~~~~~~~~

*   The possibility to omit :code:`override` annotations on class member predicates that override a base class predicate has been deprecated.
    This is to avoid confusion with shadowing behaviour in the presence of final member predicates.

    ..  code-block:: ql
    
        class Foo extends Base {
          final predicate foo() { ... }
        
          predicate bar() { ... }
        
          predicate baz() { ... }
        }
        
        class Bar extends Foo {
          // This method shadows Foo::foo.
          predicate foo() { ... }
        
          // This used to override Foo::bar with a warning, is now deprecated.
          predicate bar() { ... }
        
          // This correctly overrides Foo::baz
          override predicate baz() { ... }
        }

New Features
~~~~~~~~~~~~

*   :code:`codeql database analyze` and related commands now export file coverage information by default. GHAS customers using CodeQL in third-party CI systems will now see file coverage information on the
    \ `tool status page <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-the-tool-status-page>`__ without needing to modify their CI workflows.

Known Issues
~~~~~~~~~~~~

*   We recommend that customers using the CodeQL CLI in a third party CI system do not upgrade to this release, due to an issue with :code:`codeql github upload-results`. Instead, please use CodeQL 2.12.5, or, when available, CodeQL 2.12.7 or 2.13.1. For more information, see the
    "Known issues" section for CodeQL 2.12.6.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed a bug where a destructuring pattern could not be parsed if it had a property named :code:`get` or :code:`set` with a default value.

Python
""""""

*   Nonlocal variables are excluded from alerts.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The query :code:`cpp/tainted-arithmetic` now also flags possible overflows in arithmetic assignment operations.

C#
""

*   The query :code:`cs/web/debug-binary` now disregards the :code:`debug` attribute in case there is a transformation that removes it.

Golang
""""""

*   The receiver arguments of :code:`net/http.Header.Set` and :code:`.Del` are no longer flagged by query :code:`go/untrusted-data-to-external-api`.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`DisablingCertificateValidation.ql` query has been updated to check :code:`createServer` from :code:`https` for disabled certificate validation.
*   Improved the model of jQuery to account for XSS sinks where the HTML string is provided via a callback. This may lead to more results for the :code:`js/xss` query.
*   The :code:`js/weak-cryptographic-algorithm` query now flags cryptograhic operations using a weak block mode,
    such as AES-ECB.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   The query :code:`cpp/redundant-null-check-simple` has been promoted to Code Scanning. The query finds cases where a pointer is compared to null after it has already been dereferenced. Such comparisons likely indicate a bug at the place where the pointer is dereferenced, or where the pointer is compared to null.

Java
""""

*   The query :code:`java/insecure-ldap-auth` has been promoted from experimental to the main query pack. This query detects transmission of cleartext credentials in LDAP authentication. Insecure LDAP authentication causes sensitive information to be vulnerable to remote attackers. This query was originally `submitted as an experimental query by @luchua-bc <https://github.com/github/codeql/pull/4854>`__

Ruby
""""

*   Added a new experimental query, :code:`rb/server-side-template-injection`, to detect cases where user input may be embedded into a template's code in an unsafe manner.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

C/C++
"""""

*   Fixed some accidental predicate visibility in the backwards-compatible wrapper for data flow configurations. In particular :code:`DataFlow::hasFlowPath`, :code:`DataFlow::hasFlow`, :code:`DataFlow::hasFlowTo`, and :code:`DataFlow::hasFlowToExpr` were accidentally exposed in a single version.

C#
""

*   Fixed some accidental predicate visibility in the backwards-compatible wrapper for data flow configurations. In particular :code:`DataFlow::hasFlowPath`, :code:`DataFlow::hasFlow`, :code:`DataFlow::hasFlowTo`, and :code:`DataFlow::hasFlowToExpr` were accidentally exposed in a single version.

Golang
""""""

*   Fixed some accidental predicate visibility in the backwards-compatible wrapper for data flow configurations. In particular :code:`DataFlow::hasFlowPath`, :code:`DataFlow::hasFlow`, :code:`DataFlow::hasFlowTo`, and :code:`DataFlow::hasFlowToExpr` were accidentally exposed in a single version.

Java
""""

*   Fixed some accidental predicate visibility in the backwards-compatible wrapper for data flow configurations. In particular :code:`DataFlow::hasFlowPath`, :code:`DataFlow::hasFlow`, :code:`DataFlow::hasFlowTo`, and :code:`DataFlow::hasFlowToExpr` were accidentally exposed in a single version.

Python
""""""

*   Fixed some accidental predicate visibility in the backwards-compatible wrapper for data flow configurations. In particular, :code:`DataFlow::hasFlowPath`, :code:`DataFlow::hasFlow`, :code:`DataFlow::hasFlowTo`, and :code:`DataFlow::hasFlowToExpr` were accidentally exposed in a single version.

Ruby
""""

*   Fixed some accidental predicate visibility in the backwards-compatible wrapper for data flow configurations. In particular :code:`DataFlow::hasFlowPath`, :code:`DataFlow::hasFlow`, :code:`DataFlow::hasFlowTo`, and :code:`DataFlow::hasFlowToExpr` were accidentally exposed in a single version.

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The internal :code:`SsaConsistency` module has been moved from :code:`SSAConstruction` to :code:`SSAConsitency`, and the deprecated :code:`SSAConsistency` module has been removed.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 5.0.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`BufferAccess` library (:code:`semmle.code.cpp.security.BufferAccess`) no longer matches buffer accesses inside unevaluated contexts (such as inside :code:`sizeof` or :code:`decltype` expressions). As a result, queries using this library may see fewer false positives.

Java
""""

*   Fixed a bug in the regular expression used to identify sensitive information in :code:`SensitiveActions::getCommonSensitiveInfoRegex`. This may affect the results of the queries :code:`java/android/sensitive-communication`, :code:`java/android/sensitive-keyboard-cache`, and :code:`java/sensitive-log`.
*   Added a summary model for the :code:`java.lang.UnsupportedOperationException(String)` constructor.
*   The filenames embedded in :code:`Compilation.toString()` now use :code:`/` as the path separator on all platforms.
*   Added models for the following packages:

    *   :code:`java.lang`
    *   :code:`java.net`
    *   :code:`java.nio.file`
    *   :code:`java.io`
    *   :code:`java.lang.module`
    *   :code:`org.apache.commons.httpclient.util`
    *   :code:`org.apache.commons.io`
    *   :code:`org.apache.http.client`
    *   :code:`org.eclipse.jetty.client`
    *   :code:`com.google.common.io`
    *   :code:`kotlin.io`
    
*   Added the :code:`TaintedPathQuery.qll` library to provide the :code:`TaintedPathFlow` and :code:`TaintedPathLocalFlow` taint-tracking modules to reason about tainted path vulnerabilities.
*   Added the :code:`ZipSlipQuery.qll` library to provide the :code:`ZipSlipFlow` taint-tracking module to reason about zip-slip vulnerabilities.
*   Added the :code:`InsecureBeanValidationQuery.qll` library to provide the :code:`BeanValidationFlow` taint-tracking module to reason about bean validation vulnerabilities.
*   Added the :code:`XssQuery.qll` library to provide the :code:`XssFlow` taint-tracking module to reason about cross site scripting vulnerabilities.
*   Added the :code:`LdapInjectionQuery.qll` library to provide the :code:`LdapInjectionFlow` taint-tracking module to reason about LDAP injection vulnerabilities.
*   Added the :code:`ResponseSplittingQuery.qll` library to provide the :code:`ResponseSplittingFlow` taint-tracking module to reason about response splitting vulnerabilities.
*   Added the :code:`ExternallyControlledFormatStringQuery.qll` library to provide the :code:`ExternallyControlledFormatStringFlow` taint-tracking module to reason about externally controlled format string vulnerabilities.
*   Improved the handling of addition in the range analysis. This can cause in minor changes to the results produced by :code:`java/index-out-of-bounds` and :code:`java/constant-comparison`.
*   A new models as data sink kind :code:`command-injection` has been added.
*   The queries :code:`java/command-line-injection` and :code:`java/concatenated-command-line` now can be extended using the :code:`command-injection` models as data sink kind.
*   Added more sink and summary dataflow models for the following packages:

    *   :code:`java.net`
    *   :code:`java.nio.file`
    *   :code:`javax.imageio.stream`
    *   :code:`javax.naming`
    *   :code:`javax.servlet`
    *   :code:`org.geogebra.web.full.main`
    *   :code:`hudson`
    *   :code:`hudson.cli`
    *   :code:`hudson.lifecycle`
    *   :code:`hudson.model`
    *   :code:`hudson.scm`
    *   :code:`hudson.util`
    *   :code:`hudson.util.io`
    
*   Added the extensible abstract class :code:`JndiInjectionSanitizer`. Now this class can be extended to add more sanitizers to the :code:`java/jndi-injection` query.
*   Added a summary model for the :code:`nativeSQL` method of the :code:`java.sql.Connection` interface.
*   Added sink and summary dataflow models for the Jenkins and Netty frameworks.
*   The Models as Data syntax for selecting the qualifier has been changed from :code:`-1` to :code:`this` (e.g. :code:`Argument[-1]` is now written as :code:`Argument[this]`).
*   Added sources and flow step models for the Netty framework up to version 4.1.
*   Added more dataflow models for frequently-used JDK APIs.

JavaScript/TypeScript
"""""""""""""""""""""

*   :code:`router.push` and :code:`router.replace` in :code:`Next.js` are now considered as XSS sink.
*   The crypto-js module in :code:`CryptoLibraries.qll` now supports progressive hashing with algo.update().

Python
""""""

*   Added modeling of SQL execution in the packages :code:`sqlite3.dbapi2`, :code:`cassandra-driver`, :code:`aiosqlite`, and the functions :code:`sqlite3.Connection.executescript`\ /\ :code:`sqlite3.Cursor.executescript` and :code:`asyncpg.connection.connect()`.
*   Fixed module resolution so we allow imports of definitions that have had an attribute assigned to it, such as :code:`class Foo; Foo.bar = 42`.

Ruby
""""

*   Control flow graph: the evaluation order of scope expressions and receivers in multiple assignments has been adjusted to match the changes made in Ruby
    3.1 and 3.2.
*   The clear-text storage (:code:`rb/clear-text-storage-sensitive-data`) and logging (:code:`rb/clear-text-logging-sensitive-data`) queries now use built-in flow through hashes, for improved precision. This may result in both new true positives and less false positives.
*   Accesses of :code:`params` in Sinatra applications are now recognized as HTTP input accesses.
*   Data flow is tracked from Sinatra route handlers to ERB files.
*   Data flow is tracked between basic Sinatra filters (those without URL patterns) and their corresponding route handlers.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The single-parameter predicates :code:`ArrayOrVectorAggregateLiteral.getElementExpr` and :code:`ClassAggregateLiteral.getFieldExpr` have been deprecated in favor of :code:`ArrayOrVectorAggregateLiteral.getAnElementExpr` and :code:`ClassAggregateLiteral.getAFieldExpr`.
*   The recently introduced new data flow and taint tracking APIs have had a number of module and predicate renamings. The old APIs remain in place for now.
*   The :code:`SslContextCallAbstractConfig`, :code:`SslContextCallConfig`, :code:`SslContextCallBannedProtocolConfig`, :code:`SslContextCallTls12ProtocolConfig`, :code:`SslContextCallTls13ProtocolConfig`, :code:`SslContextCallTlsProtocolConfig`, :code:`SslContextFlowsToSetOptionConfig`, :code:`SslOptionConfig` dataflow configurations from :code:`BoostorgAsio` have been deprecated. Please use :code:`SslContextCallConfigSig`, :code:`SslContextCallGlobal`, :code:`SslContextCallFlow`, :code:`SslContextCallBannedProtocolFlow`, :code:`SslContextCallTls12ProtocolFlow`, :code:`SslContextCallTls13ProtocolFlow`, :code:`SslContextCallTlsProtocolFlow`, :code:`SslContextFlowsToSetOptionFlow`.

C#
""

*   The recently introduced new data flow and taint tracking APIs have had a number of module and predicate renamings. The old APIs remain in place for now.

Golang
""""""

*   The recently introduced new data flow and taint tracking APIs have had a number of module and predicate renamings. The old APIs remain in place for now.

Java
""""

*   The :code:`execTainted` predicate in :code:`CommandLineQuery.qll` has been deprecated and replaced with the predicate :code:`execIsTainted`.
*   The recently introduced new data flow and taint tracking APIs have had a number of module and predicate renamings. The old APIs remain in place for now.
*   The :code:`WebViewDubuggingQuery` library has been renamed to :code:`WebViewDebuggingQuery` to fix the typo in the file name. :code:`WebViewDubuggingQuery` is now deprecated.

Python
""""""

*   The recently introduced new data flow and taint tracking APIs have had a number of module and predicate renamings. The old APIs remain in place for now.

Ruby
""""

*   The recently introduced new data flow and taint tracking APIs have had a number of module and predicate renamings. The old APIs remain in place for now.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added overridable predicates :code:`getSizeExpr` and :code:`getSizeMult` to the :code:`BufferAccess` class (:code:`semmle.code.cpp.security.BufferAccess.qll`). This makes it possible to model a larger class of buffer reads and writes using the library.

Java
""""

*   Predicates :code:`Compilation.getExpandedArgument` and :code:`Compilation.getAnExpandedArgument` has been added.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.13.1.rst
.. _codeql-cli-2.13.1:

==========================
CodeQL 2.13.1 (2023-05-03)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.13.1 runs a total of 389 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 125 queries (covering 32 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug in :code:`codeql database upload-results` where the subcommand would fail with "A fatal error occurred: Invalid SARIF.", reporting an :code:`InvalidDefinitionException`. This issue occurred when the SARIF file contained certain kinds of diagnostic information.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.7.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixes an issue that would cause TypeScript extraction to hang in rare cases when extracting code containing recursive generic type aliases.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Additional sinks modelling writes to unencrypted local files have been added to :code:`ExternalLocationSink`, used by the :code:`cs/cleartext-storage` and :code:`cs/exposure-of-sensitive-information` queries.

JavaScript/TypeScript
"""""""""""""""""""""

*   Improved the call graph to better handle the case where a function is stored on a plain object and subsequently copied to a new host object via an :code:`extend` call.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   A new query :code:`cpp/double-free` has been added. The query finds possible cases of deallocating the same pointer twice. The precision of the query has been set to "medium".
*   The query :code:`cpp/use-after-free` has been modernized and assigned the precision "medium". The query finds cases of where a pointer is dereferenced after its memory has been deallocated.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The Yaml.qll library was moved into a shared library pack named :code:`codeql/yaml` to make it possible for other languages to re-use it. This change should be backwards compatible for existing JavaScript queries.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   Taking a slice is now considered a sanitizer for :code:`SafeUrlFlow`.

Java
""""

*   Changed some models of Spring's :code:`FileCopyUtils.copy` to be path injection sinks instead of summaries.
*   Added models for the following packages:

    *   java.nio.file
    
*   Added models for `Apache HttpComponents <https://hc.apache.org/>`__ versions 4 and 5.
*   Added sanitizers that recognize line breaks to the query :code:`java/log-injection`.
*   Added new flow steps for :code:`java.util.StringJoiner`.

Python
""""""

*   Added support for querying the contents of YAML files.

Deprecated APIs
~~~~~~~~~~~~~~~

Java
""""

*   The :code:`sensitiveResultReceiver` predicate in :code:`SensitiveResultReceiverQuery.qll` has been deprecated and replaced with :code:`isSensitiveResultReceiver` in order to use the new dataflow API.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

YAML Data Analysis
""""""""""""""""""

*   Initial release. Extracted YAML related code into a library pack to share code between languages.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.3.rst
.. _codeql-cli-2.11.3:

==========================
CodeQL 2.11.3 (2022-11-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.3 runs a total of 358 security queries when configured with the Default suite (covering 150 CWE). The Extended suite enables an additional 111 queries (covering 31 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The :code:`codeql pack ls --format json` deep plumbing command now returns only the :code:`name` and :code:`version` properties for each found pack.

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   :code:`codeql pack download`, :code:`codeql pack install`, and :code:`codeql pack add` will ignore CodeQL packs with pre-release versions, unless the
    :code:`--allow-prerelease` option is passed to the command. This brings these commands into alignment with :code:`codeql pack publish` that will avoid publishing CodeQL packs with pre-release versions unless the
    :code:`--allow-prerelease` option is specified. Pre-release versions have the following format: :code:`X.Y.Z-qualifier` where :code:`X`, :code:`Y`, and :code:`Z` are respectively the major, minor, and patch number. :code:`qualifier` is the pre-release version. For more information about pre-releases, see the
    \ `Semantic Versioning specification <https://semver.org/#spec-item-9>`__.

Deprecations
~~~~~~~~~~~~

*   The :code:`--[no-]fast-compilation` option to :code:`codeql query compile` is now deprecated.

New Features
~~~~~~~~~~~~

*   :code:`codeql resolve files` and :code:`codeql database index-files` have a new
    :code:`--find-any` option, which finds at most one match.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Apache Commons Text that is bundled with the CodeQL CLI has been updated to version 1.10.0. While previous releases shipped with version 1.6 of the library, no part of the CodeQL CLI references the :code:`StringSubstitutor` class that the recently disclosed
    \ `CVE-2022-42889 <https://github.com/advisories/GHSA-599f-7c49-w659>`__ vulnerability applies to. We therefore do not believe that running previous releases of CodeQL exposes users to this vulnerability.
*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.5.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Fixed a bug in :code:`cpp/jsf/av-rule-76` that caused the query to miss results when an implicitly-defined copy constructor or copy assignment operator was generated.

Golang
""""""

*   Query :code:`go/clear-text-logging` now excludes :code:`GetX` methods of protobuf :code:`Message` structs, except where taint is specifically known to belong to the right field. This is to avoid FPs where taint is written to one field and then spuriously read from another.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added sources for user defined path and query parameters in :code:`Next.js`.
*   The alert message of many queries have been changed to better follow the style guide and make the message consistent with other languages.

Ruby
""""

*   The :code:`rb/weak-cryptographic-algorithm` has been updated to no longer report uses of hash functions such as :code:`MD5` and :code:`SHA1` even if they are known to be weak. These hash algorithms are used very often in non-sensitive contexts, making the query too imprecise in practice.

New Queries
~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added a new query, :code:`js/second-order-command-line-injection`, to detect shell commands that may execute arbitrary code when the user has control over
    the arguments to a command-line program.
    This currently flags up unsafe invocations of git and hg.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Fixed bugs in the :code:`FormatLiteral` class that were causing :code:`getMaxConvertedLength` and related predicates to return no results when the format literal was :code:`%e`, :code:`%f` or :code:`%g` and an explicit precision was specified.

Ruby
""""

*   There was a bug in :code:`TaintTracking::localTaint` and :code:`TaintTracking::localTaintStep` such that they only tracked non-value-preserving flow steps. They have been fixed and now also include value-preserving steps.
*   Instantiations using :code:`Faraday::Connection.new` are now recognized as part of :code:`FaradayHttpRequest`\ s, meaning they will be considered as sinks for queries such as :code:`rb/request-forgery`.
*   Taint flow is now tracked through extension methods on :code:`Hash`, :code:`String` and
    :code:`Object` provided by :code:`ActiveSupport`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.7.2.rst
.. _codeql-cli-2.7.2:

=========================
CodeQL 2.7.2 (2021-11-22)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.7.2 runs a total of 278 security queries when configured with the Default suite (covering 124 CWE). The Extended suite enables an additional 85 queries (covering 31 more CWE). 5 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The Java extractor now defaults to extracting all XML documents under 10MB in size, a change from the previous default of only extracting documents with particular well-known names (e.g. :code:`pom.xml`). However,
    if the source tree contains more than 50MB of XML in total, it prints a warning and falls back to the old default behaviour.
    Set the environment variable :code:`LGTM_INDEX_XML_MODE` to :code:`byname` to get the old default behaviour, or :code:`all` to extract all documents under 10MB regardless of total size.
    
*   The experimental command-line option :code:`--native-library-path` that was introduced to support internal experiments has been removed.
    
*   The beta :code:`codeql pack publish` command will now prevent accidental publishing of packages with pre-release version qualifiers. Prerelease versions are those that include a :code:`-` after the major, minor, and patch versions such as :code:`1.2.3-dev`. To avoid this change, use the
    :code:`--allow-prerelease` option.

Bug Fixes
~~~~~~~~~

*   Fixed an issue when using the :code:`--evaluator-log` option where a
    :code:`NullPointerException` could sometimes occur non-deterministically.
    
*   Fixed bugs observed when using indirect build tracing using a CodeQL distribution unpacked to a path containing spaces or on Arch Linux.

New Features
~~~~~~~~~~~~

*   CodeQL databases now contain metadata about how and when they were created. This can be found in the :code:`creationMetadata` field of the
    :code:`codeql-database.yml` file within the CodeQL database directory. More information may be added to this field in future releases.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.5.rst
.. _codeql-cli-2.17.5:

==========================
CodeQL 2.17.5 (2024-06-12)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.5 runs a total of 414 security queries when configured with the Default suite (covering 161 CWE). The Extended suite enables an additional 131 queries (covering 35 more CWE).

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   All the commands that output SARIF will output a minified version to reduce the size.
    The :code:`codeql database analyze`, :code:`codeql database interpret-results`, :code:`codeql generate query-help`, and :code:`codeql bqrs interpret` commands support the option :code:`--no-sarif-minify` to output a pretty printed SARIF file.
    
*   A number of breaking changes have been made to the :code:`semmle-extractor-options` functionality available for C and C++ CodeQL tests.

    *   The Arm, Intel, and CodeWarrior compilers are no longer supported and the
        :code:`--armcc`, :code:`--intel`, :code:`--codewarrior` flags are now ignored, as are all the flags that only applied to those compilers.
    *   The :code:`--threads` and :code:`-main-file-name` options, which did not have any effect on tests, are now ignored. Any specification of these options as part of
        :code:`semmle-extractor-options` should be removed.
    *   Support for :code:`--linker`, all flags that would only invoke the preprocessor,
        and the :code:`/clr` flag have been removed, as those flags would never produce any usable test output.
    *   Support for the :code:`--include_path_environment` flag has been removed. All include paths should directly be specified as part of :code:`semmle-extractor-options`.
    *   Microsoft C/C++ compiler response files specified via :code:`@some_file_name` are now ignored. Instead, all options should directly be specified as part of
        :code:`semmle-extractor-options`.
    *   Support for Microsoft :code:`#import` preprocessor directive has been removed, as support depends on the availability of the Microsoft C/C++ compiler, and availability cannot be guaranteed on all platforms while executing tests.
    *   Support for the Microsoft :code:`/EHa`, :code:`/EHs`, :code:`/GX`, :code:`/GZ`, :code:`/Tc`, :code:`/Tp`, and :code:`/Zl` flags, and all :code:`/RTC` flags have been removed. Any specification of these options as part of :code:`semmle-extractor-options` should be removed.
    *   Support for the Apple-specific :code:`-F` and :code:`-iframework` flags has been removed.
        The :code:`-F` flag can still be used by replacing :code:`-F <directory>` by
        :code:`--edg -F --edg <directory>`. Any occurrence of :code:`-iframework <arg>` should be replaced by :code:`--edg --sys_framework --edg <arg>`.
    *   Support for the :code:`/TC`, :code:`/TP`, and :code:`-x` flags has been removed. Please ensure all C, respectively C++, source files have a :code:`.c`, respectively :code:`.cpp`,
        extension.
    *   The :code:`--build_error_dir`, :code:`-db`, :code:`--edg_base_dir`, :code:`--error_limit`,
        :code:`--src_archive`, :code:`--trapfolder`, and :code:`--variadic_macros` flags are now ignored.
    
    The above changes do not affect the creation of databases through the CodeQL CLI,
    or when calling the C/C++ extractor directly with the :code:`--mimic` or :code:`--linker` flags.
    Similar functionality continues to be supported in those scenarios, except for CodeWarrior and the :code:`--edg_base_dir`, :code:`--include_path_environment`, :code:`/Tc`, and :code:`/Tp` flags, which were never supported.

Improvements
~~~~~~~~~~~~

*   :code:`codeql generate log-summary` now reports completed pipeline runs that are part of an incomplete recursive predicate.

Miscellaneous
~~~~~~~~~~~~~

*   The OWASP Java HTML Sanitizer library used by the CodeQL CLI for internal documentation generation commands has been updated to version
    \ `20240325.1 <https://github.com/OWASP/java-html-sanitizer/releases/tag/release-20240325.1>`__.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/dangerous-function-overflow` no longer produces a false positive alert when the :code:`gets` function does not have exactly one parameter.

C#
""

*   .NET 8 Runtime models have been updated based on the newest version of the model generator. Furthermore, the database sources have been changed slightly to reduce result multiplicity.

Java
""""

*   The query :code:`java/spring-disabled-csrf-protection` detects disabling CSRF via :code:`ServerHttpSecurity$CsrfSpec::disable`.
*   Added more :code:`java.io.File`\ -related sinks to the path injection query.

Python
""""""

*   Added models for :code:`opml` library.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The precision of virtual dispatch has been improved. This increases precision in general for all data flow queries.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   A partial model for the :code:`Boost.Asio` network library has been added. This includes sources, sinks and summaries for certain functions in :code:`Boost.Asio`, such as :code:`read_until` and :code:`write`.

Java
""""

*   Support for Eclipse Compiler for Java (ecj) has been fixed to work with (a) runs that don't pass :code:`-noExit` and (b) runs that use post-Java-9 command-line arguments.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Data models can now be added with data extensions. In this way source, sink and summary models can be added in extension :code:`.model.yml` files, rather than by writing classes in QL code. New models should be added in the :code:`lib/ext` folder.

Golang
""""""

*   When writing models-as-data models, the receiver is now referred to as :code:`Argument[receiver]` rather than :code:`Argument[-1]`.
*   Neutral models are now supported. They have no effect except that a manual neutral summary model will stop a generated summary model from having any effect.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.0.rst
.. _codeql-cli-2.5.0:

=========================
CodeQL 2.5.0 (2021-03-26)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.0 runs a total of 239 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   By default, :code:`codeql test` now performs additional compiler checks when extracting test code written in Java.
    Existing Java tests that previously passed may therefore fail due to this change, if they do not compile using the :code:`javac` compiler.
    To allow time to migrate existing tests, the new behavior can be disabled by setting the environment variable
    :code:`CODEQL_EXTRACTOR_JAVA_FLOW_CHECKS=false`.

New Features
~~~~~~~~~~~~

*   Log files that contain output from build processes will now prefix it with :code:`[build-stdout]` and :code:`[build-stderr]` instead of :code:`[build]` and :code:`[build-err]`.  In particular the latter sometimes caused confusion.

QL Language
~~~~~~~~~~~

*   The QL language now recognizes new :code:`pragma[only_bind_into](...)` and
    :code:`pragma[only_bind_out](...)` annotations on expressions. Advanced users may use these annotations to provide hints to the compiler to influence binding behavior and thus indirectly performance.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.15.3.rst
.. _codeql-cli-2.15.3:

==========================
CodeQL 2.15.3 (2023-11-22)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.15.3 runs a total of 401 security queries when configured with the Default suite (covering 158 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed an internal error in the compiler when arguments to the :code:`codePointCount` string primitive were not bound.
*   Fixed a bug where :code:`codeql database finalize` would fail if a database under construction was moved between machines between :code:`codeql database init` and :code:`codeql database finalize`.
    This should now work, as long as both commands are run by the same *release* of the CodeQL CLI and the extractors used are the ones bundled with the CLI.
*   Fixed a bug where :code:`codeql database run-queries` would fail in some circumstances when the database path included an :code:`@`.

New Features
~~~~~~~~~~~~

*   :code:`codeql database analyze` now defaults to include markdown query help for all custom queries with help files available. To change the default behaviour you can pass the new flag :code:`--sarif-include-query-help`, which provides the options :code:`always` (which includes query help for all queries), :code:`custom_queries_only` (the default) and :code:`never` (which does not include query help for any query). The existing flag
    :code:`--sarif-add-query-help` has been deprecated and will be removed in a future release.
*   The new (advanced) command-line option :code:`--[no-]linkage-aware-import` disables the linkage-awareness phase of :code:`codeql dataset import`, as a quick fix (at the expense of database completeness) for C++ projects where this part of database creation consumes too much memory. This option is available in the commands :code:`database create`,
    :code:`database finalize`, :code:`database import`, :code:`dataset import`, :code:`test extract`, and
    :code:`test run`.
*   The CodeQL language server now provides basic support for Rename, and you can now use the Rename Symbol functionality in Visual Studio Code for CodeQL. The current Rename support is less a refactoring tool and more a labor-saving device. You may have to perform some manual edits after using Rename, but it should still be faster and less work than renaming a symbol manually.

Improvements
~~~~~~~~~~~~

*   The Find References feature in the CodeQL language server now supports all CodeQL identifiers and offers improved performance compared to CodeQL CLI 2.14 releases.
*   The compiler generates shorter human-readable DIL and RA relation names. Due to use of an extended character set, full VS Code support for short relation names requires VS Code extension 1.9.4 or newer.
*   :code:`codeql database create` and :code:`codeql database finalize` now log more diagnostic information during database finalization, including the size of each relation, their total size, and the rate at which they were written to disk.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/uninitialized-local` query has been improved to produce fewer false positives.

C#
""

*   CIL extraction is now disabled by default. It is still possible to turn on CIL extraction by setting the :code:`cil` extractor option to :code:`true` or by setting the environment variable :code:`$CODEQL_EXTRACTOR_CSHARP_OPTION_CIL` to :code:`true`. This is the first step towards sun-setting the CIL extractor entirely.

Java
""""

*   The query :code:`java/unsafe-deserialization` has been improved to detect insecure calls to :code:`ObjectMessage.getObject` in JMS.

Python
""""""

*   Added modeling of more :code:`FileSystemAccess` in packages :code:`cherrypy`, :code:`aiofile`, :code:`aiofiles`, :code:`anyio`, :code:`sanic`, :code:`starlette`, :code:`baize`, and :code:`io`. This will mainly affect the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.

Swift
"""""

*   Added additional sinks for the "Uncontrolled data used in path expression" (:code:`swift/path-injection`) query. Some of these sinks are heuristic (imprecise) in nature.
*   Fixed an issue where some Realm database sinks were not being recognized for the :code:`swift/cleartext-storage-database` query.

New Queries
~~~~~~~~~~~

Swift
"""""

*   Added new query "System command built from user-controlled sources" (:code:`swift/command-line-injection`) for Swift. This query detects system commands built from user-controlled sources without sufficient validation. The query was previously `contributed to the 'experimental' directory by @maikypedia <https://github.com/github/codeql/pull/13726>`__ but will now run by default for all code scanning users.
*   Added a new query "Missing regular expression anchor" (:code:`swift/missing-regexp-anchor`) for Swift. This query detects regular expressions without anchors that can be vulnerable to bypassing.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Lower the security severity of log-injection to medium.
*   Increase the security severity of XSS to high.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   A bug has been fixed that meant that value flow through an array was not tracked correctly in some circumstances. Taint flow was tracked correctly.

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The expressions :code:`AssignPointerAddExpr` and :code:`AssignPointerSubExpr` are no longer subtypes of :code:`AssignBitwiseOperation`.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Swift
"""""

*   Added Swift 5.9.1 support
*   New AST node is extracted: :code:`SingleValueStmtExpr`

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Returning stack-allocated memory" (:code:`cpp/return-stack-allocated-memory`) query now also detects returning stack-allocated memory allocated by calls to :code:`alloca`, :code:`strdupa`, and :code:`strndupa`.
*   Added models for :code:`strlcpy` and :code:`strlcat`.
*   Added models for the :code:`sprintf` variants from the :code:`StrSafe.h` header.
*   Added SQL API models for :code:`ODBC`.
*   Added taint models for :code:`realloc` and related functions.

C#
""

*   The predicate :code:`UnboundGeneric::getName` now prints the number of type parameters as a ```N`` suffix, instead of a :code:`<,...,>` suffix. For example, the unbound generic type
    :code:`System.Collections.Generic.IList<T>` is printed as ``IList`1`` instead of :code:`IList<>`.
    
*   The predicates :code:`hasQualifiedName`, :code:`getQualifiedName`, and :code:`getQualifiedNameWithTypes` have been deprecated, and are instead replaced by :code:`hasFullyQualifiedName`, :code:`getFullyQualifiedName`, and :code:`getFullyQualifiedNameWithTypes`, respectively. The new predicates use the same format for unbound generic types as mentioned above.
    
*   These changes also affect models-as-data rows that refer to a field or a property belonging to a generic type. For example, instead of writing

    ..  code-block:: yaml
    
        extensions:
          - addsTo:
              pack: codeql/csharp-all
              extensible: summaryModel
              data:
                - ["System.Collections.Generic", "Dictionary<TKey,TValue>", False, "Add", "(System.Collections.Generic.KeyValuePair<TKey,TValue>)", "", "Argument[0].Property[System.Collections.Generic.KeyValuePair<,>.Key]", "Argument[this].Element.Property[System.Collections.Generic.KeyValuePair<,>.Key]", "value", "manual"]

    one now writes

    ..  code-block:: yaml
    
        extensions:
          - addsTo:
              pack: codeql/csharp-all
              extensible: summaryModel
              data:
                - ["System.Collections.Generic", "Dictionary<TKey,TValue>", False, "Add", "(System.Collections.Generic.KeyValuePair<TKey,TValue>)", "", "Argument[0].Property[System.Collections.Generic.KeyValuePair`2.Key]", "Argument[this].Element.Property[System.Collections.Generic.KeyValuePair`2.Key]", "value", "manual"]

*   The models-as-data format for types and methods with type parameters has been changed to include the names of the type parameters. For example, instead of writing

    ..  code-block:: yaml
    
        extensions:
          - addsTo:
              pack: codeql/csharp-all
              extensible: summaryModel
              data:
                - ["System.Collections.Generic", "IList<>", True, "Insert", "(System.Int32,T)", "", "Argument[1]", "Argument[this].Element", "value", "manual"]
                - ["System.Linq", "Enumerable", False, "Select<,>", "(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,System.Int32,TResult>)", "", "Argument[0].Element", "Argument[1].Parameter[0]", "value", "manual"]

    one now writes

    ..  code-block:: yaml
    
        extensions:
          - addsTo:
              pack: codeql/csharp-all
              extensible: summaryModel
              data:
                - ["System.Collections.Generic", "IList<T>", True, "Insert", "(System.Int32,T)", "", "Argument[1]", "Argument[this].Element", "value", "manual"]
                - ["System.Linq", "Enumerable", False, "Select<TSource,TResult>", "(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,System.Int32,TResult>)", "", "Argument[0].Element", "Argument[1].Parameter[0]", "value", "manual"]

Golang
""""""

*   Added the `gin-contrib/cors <https://github.com/gin-contrib/cors>`__ library to the experimental query "CORS misconfiguration" (:code:`go/cors-misconfiguration`).

Java
""""

*   The types :code:`java.util.SequencedCollection`, :code:`SequencedSet` and :code:`SequencedMap`, as well as the related :code:`Collections.unmodifiableSequenced*` methods are now modelled. This means alerts may be raised relating to data flow through these types and methods.

Python
""""""

*   Added basic flow for attributes defined on classes, when the attribute lookup is on a direct reference to that class (so not instance, cls parameter, or self parameter). Example: class definition :code:`class Foo: my_tuples = (dangerous, safe)` and usage :code:`SINK(Foo.my_tuples[0])`.

Swift
"""""

*   AST and types related to parameter packs are now extracted
*   Added taint flow models for the :code:`NSString.enumerate*` methods.
*   Generalized the data flow model for subscript writes (:code:`a[index] = b`) so that it applies to subscripts on all kinds of objects, not just arrays.
*   Fixed a bug where some flow sinks at field accesses were not being correctly identified.
*   Added indexed :code:`getVariable` to :code:`CaptureListExpr`, improving its AST printing and data flow.
*   Added flow models for :code:`String` methods involving closures such as :code:`String.withUTF8(_:)`.
*   AST and types related to move semantics (:code:`copy`, :code:`consume`, :code:`_borrow`) are now extracted

Deprecated APIs
~~~~~~~~~~~~~~~

Java
""""

*   In :code:`SensitiveApi.qll`, :code:`javaApiCallablePasswordParam`, :code:`javaApiCallableUsernameParam`, :code:`javaApiCallableCryptoKeyParam`, and :code:`otherApiCallableCredentialParam` predicates have been deprecated. They have been replaced with a new class :code:`CredentialsSinkNode` and its child classes :code:`PasswordSink`, :code:`UsernameSink`, and :code:`CryptoKeySink`. The predicates have been changed to using the new classes, so there may be minor changes in results relying on these predicates.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.4.rst
.. _codeql-cli-2.5.4:

=========================
CodeQL 2.5.4 (2021-05-03)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.4 runs a total of 239 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE).

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.1.rst
.. _codeql-cli-2.17.1:

==========================
CodeQL 2.17.1 (2024-04-24)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.1 runs a total of 412 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 130 queries (covering 34 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Deprecations
~~~~~~~~~~~~

*   The :code:`--mode` option and :code:`-m` alias to :code:`codeql database create`,
    :code:`codeql database cleanup`, and :code:`codeql dataset cleanup` has been deprecated. Instead, use the new :code:`--cache-cleanup` option, which has identical behavior.

Improvements
~~~~~~~~~~~~

*   Improved the diagnostic message produced when no code is processed when creating a database. If a build mode was specified using
    :code:`--build-mode`, the message is now tailored to your build mode.

Miscellaneous
~~~~~~~~~~~~~

*   The :code:`scc` tool used by the CodeQL CLI to calculate source code baseline information has been updated to version `3.2.0 <https://github.com/boyter/scc/releases/tag/v3.2.0>`__.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The :code:`java/unknown-javadoc-parameter` now accepts :code:`@param` tags that apply to the parameters of a record.

JavaScript/TypeScript
"""""""""""""""""""""

*   :code:`API::Node#getInstance()` now includes instances of subclasses, include transitive subclasses.
    The same changes applies to uses of the :code:`Instance` token in data extensions.

New Queries
~~~~~~~~~~~

Ruby
""""

*   Added a new query, :code:`rb/insecure-mass-assignment`, for finding instances of mass assignment operations accepting arbitrary parameters from remote user input.
*   Added a new query, :code:`rb/csrf-protection-not-enabled`, to detect cases where Cross-Site Request Forgery protection is not enabled in Ruby on Rails controllers.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Extracting suppress nullable warning expressions did not work when applied directly to a method call (like :code:`System.Console.Readline()!`). This has been fixed.

Golang
""""""

*   Data flow through variables declared in statements of the form :code:`x := y.(type)` at the beginning of type switches has been fixed, which may result in more alerts.
*   Added strings.ReplaceAll, http.ParseMultipartForm sanitizers and remove path sanitizer.

Java
""""

*   About 6,700 summary models and 6,800 neutral summary models for the JDK that were generated using data flow have been added. This may lead to new alerts being reported.

Python
""""""

*   Improved the type-tracking capabilities (and therefore also API graphs) to allow tracking items in tuples and dictionaries.

Shared Libraries
----------------

New Features
~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The :code:`PathGraph` result of a data flow computation has been augmented with model provenance information for each of the flow steps. Any qltests that include the edges relation in their output (for example, :code:`.qlref`\ s that reference path-problem queries) will need to be have their expected output updated accordingly.

Type-flow Analysis
""""""""""""""""""

*   Initial release. Adds a library to implement type-flow analysis.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.7.6.rst
.. _codeql-cli-2.7.6:

=========================
CodeQL 2.7.6 (2022-01-24)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.7.6 runs a total of 289 security queries when configured with the Default suite (covering 127 CWE). The Extended suite enables an additional 88 queries (covering 31 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   A bug where creation of a CodeQL database could sometimes fail with a :code:`NegativeArraySizeException` has now been fixed.

New Features
~~~~~~~~~~~~

*   The CLI and evaluator contain a number of new features in support of internal machine learning experiments. This includes an experimental
    :code:`resolve ml-models` subcommand and new :code:`mlModels` metadata in pack definition files. As these new features are not yet ready for general use, they should be ignored by external CodeQL users.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.13.5.rst
.. _codeql-cli-2.13.5:

==========================
CodeQL 2.13.5 (2023-07-05)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.13.5 runs a total of 390 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 125 queries (covering 32 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   The Swift extractor now supports Swift 5.8.1.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.13.4.rst
.. _codeql-cli-2.13.4:

==========================
CodeQL 2.13.4 (2023-06-19)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.13.4 runs a total of 390 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 125 queries (covering 32 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed an issue where indirect build tracing did not work in Azure DevOps pipeline jobs in Windows containers. To use indirect build tracing in such environments, ensure both the :code:`--begin-tracing` and
    :code:`--trace-process-name=CExecSvc.exe` arguments are passed to
    :code:`codeql database init`.
*   Improved the error message for the :code:`codeql pack create` command when the pack being published has a dependency with no scope in its name.

New Features
~~~~~~~~~~~~

*   Temporary files and folders created by the CodeQL CLI will now be cleaned up when each CLI command (and its internal JVM) shuts down normally.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

Python
""""""

*   The display name (:code:`@name`) of the :code:`py/unsafe-deserialization` query has been updated in favor of consistency with other languages.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The :code:`java/summary/lines-of-code` query now only counts lines of Java code. The new :code:`java/summary/lines-of-code-kotlin` counts lines of Kotlin code.

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed an issue where calls to a method named :code:`search` would lead to false positive alerts related to regular expressions.
    This happened when the call was incorrectly seen as a call to :code:`String.prototype.search`, since this function converts its first argument to a regular expression. The analysis is now more restrictive about when to treat :code:`search` calls as regular expression sinks.

Ruby
""""

*   Fixed a bug that would occur when an :code:`initialize` method returns :code:`self` or one of its parameters.
    In such cases, the corresponding calls to :code:`new` would be associated with an incorrect return type.
    This could result in inaccurate call target resolution and cause false positive alerts.
*   Fixed an issue where calls to :code:`delete` or :code:`assoc` with a constant-valued argument would be analyzed imprecisely,
    as if the argument value was not a known constant.

Swift
"""""

*   Fixed some false positive results from the :code:`swift/string-length-conflation` query, caused by imprecise sinks.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/overrun-write`, to detect buffer overflows in C-style functions that manipulate buffers.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Swift
"""""

*   Fixed a number of inconsistencies in the abstract syntax tree (AST) and in the control-flow graph (CFG). This may lead to more results in queries that use these libraries, or libraries that depend on them (such as dataflow).

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The extractor has been changed to run after the traced compiler call. This allows inspecting compiler generated files, such as the output of source generators. With this change, :code:`.cshtml` files and their generated :code:`.cshtml.g.cs` counterparts are extracted on dotnet 6 and above.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 5.1.

Swift
"""""

*   Incorporated the cross-language :code:`SensitiveDataHeuristics.qll` heuristics library into the Swift :code:`SensitiveExprs.qll` library. This adds a number of new heuristics enhancing detection from the library.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Deleted the deprecated :code:`hasCopyConstructor` predicate from the :code:`Class` class in :code:`Class.qll`.
*   Deleted many deprecated predicates and classes with uppercase :code:`AST`, :code:`SSA`, :code:`CFG`, :code:`API`, etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`CodeDuplication.qll` file.

C#
""

*   C#: Analysis of the :code:`dotnet test` command supplied with a :code:`dll` or :code:`exe` file as argument no longer fails due to the addition of an erroneous :code:`-p:SharedCompilation=false` argument.
*   Deleted the deprecated :code:`WebConfigXML`, :code:`ConfigurationXMLElement`, :code:`LocationXMLElement`, :code:`SystemWebXMLElement`, :code:`SystemWebServerXMLElement`, :code:`CustomErrorsXMLElement`, and :code:`HttpRuntimeXMLElement` classes from :code:`WebConfig.qll`. The non-deprecated names with PascalCased Xml suffixes should be used instead.
*   Deleted the deprecated :code:`Record` class from both :code:`Types.qll` and :code:`Type.qll`.
*   Deleted the deprecated :code:`StructuralComparisonConfiguration` class from :code:`StructuralComparison.qll`, use :code:`sameGvn` instead.
*   Deleted the deprecated :code:`isParameterOf` predicate from the :code:`ParameterNode` class.
*   Deleted the deprecated :code:`SafeExternalAPICallable`, :code:`ExternalAPIDataNode`, :code:`UntrustedDataToExternalAPIConfig`, :code:`UntrustedExternalAPIDataNode`, and :code:`ExternalAPIUsedWithUntrustedData` classes from :code:`ExternalAPIsQuery.qll`. The non-deprecated names with PascalCased Api suffixes should be used instead.
*   Updated the following C# sink kind names. Any custom data extensions that use these sink kinds will need to be updated accordingly in order to continue working.

    *   :code:`code` to :code:`code-injection`
    *   :code:`sql` to :code:`sql-injection`
    *   :code:`html` to :code:`html-injection`
    *   :code:`xss` to :code:`js-injection`
    *   :code:`remote` to :code:`file-content-store`

Java
""""

*   Added flow through the block arguments of :code:`kotlin.io.use` and :code:`kotlin.with`.
    
*   Added models for the following packages:

    *   com.alibaba.druid.sql
    *   com.fasterxml.jackson.databind
    *   com.jcraft.jsch
    *   io.netty.handler.ssl
    *   okhttp3
    *   org.antlr.runtime
    *   org.fusesource.leveldbjni
    *   org.influxdb
    *   org.springframework.core.io
    *   org.yaml.snakeyaml
    
*   Deleted the deprecated :code:`getRHS` predicate from the :code:`LValue` class, use :code:`getRhs` instead.
    
*   Deleted the deprecated :code:`getCFGNode` predicate from the :code:`SsaVariable` class, use :code:`getCfgNode` instead.
    
*   Deleted many deprecated predicates and classes with uppercase :code:`XML`, :code:`JSON`, :code:`URL`, :code:`API`, etc. in their names. Use the PascalCased versions instead.
    
*   Added models for the following packages:

    *   java.lang
    *   java.nio.file
    
*   Added dataflow models for the Gson deserialization library.
    
*   Added models for the following packages:

    *   okhttp3
    
*   Added more dataflow models for the Play Framework.
    
*   Modified the models related to :code:`java.nio.file.Files.copy` so that generic :code:`[Input|Output]Stream` arguments are not considered file-related sinks.
    
*   Dataflow analysis has a new flow step through constructors of transitive subtypes of :code:`java.io.InputStream` that wrap an underlying data source. Previously, the step only existed for direct subtypes of :code:`java.io.InputStream`.
    
*   Path creation sinks modeled in :code:`PathCreation.qll` have been added to the models-as-data sink kind :code:`path-injection`.
    
*   Updated the regular expression in the :code:`HostnameSanitizer` sanitizer in the :code:`semmle.code.java.security.RequestForgery` library to better detect strings prefixed with a hostname.
    
*   Changed the :code:`android-widget` Java source kind to :code:`remote`. Any custom data extensions that use the :code:`android-widget` source kind will need to be updated accordingly in order to continue working.
    
*   Updated the following Java sink kind names. Any custom data extensions will need to be updated accordingly in order to continue working.

    *   :code:`sql` to :code:`sql-injection`
    *   :code:`url-redirect` to :code:`url-redirection`
    *   :code:`xpath` to :code:`xpath-injection`
    *   :code:`ssti` to :code:`template-injection`
    *   :code:`logging` to :code:`log-injection`
    *   :code:`groovy` to :code:`groovy-injection`
    *   :code:`jexl` to :code:`jexl-injection`
    *   :code:`mvel` to :code:`mvel-injection`
    *   :code:`xslt` to :code:`xslt-injection`
    *   :code:`ldap` to :code:`ldap-injection`
    *   :code:`pending-intent-sent` to :code:`pending-intents`
    *   :code:`intent-start` to :code:`intent-redirection`
    *   :code:`set-hostname-verifier` to :code:`hostname-verification`
    *   :code:`header-splitting` to :code:`response-splitting`
    *   :code:`xss` to :code:`html-injection` and :code:`js-injection`
    *   :code:`write-file` to :code:`file-system-store`
    *   :code:`create-file` and :code:`read-file` to :code:`path-injection`
    *   :code:`open-url` and :code:`jdbc-url` to :code:`request-forgery`

JavaScript/TypeScript
"""""""""""""""""""""

*   Deleted many deprecated predicates and classes with uppercase :code:`XML`, :code:`JSON`, :code:`URL`, :code:`API`, etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`localTaintStep` predicate from :code:`DataFlow.qll`.
*   Deleted the deprecated :code:`stringStep`, and :code:`localTaintStep` predicates from :code:`TaintTracking.qll`.
*   Deleted many modules that started with a lowercase letter. Use the versions that start with an uppercase letter instead.
*   Deleted the deprecated :code:`HtmlInjectionConfiguration` and :code:`JQueryHtmlOrSelectorInjectionConfiguration` classes from :code:`DomBasedXssQuery.qll`, use :code:`Configuration` instead.
*   Deleted the deprecated :code:`DefiningIdentifier` class and the :code:`Definitions.qll` file it was in. Use :code:`SsaDefinition` instead.
*   Deleted the deprecated :code:`definitionReaches`, :code:`localDefinitionReaches`, :code:`getAPseudoDefinitionInput`, :code:`nextDefAfter`, and :code:`localDefinitionOverwrites` predicates from :code:`DefUse.qll`.
*   Updated the following JavaScript sink kind names. Any custom data extensions that use these sink kinds will need to be updated accordingly in order to continue working.

    *   :code:`command-line-injection` to :code:`command-injection`
    *   :code:`credentials[kind]` to :code:`credentials-kind`
    
*   Added a support of sub modules in :code:`node_modules`.

Ruby
""""

*   Deleted many deprecated predicates and classes with uppercase :code:`URL`, :code:`XSS`, etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`getValueText` predicate from the :code:`Expr`, :code:`StringComponent`, and :code:`ExprCfgNode` classes. Use :code:`getConstantValue` instead.
*   Deleted the deprecated :code:`VariableReferencePattern` class, use :code:`ReferencePattern` instead.
*   Deleted all deprecated aliases in :code:`StandardLibrary.qll`, use :code:`codeql.ruby.frameworks.Core` and :code:`codeql.ruby.frameworks.Stdlib` instead.
*   Support for the :code:`sequel` gem has been added. Method calls that execute queries against a database that may be vulnerable to injection attacks will now be recognized.
*   Support for the :code:`mysql2` gem has been added. Method calls that execute queries against an MySQL database that may be vulnerable to injection attacks will now be recognized.
*   Support for the :code:`pg` gem has been added. Method calls that execute queries against a PostgreSQL database that may be vulnerable to injection attacks will now be recognized.

Swift
"""""

*   Some models for the :code:`Data` class have been generalized to :code:`DataProtocol` so that they apply more widely.

New Features
~~~~~~~~~~~~

Java
""""

*   Kotlin versions up to 1.9.0 are now supported.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.6.rst
.. _codeql-cli-2.11.6:

==========================
CodeQL 2.11.6 (2022-12-13)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.6 runs a total of 361 security queries when configured with the Default suite (covering 150 CWE). The Extended suite enables an additional 112 queries (covering 32 more CWE).

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   Java and Kotlin analyses in this release of the CLI and all earlier releases are incompatible with Kotlin 1.7.30 and later. To prevent code scanning alerts being spuriously dismissed, Java and Kotlin analyses will now fail when using Kotlin 1.7.30 or later.
    
    If you are unable to use Kotlin 1.7.29 or earlier, you can disable Kotlin support by setting
    :code:`CODEQL_EXTRACTOR_JAVA_AGENT_DISABLE_KOTLIN` to :code:`true` in the environment.

Bug Fixes
~~~~~~~~~

*   Fixed a bug where it was not possible to run queries in CodeQL query packs for C# that use the legacy :code:`libraryPathDependencies` property in their :code:`qlpack.yml` file. The associated error message complained about undefined extensional predicates.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Kotlin extraction will now fail if the Kotlin version in use is at least 1.7.30. This is to ensure using an as-yet-unsupported version is noticable, rather than silently failing to extract Kotlin code and therefore producing false-negative results.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.0.rst
.. _codeql-cli-2.17.0:

==========================
CodeQL 2.17.0 (2024-04-04)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.0 runs a total of 410 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 130 queries (covering 34 more CWE).

CodeQL CLI
----------

Deprecations
~~~~~~~~~~~~

*   The :code:`--[no-]analysis-summary-v2` and :code:`--[no-]new-analysis-summary` options that were used to enable (or disable) improved summary information printed at the end of a :code:`codeql database analyze` invocation are no longer supported.
    Improved summary information is now enabled for all invocations.
*   Support for overwriting default CodeQL SARIF run properties using the
    :code:`--sarif-run-property` command line option has been removed. This removes the ability to overwrite the :code:`semmle.formatSpecifier`, :code:`metricResults`, and
    :code:`codeqlConfigSummary` properties in the SARIF run file.

Improvements
~~~~~~~~~~~~

*   TRAP import (a part of :code:`codeql database create` and :code:`codeql database finalize`)
    now performs better in low-memory situations. (Put another way, it now needs less RAM to achieve the same performance as before.)
    
*   The worst-case performance of transitive closure computation (using the :code:`+` or :code:`*` postfix operators or the :code:`fastTC` higher-order primitive in QL) has been greatly improved.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is used to run the CodeQL CLI has been updated to version 21.0.2.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The :code:`Stored` variants of some queries (:code:`cs/stored-command-line-injection`, :code:`cs/web/stored-xss`, :code:`cs/stored-ldap-injection`, :code:`cs/xml/stored-xpath-injection`, :code:`cs/second-order-sql-injection`) have been removed. If you were using these queries, their results can be restored by enabling the :code:`file` and :code:`database` threat models in your threat model configuration.

Java
""""

*   The :code:`java/missing-case-in-switch` query now gives only a single alert for each switch statement, giving some examples of the missing cases as well as a count of how many are missing.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Missing return-value check for a 'scanf'-like function" query (:code:`cpp/missing-check-scanf`) has been converted to a :code:`path-problem` query.
*   The "Potentially uninitialized local variable" query (:code:`cpp/uninitialized-local`) has been converted to a :code:`path-problem` query.
*   Added models for :code:`GLib` allocation and deallocation functions.

C#
""

*   The alert message of :code:`cs/wrong-compareto-signature` has been changed to remove unnecessary element references.
*   Data flow queries that track flow from *local* flow sources now use the current *threat model* configuration instead. This may lead to changes in the produced alerts if the threat model configuration only uses *remote* flow sources. The changed queries are :code:`cs/code-injection`, :code:`cs/resource-injection`, :code:`cs/sql-injection`, and :code:`cs/uncontrolled-format-string`.

Golang
""""""

*   The query :code:`go/hardcoded-credentials` no longer discards string literals based on "weak password" heuristics.
*   The query :code:`go/sql-injection` now recognizes more sinks in the package :code:`github.com/Masterminds/squirrel`.

Java
""""

*   Variables named :code:`tokenImage` are no longer sources for  the :code:`java/sensitive-log` query. This is because this variable name is used in parsing code generated by JavaCC, so it causes a large number of false positive alerts.
*   Added sanitizers for relative URLs, :code:`List.contains()`, and checking the host of a URI to the :code:`java/ssrf` and :code:`java/unvalidated-url-redirection` queries.

JavaScript/TypeScript
"""""""""""""""""""""

*   The call graph has been improved, leading to more alerts for data flow based queries.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/type-confusion`, to detect casts to invalid types.

Golang
""""""

*   The query "Slice memory allocation with excessive size value" (:code:`go/uncontrolled-allocation-size`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @Malayke <https://github.com/github/codeql/pull/15130>`__.

Java
""""

*   The query :code:`java/unsafe-url-forward-dispatch-load` has been promoted from experimental to the main query pack as :code:`java/unvalidated-url-forward`. Its results will now appear by default. This query was originally submitted as an experimental query `by @haby0 <https://github.com/github/codeql/pull/6240>`__ and `by @luchua-bc <https://github.com/github/codeql/pull/7286>`__.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   :code:`@precision medium` metadata was added to the :code:`cpp/boost/tls-settings-misconfiguration` and :code:`cpp/boost/use-of-deprecated-hardcoded-security-protocol` queries, and these queries are now included in the security-extended suite. The :code:`@name` metadata of these queries were also updated.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`@precision` of the :code:`js/unsafe-external-link` has been reduced to :code:`low` to reflect the fact that modern browsers do not expose the opening window for such links. This mitigates the potential security risk of having a link with :code:`target="_blank"`.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

C#
""

*   The CIL extractor has been deleted and the corresponding extractor option :code:`cil` has been removed. It is no longer possible to do CIL extraction.
*   The QL library C# classes no longer extend their corresponding :code:`DotNet` classes. Furthermore, CIL related data flow functionality has been deleted and all :code:`DotNet` and :code:`CIL` related classes have been deprecated. This effectively means that it no longer has any effect to enable CIL extraction.

Java
""""

*   The Java extractor no longer supports the :code:`ODASA_SNAPSHOT` legacy environment variable.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 5.4.

Swift
"""""

*   Upgraded to Swift 5.10
*   New AST node is extracted: :code:`ThenStmt`

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Added destructors for temporary objects with extended lifetimes to the intermediate representation.

C#
""

*   Added new source models for the :code:`Dapper` package. These models can be enabled by enabling the :code:`database` threat model.
*   Additional models have been added for :code:`System.IO`. These are primarily source models with the :code:`file` threat model, and summaries related to reading from a file or stream.
*   Support for C# 12 / .NET8.
*   Added the :code:`windows-registry` source kind and threat model to represent values which come from the registry on Windows.
*   The models for :code:`System.Net.Http.HttpRequestMessage` have been modified to better model the flow of tainted URIs.
*   The .NET standard libraries APIs for accessing command line arguments and environment variables have been modeled using the :code:`commandargs` and :code:`environment` threat models.
*   The :code:`cs/assembly-path-injection` query has been modified so that it's sources rely on :code:`ThreatModelFlowSource`. In order to restore results from command line arguments, you should enable the :code:`commandargs` threat model.
*   The models for :code:`System.IO.TextReader` have been modified to better model the flow of tainted text from a :code:`TextReader`.

Golang
""""""

*   The :code:`CODEQL_EXTRACTOR_GO_FAST_PACKAGE_INFO` option, which speeds up retrieval of dependency information, is now on by default. This was originally an external contribution by @xhd2015.
*   Added dataflow sources for the package :code:`gopkg.in/macaron.v1`.

Java
""""

*   Increased the precision of some dataflow models of the class :code:`java.net.URL` by distinguishing the parts of a URL.
*   The Java extractor and QL libraries now support Java 22, including support for anonymous variables, lambda parameters and patterns.
*   Pattern cases with multiple patterns and that fall through to or from other pattern cases are now supported. The :code:`PatternCase` class gains the new :code:`getPatternAtIndex` and :code:`getAPattern` predicates, and deprecates :code:`getPattern`.
*   Added a :code:`path-injection` sink for the :code:`open` methods of the :code:`android.os.ParcelFileDescriptor` class.

Ruby
""""

*   Data flow is now tracked through :code:`ActiveRecord` scopes.
*   Modeled instances of :code:`ActionDispatch::Http::UploadedFile` that can be obtained from element reads of :code:`ActionController::Parameters`, with calls to :code:`original_filename`, :code:`content_type`, and :code:`read` now propagating taint from their receiver.
*   The second argument, :code:`subquery_name`, of the :code:`ActiveRecord::QueryMethods::from` method, is now recognized as an sql injection sink.
*   Calls to :code:`Typhoeus::Request.new` are now considered as instances of the :code:`Http::Client::Request` concept, with the response body being treated as a remote flow source.
*   New command injection sinks have been added, including :code:`Process.spawn`, :code:`Process.exec`, :code:`Terrapin::CommandLine` and the :code:`open4` gem.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added a :code:`TaintInheritingContent` class that can be extended to model taint flowing from a qualifier to a field.
*   Added a predicate :code:`GuardCondition.comparesEq/4` to query whether an expression is compared to a constant.
*   Added a predicate :code:`GuardCondition.ensuresEq/4` to query whether a basic block is guarded by an expression being equal to a constant.
*   Added a predicate :code:`GuardCondition.comparesLt/4` to query whether an expression is compared to a constant.
*   Added a predicate :code:`GuardCondition.ensuresLt/4` to query whether a basic block is guarded by an expression being less than a constant.
*   Added a predicate :code:`GuardCondition.valueControls` to query whether a basic block is guarded by a particular :code:`case` of a :code:`switch` statement.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   Path explanations now include flow that goes through callbacks passed into library functions. For example, if :code:`map` is a library function, then in :code:`result = map(xs, x => x + 1)` we will now include the step from :code:`x` to :code:`x + 1` in the path explanation, instead of going directly from :code:`xs` to :code:`result`. Note that this change does not affect actual query results, but only how path explanations are computed.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.5.rst
.. _codeql-cli-2.5.5:

=========================
CodeQL 2.5.5 (2021-05-17)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.5 runs a total of 248 security queries when configured with the Default suite (covering 112 CWE). The Extended suite enables an additional 72 queries (covering 26 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   When scanning the disk for QL packs and extractors, directories of the form :code:`.../SOMETHING/SOMETHING.testproj` (where the two
    :code:`SOMETHING` are identical) will now be ignored.  Names of this form are used by :code:`codeql test run` for ephemeral test databases, which can sometimes contain files that confuse QL compilations.

Bug Fixes
~~~~~~~~~

*   When using the :code:`--sarif-group-rules-by-pack` flag to place the SARIF rule object for each query underneath its corresponding query pack in :code:`runs[].tool.extensions`, the :code:`rule` property of result objects can now be used to look up the rule within the :code:`rules` property of the appropriate query pack in :code:`runs[].tool.extensions`. Previously,
    rule lookup for result objects in the SARIF output was not well-defined when the :code:`--sarif-group-rules-by-pack` flag was passed.

New Features
~~~~~~~~~~~~

*   Query writers can now optionally use :code:`@severity` in place of
    :code:`@problem.severity` in the metadata for alert queries. SARIF consumers should continue to consume this severity information using the :code:`rule.defaultConfiguration.level` property for SARIF v2.1.0, and corresponding properties for other versions of SARIF. They should not depend on the value stored in the :code:`rule.properties` property bag, since this will contain either :code:`@problem.severity` or
    :code:`@severity` based on exactly what was written in the query metadata.
    
*   When exporting analysis results to SARIF v2.1.0, results and metric results now contain a `reporting descriptor reference object <https://docs.oasis-open.org/sarif/sarif/v2.1.0/csprd01/sarif-v2.1.0-csprd01.html#_Toc10541300>`__ that specifies the rule that produced them. For metric results, this new property replaces the :code:`metric` property.
    
*   :code:`codeql database analyze` now outputs a table that summarizes the results of metric queries that were part of the analysis. This can be suppressed by passing the :code:`--no-print-metrics-summary` flag.
    



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.15.2.rst
.. _codeql-cli-2.15.2:

==========================
CodeQL 2.15.2 (2023-11-13)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.15.2 runs a total of 399 security queries when configured with the Default suite (covering 158 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   C++ extraction has been updated to output more accurate C++ value categories.
    This may cause unexpected alerts on databases extracted with an up-to-date CodeQL when the queries are part of a query pack that was compiled with an earlier CodeQL.
    To resolve this, please recompile the query pack with the latest CodeQL.

Bug Fixes
~~~~~~~~~

*   Fixed a bug where :code:`codeql github upload-results` would report a 403 error when attempting to upload to a GitHub Enterprise Server instance.
*   Fixed a bug in Python extraction where UTF-8 characters would cause logging to fail on systems with non-UTF-8 default system encoding (for example, Windows systems).
*   The :code:`resolve qlpacks --kind extension` command no longer resolves extensions packs from the search path. This matches the behavior of
    :code:`resolve extensions-by-pack` and will ensure that extensions which are resolved by :code:`resolve qlpacks --kind extension` can also be resolved by
    :code:`resolve extensions-by-pack`.

New Features
~~~~~~~~~~~~

*   :code:`codeql database analyze` and :code:`codeql database interpret-results` can now output human-readable analysis summaries in a new format. This format provides file coverage information and improves the way that diagnostic messages are displayed. The new format also includes a link to the tool status page when the :code:`GITHUB_SERVER_URL` and :code:`GITHUB_REPOSITORY` environment variables are set. Note that that page only exists on GitHub.com, or in GitHub Enterprise Server version 3.9.0 or later. To enable this new format, pass the :code:`--analysis-summary-v2` flag.
*   CodeQL now supports distinguishing file coverage information between related languages C and C++, Java and Kotlin,
    and JavaScript and TypeScript. By default, file coverage information for each of these pairs of languages is grouped together. To enable specific file coverage information for these languages, pass the
    :code:`--sublanguage-file-coverage` flag when initializing the database (with :code:`codeql database create` or :code:`codeql database init`) and when analyzing the database (with :code:`codeql database analyze` or :code:`codeql database interpret-results`). If you are uploading results to a GitHub instance, this flag requires GitHub.com or GitHub Enterprise Server version 3.12 or later.
*   All CLI commands now support :code:`--common-caches`, which controls the location of the cached data that is persisted between several runs of the CLI, such as downloaded QL packs and compiled query plans.

Improvements
~~~~~~~~~~~~

*   Model packs that are used in an analysis will now be included in an output SARIF results file. All model packs now include the :code:`isCodeQLModelPack: true` property in their tool component property bag.
*   The default formatting of DIL now more closely resembles equivalent QL code.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   The query :code:`go/incorrect-integer-conversion` now correctly recognizes more guards of the form :code:`if val <= x` to protect a conversion :code:`uintX(val)`.

Java
""""

*   java/summary/lines-of-code now gives the total number of lines of Java and Kotlin code, and is the only query tagged :code:`lines-of-code`. java/summary/lines-of-code-java and java/summary/lines-of-code-kotlin give the per-language counts.
*   The query :code:`java/spring-disabled-csrf-protection` has been improved to detect more ways of disabling CSRF in Spring.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added modeling for importing :code:`express-rate-limit` using a named import.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   Fixed a bug where data flow nodes in files that are not in the project being analyzed (such as libraries) and are not contained within a function were not given an enclosing :code:`Callable`. Note that for nodes that are not contained within a function, the enclosing callable is considered to be the file itself. This may cause some minor changes to results.

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`Container` and :code:`Folder` classes now derive from :code:`ElementBase` instead of :code:`Locatable`, and no longer expose the :code:`getLocation` predicate. Use :code:`getURL` instead.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   More field accesses are identified as :code:`ImplicitThisFieldAccess`.
*   Added support for new floating-point types in C23 and C++23.

Golang
""""""

*   Added `Request.Cookie <https://pkg.go.dev/net/http#Request.Cookie>`__ to reflected XSS sanitizers.

Java
""""

*   Java classes :code:`MethodAccess`, :code:`LValue` and :code:`RValue` were renamed to :code:`MethodCall`, :code:`VarWrite` and :code:`VarRead` respectively, along with related predicates and class names. The old names remain usable for the time being but are deprecated and should be replaced.
    
*   New class :code:`NewClassExpr` was added to represent specifically an explicit :code:`new ClassName(...)` invocation, in contrast to :code:`ClassInstanceExpr` which also includes expressions that implicitly instantiate classes, such as defining a lambda or taking a method reference.
    
*   Added up to date models related to Spring Framework 6's :code:`org.springframework.http.ResponseEntity`.
    
*   Added models for the following packages:

    *   com.alibaba.fastjson2
    *   javax.management
    *   org.apache.http.client.utils

Python
""""""

*   Added support for functions decorated with :code:`contextlib.contextmanager`.
*   Namespace packages in the form of regular packages with missing :code:`__init__.py`\ -files are now allowed. This enables the analysis to resolve modules and functions inside such packages.

Swift
"""""

*   Improved support for flow through captured variables that properly adheres to inter-procedural control flow.
*   Added children of :code:`UnspecifiedElement`, which will be present only in certain downgraded databases.
*   Collection content is now automatically read at taint flow sinks. This removes the need to define an :code:`allowImplicitRead` predicate on data flow configurations where the sink might be an array, set or similar type with tainted contents. Where that step had not been defined, taint may find additional results now.
*   Added taint models for :code:`StringProtocol.appendingFormat` and :code:`String.decodeCString`.
*   Added taint flow models for members of :code:`Substring`.
*   Added taint flow models for :code:`RawRepresentable`.
*   The contents of autoclosure function parameters are now included in the control flow graph and data flow libraries.
*   Added models of :code:`StringProtocol` and :code:`NSString` methods that evaluate regular expressions.
*   Flow through 'open existential expressions', implicit expressions created by the compiler when a method is called on a protocol. This may apply, for example, when the method is a modelled taint source.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added a new class :code:`AdditionalCallTarget` for specifying additional call targets.

Shared Libraries
----------------

Bug Fixes
~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The API for debugging flow using partial flow has changed slightly. Instead of using :code:`module Partial = FlowExploration<limit/0>` and choosing between :code:`Partial::partialFlow` and :code:`Partial::partialFlowRev`, you now choose between :code:`module Partial = FlowExplorationFwd<limit/0>` and :code:`module Partial = FlowExplorationRev<limit/0>`, and then always use :code:`Partial::partialFlow`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Range Analysis
""""""""""""""

*   Initial release. Moves the range analysis library into its own qlpack.

New Features
~~~~~~~~~~~~

Utility Classes
"""""""""""""""

*   Added :code:`FilePath` API for normalizing filepaths.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.15.0.rst
.. _codeql-cli-2.15.0:

==========================
CodeQL 2.15.0 (2023-10-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.15.0 runs a total of 397 security queries when configured with the Default suite (covering 157 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed an issue with analyzing Python projects using Python 3.12.

Deprecations
~~~~~~~~~~~~

*   :code:`pragma[assume_small_delta]` is now deprecated. The pragma has no effect and should be removed.
    
*   Missing override annotations on class fields now raise errors rather than warnings. This is to avoid confusion with the shadowing behavior in the presence of final fields.
    
*   The CodeQL CLI no longer supports ML-powered alerts. For more information,
    including details of our work in the AI-powered security technology space,
    see
    "\ `CodeQL code scanning deprecates ML-powered alerts <https://github.blog/changelog/2023-09-29-codeql-code-scanning-deprecates-ml-powered-alerts/>`__."

New Features
~~~~~~~~~~~~

*   The output of :code:`codeql version --format json` now includes a :code:`features` property. Each key in the map identifies a feature of the CodeQL CLI. The value for a key is always :code:`true`. Going forward, whenever a significant new feature is added to the CodeQL CLI, a corresponding entry will be added to the
    :code:`features` map. This is intended to make it easier for tools that invoke the CodeQL CLI to know if the particular version of the CLI they are invoking supports a given feature, without having to know exactly what CLI version introduced that feature.

Improvements
~~~~~~~~~~~~

*   You can now specify the CodeQL languages C/C++, Java/Kotlin, and JavaScript/TypeScript using :code:`--language c-cpp`, :code:`--language java-kotlin`, and
    :code:`--language javascript-typescript` respectively. These new CodeQL language names convey more clearly what languages each CodeQL language will analyze.
    
    You can also reference these CodeQL languages via their secondary language names (C/C++ via :code:`--language c` or :code:`--language cpp`, Java/Kotlin via
    :code:`--language java` or :code:`--language kotlin`, and JavaScript/TypeScript via
    :code:`--language javascript` or :code:`--language typescript`), however we recommend you refer to them via the new primary CodeQL language names for improved clarity.
    
*   CodeQL now respects custom home directories set by the :code:`$HOME` environment variable on MacOS and Linux and :code:`%USERPROFILE%` on Windows. When set, CodeQL will use the variable's value to change the default location of downloaded packages and the global compilation cache.
    
*   This release improves the quality of
    \ `file coverage information <https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/about-the-tool-status-page#using-the-tool-status-page>`__ for repositories that vendor their dependencies. This is currently supported for Go and JavaScript projects.

QL Language
~~~~~~~~~~~

*   The QL language now has two new methods :code:`codePointAt` and :code:`codePointCount` on the :code:`string` type. The methods both return integers and act the same as the similarly named Java methods on strings. For example, :code:`"abc".codePointAt(2)` is :code:`99` and :code:`("a" + 128512.toUnicode() + "c").codePointAt(1)` is a :code:`128512`.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The queries :code:`cpp/double-free` and :code:`cpp/use-after-free` find fewer false positives in cases where a non-returning function is called.
*   The number of duplicated dataflow paths reported by queries has been significantly reduced.

Python
""""""

*   Improved *URL redirection from remote source* (:code:`py/url-redirection`) query to not alert when URL has been checked with :code:`django.utils.http. url_has_allowed_host_and_scheme`.
*   Extended the :code:`py/command-line-injection` query with sinks from Python's :code:`asyncio` module.

Ruby
""""

*   Built-in Ruby queries now use the new DataFlow API.

Swift
"""""

*   Adder barriers for numeric type values to the injection-like queries, to reduce false positive results where the user input that can be injected is constrainted to a numerical value. The queries updated by this change are: "Predicate built from user-controlled sources" (:code:`swift/predicate-injection`), "Database query built from user-controlled sources" (:code:`swift/sql-injection`), "Uncontrolled format string" (:code:`swift/uncontrolled-format-string`), "JavaScript Injection" (:code:`swift/unsafe-js-eval`) and "Regular expression injection" (:code:`swift/regex-injection`).
*   Added additional taint steps to the :code:`swift/cleartext-transmission`, :code:`swift/cleartext-logging` and :code:`swift/cleartext-storage-preferences` queries to identify data within sensitive containers. This is similar to an existing additional taint step in the :code:`swift/cleartext-storage-database` query.
*   Added new logging sinks to the :code:`swift/cleartext-logging` query.
*   Added sqlite3 and SQLite.swift path injection sinks for the :code:`swift/path-injection` query.

New Queries
~~~~~~~~~~~

C#
""

*   Added a new query, :code:`cs/web/insecure-direct-object-reference`, to find instances of missing authorization checks for resources selected by an ID parameter.

Python
""""""

*   The query :code:`py/nosql-injection` for finding NoSQL injection vulnerabilities is now available in the default security suite.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/double-free` query has been further improved to reduce false positives and its precision has been increased from :code:`medium` to :code:`high`.
*   The :code:`cpp/use-after-free` query has been further improved to reduce false positives and its precision has been increased from :code:`medium` to :code:`high`.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Java
""""

*   The regular expressions library no longer incorrectly matches mode flag characters against the input.

Python
""""""

*   Subterms of regular expressions encoded as single-line string literals now have better source-location information.

Swift
"""""

*   The regular expressions library no longer incorrectly matches mode flag characters against the input.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ruby
""""

*   Improved support for flow through captured variables that properly adheres to inter-procedural control flow.

Swift
"""""

*   The predicates :code:`getABaseType`, :code:`getABaseTypeDecl`, :code:`getADerivedType` and :code:`getADerivedTypeDecl` on :code:`Type` and :code:`TypeDecl` now behave more usefully and consistently. They now explore through type aliases used in base class declarations, and include protocols added in extensions.
    
    To examine base class declarations at a low level without these enhancements, use :code:`TypeDecl.getInheritedType`.
    
    :code:`Type.getABaseType` (only) previously resolved a type alias it was called directly on. This behaviour no longer exists. To find any base type of a type that could be an alias, the construct :code:`Type.getUnderlyingType().getABaseType*()` is recommended.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Functions that do not return due to calling functions that don't return (e.g. :code:`exit`) are now detected as non-returning in the IR and dataflow.
*   Treat functions that reach the end of the function as returning in the IR.
    They used to be treated as unreachable but it is allowed in C.
*   The :code:`DataFlow::asDefiningArgument` predicate now takes its argument from the range starting at :code:`1` instead of :code:`2`. Queries that depend on the single-parameter version of :code:`DataFlow::asDefiningArgument` should have their arguments updated accordingly.

Golang
""""""

*   Added Numeric and Boolean types to SQL injection sanitzers.

Java
""""

*   Fixed a control-flow bug where case rule statements would incorrectly include a fall-through edge.
*   Added support for default cases as proper guards in switch expressions to match switch statements.
*   Improved the class :code:`ArithExpr` of the :code:`Overflow.qll` module to also include compound operators. Because of this, new alerts may be raised in queries related to overflows/underflows.
*   Added new dataflow models for the Apache CXF framework.
*   Regular expressions containing multiple parse mode flags are now interpretted correctly. For example :code:`"(?is)abc.*"` with both the :code:`i` and :code:`s` flags.

Python
""""""

*   Django Rest Framework better handles custom :code:`ModelViewSet` classes functions
*   Regular expression fragments residing inside implicitly concatenated strings now have better location information.

Swift
"""""

*   Modelled varargs function in :code:`NSString` more accurately.
*   Modelled :code:`CustomStringConvertible.description` and :code:`CustomDebugStringConvertible.debugDescription`, replacing ad-hoc models of these properties on derived classes.
*   The regular expressions library now accepts a wider range of mode flags in a regular expression mode flag group (such as :code:`(?u)`). The :code:`(?w`) flag has been renamed from "UNICODE" to "UNICODEBOUNDARY", and the :code:`(?u)` flag is called "UNICODE" in the libraries.
*   Renamed :code:`TypeDecl.getBaseType/1` to :code:`getInheritedType`.
*   Flow through writes via keypaths is now supported by the data flow library.
*   Added flow through variadic arguments, and the :code:`getVaList` function.
*   Added flow steps through :code:`Dictionary` keys and values.
*   Added taint models for :code:`Numeric` conversions.

Deprecated APIs
~~~~~~~~~~~~~~~

Swift
"""""

*   The :code:`ArrayContent` type in the data flow library has been deprecated and made an alias for the :code:`CollectionContent` type, to better reflect the hierarchy of the Swift standard library. Uses of :code:`ArrayElement` in model files will be interpreted as referring to :code:`CollectionContent`.

New Features
~~~~~~~~~~~~

Java
""""

*   Kotlin versions up to 1.9.20 are now supported.

Shared Libraries
----------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   Added support for type-based call edge pruning. This removes data flow call edges that are incompatible with the set of flow paths that reach it based on type information. This improves dispatch precision for constructs like lambdas, :code:`Object.toString()` calls, and the visitor pattern. For now this is only enabled for Java and C#.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The :code:`isBarrierIn` and :code:`isBarrierOut` predicates in :code:`DataFlow::StateConfigSig` now have overloaded variants that block a specific :code:`FlowState`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.7.rst
.. _codeql-cli-2.5.7:

=========================
CodeQL 2.5.7 (2021-07-02)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.7 runs a total of 268 security queries when configured with the Default suite (covering 114 CWE). The Extended suite enables an additional 56 queries (covering 28 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   :code:`codeql database create` and :code:`codeql database init` can now automatically recognise the languages present in checkouts of GitHub repositories by making an API call to the GitHub server. This requires a PAT token to either be set in the :code:`GITHUB_TOKEN` environment variable, or passed by stdin with the
    :code:`--github-auth-stdin` argument.
    
*   Operations that make outgoing HTTP calls (that is, :code:`codeql github upload-results` and the language-detection feature described above)
    now support the use of HTTP proxies. To use a proxy, specify an
    :code:`$https_proxy` environment variable for HTTPS requests or a
    :code:`$http_proxy` environment variable for HTTP requests. If the
    :code:`$no_proxy` variable is also set, these variables will be ignored and requests will be made without a proxy.

QL Language
~~~~~~~~~~~

*   The QL language now has a new method :code:`toUnicode` on the :code:`int` type. This method converts Unicode codepoint to a one-character string.  For example, :code:`65.toUnicode() = "A"`, :code:`128512.toUnicode()` results in a smiley, and :code:`any(int i | i.toUnicode() = "A") = 65`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.2.rst
.. _codeql-cli-2.17.2:

==========================
CodeQL 2.17.2 (2024-05-07)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.2 runs a total of 413 security queries when configured with the Default suite (covering 161 CWE). The Extended suite enables an additional 130 queries (covering 34 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Improvements
~~~~~~~~~~~~

*   When uploading a SARIF file to GitHub using :code:`codeql github upload-results`, the CodeQL CLI now waits for the file to be processed by GitHub. If any errors occurred during processing of the analysis results, the command will log these and return a non-zero exit code. To disable this behaviour, pass the
    :code:`--no-wait-for-processing` flag.
    
    By default, the command will wait for the SARIF file to be processed for a maximum of 2 minutes, however this is configurable with the
    :code:`--wait-for-processing-timeout` option.
    
*   The build tracer is no longer enabled when using the |link-code-none-build-mode-1|_
    to analyze a compiled language, thus improving performance.

Known Issues
~~~~~~~~~~~~

*   The beta support for analyzing Swift in this release and all previous releases requires :code:`g++-13` when running on Linux. Users analyzing Swift using the :code:`ubuntu-latest`, :code:`ubuntu-22.04`, or
    :code:`ubuntu-20.04` runner images for GitHub Actions should update their workflows to install :code:`g++-13`. For more information, see `the runner images announcement <https://github.com/actions/runner-images/issues/9679>`__.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Uncontrolled data used in path expression" query (:code:`cpp/path-injection`) query produces fewer near-duplicate results.
*   The "Global variable may be used before initialization" query (:code:`cpp/global-use-before-init`) no longer raises an alert on global variables that are initialized when they are declared.
*   The "Inconsistent null check of pointer" query (:code:`cpp/inconsistent-nullness-testing`) query no longer raises an alert when the guarded check is in a macro expansion.

Golang
""""""

*   The query :code:`go/incomplete-hostname-regexp` now recognizes more sources involving concatenation of string literals and also follows flow through string concatenation. This may lead to more alerts.
*   Added some more barriers to flow for :code:`go/incorrect-integer-conversion` to reduce false positives, especially around type switches.

JavaScript/TypeScript
"""""""""""""""""""""

*   The JavaScript extractor will on longer report syntax errors related to "strict mode".
    Files containing such errors are now being fully analyzed along with other sources files.
    This improves our support for source files that technically break the "strict mode" rules,
    but where a build steps transforms the code such that it ends up working at runtime.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   Deleted the deprecated :code:`GlobalValueNumberingImpl.qll` implementation.

C#
""

*   Deleted the deprecated :code:`getAssemblyName` predicate from the :code:`Operator` class. Use :code:`getFunctionName` instead.
*   Deleted the deprecated :code:`LShiftOperator`, :code:`RShiftOperator`, :code:`AssignLShiftExpr`, :code:`AssignRShiftExpr`, :code:`LShiftExpr`, and :code:`RShiftExpr` aliases.
*   Deleted the deprecated :code:`getCallableDescription` predicate from the :code:`ExternalApiDataNode` class. Use :code:`hasQualifiedName` instead.

Golang
""""""

*   Deleted the deprecated :code:`CsvRemoteSource` alias. Use :code:`MaDRemoteSource` instead.

Java
""""

*   Deleted the deprecated :code:`AssignLShiftExpr`, :code:`AssignRShiftExpr`, :code:`AssignURShiftExpr`, :code:`LShiftExpr`, :code:`RShiftExpr`, and :code:`URShiftExpr` aliases.

JavaScript/TypeScript
"""""""""""""""""""""

*   Deleted the deprecated :code:`getInput` predicate from the :code:`CryptographicOperation` class. Use :code:`getAnInput` instead.
*   Deleted the deprecated :code:`RegExpPatterns` module from :code:`Regexp.qll`.
*   Deleted the deprecated :code:`semmle/javascript/security/BadTagFilterQuery.qll`, :code:`semmle/javascript/security/OverlyLargeRangeQuery.qll`, :code:`semmle/javascript/security/regexp/RegexpMatching.qll`, and :code:`Security/CWE-020/HostnameRegexpShared.qll` files.

Python
""""""

*   Deleted the deprecated :code:`RegExpPatterns` module from :code:`Regexp.qll`.
*   Deleted the deprecated :code:`Security/CWE-020/HostnameRegexpShared.qll` file.

Ruby
""""

*   Deleted the deprecated :code:`RegExpPatterns` module from :code:`Regexp.qll`.
*   Deleted the deprecated :code:`security/cwe-020/HostnameRegexpShared.qll` file.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Source models have been added for the standard library function :code:`getc` (and variations).
*   Source, sink and flow models for the ZeroMQ (ZMQ) networking library have been added.
*   Parameters of functions without definitions now have :code:`ParameterNode`\ s.
*   The alias analysis used internally by various libraries has been improved to answer alias questions more conservatively. As a result, some queries may report fewer false positives.

C#
""

*   Generated .NET Runtime models for properties with both getters and setters have been removed as this is now handled by the data flow library.

JavaScript/TypeScript
"""""""""""""""""""""

*   Improved detection of whether a file uses CommonJS module system.

Deprecated APIs
~~~~~~~~~~~~~~~

Golang
""""""

*   To make Go consistent with other language libraries, the :code:`UntrustedFlowSource` name has been deprecated throughout. Use :code:`RemoteFlowSource` instead, which replaces it.
*   Where modules have classes named :code:`UntrustedFlowAsSource`, these are also deprecated and the :code:`Source` class in the same module or the :code:`RemoteFlowSource` class should be used instead.

Python
""""""

*   Renamed the :code:`StrConst` class to :code:`StringLiteral`, for greater consistency with other languages. The :code:`StrConst` and :code:`Str` classes are now deprecated and will be removed in a future release.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Models-as-Data support has been added for C/C++. This feature allows flow sources, sinks and summaries to be expressed in compact strings as an alternative to modelling each source / sink / summary with explicit QL. See :code:`dataflow/ExternalFlow.qll` for documentation and specification of the model format, and :code:`models/implementations/ZMQ.qll` for a simple example of models. Importing models from :code:`.yml` is not yet supported.

Shared Libraries
----------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The data flow library performs heuristic filtering of code paths that have a high degree of control-flow uncertainty for improved performance in cases that are deemed unlikely to yield true positive flow paths. This filtering can be controlled with the :code:`fieldFlowBranchLimit` predicate in configurations. Two bugs have been fixed in relation to this: Some cases of high uncertainty were not being correctly identified. This fix improves performance in certain scenarios. Another group of cases of low uncertainty were also being misidentified, which led to false negatives. Taken together, we generally expect some additional query results with more true positives and fewer false positives.

.. |link-code-none-build-mode-1| replace:: :code:`none` build mode
.. _link-code-none-build-mode-1: https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/codeql-code-scanning-for-compiled-languages#codeql-build-modes




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.7.5.rst
.. _codeql-cli-2.7.5:

=========================
CodeQL 2.7.5 (2022-01-17)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.7.5 runs a total of 289 security queries when configured with the Default suite (covering 127 CWE). The Extended suite enables an additional 88 queries (covering 31 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

Deprecations
~~~~~~~~~~~~

*   The CodeQL Action versions up to and including version 1.0.22 are now deprecated for use with CodeQL CLI 2.7.5 and later.  The CLI will emit a warning if it detects that it is being used by a deprecated version of the codeql-action.  This warning will become a fatal error with version 2.8.0 of the CLI.

Documentation
~~~~~~~~~~~~~

*   The documentation for the :code:`--trace-process-level` flag of :code:`codeql database init` (which is used with indirect build tracing on Windows) was erroneous.
    
    The help text previously claimed that :code:`--trace-process-level=1` would inject CodeQL's build tracer into the calling process. This is actually what :code:`--trace-process-level=0` achieves. The help text has now been corrected to match the actual (unchanged) behavior.
    
    Also, some log messages incorrectly stated which process CodeQL was injected into. These have also been corrected.

New Features
~~~~~~~~~~~~

*   The :code:`codeql github upload-results` command will now print the API response body in JSON format if a :code:`--format=json` flag is given. Otherwise the command will print the URL of the SARIF upload. This URL can be used to get status information for the upload.
    
    See also: https://docs.github.com/en/rest/reference/code-scanning

Miscellaneous
~~~~~~~~~~~~~

*   For commands that run queries, the :code:`--timeout` option now controls the maximal time it may take to evaluate a "layer" of a query rather than a "stage".  There are usually many "layers" in each "stage",
    but it is usually a single one of the layers in a stage that uses most of the time, so there is no need to reduce existing timeout values as a result of this change.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   TypeScript 4.5 is now supported.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The :code:`java/constant-comparison` query no longer raises false alerts regarding comparisons with Unicode surrogate character literals.

JavaScript/TypeScript
"""""""""""""""""""""

*   Support for handlebars templates has improved. Raw interpolation tags of the form :code:`{{& ... }}` are now recognized,
    as well as whitespace-trimming tags like :code:`{{~ ... }}`.
*   Data flow is now tracked across middleware functions in more cases, leading to more security results in general. Affected packages are :code:`express` and :code:`fastify`.
*   :code:`js/missing-token-validation` has been made more precise, yielding both fewer false positives and more true positives.

Python
""""""

*   Added modeling of many functions from the :code:`os` module that uses file system paths, such as :code:`os.stat`, :code:`os.chdir`, :code:`os.mkdir`, and so on. All of these are new sinks for the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.
*   Added modeling of the :code:`tempfile` module for creating temporary files and directories, such as the functions :code:`tempfile.NamedTemporaryFile` and :code:`tempfile.TemporaryDirectory`. The :code:`suffix`, :code:`prefix`, and :code:`dir` arguments are all vulnerable to path-injection, and these are new sinks for the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.
*   Extended the modeling of FastAPI such that :code:`fastapi.responses.FileResponse` are considered :code:`FileSystemAccess`, making them sinks for the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.
*   Added modeling of the :code:`posixpath`, :code:`ntpath`, and :code:`genericpath` modules for path operations (although these are not supposed to be used), resulting in new sinks for the *Uncontrolled data used in path expression* (:code:`py/path-injection`) query.
*   Added modeling of :code:`wsgiref.simple_server` applications, leading to new remote flow sources.
*   To support the new SSRF queries, the PyPI package :code:`requests` has been modeled, along with :code:`http.client.HTTP[S]Connection` from the standard library.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   A new query :code:`cpp/certificate-not-checked` has been added for C/C++. The query flags unsafe use of OpenSSL and similar libraries.
*   A new query :code:`cpp/certificate-result-conflation` has been added for C/C++. The query flags unsafe use of OpenSSL and similar libraries.

Python
""""""

*   Two new queries have been added for detecting Server-side request forgery (SSRF). *Full server-side request forgery* (:code:`py/full-ssrf`) will only alert when the URL is fully user-controlled, and *Partial server-side request forgery* (:code:`py/partial-ssrf`) will alert when any part of the URL is user-controlled. Only :code:`py/full-ssrf` will be run by default.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Java
""""

*   :code:`CharacterLiteral`\ 's :code:`getCodePointValue` predicate now returns the correct value for UTF-16 surrogates.
*   The :code:`RangeAnalysis` module now properly handles comparisons with Unicode surrogate character literals.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Data flow now propagates taint from remote source :code:`Parameter` types to read steps of their fields (e.g. :code:`tainted.publicField` or :code:`tainted.getField()`). This also applies to their subtypes and the types of their fields, recursively.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Added modeling of many functions from the :code:`os` module that uses file system paths, such as :code:`os.stat`, :code:`os.chdir`, :code:`os.mkdir`, and so on.
*   Added modeling of the :code:`tempfile` module for creating temporary files and directories, such as the functions :code:`tempfile.NamedTemporaryFile` and :code:`tempfile.TemporaryDirectory`.
*   Extended the modeling of FastAPI such that custom subclasses of :code:`fastapi.APIRouter` are recognized.
*   Extended the modeling of FastAPI such that :code:`fastapi.responses.FileResponse` are considered :code:`FileSystemAccess`.
*   Added modeling of the :code:`posixpath`, :code:`ntpath`, and :code:`genericpath` modules for path operations (although these are not supposed to be used), resulting in new sinks.
*   Added modeling of :code:`wsgiref.simple_server` applications, leading to new remote flow sources.

Deprecated APIs
~~~~~~~~~~~~~~~

Ruby
""""

*   :code:`ConstantWriteAccess.getQualifiedName()` has been deprecated in favor of :code:`getAQualifiedName()` which can return multiple possible qualified names for a given constant write access.

New Features
~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   TypeScript 4.5 is now supported.

Ruby
""""

*   A new library, :code:`Customizations.qll`, has been added, which allows for global customizations that affect all queries.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.4.rst
.. _codeql-cli-2.11.4:

==========================
CodeQL 2.11.4 (2022-11-24)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.4 runs a total of 361 security queries when configured with the Default suite (covering 150 CWE). The Extended suite enables an additional 112 queries (covering 32 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   CodeQL 2.11.1 to 2.11.3 contained a bug in `indirect build tracing <https://codeql.github.com/docs/codeql-cli/creating-codeql-databases/#using-indirect-build-tracing>`__ on Windows when using :code:`codeql database init` with the |link-code-trace-process-level-1|_ flag.
    In these versions, when :code:`--trace-process-level` was set to a value greater than zero,
    (or left at the default value of 1), CodeQL attempted to inject its build tracer at a higher level in the process tree than the requested process level.
    This could lead to errors of the form "No source code found" or
    "Process tree ended before reaching required level".
    From 2.11.4 onwards, the CodeQL build tracer is injected at the requested process level.

Deprecations
~~~~~~~~~~~~

*   The :code:`--[no-]fast-compilation` option to :code:`codeql test run` is now deprecated.

New Features
~~~~~~~~~~~~

*   Kotlin support is now in beta. This means that Java analyses will also include Kotlin code by default. Kotlin support can be disabled by setting :code:`CODEQL_EXTRACTOR_JAVA_AGENT_DISABLE_KOTLIN` to :code:`true` in the environment.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed a bug that would cause the extractor to crash when an :code:`import` type is used in the :code:`extends` clause of an :code:`interface`.
*   Fixed an issue with multi-line strings in YAML files being associated with an invalid location,
    causing alerts related to such strings to appear at the top of the YAML file.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for :code:`@hapi/glue` and Hapi plugins to the :code:`frameworks/Hapi.qll` library.

Ruby
""""

*   The :code:`rb/sql-injection` query now considers consider SQL constructions, such as calls to :code:`Arel.sql`, as sinks.

New Queries
~~~~~~~~~~~

Java
""""

*   The query :code:`java/insufficient-key-size` has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @luchua-bc <https://github.com/github/codeql/pull/4926>`__.
*   Added a new query, :code:`java/android/sensitive-keyboard-cache`, to detect instances of sensitive information possibly being saved to the Android keyboard cache.

Ruby
""""

*   Added a new query, :code:`rb/shell-command-constructed-from-input`, to detect libraries that unsafely construct shell commands from their inputs.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 4.9.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The :code:`[Summary|Sink|Source]ModelCsv` classes have been deprecated and Models as Data models are defined as data extensions instead.

Java
""""

*   The ReDoS libraries in :code:`semmle.code.java.security.regexp` has been moved to a shared pack inside the :code:`shared/` folder, and the previous location has been deprecated.
*   Added data flow summaries for tainted Android intents sent to activities via :code:`Activity.startActivities`.

Python
""""""

*   The ReDoS libraries in :code:`semmle.code.python.security.regexp` have been moved to a shared pack inside the :code:`shared/` folder, and the previous location has been deprecated.

Ruby
""""

*   Data flow through the :code:`ActiveSupport` extension :code:`Enumerable#index_by` is now modeled.
*   The :code:`codeql.ruby.Concepts` library now has a :code:`SqlConstruction` class, in addition to the existing :code:`SqlExecution` class.
*   Calls to :code:`Arel.sql` are now modeled as instances of the new :code:`SqlConstruction` concept.
*   Arguments to RPC endpoints (public methods) on subclasses of :code:`ActionCable::Channel::Base` are now recognized as sources of remote user input.
*   Taint flow through the :code:`ActiveSupport` extensions :code:`Hash#reverse_merge` and :code:`Hash:reverse_merge!`, and their aliases, is now modeled more generally, where previously it was only modeled in the context of :code:`ActionController` parameters.
*   Calls to :code:`logger` in :code:`ActiveSupport` actions are now recognised as logger instances.
*   Calls to :code:`send_data` in :code:`ActiveSupport` actions are recognised as HTTP responses.
*   Calls to :code:`body_stream` in :code:`ActiveSupport` actions are recognised as HTTP request accesses.
*   The :code:`ActiveSupport` extensions :code:`Object#try` and :code:`Object#try!` are now recognised as code executions.

New Features
~~~~~~~~~~~~

Java
""""

*   Kotlin support is now in beta. This means that Java analyses will also include Kotlin code by default. Kotlin support can be disabled by setting :code:`CODEQL_EXTRACTOR_JAVA_AGENT_DISABLE_KOTLIN` to :code:`true` in the environment.
*   The new :code:`string Compilation.getInfo(string)` predicate provides access to some information about compilations.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Regular Expression Analysis
"""""""""""""""""""""""""""

*   Initial release. Extracted common regex related code, including the ReDoS analysis, into a library pack to share code between languages.

.. |link-code-trace-process-level-1| replace:: :code:`--trace-process-level`\ 
.. _link-code-trace-process-level-1: https://codeql.github.com/docs/codeql-cli/manual/database-init/#cmdoption-codeql-database-init-trace-process-level




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.11.5.rst
.. _codeql-cli-2.11.5:

==========================
CodeQL 2.11.5 (2022-12-07)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.11.5 runs a total of 361 security queries when configured with the Default suite (covering 150 CWE). The Extended suite enables an additional 112 queries (covering 32 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug that could cause log summary generation to fail in vscode.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.17.3.rst
.. _codeql-cli-2.17.3:

==========================
CodeQL 2.17.3 (2024-05-17)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.17.3 runs a total of 414 security queries when configured with the Default suite (covering 161 CWE). The Extended suite enables an additional 131 queries (covering 35 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Improvements
~~~~~~~~~~~~

*   The language server that our IDE integration is built on now defaults to fine-grained dependency tracking for incremental error-checking after file changes. This slightly improves the latency of refreshing errors after local source code edits and will enable significant speedups in the future.
*   We now properly handle globs (such as :code:`folder/**/*.py`) in :code:`paths` configuration to specify what files to include for Python analysis (see https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#specifying-directories-to-scan).
*   TRAP import (a part of :code:`codeql database create` and :code:`codeql database finalize`)
    now supports allocating 2^32 IDs during the import process. The previous limit was 2^31 IDs.

Query Packs
-----------

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/iterator-to-expired-container`, to detect the creation of iterators owned by a temporary objects that are about to be destroyed.

Python
""""""

*   The :code:`py/header-injection` query, originally contributed to the experimental query pack by @jorgectf, has been promoted to the main query pack and renamed to :code:`py/http-response-splitting`. This query finds instances of http header injection / response splitting vulnerabilities.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

Java
""""

*   The Java extractor no longer supports the :code:`ODASA_JAVA_LAYOUT`, :code:`ODASA_TOOLS` and :code:`ODASA_HOME` legacy environment variables.
*   The Java extractor no longer supports the :code:`ODASA_BUILD_ERROR_DIR` legacy environment variable.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Added modeling of the :code:`pyramid` framework, leading to new remote flow sources and sinks.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   Fixed a bug that stopped built-in functions from being referenced using the predicate :code:`hasQualifiedName` because technically they do not belong to any package. Now you can use the empty string as the package, e.g. :code:`f.hasQualifiedName("", "len")`.
*   Fixed a bug that stopped data flow models for built-in functions from having any effect because the package "" was not parsed correctly.
*   Fixed a bug that stopped data flow from being followed through variadic arguments to built-in functions or to functions called using a variable.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.5.6.rst
.. _codeql-cli-2.5.6:

=========================
CodeQL 2.5.6 (2021-06-22)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.5.6 runs a total of 266 security queries when configured with the Default suite (covering 114 CWE). The Extended suite enables an additional 57 queries (covering 28 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   :code:`codeql database create` (and the plumbing commands it comprises)
    now supports creating databases for a source tree with several languages while tracing a single build. This is enabled by a new
    :code:`--db-cluster` option. Once created, the multiple databases must be
    *analyzed* one by one.
    
*   :code:`codeql database create` and :code:`codeql database init` now accept an
    :code:`--overwrite` argument which will lead existing CodeQL databases to be overwritten.
    
*   :code:`codeql database analyze` now supports "diagnostic" queries (tagged
    :code:`@kind diagnostic`), which are intended to report information about the analysis process itself rather than problems with the analyzed code. The results of these queries will be summarized in a table printed to the terminal when :code:`codeql database analyze` finishes.
    
    They are also included in the analysis results in SARIF output formats as `notification objects <https://docs.oasis-open.org/sarif/sarif/v2.1.0/os/sarif-v2.1.0-os.html#_Toc34317894>`__ so they can be displayed by subsequent tooling such as the Code Scanning user interface.

    *   For SARIF v2.1.0, a reporting descriptor object for each diagnostic query is output to output to
        :code:`runs[].tool.driver.notifications`, or
        :code:`runs[].tool.extensions[].notifications` if running with
        :code:`--sarif-group-rules-by-pack`. A rule object for each diagnostic query is output to :code:`runs[].resources[].rules` for SARIF v2, or to
        :code:`runs[].rules` for SARIF v1.
        
    *   Results of diagnostic queries are exported to the
        :code:`runs[].invocations[].toolExecutionNotifications` property in SARIF v2.1.0, the :code:`runs[].invocations[].toolNotifications` property in SARIF v2, and the :code:`runs[].toolNotifications` property in SARIF v1.

    SARIF v2.1.0 output will now also contain version information for query packs in :code:`runs[].tool.extensions[].semanticVersion`, if the Git commit the queries come from is known.
    
*   :code:`codeql github upload-results` has a :code:`--checkout-path` option which will attempt to automatically configure upload target parameters.
    When this is given, the :code:`--commit` option will be taken from the HEAD of the checkout Git repository, and if there is precisely one remote configured in the local repository, the :code:`--repository` and
    :code:`--github-url` options will also be automatically configured.
    
*   The CodeQL C++ extractor includes beta support for C++20.
    This is only available when building codebases with GCC on Linux.
    C++20 modules are **not** supported.
    



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.15.1.rst
.. _codeql-cli-2.15.1:

==========================
CodeQL 2.15.1 (2023-10-19)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.15.1 runs a total of 398 security queries when configured with the Default suite (covering 158 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The query server's :code:`evaluation/trimCache` command was previously equivalent to the :code:`codeql database cleanup --mode=gentle` CLI command, but is now equivalent to using :code:`--mode=normal`. The new meaning of the command is to clear the entire evaluation cache of a database except for predicates annotated with the :code:`cached` keyword.

Bug Fixes
~~~~~~~~~

*   Fixed a bug where the :code:`$CODEQL_JAVA_HOME` environment variable was erroneously ignored for certain subsidiary Java processes started by
    :code:`codeql`.
*   Fixed a bug in the CodeQL build tracer on Apple Silicon machines that prevented database creation if System Integrity Protection was disabled.

Deprecations
~~~~~~~~~~~~

*   The accepted values of the :code:`--mode` option for :code:`codeql database cleanup`  have been renamed to bring them in line with what they are called in the VSCode extension and the query server:

    *   :code:`--mode=brutal` is now :code:`--mode=clear`.
    *   :code:`--mode=normal` is now :code:`--mode=trim`.
    *   :code:`--mode=light` is now :code:`--mode=fit`.
    *   The old names are deprecated, but will be accepted for backwards-compatibility reasons until further notice.

Improvements
~~~~~~~~~~~~

*   The list of failed tests at the end of a :code:`codeql test run` is now sorted lexicographically.
*   The syntax of DIL now more closely resembles the QL source code that it is compiled from. In particular, conjunctions and disjunctions now use the familiar :code:`and` and :code:`or` keywords, and clauses are enclosed in curly braces.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The :code:`cs/web/insecure-direct-object-reference` and :code:`cs/web/missing-function-level-access-control` have been improved to better recognize attributes on generic classes.

Golang
""""""

*   The query "Incorrect conversion between integer types" (:code:`go/incorrect-integer-conversion`) has been improved. It can now detect parsing an unsigned integer type (like :code:`uint32`) and converting it to the signed integer type of the same size (like :code:`int32`), which may lead to more results. It also treats :code:`int` and :code:`uint` more carefully, which may lead to more results or fewer incorrect results.

Java
""""

*   Most data flow queries that track flow from *remote* flow sources now use the current *threat model* configuration instead. This doesn't lead to any changes in the produced alerts (as the default configuration is *remote* flow sources) unless the threat model configuration is changed.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added the :code:`AmdModuleDefinition::Range` class, making it possible to define custom aliases for the AMD :code:`define` function.

Swift
"""""

*   Added more new logging sinks to the :code:`swift/cleartext-logging` query.
*   Added sinks for the GRDB database library to the :code:`swift/hardcoded-key` query.
*   Added sqlite3 and SQLite.swift sinks and flow summaries for the :code:`swift/hardcoded-key` query.
*   Added sqlite3 and SQLite.swift sinks and flow summaries for the :code:`swift/cleartext-storage-database` query.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   The query :code:`cpp/redundant-null-check-simple` has been promoted to Code Scanning. The query finds cases where a pointer is compared to null after it has already been dereferenced. Such comparisons likely indicate a bug at the place where the pointer is dereferenced, or where the pointer is compared to null.
    
    Note: This query was incorrectly noted as being promoted to Code Scanning in CodeQL version 2.14.6.

Ruby
""""

*   Added a new experimental query, :code:`rb/jwt-empty-secret-or-algorithm`, to detect when application uses an empty secret or weak algorithm.
*   Added a new experimental query, :code:`rb/jwt-missing-verification`, to detect when the application does not verify a JWT payload.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Deleted the deprecated :code:`AnalysedString` class, use the new name :code:`AnalyzedString`.
*   Deleted the deprecated :code:`isBarrierGuard` predicate from the dataflow library and its uses, use :code:`isBarrier` and the :code:`BarrierGuard` module instead.

C#
""

*   Deleted the deprecated :code:`isBarrierGuard` predicate from the dataflow library and its uses, use :code:`isBarrier` and the :code:`BarrierGuard` module instead.

Golang
""""""

*   Deleted the deprecated :code:`isBarrierGuard` predicate from the dataflow library and its uses, use :code:`isBarrier` and the :code:`BarrierGuard` module instead.
*   Support has been added for file system access sinks in the following libraries: \ `net/http <https://pkg.go.dev/net/http>`__, `Afero <https://github.com/spf13/afero>`__, `beego <https://pkg.go.dev/github.com/astaxie/beego>`__, `Echo <https://pkg.go.dev/github.com/labstack/echo>`__, `Fiber <https://github.com/kataras/iris>`__, `Gin <https://pkg.go.dev/github.com/gin-gonic/gin>`__, `Iris <https://github.com/kataras/iris>`__.
*   Added :code:`GoKit.qll` to :code:`go.qll` enabling the GoKit framework by default

Java
""""

*   The :code:`isBarrier`, :code:`isBarrierIn`, :code:`isBarrierOut`, and :code:`isAdditionalFlowStep` methods of the taint-tracking configurations for local queries in the :code:`ArithmeticTaintedLocalQuery`, :code:`ExternallyControlledFormatStringLocalQuery`, :code:`ImproperValidationOfArrayIndexQuery`, :code:`NumericCastTaintedQuery`, :code:`ResponseSplittingLocalQuery`, :code:`SqlTaintedLocalQuery`, and :code:`XssLocalQuery` libraries have been changed to match their remote counterpart configurations.
*   Deleted the deprecated :code:`isBarrierGuard` predicate from the dataflow library and its uses, use :code:`isBarrier` and the :code:`BarrierGuard` module instead.
*   Deleted the deprecated :code:`getAValue` predicate from the :code:`Annotation` class.
*   Deleted the deprecated alias :code:`FloatingPointLiteral`, use :code:`FloatLiteral` instead.
*   Deleted the deprecated :code:`getASuppressedWarningLiteral` predicate from the :code:`SuppressWarningsAnnotation` class.
*   Deleted the deprecated :code:`getATargetExpression` predicate form the :code:`TargetAnnotation` class.
*   Deleted the deprecated :code:`getRetentionPolicyExpression` predicate from the :code:`RetentionAnnotation` class.
*   Deleted the deprecated :code:`conditionCheck` predicate from :code:`Preconditions.qll`.
*   Deleted the deprecated :code:`semmle.code.java.security.performance` folder, use :code:`semmle.code.java.security.regexp` instead.
*   Deleted the deprecated :code:`ExternalAPI` class from :code:`ExternalApi.qll`, use :code:`ExternalApi` instead.
*   Modified the :code:`EnvInput` class in :code:`semmle.code.java.dataflow.FlowSources` to include :code:`environment` and :code:`file` source nodes.
    There are no changes to results unless you add source models using the :code:`environment` or :code:`file` source kinds.
*   Added :code:`environment` source models for the following methods:

    *   :code:`java.lang.System#getenv`
    *   :code:`java.lang.System#getProperties`
    *   :code:`java.lang.System#getProperty`
    *   :code:`java.util.Properties#get`
    *   :code:`java.util.Properties#getProperty`
    
*   Added :code:`file` source models for the following methods:

    *   the :code:`java.io.FileInputStream` constructor
    *   :code:`hudson.FilePath#newInputStreamDenyingSymlinkAsNeeded`
    *   :code:`hudson.FilePath#openInputStream`
    *   :code:`hudson.FilePath#read`
    *   :code:`hudson.FilePath#readFromOffset`
    *   :code:`hudson.FilePath#readToString`
    
*   Modified the :code:`DatabaseInput` class in :code:`semmle.code.java.dataflow.FlowSources` to include :code:`database` source nodes.
    There are no changes to results unless you add source models using the :code:`database` source kind.
*   Added :code:`database` source models for the following method:

    *   :code:`java.sql.ResultSet#getString`

JavaScript/TypeScript
"""""""""""""""""""""

*   The contents of :code:`.jsp` files are now extracted, and any :code:`<script>` tags inside these files will be parsed as JavaScript.
*   \ `Import attributes <https://github.com/tc39/proposal-import-attributes>`__ are now supported in JavaScript code.
    Note that import attributes are an evolution of an earlier proposal called "import assertions", which were implemented in TypeScript 4.5.
    The QL library includes new predicates named :code:`getImportAttributes()` that should be used in favor of the now deprecated :code:`getImportAssertion()`\ ;
    in addition, the :code:`getImportAttributes()` method of the :code:`DynamicImportExpr` has been renamed to :code:`getImportOptions()`.
*   Deleted the deprecated :code:`getAnImmediateUse`, :code:`getAUse`, :code:`getARhs`, and :code:`getAValueReachingRhs` predicates from the :code:`API::Node` class.
*   Deleted the deprecated :code:`mayReferToParameter` predicate from :code:`DataFlow::Node`.
*   Deleted the deprecated :code:`getStaticMethod` and :code:`getAStaticMethod` predicates from :code:`DataFlow::ClassNode`.
*   Deleted the deprecated :code:`isLibaryFile` predicate from :code:`ClassifyFiles.qll`, use :code:`isLibraryFile` instead.
*   Deleted many library models that were build on the AST. Use the new models that are build on the dataflow library instead.
*   Deleted the deprecated :code:`semmle.javascript.security.performance` folder, use :code:`semmle.javascript.security.regexp` instead.
*   Tagged template literals have been added to :code:`DataFlow::CallNode`. This allows the analysis to find flow into functions called with a tagged template literal,
    and the arguments to a tagged template literal are part of the API-graph in :code:`ApiGraphs.qll`.

Python
""""""

*   Added better support for API graphs when encountering :code:`from ... import *`. For example in the code :code:`from foo import *; Bar()`, we will now find a result for :code:`API::moduleImport("foo").getMember("Bar").getACall()`
*   Deleted the deprecated :code:`isBarrierGuard` predicate from the dataflow library and its uses, use :code:`isBarrier` and the :code:`BarrierGuard` module instead.
*   Deleted the deprecated :code:`getAUse`, :code:`getAnImmediateUse`, :code:`getARhs`, and :code:`getAValueReachingRhs` predicates from the :code:`API::Node` class.
*   Deleted the deprecated :code:`fullyQualifiedToAPIGraphPath` class from :code:`SubclassFinder.qll`, use :code:`fullyQualifiedToApiGraphPath` instead.
*   Deleted the deprecated :code:`Paths.qll` file.
*   Deleted the deprecated :code:`semmle.python.security.performance` folder, use :code:`semmle.python.security.regexp` instead.
*   Deleted the deprecated :code:`semmle.python.security.strings` and :code:`semmle.python.web` folders.
*   Improved modeling of decoding through pickle related functions (which can lead to code execution), resulting in additional sinks for the *Deserializing untrusted input* query (:code:`py/unsafe-deserialization`). Added support for :code:`pandas.read_pickle`, :code:`numpy.load` and :code:`joblib.load`.

Ruby
""""

*   Deleted the deprecated :code:`isBarrierGuard` predicate from the dataflow library and its uses, use :code:`isBarrier` and the :code:`BarrierGuard` module instead.
*   Deleted the deprecated :code:`isWeak` predicate from the :code:`CryptographicOperation` class.
*   Deleted the deprecated :code:`getStringOrSymbol` and :code:`isStringOrSymbol` predicates from the :code:`ConstantValue` class.
*   Deleted the deprecated :code:`getAPI` from the :code:`IOOrFileMethodCall` class.
*   Deleted the deprecated :code:`codeql.ruby.security.performance` folder, use :code:`codeql.ruby.security.regexp` instead.
*   GraphQL enums are no longer considered remote flow sources.

Swift
"""""

*   Improved taint models for :code:`Numeric` types and :code:`RangeReplaceableCollection`\ s.
*   The nil-coalescing operator :code:`??` is now supported by the CFG construction and dataflow libraries.
*   The data flow library now supports flow to the loop variable of for-in loops.
*   The methods :code:`getIteratorVar` and :code:`getNextCall` have been added to the :code:`ForEachStmt` class.

New Features
~~~~~~~~~~~~

Java
""""

*   Added predicate :code:`MemberRefExpr::getReceiverExpr`\ 



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.0.rst
.. _codeql-cli-2.12.0:

==========================
CodeQL 2.12.0 (2023-01-10)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.0 runs a total of 365 security queries when configured with the Default suite (covering 150 CWE). The Extended suite enables an additional 116 queries (covering 32 more CWE). 8 security queries have been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The :code:`--[no-]count-lines` option to :code:`codeql database create` and related commands that was deprecated in 2.11.1 has been removed. Users of this option should instead pass
    :code:`--[no-]calculate-baseline`.

Bug Fixes
~~~~~~~~~

*   Fixed a bug where the :code:`codeql pack install` command would fail if a `CodeQL configuration file <https://codeql.github.com/docs/codeql-cli/specifying-command-options-in-a-codeql-configuration-file/#using-a-codeql-configuration-file>`__ is used and the :code:`--additional-packs` option is specified.

New Features
~~~~~~~~~~~~

*   Query packs created by :code:`codeql pack create`, :code:`codeql pack bundle`, and :code:`codeql pack release` now contain precompiled queries in a new format that aims to be compatible with future (and, to a certain extent, past) releases of the CodeQL CLI. Previously the precompiled queries were in a format specific to each CLI release, and all other releases would need to re-compile queries.
    
    Published packs contain precompiled queries in files with a :code:`.qlx` extension located next to each query's :code:`.ql` source file.  In case of differences between the :code:`.ql` and :code:`.qlx` files, the :code:`.qlx` file takes priority when evaluating queries from the command line, so if you need to modify a published pack, be sure to delete the :code:`.qlx` files first.
    
    A new :code:`--precompile` flag to :code:`codeql query compile` can be used to construct :code:`*.qlx` file explicitly, but in all usual cases it should be enough to rely on :code:`codeql pack create` doing the right thing.
    
*   The :code:`codeql database init` command now accepts a PAT that allows you to download queries from external, private repositories when using the :code:`--codescanning-config <config-file>` option. For example, you can specify the following queries block in the config file, which will checkout the main branch of the :code:`codeql-test/my-private-repository` repository and evaluate any queries found in that repository:

    ..  code-block:: yaml
    
        queries:
          - codeql-test/my-private-repository@main
        
    If the repository is private, you can add a :code:`--external-repository-token-stdin` option and supply a PAT with appropriate permissions via standard input. For more information on queries and external repositories in Code Scanning, see `Using queries in QL packs <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#using-queries-in-ql-packs>`__.
    
*   The baseline information produced by :code:`codeql database init` and
    :code:`codeql database create` now accounts for
    |link-code-paths-and-code-paths-ignore-configuration-1|_.
    
*   In the VS Code extension, recursive calls will be marked with inlay hints. These can be disabled with the global inlay hints setting
    (:code:`editor.inlayHints.enabled`). If you just want to disable them for codeql the settings can be scoped to just codeql files (language id is :code:`ql`).
    See `Language Specific Editor Settings <https://code.visualstudio.com/docs/getstarted/settings#_language-specific-editor-settings>`__ in the VS Code documentation for more information.
    
*   The CLI now gives a more helpful error message when asked to run queries on a database that has not been finalized.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

C#
""

*   Fixes a bug where the Owin.qll framework library will look for "URI" instead of "Uri" in the OwinRequest class.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`AlertSuppression.ql` query has been updated to support the new :code:`// codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`// lgtm` and :code:`// lgtm[query-id]` comments can now also be placed on the line before an alert.
*   The :code:`cpp/missing-check-scanf` query no longer reports the free'ing of :code:`scanf` output variables as potential reads.

C#
""

*   The :code:`AlertSuppression.ql` query has been updated to support the new :code:`// codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`// lgtm` and :code:`// lgtm[query-id]` comments can now also be placed on the line before an alert.
*   The extensible predicates for Models as Data have been renamed (the :code:`ext` prefix has been removed). As an example, :code:`extSummaryModel` has been renamed to :code:`summaryModel`.

Golang
""""""

*   The :code:`AlertSuppression.ql` query has been updated to support the new :code:`// codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`// lgtm` and :code:`// lgtm[query-id]` comments can now also be placed on the line before an alert.

Java
""""

*   The :code:`AlertSuppression.ql` query has been updated to support the new :code:`// codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`// lgtm` and :code:`// lgtm[query-id]` comments can now also be placed on the line before an alert.
*   The extensible predicates for Models as Data have been renamed (the :code:`ext` prefix has been removed). As an example, :code:`extSummaryModel` has been renamed to :code:`summaryModel`.
*   The query :code:`java/misnamed-type` is now enabled for Kotlin.
*   The query :code:`java/non-serializable-field` is now enabled for Kotlin.
*   Fixed an issue in the query :code:`java/android/implicit-pendingintents` by which an implicit Pending Intent marked as immutable was not correctly recognized as such.
*   The query :code:`java/maven/non-https-url` no longer alerts about disabled repositories.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`AlertSuppression.ql` query has been updated to support the new :code:`// codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`// lgtm` and :code:`// lgtm[query-id]` comments can now also be placed on the line before an alert.

Python
""""""

*   The :code:`analysis/AlertSuppression.ql` query has moved to the root folder. Users that refer to this query by path should update their configurations. The query has been updated to support the new :code:`# codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`# lgtm` and :code:`# lgtm[query-id]` comments can now also be placed on the line before an alert.
*   Bumped the minimum keysize we consider secure for elliptic curve cryptography from 224 to 256 bits, following current best practices. This might effect results from the *Use of weak cryptographic key* (:code:`py/weak-crypto-key`) query.
*   Added modeling of :code:`getpass.getpass` as a source of passwords, which will be an additional source for :code:`py/clear-text-logging-sensitive-data`, :code:`py/clear-text-storage-sensitive-data`, and :code:`py/weak-sensitive-data-hashing`.

Ruby
""""

*   The :code:`AlertSuppression.ql` query has been updated to support the new :code:`# codeql[query-id]` supression comments. These comments can be used to suppress an alert and must be placed on a blank line before the alert. In addition the legacy :code:`# lgtm` and :code:`# lgtm[query-id]` comments can now also be placed on the line before an alert.
*   Extended the :code:`rb/kernel-open` query with following sinks: :code:`IO.write`, :code:`IO.binread`, :code:`IO.binwrite`, :code:`IO.foreach`, :code:`IO.readlines`, and :code:`URI.open`.

New Queries
~~~~~~~~~~~

C#
""

*   Added a new query, :code:`csharp/telemetry/supported-external-api`, to detect supported 3rd party APIs used in a codebase.

Java
""""

*   Added a new query, :code:`java/summary/generated-vs-manual-coverage`, to expose metrics for the number of API endpoints covered by generated versus manual MaD models.
*   Added a new query, :code:`java/telemetry/supported-external-api`, to detect supported 3rd party APIs used in a codebase.
*   Added a new query, :code:`java/android/missing-certificate-pinning`, to find network calls where certificate pinning is not implemented.
*   Added a new query, :code:`java/android-webview-addjavascriptinterface`, to detect the use of :code:`addJavascriptInterface`, which can lead to cross-site scripting.
*   Added a new query, :code:`java/android-websettings-file-access`, to detect configurations that enable file system access in Android WebViews.
*   Added a new query, :code:`java/android-websettings-javascript-enabled`, to detect if JavaScript execution is enabled in an Android WebView.
*   The query :code:`java/regex-injection` has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @edvraa <https://github.com/github/codeql/pull/5704>`__.

Ruby
""""

*   Added a new query, :code:`rb/stack-trace-exposure`, to detect exposure of stack-traces to users via HTTP responses.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   Fixed an issue in the taint tracking analysis where implicit reads were not allowed by default in sinks or additional taint steps that used flow states.

Java
""""

*   We now correctly handle empty block comments, like :code:`/**/`. Previously these could be mistaken for Javadoc comments and led to attribution of Javadoc tags to the wrong declaration.

Python
""""""

*   :code:`except*` is now supported.
*   The result of :code:`Try.getAHandler` and :code:`Try.getHandler(<index>)` is no longer of type :code:`ExceptStmt`, as handlers may also be :code:`ExceptGroupStmt`\ s (After Python 3.11 introduced PEP 654). Instead, it is of the new type :code:`ExceptionHandler` of which :code:`ExceptStmt` and :code:`ExceptGroupStmt` are subtypes. To support selecting only one type of handler, :code:`Try.getANormalHandler` and :code:`Try.getAGroupHandler` have been added. Existing uses of :code:`Try.getAHandler` for which it is important to select only normal handlers, will need to be updated to :code:`Try.getANormalHandler`.

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The predicates in the :code:`MustFlow::Configuration` class used by the :code:`MustFlow` library (:code:`semmle.code.cpp.ir.dataflow.MustFlow`) have changed to be defined directly in terms of the C++ IR instead of IR dataflow nodes.

Golang
""""""

*   The signature of :code:`allowImplicitRead` on :code:`DataFlow::Configuration` and :code:`TaintTracking::Configuration` has changed from :code:`allowImplicitRead(DataFlow::Node node, DataFlow::Content c)` to :code:`allowImplicitRead(DataFlow::Node node, DataFlow::ContentSet c)`.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   The *PAM authorization bypass due to incorrect usage* (:code:`py/pam-auth-bypass`) query has been converted to a taint-tracking query, resulting in significantly fewer false positives.

Ruby
""""

*   Flow through :code:`initialize` constructors is now taken into account. For example, in

    ..  code-block:: rb
    
        class C
          def initialize(x)
            @field = x
          end
        end
        
        C.new(y)
        
    there will be flow from :code:`y` to the field :code:`@field` on the constructed :code:`C` object.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`ArgvSource` flow source now uses the second parameter of :code:`main` as its source instead of the uses of this parameter.
*   The :code:`ArgvSource` flow source has been generalized to handle cases where the argument vector of :code:`main` is not named :code:`argv`.
*   The :code:`getaddrinfo` function is now recognized as a flow source.
*   The :code:`secure_getenv` and :code:`_wgetenv` functions are now recognized as local flow sources.
*   The :code:`scanf` and :code:`fscanf` functions and their variants are now recognized as flow sources.
*   Deleted the deprecated :code:`getName` and :code:`getShortName` predicates from the :code:`Folder` class.

C#
""

*   C# 11: Added support for list- and slice patterns in the extractor.
*   Deleted the deprecated :code:`getNameWithoutBrackets` predicate from the :code:`ValueOrRefType` class in :code:`Type.qll`.
*   :code:`Element::hasQualifiedName/1` has been deprecated. Use :code:`hasQualifiedName/2` or :code:`hasQualifiedName/3` instead.
*   Added TCP/UDP sockets as taint sources.

Golang
""""""

*   The predicate :code:`getNumParameter` on :code:`FuncTypeExpr` has been changed to actually give the number of parameters. It previously gave the number of parameter declarations. :code:`getNumParameterDecl` has been introduced to preserve this functionality.
*   The definition of :code:`mayHaveSideEffects` for :code:`ReturnStmt` was incorrect when more than one expression was being returned. Such return statements were effectively considered to never have side effects. This has now been fixed. In rare circumstances :code:`globalValueNumber` may have incorrectly treated two values as the same when they were in fact distinct.
*   Queries that care about SQL, such as :code:`go/sql-injection`, now recognise SQL-consuming functions belonging to the :code:`gorqlite` and :code:`GoFrame` packages.
*   :code:`rsync` has been added to the list of commands which may evaluate its parameters as a shell command.

Java
""""

*   Added more dataflow models for frequently-used JDK APIs.
*   The extraction of Kotlin extension methods has been improved when default parameter values are present. The dispatch and extension receiver parameters are extracted in the correct order. The :code:`ExtensionMethod::getExtensionReceiverParameterIndex` predicate has been introduced to facilitate getting the correct extension parameter index.
*   The query :code:`java/insecure-cookie` now uses global dataflow to track secure cookies being set to the HTTP response object.
*   The library :code:`PathSanitizer.qll` has been improved to detect more path validation patterns in Kotlin.
*   Models as Data models for Java are defined as data extensions instead of being inlined in the code. New models should be added in the :code:`lib/ext` folder.
*   Added a taint model for the method :code:`java.nio.file.Path.getParent`.
*   Fixed a problem in the taint model for the method :code:`java.nio.file.Paths.get`.
*   Deleted the deprecated :code:`LocalClassDeclStmtNode` and :code:`LocalClassDeclStmt` classes from :code:`PrintAst.qll` and :code:`Statement.qll` respectively.
*   Deleted the deprecated :code:`getLocalClass` predicate from :code:`LocalTypeDeclStmt`, and the deprecated :code:`getLocalClassDeclStmt` predicate from :code:`LocalClassOrInterface`.
*   Added support for Android Manifest :code:`<activity-aliases>` elements in data flow sources.

JavaScript/TypeScript
"""""""""""""""""""""

*   Deleted the deprecated :code:`Instance` class from the :code:`Vue` module.
*   Deleted the deprecated :code:`VHtmlSourceWrite` class from :code:`DomBasedXssQuery.qll`.
*   Deleted all the deprecated :code:`[QueryName].qll` files from the :code:`javascript/ql/lib/semmle/javascript/security/dataflow` folder, use the corresponding :code:`[QueryName]Query.qll` files instead.
*   The ReDoS libraries in :code:`semmle.code.javascript.security.regexp` has been moved to a shared pack inside the :code:`shared/` folder, and the previous location has been deprecated.

Python
""""""

*   Added :code:`subprocess.getoutput` and :code:`subprocess.getoutputstatus` as new command injection sinks for the StdLib.
*   The data-flow library has been rewritten to no longer rely on the points-to analysis in order to resolve references to modules. Improvements in the module resolution can lead to more results.
*   Deleted the deprecated :code:`importNode` predicate from the :code:`DataFlowUtil.qll` file.
*   Deleted the deprecated features from :code:`PEP249.qll` that were not inside the :code:`PEP249` module.
*   Deleted the deprecated :code:`werkzeug` from the :code:`Werkzeug` module in :code:`Werkzeug.qll`.
*   Deleted the deprecated :code:`methodResult` predicate from :code:`PEP249::Cursor`.

Ruby
""""

*   Calls to :code:`Kernel.load`, :code:`Kernel.require`, :code:`Kernel.autoload` are now modeled as sinks for path injection.
*   Calls to :code:`mail` and :code:`inbound_mail` in :code:`ActionMailbox` controllers are now considered sources of remote input.
*   Calls to :code:`GlobalID::Locator.locate` and its variants are now recognized as instances of :code:`OrmInstantiation`.
*   Data flow through the :code:`ActiveSupport` extensions :code:`Enumerable#index_with`, :code:`Enumerable#pick`, :code:`Enumerable#pluck` and :code:`Enumerable#sole`  are now modeled.
*   When resolving a method call, the analysis now also searches in sub-classes of the receiver's type.
*   Taint flow is now tracked through many common JSON parsing and generation methods.
*   The ReDoS libraries in :code:`codeql.ruby.security.regexp` has been moved to a shared pack inside the :code:`shared/` folder, and the previous location has been deprecated.
*   String literals and arrays of string literals in case expression patterns are now recognised as barrier guards.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   Deprecated :code:`semmle.code.cpp.ir.dataflow.DefaultTaintTracking`. Use :code:`semmle.code.cpp.ir.dataflow.TaintTracking`.
*   Deprecated :code:`semmle.code.cpp.security.TaintTrackingImpl`. Use :code:`semmle.code.cpp.ir.dataflow.TaintTracking`.
*   Deprecated :code:`semmle.code.cpp.valuenumbering.GlobalValueNumberingImpl`. Use :code:`semmle.code.cpp.valuenumbering.GlobalValueNumbering`, which exposes the same API.

Golang
""""""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.

New Features
~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Improved support for `Restify <http://restify.com/>`__ framework, leading to more results when scanning applications developed with this framework.
*   Added support for the `Spife <https://github.com/npm/spife>`__ framework.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Type Trackers
"""""""""""""

*   Initial release. Includes a parameterized module implementing type-trackers.

QL Detective Tutorial
"""""""""""""""""""""

*   Initial release. Contains the library for the CodeQL detective tutorials, helping new users learn to write CodeQL queries.

Utility Classes
"""""""""""""""

*   Initial release. Includes common utility classes and modules: Unit, Boolean, and Option.

.. |link-code-paths-and-code-paths-ignore-configuration-1| replace:: :code:`paths` and :code:`paths-ignore` configuration
.. _link-code-paths-and-code-paths-ignore-configuration-1: https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#specifying-directories-to-scan




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.10.2.rst
.. _codeql-cli-2.10.2:

==========================
CodeQL 2.10.2 (2022-08-02)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.10.2 runs a total of 341 security queries when configured with the Default suite (covering 144 CWE). The Extended suite enables an additional 104 queries (covering 30 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The option :code:`--compiler-spec` to :code:`codeql database create` (and
    :code:`codeql database trace-command`) no longer works. It is replaced by
    :code:`--extra-tracing-config`, which accepts a tracer configuration file in the new, Lua-based tracer configuration format instead. See
    :code:`tools/tracer/base.lua` for the precise API available. If you need help help porting your existing compiler specification files, please file a public issue in https://github.com/github/codeql-cli-binaries,
    or open a private ticket with GitHub support and request an escalation to engineering.

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   Versions of the CodeQL extension for Visual Studio Code released before February 2021 may not work correctly with this CLI, in particular if database upgrades are necessary. We recommend keeping your VS Code extension up-to-date.

Deprecations
~~~~~~~~~~~~

*   The experimental :code:`codeql resolve ml-models` command has been deprecated. Advanced users calling this command should use the new
    :code:`codeql resolve extensions` command instead.

New Features
~~~~~~~~~~~~

*   The :code:`codeql github upload-results` command now supports a :code:`--merge` option. If this option is provided, the command will accept the paths to multiple SARIF files, and will merge those files before uploading them as a single analysis. This option is recommended *only* for backwards compatibility with old analyses produced by the CodeQL Runner, which combined the results for multiple languages into a single analysis.

Query Packs
-----------

Breaking Changes
~~~~~~~~~~~~~~~~

Python
""""""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/python-all` package.

New Queries
~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   A new query "Case-sensitive middleware path" (:code:`js/case-sensitive-middleware-path`) has been added.
    It highlights middleware routes that can be bypassed due to having a case-sensitive regular expression path.

Ruby
""""

*   Added a new experimental query, :code:`rb/manually-checking-http-verb`, to detect cases when the HTTP verb for an incoming request is checked and then used as part of control flow.
*   Added a new experimental query, :code:`rb/weak-params`, to detect cases when the rails strong parameters pattern isn't followed and values flow into persistent store writes.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

C/C++
"""""

*   Under certain circumstances a variable declaration that is not also a definition could be associated with a :code:`Variable` that did not have the definition as a :code:`VariableDeclarationEntry`. This is now fixed, and a unique :code:`Variable` will exist that has both the declaration and the definition as a :code:`VariableDeclarationEntry`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The JUnit5 version of :code:`AssertNotNull` is now recognized, which removes related false positives in the nullness queries.
*   Added data flow models for :code:`java.util.Scanner`.

Ruby
""""

*   Calls to :code:`Arel.sql` are now recognised as propagating taint from their argument.
*   Calls to :code:`ActiveRecord::Relation#annotate` are now recognized as :code:`SqlExecution`\ s so that it will be considered as a sink for queries like rb/sql-injection.

New Features
~~~~~~~~~~~~

Java
""""

*   The QL predicate :code:`Expr::getUnderlyingExpr` has been added. It can be used to look through casts and not-null expressions and obtain the underlying expression to which they apply.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.4.rst
.. _codeql-cli-2.16.4:

==========================
CodeQL 2.16.4 (2024-03-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.4 runs a total of 409 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 132 queries (covering 34 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   A number of internal command line options (:code:`--builtin_functions_file`, :code:`--clang_builtin_functions`,
    :code:`--disable-objc-default-synthesize-properties`, :code:`--list_builtin_functions`, :code:`--memory-limit-bytes`,
    :code:`--mimic_config`, and :code:`--objc`) has been removed from the C/C++ extractor. It has never been possible to pass these options through the CLI itself, but some customers with advanced setups may have been passing them through internal undocumented interfaces. All of the removed options were already no-ops, and will now generate errors.
    
    The :code:`--verbosity` command line option has also been removed. The option was an alias for
    :code:`--codeql-verbosity`, which should be used instead.

Bug Fixes
~~~~~~~~~

*   When parsing user-authored YAML files such as :code:`codeql-pack.yml`,
    :code:`qlpack.yml`, :code:`codeql-workspace.yml`, and any YAML file defining a data extension, unquoted string values starting with a :code:`*` character are now correctly interpreted as YAML aliases. Previously, they were interpreted as strings, but with the first character skipped.
    
    If you see a parse error similar to :code:`while scanning an alias... unexpected` :code:`character found *(42)`,it likely means that you need to add quotes around the indicated string value. The most common cause is unquoted glob patterns that start with :code:`*`, such as :code:`include: **/*.yml`, which will need to be quoted as :code:`include: "**/*.yml"`.

Improvements
~~~~~~~~~~~~

*   The frontend of the C/C++ extractor has been updated, improving the extractor's reliability and increasing its ability to extract source code.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "non-constant format string" query (:code:`cpp/non-constant-format`) has been converted to a :code:`path-problem` query.
*   The new C/C++ dataflow and taint-tracking libraries (:code:`semmle.code.cpp.dataflow.new.DataFlow` and :code:`semmle.code.cpp.dataflow.new.TaintTracking`) now implicitly assume that dataflow and taint modelled via :code:`DataFlowFunction` and :code:`TaintFunction` always fully overwrite their buffers and thus act as flow barriers. As a result, many dataflow and taint-tracking queries now produce fewer false positives. To remove this assumption and go back to the previous behavior for a given model, one can override the new :code:`isPartialWrite` predicate.

C#
""

*   Most data flow queries that track flow from *remote* flow sources now use the current *threat model* configuration instead. This doesn't lead to any changes in the produced alerts (as the default configuration is *remote* flow sources) unless the threat model configuration is changed. The changed queries are :code:`cs/code-injection`, :code:`cs/command-line-injection`, :code:`cs/user-controlled-bypass`, :code:`cs/count-untrusted-data-external-api`, :code:`cs/untrusted-data-to-external-api`, :code:`cs/ldap-injection`, :code:`cs/log-forging`, :code:`cs/xml/missing-validation`, :code:`cs/redos`, :code:`cs/regex-injection`, :code:`cs/resource-injection`, :code:`cs/sql-injection`, :code:`cs/path-injection`, :code:`cs/unsafe-deserialization-untrusted-input`, :code:`cs/web/unvalidated-url-redirection`, :code:`cs/xml/insecure-dtd-handling`, :code:`cs/xml/xpath-injection`, :code:`cs/web/xss`, and :code:`cs/uncontrolled-format-string`.

Java
""""

*   To reduce the number of false positives in the query "Insertion of sensitive information into log files" (:code:`java/sensitive-log`), variables with names that contain "null" (case-insensitively) are no longer considered sources of sensitive information.

Ruby
""""

*   Calls to :code:`Object#method`, :code:`Object#public_method` and :code:`Object#singleton_method` with untrusted data are now recognised as sinks for code injection.
*   Added additional request sources for Ruby on Rails.

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query :code:`java/android/insecure-local-key-gen` for finding instances of keys generated for biometric authentication in an insecure way.

Python
""""""

*   The query :code:`py/nosql-injection` for finding NoSQL injection vulnerabilities is now part of the default security suite.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Golang
""""""

*   Fixed dataflow out of a :code:`map` using a :code:`range` statement.

Java
""""

*   Fixed the Java autobuilder overriding the version of Maven used by a project when the Maven wrapper :code:`mvnw` is in use and the :code:`maven-wrapper.jar` file is not present in the repository.
*   Some flow steps related to :code:`android.text.Editable.toString` that were accidentally disabled have been re-enabled.

Swift
"""""

*   Fixed an issue where :code:`TypeDecl.getFullName` would get stuck in an loop and fail when minor database inconsistencies are present.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Improved support for flow through captured variables that properly adheres to inter-procedural control flow.
*   We no longer make use of CodeQL database stats, which may affect join-orders in custom queries. It is therefore recommended to test performance of custom queries after upgrading to this version.

Golang
""""""

*   We have significantly improved the Go autobuilder to understand a greater range of project layouts, which allows Go source files to be analysed that could previously not be processed.
*   Go 1.22 has been included in the range of supported Go versions.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Added destructors for named objects to the intermediate representation.

C#
""

*   C# 12: Add QL library support (:code:`ExperimentalAttribute`) for the experimental attribute.
*   C# 12: Add extractor and QL library support for :code:`ref readonly` parameters.
*   C#: The table :code:`expr_compiler_generated` has been deleted and its content has been added to :code:`compiler_generated`.
*   Data flow via get only properties like :code:`public object Obj { get; }` is now captured by the data flow library.

Java
""""

*   Java expressions with erroneous types (e.g. the result of a call whose callee couldn't be resolved during extraction) are now given a CodeQL :code:`ErrorType` more often.

Python
""""""

*   Fixed missing flow for dictionary updates (:code:`d[<key>] = ...`) when :code:`<key>` is a string constant not used in dictionary literals or as name of keyword-argument.
*   Fixed flow for iterable unpacking (:code:`a,b = my_tuple`) when it occurs on top-level (module) scope.

Ruby
""""

*   Calls to :code:`I18n.translate` as well as Rails helper translate methods now propagate taint from their keyword arguments. The Rails translate methods are also recognized as XSS sanitizers when using keys marked as html safe.
*   Calls to :code:`Arel::Nodes::SqlLiteral.new` are now modeled as instances of the :code:`SqlConstruction` concept, as well as propagating taint from their argument.
*   Additional arguments beyond the first of calls to the  :code:`ActiveRecord` methods :code:`select`, :code:`reselect`, :code:`order`, :code:`reorder`, :code:`joins`, :code:`group`, and :code:`pluck` are now recognized as sql injection sinks.
*   Calls to several methods of :code:`ActiveRecord::Connection`, such as :code:`ActiveRecord::Connection#exec_query`, are now recognized as SQL executions, including those via subclasses.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.6.3.rst
.. _codeql-cli-2.6.3:

=========================
CodeQL 2.6.3 (2021-10-06)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.6.3 runs a total of 274 security queries when configured with the Default suite (covering 120 CWE). The Extended suite enables an additional 81 queries (covering 28 more CWE).

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The option :code:`--compiler-spec` accepted by some subcommands of :code:`codeql database` is deprecated.  It will be removed in a later version
    (earliest 2.7.0).  If you need this option, please file a public issue in https://github.com/github/codeql-cli-binaries, or open a private ticket with GitHub support and request an escalation to engineering.
    
*   By default, databases created using the CodeQL CLI will now have their underlying datasets finalized, meaning that no further data can be subsequently imported into them. This change should not affect most users.
    
*   The :code:`codeql resolve qlref` command will now throw an error when the target is ambiguous.  The qlref resolution rules are now as follows:

    #.  If the target of a qlref is in the same qlpack, then that target is always returned.
        
    #.  If multiple targets of the qlref are found in dependent packs,
        this is an error.

    Previously, the command would have arbitrarily chosen one of the targets and ignored any ambiguities.

Bug Fixes
~~~~~~~~~

*   Linux/MacOS: When tracing a build that involves an
    :code:`execvp`\ /\ :code:`execvpe` (Linux-only)/\ :code:`posix_spawnp` syscall where :code:`PATH` was not set in the environment, CodeQL sometimes would break the build.  Now, CodeQL uses the correct, platform-specific fallback for
    :code:`PATH` instead.
    
*   Linux/MacOS: When tracing a build that involves an :code:`execvpe` (Linux-only)/\ :code:`posix_spawnp` syscall, the :code:`PATH` lookup of the executable wrongly took place in the environment provided via
    :code:`envp`, instead of the environment of the process calling
    :code:`execvpe`\ /\ :code:`posix_spawnp`.  Now, the correct environment is used for the :code:`PATH` lookup.
    
*   A bug where query compilation would sometimes fail with a
    :code:`StackOverflowError` when compiling a query that uses :code:`instanceof` has now been fixed.

New Features
~~~~~~~~~~~~

*   The :code:`codeql query compile` command now accepts a :code:`--keep-going` or
    :code:`-k` option, which indicates that the compiler should continue compiling queries even if one of the queries has a compile error in it.
    
*   CLI commands now run default queries if none are specified. If no queries are specified, the :code:`codeql database analyze`, :code:`codeql database run-queries`, and :code:`codeql database interpret-results` commands will now run the default suite for the language being analyzed.
    
*   :code:`codeql pack publish` now copies the published package to the local package cache. In addition to publishing to a remote repository, the
    :code:`codeql pack publish` command will also copy the published package to the local package cache.
    



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.6.rst
.. _codeql-cli-2.14.6:

==========================
CodeQL 2.14.6 (2023-09-26)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.6 runs a total of 394 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 129 queries (covering 35 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   The tracking of RAM usage has been improved. This fixes some cases where CodeQL uses more RAM than requested.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed an extractor crash that could occur in projects containing TypeScript files larger than 10 MB.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.4.1.rst
.. _codeql-cli-2.4.1:

=========================
CodeQL 2.4.1 (2020-12-19)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.4.1 runs a total of 231 security queries when configured with the Default suite (covering 105 CWE). The Extended suite enables an additional 77 queries (covering 26 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   :code:`codeql query format` now checks all files rather than stopping after the first failure when the :code:`--check-only` option is given.
    
*   :code:`codeql resolve database` will produce a :code:`languages` key giving the language the database was created for. This can be useful in IDEs to help describe the database and suggest default actions or queries.
    For databases created by earlier versions, the result will be a best-effort guess.
    
*   :code:`codeql database interpret-results` can now produce Graphviz :code:`.dot` files from queries with :code:`@kind graph`.

Removed Features
~~~~~~~~~~~~~~~~

*   :code:`codeql test run` had some special compatibility support for running unit tests for the "code duplication" extractor features of certain discontinued Semmle products. Those tests have since been removed from the `public QL repository <https://github.com/github/codeql>`__,
    so the compatibility support for them has been removed. This should not affect any external users (since the extractor feature in question was never supported by :code:`codeql database create` anyway),
    but if you run :code:`codeql test run` against the unit tests belonging to an *old* checkout of the repository, you may now see some failures among :code:`Metrics` tests.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.6.2.rst
.. _codeql-cli-2.6.2:

=========================
CodeQL 2.6.2 (2021-09-21)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.6.2 runs a total of 274 security queries when configured with the Default suite (covering 120 CWE). The Extended suite enables an additional 81 queries (covering 28 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   A bug where :code:`codeql generate log-summary` would sometimes crash with a :code:`JsonMappingException` has been fixed.

Documentation
~~~~~~~~~~~~~

*   Documentation has been added detailing how to use the "indirect build tracing" feature, which is enabled by using the
    :code:`--begin-tracing` flag provided by :code:`codeql database init`. The new documentation can be found `here <https://aka.ms/codeql-docs/indirect-tracing>`__. This feature was temporarily described as "sandwiched tracing" in the 2.6.0 release notes.

New Features
~~~~~~~~~~~~

*   The CodeQL CLI now counts the lines of code found under
    :code:`--source-root` when :code:`codeql database init` or :code:`codeql database create` is called. This information can be viewed later by either the new :code:`codeql database print-baseline` command or the new
    :code:`--print-baseline-loc` argument to :code:`codeql database interpret-results`.
    
*   :code:`qlpack.yml` files now support an additional field :code:`include` in which glob patterns of additional files that should be included (or excluded) when creating a given CodeQL pack can be specified.
    
*   QL packs created by the experimental :code:`codeql pack create` command will now include some information about the build in a new
    :code:`buildMetadata` field of their :code:`qlpack.yml` file.
    
*   :code:`codeql database create` now supports the same flags as :code:`codeql database init` for automatically recognizing the languages present in checkouts of GitHub repositories:

    *   :code:`--github-url` accepts the URL of a custom GitHub instance
        (previously only :code:`github.com` was supported).
        
    *   :code:`--github-auth-stdin` allows a personal access token to be provided through standard input (previously only the
        :code:`GITHUB_TOKEN` environment variable was supported).




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.5.rst
.. _codeql-cli-2.16.5:

==========================
CodeQL 2.16.5 (2024-03-21)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.5 runs a total of 409 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 132 queries (covering 34 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Beta support has been added for analyzing Java codebases without needing a working build. To enable this, pass the :code:`--build-mode none` option to :code:`codeql database create`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.10.3.rst
.. _codeql-cli-2.10.3:

==========================
CodeQL 2.10.3 (2022-08-15)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.10.3 runs a total of 342 security queries when configured with the Default suite (covering 144 CWE). The Extended suite enables an additional 104 queries (covering 30 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   When called with :code:`--start-tracing`, the :code:`codeql database init` command now accepts extractor options for the indirect tracing environment via
    :code:`--extractor-option`. Users should continue to specify extractor options for direct tracing environments by passing them to
    :code:`codeql database trace-command` invocations.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.4.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The query :code:`java/sensitive-log` has been improved to no longer report results that are effectively duplicates due to one source flowing to another source.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The query :code:`cpp/bad-strncpy-size` now covers more :code:`strncpy`\ -like functions than before, including :code:`strxfrm`(:code:`_l`), :code:`wcsxfrm`(:code:`_l`), and :code:`stpncpy`. Users of this query may see an increase in results.

Golang
""""""

*   The query :code:`go/path-injection` no longer considers user-controlled numeric or boolean-typed data as potentially dangerous.

Java
""""

*   The query :code:`java/path-injection` now recognises vulnerable APIs defined using the :code:`SinkModelCsv` class with the :code:`create-file` type. Out of the box this includes Apache Commons-IO functions, as well as any user-defined sinks.

New Queries
~~~~~~~~~~~

Java
""""

*   A new query "Android :code:`WebView` that accepts all certificates" (:code:`java/improper-webview-certificate-validation`) has been added. This query finds implementations of :code:`WebViewClient`\ s that accept all certificates in the case of an SSL error.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The IR dataflow library now includes flow through global variables. This enables new findings in many scenarios.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Improved analysis of the Android class :code:`AsyncTask` so that data can properly flow through its methods according to the life-cycle steps described here: https://developer.android.com/reference/android/os/AsyncTask#the-4-steps.
*   Added a data-flow model for the :code:`setProperty` method of :code:`java.util.Properties`. Additional results may be found where relevant data is stored in and then retrieved from a :code:`Properties` instance.

Python
""""""

*   Change :code:`.getASubclass()` on :code:`API::Node` so it allows to follow subclasses even if the class has a class decorator.

Ruby
""""

*   Calls to methods generated by ActiveRecord associations are now recognised as instantiations of ActiveRecord objects. This increases the sensitivity of queries such as :code:`rb/sql-injection` and :code:`rb/stored-xss`.
*   Calls to :code:`ActiveRecord::Base.create` and :code:`ActiveRecord::Base.update` are now recognised as write accesses.
*   Arguments to :code:`Mime::Type#match?` and :code:`Mime::Type#=~` are now recognised as regular expression sources.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added a predicate :code:`getValueConstant` to :code:`AttributeArgument` that yields the argument value as an :code:`Expr` when the value is a constant expression.
*   A new class predicate :code:`MustFlowConfiguration::allowInterproceduralFlow` has been added to the :code:`semmle.code.cpp.ir.dataflow.MustFlow` library. The new predicate can be overridden to disable interprocedural flow.
*   Added subclasses of :code:`BuiltInOperations` for :code:`__builtin_bit_cast`, :code:`__builtin_shuffle`, :code:`__has_unique_object_representations`, :code:`__is_aggregate`, and :code:`__is_assignable`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.1.rst
.. _codeql-cli-2.12.1:

==========================
CodeQL 2.12.1 (2023-01-23)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.1 runs a total of 384 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 120 queries (covering 31 more CWE). 23 security queries have been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Added a new command-line flag :code:`--expect-discarded-cache`, which gives a hint to the evaluator that the evaluation cache will be discarded after analysis completes. This allows it to avoid some unnecessary writes to the cache, for predicates that aren't needed by the query/suite being evaluated.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/no-space-for-terminator` and :code:`cpp/uncontrolled-allocation-size` queries have been enhanced with heuristic detection of allocations. These queries now find more results.

Golang
""""""

*   Replacing "\r" or "\n" using the functions :code:`strings.ReplaceAll`, :code:`strings.Replace`, :code:`strings.Replacer.Replace` and :code:`strings.Replacer.WriteString` has been added as a sanitizer for the queries "Log entries created from user input".
*   The functions :code:`strings.Replacer.Replace` and :code:`strings.Replacer.WriteString` have been added as sanitizers for the query "Potentially unsafe quoting".

Java
""""

*   The name, description and alert message for the query :code:`java/concatenated-sql-query` have been altered to emphasize that the query flags the use of string concatenation to construct SQL queries, not the lack of appropriate escaping. The query's files have been renamed from :code:`SqlUnescaped.ql` and :code:`SqlUnescapedLib.qll` to :code:`SqlConcatenated.ql` and :code:`SqlConcatenatedLib.qll` respectively; in the unlikely event your custom configuration or queries refer to either of these files by name, those references will need to be adjusted. The query id remains :code:`java/concatenated-sql-query`, so alerts should not be re-raised as a result of this change.

Ruby
""""

*   The :code:`rb/unsafe-deserialization` query now recognizes input from STDIN as a source.

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query :code:`java/android/websettings-allow-content-access` to detect Android WebViews which do not disable access to :code:`content://` urls.

Ruby
""""

*   Added a new query, :code:`rb/unsafe-code-construction`, to detect libraries that unsafely construct code from their inputs.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Added library support for generic attributes (also for CIL extracted attributes).
*   :code:`cil.ConstructedType::getName` was changed to include printing of the type arguments.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Attributes on methods in CIL are now extracted (Bugfix).
*   Support for :code:`static virtual` and :code:`static abstract` interface members.
*   Support for *operators* in interface definitions.
*   C# 11: Added support for the unsigned right shift :code:`>>>` and unsigned right shift assignment :code:`>>>=` operators.
*   Query id's have been aligned such that they are prefixed with :code:`cs` instead of :code:`csharp`.

Java
""""

*   Added sink models for the constructors of :code:`org.springframework.jdbc.object.MappingSqlQuery` and :code:`org.springframework.jdbc.object.MappingSqlQueryWithParameters`.
*   Added more dataflow models for frequently-used JDK APIs.
*   Removed summary model for :code:`java.lang.String#endsWith(String)` and added neutral model for this API.
*   Added additional taint step for :code:`java.lang.String#endsWith(String)` to :code:`ConditionalBypassFlowConfig`.
*   Added :code:`AllowContentAccessMethod` to represent the :code:`setAllowContentAccess` method of the :code:`android.webkit.WebSettings` class.
*   Added an external flow source for the parameters of methods annotated with :code:`android.webkit.JavascriptInterface`.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.3.rst
.. _codeql-cli-2.12.3:

==========================
CodeQL 2.12.3 (2023-02-23)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.3 runs a total of 385 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 122 queries (covering 31 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug where the CLI would refuse to complete database creation if the OS reports less than about 1.5 GB of physical memory. Now an attempt will be made even on low-memory systems (but it might still run out of memory unless there's swap space available).

New Features
~~~~~~~~~~~~

*   The CodeQL compiler now produces better error messages when it is unable to find a QL library that the query being evaluated depends on.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The :code:`java/index-out-of-bounds` query has improved its handling of arrays of constant length, and may report additional results in those cases.

Ruby
""""

*   The :code:`rb/polynomial-redos` query now considers the entrypoints of the API of a gem as sources.

New Queries
~~~~~~~~~~~

Golang
""""""

*   Added a new query, :code:`go/unhandled-writable-file-close`, to detect instances where writable file handles are closed without appropriate checks for errors.

Java
""""

*   Added a new query, :code:`java/xxe-local`, which is a version of the XXE query that uses local sources (for example, reads from a local file).

Ruby
""""

*   Added a new query, :code:`rb/regex/badly-anchored-regexp`, to detect regular expression validators that use :code:`^` and :code:`$` as anchors and therefore might match only a single line of a multi-line string.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   The precision of the :code:`go/log-injection` query was decreased from :code:`high` to :code:`medium`, since it may not be able to identify every way in which log data may be sanitized. This also aligns it with the precision of comparable queries for other languages.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

Python
""""""

*   Python 2 is no longer supported for extracting databases using the CodeQL CLI. As a consequence,
    the previously deprecated support for :code:`pyxl` and :code:`spitfire` templates has also been removed. When extracting Python 2 code, having Python 2 installed is still recommended, as this ensures the correct version of the Python standard library is extracted.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   C# 11: Added extractor support for the :code:`scoped` modifier annotation on parameters and local variables.

Golang
""""""

*   Support for the Twirp framework has been added.

Java
""""

*   Removed the first argument of :code:`java.nio.file.Files#createTempDirectory(String,FileAttribute[])` as a "create-file" sink.
*   Added the first argument of :code:`java.nio.file.Files#copy` as a "read-file" sink for the :code:`java/path-injection` query.
*   The data flow library now disregards flow through code that is dead based on some basic constant propagation, for example, guards like :code:`if (1+1>3)`.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added dataflow sources for the `express-ws <https://www.npmjs.com/package/express-ws>`__ library.

Python
""""""

*   Fixed module resolution so we properly recognize that in :code:`from <pkg> import *`, where :code:`<pkg>` is a package, the actual imports are made from the :code:`<pkg>/__init__.py` file.

Ruby
""""

*   Ruby 3.1: one-line pattern matches are now supported. The AST nodes are named :code:`TestPattern` (:code:`expr in pattern`) and :code:`MatchPattern` (:code:`expr => pattern`).

New Features
~~~~~~~~~~~~

Golang
""""""

*   Go 1.20 is now supported. The extractor now functions as expected when Go 1.20 is installed; the definition of :code:`implementsComparable` has been updated according to Go 1.20's new, more-liberal rules; and taint flow models have been added for relevant, new standard-library functions.

Java
""""

*   Kotlin versions up to 1.8.20 are now supported.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.10.1.rst
.. _codeql-cli-2.10.1:

==========================
CodeQL 2.10.1 (2022-07-19)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.10.1 runs a total of 340 security queries when configured with the Default suite (covering 143 CWE). The Extended suite enables an additional 104 queries (covering 30 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   Improved error message from :code:`codeql database analyze` when a query is missing :code:`@id` or :code:`@kind` query metadata.

Query Packs
-----------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/cpp-all` package.

C#
""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/csharp-all` package.

Java
""""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/java-all` package.

JavaScript/TypeScript
"""""""""""""""""""""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/javascript-all` package.

Python
""""""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/python-all` package.

Ruby
""""

*   Contextual queries and the query libraries they depend on have been moved to the :code:`codeql/ruby-all` package.

New Queries
~~~~~~~~~~~

Java
""""

*   A new query "Improper verification of intent by broadcast receiver" (:code:`java/improper-intent-verification`) has been added.
    This query finds instances of Android :code:`BroadcastReceiver`\ s that don't verify the action string of received intents when registered to receive system intents.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   :code:`AnalysedExpr::isNullCheck` and :code:`AnalysedExpr::isValidCheck` have been updated to handle variable accesses on the left-hand side of the C++ logical "and", and variable declarations in conditions.

Java
""""

*   Added data-flow models for :code:`java.util.Properties`. Additional results may be found where relevant data is stored in and then retrieved from a :code:`Properties` instance.
*   Added :code:`Modifier.isInline()`.
*   Removed Kotlin-specific database and QL structures for loops and :code:`break`\ /\ :code:`continue` statements. The Kotlin extractor was changed to reuse the Java structures for these constructs.
*   Added additional flow sources for uses of external storage on Android.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`chownr` library is now modeled as a sink for the :code:`js/path-injection` query.
*   Improved modeling of sensitive data sources, so common words like :code:`certain` and :code:`secretary` are no longer considered a certificate and a secret (respectively).
*   The :code:`gray-matter` library is now modeled as a sink for the :code:`js/code-injection` query.

Python
""""""

*   Improved modeling of sensitive data sources, so common words like :code:`certain` and :code:`secretary` are no longer considered a certificate and a secret (respectively).

Ruby
""""

*   Fixed a bug causing every expression in the database to be considered a system-command execution sink when calls to any of the following methods exist:

    *   The :code:`spawn`, :code:`fspawn`, :code:`popen4`, :code:`pspawn`, :code:`system`, :code:`_pspawn` methods and the backtick operator from the :code:`POSIX::spawn` gem.
    *   The :code:`execute_command`, :code:`rake`, :code:`rails_command`, and :code:`git` methods in :code:`Rails::Generation::Actions`.
    
*   Improved modeling of sensitive data sources, so common words like :code:`certain` and :code:`secretary` are no longer considered a certificate and a secret (respectively).

Deprecated APIs
~~~~~~~~~~~~~~~

Python
""""""

*   The documentation of API graphs (the :code:`API` module) has been expanded, and some of the members predicates of :code:`API::Node` have been renamed as follows:

    *   :code:`getAnImmediateUse` -> :code:`asSource`
    *   :code:`getARhs` -> :code:`asSink`
    *   :code:`getAUse` -> :code:`getAValueReachableFromSource`
    *   :code:`getAValueReachingRhs` -> :code:`getAValueReachingSink`

New Features
~~~~~~~~~~~~

Java
""""

*   Added an :code:`ErrorType` class. An instance of this class will be used if an extractor is unable to extract a type, or if an up/downgrade script is unable to provide a type.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.6.0.rst
.. _codeql-cli-2.6.0:

=========================
CodeQL 2.6.0 (2021-08-24)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.6.0 runs a total of 275 security queries when configured with the Default suite (covering 119 CWE). The Extended suite enables an additional 78 queries (covering 27 more CWE). 6 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   The :code:`physicalLocation.artifactLocation.uri` fields in SARIF output are now properly encoded as specified by RFC 3986.
    
*   The :code:`--include-extension` option to the :code:`codeql database index-files` command no longer includes directories that are named with the provided extension. For example, if the option
    :code:`--include-extension=.rb` is provided, then a directory named
    :code:`foo.rb/` will be excluded from the indexing.

New Features
~~~~~~~~~~~~

*   A new :code:`codeql database unbundle` subcommand performs the reverse of
    :code:`codeql database bundle` and extracts a CodeQL database from an archive.
    
*   The CLI now understands per-codebase configuration files in `the format already supported by the CodeQL Action <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning#example-configuration-files>`__.  The configuration file must be given in a :code:`--codescanning-config` option to :code:`codeql database create` or :code:`codeql database init`. For some languages, this configuration can contain pathname filters that control which parts of the codebase is analysed; the configuration file is the only way this functionality is exposed. The configuration file can also control which queries are run, including custom queries from repositories that must first be downloaded. To actually use those queries, run :code:`codeql database analyze` without any query-selection arguments.
    
*   The CLI now supports the "sandwiched tracing" feature that has previously only been offered through the separate CodeQL Runner.
    This feature is intended for use with CI systems that cannot be configured to wrap build actions with :code:`codeql database trace-command`. Instead the CI system must be able to set custom environment variables for each build action; the required environment variables are output by :code:`codeql database init` when given a :code:`--begin-tracing` argument.
    
    On Windows, :code:`codeql database init --begin-tracing` will also inject build-tracing code into the calling process or an ancestor; there are additional options to control this.
    
*   This version contains *beta* support for a new packaging and publishing system for third-party QL queries and libraries. It comprises the following new commands:

    *   :code:`codeql pack init`\ : Creates an empty CodeQL pack from a template.
        
    *   :code:`codeql pack add`\ : Adds a dependency to a CodeQL pack.
        
    *   :code:`codeql pack install`\ : Installs all pack dependencies specified in the :code:`qlpack.yml` file.
        
    *   :code:`codeql pack download`\ : Downloads one or more pack dependencies into the global package cache.
        
    *   :code:`codeql pack publish`\ : Publishes a package to the GitHub Container Registry.
        
    *   (Plumbing) :code:`codeql pack bundle`\ : Builds a :code:`.zip` file for a CodeQL query or library pack from sources. Used by :code:`codeql pack publish`.
        
    *   (Plumbing) :code:`codeql pack create`\ : Creates a compiled CodeQL query or library pack from sources. Used by :code:`codeql pack bundle`.
        
    *   (Plumbing) :code:`codeql pack packlist`\ : Lists all files in a local CodeQL pack that will be included in the pack's bundle. Used by
        :code:`codeql pack create`.
        
    *   (Plumbing) :code:`codeql pack resolve-dependencies`\ : Resolves all transitive dependencies of a local CodeQL pack. Used by :code:`codeql pack install`.




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.5.rst
.. _codeql-cli-2.14.5:

==========================
CodeQL 2.14.5 (2023-09-14)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.5 runs a total of 394 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 129 queries (covering 35 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a JavaScript extractor crash that was introduced in 2.14.4.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.4.2.rst
.. _codeql-cli-2.4.2:

=========================
CodeQL 2.4.2 (2021-01-22)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.4.2 runs a total of 233 security queries when configured with the Default suite (covering 106 CWE). The Extended suite enables an additional 78 queries (covering 26 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.4.3.rst
.. _codeql-cli-2.4.3:

=========================
CodeQL 2.4.3 (2021-01-29)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.4.3 runs a total of 233 security queries when configured with the Default suite (covering 106 CWE). The Extended suite enables an additional 78 queries (covering 26 more CWE).

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.4.rst
.. _codeql-cli-2.14.4:

==========================
CodeQL 2.14.4 (2023-09-12)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.4 runs a total of 394 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 129 queries (covering 35 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The CodeQL CLI no longer supports the :code:`SEMMLE_JAVA_ARGS` environment variable.
    All previous versions of the CodeQL CLI perform command substitution on the
    :code:`SEMMLE_JAVA_ARGS` value (for example, replacing :code:`'$(echo foo)'` with :code:`'foo'`)
    when starting a new Java virtual machine, which, depending on the execution environment, may have security implications.  Users are advised to check their environments for possible :code:`SEMMLE_JAVA_ARGS` misuse.

Bug Fixes
~~~~~~~~~

*   :code:`codeql database init` (and :code:`github/codeql-action/init@v2` on GitHub Actions)
    should no longer hang or crash for traced languages on 64-bit Windows machines when certain antivirus software is installed.
*   During :code:`codeql pack create` and :code:`codeql pack publish`, a source version of a pack coming from :code:`--additional-packs` can explicitly be used to override a requested pack version even if this source version is incompatible with the requested version in the pack file. Previously, this would fail with a confusing error message.
*   Fixed a bug where :code:`codeql database interpret-results` hangs when a path query produces a result that has no paths from source to sink.

New Features
~~~~~~~~~~~~

*   The Java extractor now supports files that use Lombok.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.8.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed an extractor crash that would occur in rare cases when a TypeScript file contains a self-referential namespace alias.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Comparison where assignment was intended" query (:code:`cpp/compare-where-assign-meant`) no longer reports comparisons that appear in macro expansions.
*   Some queries that had repeated results corresponding to different levels of indirection for :code:`argv` now only have a single result.
*   The :code:`cpp/non-constant-format` query no longer considers an assignment on the right-hand side of another assignment to be a source of non-constant format strings. As a result, the query may now produce fewer results.

Java
""""

*   The queries "Resolving XML external entity in user-controlled data" (:code:`java/xxe`) and "Resolving XML external entity in user-controlled data from local source" (:code:`java/xxe-local`) now recognize sinks in the MDHT library.

JavaScript/TypeScript
"""""""""""""""""""""

*   Files larger than 10 MB are no longer be extracted or analyzed.
*   Imports can now be resolved in more cases, where a non-constant string expression is passed to a :code:`require()` call.

Python
""""""

*   Improved *Reflected server-side cross-site scripting* (:code:`py/reflective-xss`) query to not alert on data passed to :code:`flask.jsonify`. Since these HTTP responses are returned with mime-type :code:`application/json`, they do not pose a security risk for XSS.
*   Updated path explanations for :code:`@kind path-problem` queries to always include left hand side of assignments, making paths easier to understand.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/invalid-pointer-deref`, to detect out-of-bounds pointer reads and writes.

Java
""""

*   Added the :code:`java/trust-boundary-violation` query to detect trust boundary violations between HTTP requests and the HTTP session. Also added the :code:`trust-boundary-violation` sink kind for sinks which may cross a trust boundary, such as calls to the :code:`HttpSession#setAttribute` method.

Ruby
""""

*   Added a new experimental query, :code:`rb/improper-ldap-auth`, to detect cases where user input is used during LDAP authentication without proper validation or sanitization, potentially leading to authentication bypass.

Swift
"""""

*   Added new query "Incomplete regular expression for hostnames" (:code:`swift/incomplete-hostname-regexp`). This query finds regular expressions matching a URL or hostname that may match more hostnames than expected.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 5.2.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   :code:`delete` and :code:`delete[]` are now modeled as calls to the relevant :code:`operator delete` in the IR. In the case of a dynamic delete call a new instruction :code:`VirtualDeleteFunctionAddress` is used to represent a function that dispatches to the correct delete implementation.
*   Only the 2 level indirection of :code:`argv` (corresponding to :code:`**argv`) is consided for :code:`FlowSource`.

C#
""

*   The :code:`--nostdlib` extractor option for the standalone extractor has been removed.

Golang
""""""

*   Added `http.Error <https://pkg.go.dev/net/http#Error>`__ to XSS sanitzers.

Java
""""

*   Fixed the MaD signature specifications to use proper nested type names.
*   Added new sanitizer to Java command injection model
*   Added more dataflow models for JAX-RS.
*   The predicate :code:`JaxWsEndpoint::getARemoteMethod` no longer requires the result to be annotated with :code:`@WebMethod`. Instead, the requirements listed in the JAX-RPC Specification 1.1 for required parameter and return types are used. Applications using JAX-RS may see an increase in results.

Python
""""""

*   Regular expressions containing multiple parse mode flags are now interpretted correctly. For example :code:`"(?is)abc.*"` with both the :code:`i` and :code:`s` flags.
*   Added :code:`shlex.quote` as a sanitizer for the :code:`py/shell-command-constructed-from-input` query.

Swift
"""""

*   Flow through optional chaining and forced unwrapping in keypaths is now supported by the data flow library.
*   Added flow models of collection :code:`.withContiguous[Mutable]StorageIfAvailable`, :code:`.withUnsafe[Mutable]BufferPointer` and :code:`.withUnsafe[Mutable]Bytes` methods.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   :code:`getAllocatorCall` on :code:`DeleteExpr` and :code:`DeleteArrayExpr` has been deprecated. :code:`getDeallocatorCall` should be used instead.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added :code:`DeleteOrDeleteArrayExpr` as a super type of :code:`DeleteExpr` and :code:`DeleteArrayExpr`

Java
""""

*   Kotlin versions up to 1.9.10 are now supported.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The shared taint-tracking library is now part of the dataflow qlpack.

New Features
~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The various inline flow test libraries have been consolidated as a shared library part in the dataflow qlpack.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.6.1.rst
.. _codeql-cli-2.6.1:

=========================
CodeQL 2.6.1 (2021-09-07)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.6.1 runs a total of 274 security queries when configured with the Default suite (covering 119 CWE). The Extended suite enables an additional 80 queries (covering 27 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The :code:`codeql resolve qlref` command will now throw an error when the target is ambiguous.
    
    The qlref resolution rules are now as follows:

    #.  If the target of a qlref is in the same qlpack, then that target is always returned.
        
    #.  If multiple targets of the qlref are found in dependent packs, this is an error.

    Previously, the command would have arbitrarily chosen one of the targets and ignored any ambiguities.
    
*   The :code:`qlpack` directive in query suites has its semantics changed.
    Previously, this directive would return all queries in the qlpack. Now, the directive returns only those queries matched by the
    :code:`defaultSuite` directive in the query pack. Here is an example:
    
    Consider a :code:`qlpack.yml` like the following:

    ..  code-block:: yaml
    
        name: codeql/my-qlpack
        version: 0.0.1
        defaultSuite:
          queries: standard
        
    And the directory structure is the following:

    ..  code-block:: text
    
        qlpack.yml
        standard/
          a.ql
        experimental/
          b.ql
        
    A query suite :code:`suite.qls` like this:

    ..  code-block:: yaml
    
        - qlpack: codeql/my-qlpack
        
    Previously, would return all the queries in all subdirectories (i.e,
    :code:`standard/a.ql` and :code:`experimental/b.ql`). Now, it only returns
    :code:`standard/a.ql`, since that is the only query matched by its default suite.
    
    If you want to have the same behavior as before, you must update your query suites to use the :code:`queries` directive with a :code:`from` attribute,
    like this:

    ..  code-block:: yaml
    
        - queries: .
          from: codeql/my-qlpack

New Features
~~~~~~~~~~~~

*   Commands that evaluate CodeQL queries now support an additional option :code:`--evaluator-log=path/to/log.json` that will result in the evaluator producing a structured log (in JSON format) of events that occurred during evaluation in order to aid debugging of query performance. The format of these logs will be subject to change with no notice as we make modifications to the evaluator.
    
    There is also a new CLI command :code:`codeql generate log-summary` that will produce a summary of the predicates that were evaluated from these event logs. We will aim to keep this summary format more stable, although it is also subject to change. Unless you have a good reason to use the event logs directly, it is strongly recommended you use this command to produce summary logs and use these instead.
    
    For further information on these new logs and additional options to configure their format and verbosity, please refer to the CLI documentation.

QL Language
~~~~~~~~~~~

*   QL classes can now be non-extending subtypes via the :code:`instanceof` keyword, allowing for a form of private subtyping that is not visible externally. Methods of the supertype are accessible from within a non-extending subtype class through extended semantics of the :code:`super` keyword.

    ..  code-block:: text
    
        class Foo instanceof int {
          Foo() { this in [1 .. 10] }
          string toString() { result = "foo" + super.toString() }
        }
        



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.6.rst
.. _codeql-cli-2.16.6:

==========================
CodeQL 2.16.6 (2024-03-26)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.6 runs a total of 409 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 132 queries (covering 34 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixes a bug where extractor logs would be output at a lower than expected verbosity level when using the :code:`codeql database create` command.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.10.0.rst
.. _codeql-cli-2.10.0:

==========================
CodeQL 2.10.0 (2022-06-27)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.10.0 runs a total of 339 security queries when configured with the Default suite (covering 142 CWE). The Extended suite enables an additional 104 queries (covering 30 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The :code:`--format=stats` option of :code:`codeql generate log-summary` has been renamed to :code:`--format=overall`. It now produces a richer JSON object that, in addition to the previous statistics about the run (which can be found in the :code:`stats` property) also records the most expensive predicates in the evaluation run.

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The :code:`codeql resolve ml-model` command now requires one or more query specifications as command line arguments in order to determine the set of starting packs from which to initiate the resolution process. The command will locate all ML models in any qlpack that is a transitive dependency of any of the starting packs. Also, the output of the command has been expanded to include for each model the containing package's name, version, and path.
    
*   The :code:`buildMetadata` inside of compiled CodeQL packs no longer contains a :code:`creationTime` property. This was removed in order to ensure that the content of a CodeQL pack is identical when it is re-compiled.
    
*   The :code:`codeql pack download` command, when used with the :code:`--dir` option,
    now downloads requested packs in directories corresponding to their version numbers. Previously,
    :code:`codeql pack download --dir ./somewhere codeql/java-queries@0.1.2` would download the pack into the :code:`./somewhere/codeql/java-queries` directory. Now, it will download the pack into the
    :code:`./somewhere/codeql/java-queries/0.1.2` directory. This allows you to download multiple versions of the same pack using a single command.

Bug Fixes
~~~~~~~~~

*   Fixed a bug where :code:`codeql pack download`, when used with the :code:`--dir` option, would not download a pack that is in the global package cache.
    
*   Fixed a bug where some versions of a CodeQL package could not be downloaded if there are more than 100 versions of this package in the package registry.
    
*   Fixed a bug where the :code:`--also-match` option for :code:`codeql resolve files` and :code:`codeql database index-files` does not work with relative paths.
    
*   Fixed a bug that caused :code:`codeql query decompile` to ignore the
    :code:`--output` option when producing bytecode output (:code:`--kind=bytecode`),
    writing only to :code:`stdout`.

New Features
~~~~~~~~~~~~

*   You can now include diagnostic messages in the summary produced by the :code:`--print-diagnostics-summary` option of the
    :code:`codeql database interpret-results` and :code:`codeql database analyze` commands by running these commands at high verbosity levels.

Query Packs
-----------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Improved library modeling for the query "Request without certificate validation" (:code:`py/request-without-cert-validation`), so it now also covers :code:`httpx`, :code:`aiohttp.client`, and :code:`urllib3`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The syntax of the (source|sink|summary)model CSV format has been changed slightly for Java and C#. A new column called :code:`provenance` has been introduced, where the allowed values are :code:`manual` and :code:`generated`. The value used to indicate whether a model as been written by hand (:code:`manual`) or create by the CSV model generator (:code:`generated`).
*   All auto implemented public properties with public getters and setters on ASP.NET Core remote flow sources are now also considered to be tainted.

Java
""""

*   The query :code:`java/log-injection` now reports problems at the source (user-controlled data) instead of at the ultimate logging call. This was changed because user functions that wrap the ultimate logging call could result in most alerts being reported in an uninformative location.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/resource-exhaustion` query no longer treats the 3-argument version of :code:`Buffer.from` as a sink,
    since it does not allocate a new buffer.

Python
""""""

*   The query "Use of a broken or weak cryptographic algorithm" (:code:`py/weak-cryptographic-algorithm`) now reports if a cryptographic operation is potentially insecure due to use of a weak block mode.

Ruby
""""

*   The query "Use of a broken or weak cryptographic algorithm" (:code:`rb/weak-cryptographic-algorithm`) now reports if a cryptographic operation is potentially insecure due to use of a weak block mode.

New Queries
~~~~~~~~~~~

Ruby
""""

*   Added a new query, :code:`rb/improper-memoization`. The query finds cases where the parameter of a memoization method is not used in the memoization key.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The :code:`kind` query metadata was changed to :code:`diagnostic` on :code:`cs/compilation-error`, :code:`cs/compilation-message`, :code:`cs/extraction-error`, and :code:`cs/extraction-message`.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

C/C++
"""""

*   :code:`UserType.getADeclarationEntry()` now yields all forward declarations when the user type is a :code:`class`, :code:`struct`, or :code:`union`.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for TypeScript 4.7.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Added a flow step for :code:`String.valueOf` calls on tainted :code:`android.text.Editable` objects.

JavaScript/TypeScript
"""""""""""""""""""""

*   All new ECMAScript 2022 features are now supported.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.

C#
""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.

Golang
""""""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.

Java
""""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.

Python
""""""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.

Ruby
""""

*   The :code:`BarrierGuard` class has been deprecated. Such barriers and sanitizers can now instead be created using the new :code:`BarrierGuard` parameterized module.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.2.rst
.. _codeql-cli-2.12.2:

==========================
CodeQL 2.12.2 (2023-02-07)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.2 runs a total of 385 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 121 queries (covering 31 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a QL evaluator bug introduced in release 2.12.1 which could in certain rare cases lead to wrong analysis results.
    
*   Fixed handling of :code:`-Xclang <arg>` arguments passed to the :code:`clang` compiler which could cause missing extractions for C++ code bases.
    
*   Fixed a bug where the :code:`--overwrite` option was failing for database clusters.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.6.

Query Packs
-----------

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query, :code:`java/android/sensitive-result-receiver`, to find instances of sensitive data being leaked to an untrusted :code:`ResultReceiver`.

Ruby
""""

*   Added a new query, :code:`rb/html-constructed-from-input`, to detect libraries that unsafely construct HTML from their inputs.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Add extractor and library support for UTF-8 encoded strings.
*   The :code:`StringLiteral` class includes UTF-8 encoded strings.
*   In the DB Scheme :code:`@string_literal_expr` is renamed to :code:`@utf16_string_literal_expr`.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   C# 11: Added extractor support for :code:`ref` fields in :code:`ref struct` declarations.

Java
""""

*   Added sink models for the :code:`createQuery`, :code:`createNativeQuery`, and :code:`createSQLQuery` methods of the :code:`org.hibernate.query.QueryProducer` interface.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added sinks from the |link-code-node-pty-1|_ library to the :code:`js/code-injection` query.

Ruby
""""

*   Data flowing from the :code:`locals` argument of a Rails :code:`render` call is now tracked to uses of that data in an associated view.
*   Access to headers stored in the :code:`env` of Rack requests is now recognized as a source of remote input.
*   Ruby 3.2: anonymous rest and keyword rest arguments can now be passed as arguments, instead of just used in method parameters.

.. |link-code-node-pty-1| replace:: :code:`node-pty`\ 
.. _link-code-node-pty-1: https://www.npmjs.com/package/node-pty




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.6.rst
.. _codeql-cli-2.12.6:

==========================
CodeQL 2.12.6 (2023-04-04)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.6 runs a total of 386 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 124 queries (covering 31 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug in :code:`codeql database analyze` and related commands where the :code:`--max-paths` option was not respected correctly when multiple alerts with the same primary code location were grouped together.
    (This grouping is the default behavior unless the :code:`--no-group-alerts` option is passed.)
    This bug caused some SARIF files produced by CodeQL to exceed the limits on the number of paths (:code:`threadFlows`) accepted by code scanning,
    leading to errors when uploading results.

New Features
~~~~~~~~~~~~

*   Several experimental subcommands have been added in support of the new `code scanning tool status page <https://github.blog/changelog/2023-03-28-code-scanning-shows-the-health-of-tools-enabled-on-a-repository/>`__.
    These include :code:`codeql database add-diagnostic`,
    :code:`codeql database export-diagnostics`, and the
    :code:`codeql diagnostic add` and :code:`codeql diagnostic export` plumbing subcommands.

Known Issues
~~~~~~~~~~~~

*   We recommend that customers using the CodeQL CLI in a third party CI system do not upgrade to this release, due to an issue with :code:`codeql github upload-results`. Instead, please use CodeQL 2.12.5, or, when available, CodeQL 2.12.7 or 2.13.1.
    
    This issue occurs when uploading certain kinds of diagnostic information and causes the subcommand to fail with "A fatal error occurred: Invalid SARIF.", reporting an :code:`InvalidDefinitionException`.
    
    Customers who wish to use CodeQL 2.12.6 or 2.13.0 can work around the problem by passing :code:`--no-sarif-include-diagnostics` to any invocations of :code:`codeql database analyze` or :code:`codeql database interpret-results`.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ruby
""""

*   :code:`rb/sensitive-get-query` no longer reports flow paths from input parameters to sensitive use nodes. This avoids cases where many flow paths could be generated for a single parameter, which caused excessive paths to be generated.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.10.4.rst
.. _codeql-cli-2.10.4:

==========================
CodeQL 2.10.4 (2022-08-31)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.10.4 runs a total of 352 security queries when configured with the Default suite (covering 146 CWE). The Extended suite enables an additional 106 queries (covering 30 more CWE). 12 security queries have been added with this release.

CodeQL CLI
----------

There are no user-facing CLI changes in this release.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "Cleartext storage of sensitive information in buffer" (:code:`cpp/cleartext-storage-buffer`) query has been improved to produce fewer false positives.

C#
""

*   Parameters of delegates passed to routing endpoint calls like :code:`MapGet` in ASP.NET Core are now considered remote flow sources.
*   The query :code:`cs/unsafe-deserialization-untrusted-input` is not reporting on all calls of :code:`JsonConvert.DeserializeObject` any longer, it only covers cases that explicitly use unsafe serialization settings.
*   Added better support for the SQLite framework in the SQL injection query.
*   File streams are now considered stored flow sources. For example, reading query elements from a file can lead to a Second Order SQL injection alert.

Java
""""

*   The query :code:`java/static-initialization-vector` no longer requires a :code:`Cipher` object to be initialized with :code:`ENCRYPT_MODE` to be considered a valid sink. Also, several new sanitizers were added.
*   Improved sanitizers for :code:`java/sensitive-log`, which removes some false positives and improves performance a bit.

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query, :code:`java/android/implicitly-exported-component`, to detect if components are implicitly exported in the Android manifest.
*   A new query "Use of RSA algorithm without OAEP" (:code:`java/rsa-without-oaep`) has been added. This query finds uses of RSA encryption that don't use the OAEP scheme.
*   Added a new query, :code:`java/android/debuggable-attribute-enabled`, to detect if the :code:`android:debuggable` attribute is enabled in the Android manifest.
*   The query "Using a static initialization vector for encryption" (:code:`java/static-initialization-vector`) has been promoted from experimental to the main query pack. This query was originally `submitted as an experimental query by @artem-smotrakov <https://github.com/github/codeql/pull/6357>`__.
*   A new query :code:`java/partial-path-traversal` finds partial path traversal vulnerabilities resulting from incorrectly using
    :code:`String#startsWith` to compare canonical paths.
*   Added a new query, :code:`java/suspicious-regexp-range`, to detect character ranges in regular expressions that seem to match
    too many characters.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added a new query, :code:`py/suspicious-regexp-range`, to detect character ranges in regular expressions that seem to match
    too many characters.

Python
""""""

*   Added a new query, :code:`py/suspicious-regexp-range`, to detect character ranges in regular expressions that seem to match
    too many characters.

Ruby
""""

*   Added a new query, :code:`rb/log-injection`, to detect cases where a malicious user may be able to forge log entries.
*   Added a new query, :code:`rb/incomplete-multi-character-sanitization`. The query finds string transformations that do not replace all occurrences of a multi-character substring.
*   Added a new query, :code:`rb/suspicious-regexp-range`, to detect character ranges in regular expressions that seem to match
    too many characters.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The queries :code:`java/redos` and :code:`java/polynomial-redos` now have a tag for CWE-1333.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   Fixed that top-level :code:`for await` statements would produce a syntax error. These statements are now parsed correctly.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

C#
""

*   All deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

Golang
""""""

*   Go 1.19 is now supported, including adding new taint propagation steps for new standard-library functions introduced in this release.
*   Most deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.
*   Fixed data-flow to captured variable references.
*   We now assume that if a channel-typed field is only referred to twice in the user codebase, once in a send operation and once in a receive, then data flows from the send to the receive statement. This enables finding some cross-goroutine flow.

Java
""""

*   Added new flow steps for the classes :code:`java.nio.file.Path` and :code:`java.nio.file.Paths`.
*   The class :code:`AndroidFragment` now also models the Android Jetpack version of the :code:`Fragment` class (:code:`androidx.fragment.app.Fragment`).
*   Java 19 builds can now be extracted. There are no non-preview new language features in this release, so the only user-visible change is that the CodeQL extractor will now correctly trace compilations using the JDK 19 release of :code:`javac`.
*   Classes and methods that are seen with several different paths during the extraction process (for example, packaged into different JAR files) now report an arbitrarily selected location via their :code:`getLocation` and :code:`hasLocationInfo` predicates, rather than reporting all of them. This may lead to reduced alert duplication.
*   The query :code:`java/hardcoded-credential-api-call` now recognises methods that consume usernames, passwords and keys from the JSch, Ganymed, Apache SSHD, sshj, Trilead SSH-2, Apache FTPClient and MongoDB projects.

JavaScript/TypeScript
"""""""""""""""""""""

*   Most deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

Python
""""""

*   Most deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.

Ruby
""""

*   Most deprecated predicates/classes/modules that have been deprecated for over a year have been deleted.
*   Calls to :code:`render` in Rails controllers and views are now recognized as HTTP response bodies.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   Many classes/predicates/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

C#
""

*   Many classes/predicates/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.

Java
""""

*   Many classes/predicates/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.
*   The utility files previously in the :code:`semmle.code.java.security.performance` package have been moved to the :code:`semmle.code.java.security.regexp` package.
    
    The previous files still exist as deprecated aliases.

JavaScript/TypeScript
"""""""""""""""""""""

*   Many classes/predicates/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.
*   The utility files previously in the :code:`semmle.javascript.security.performance` package have been moved to the :code:`semmle.javascript.security.regexp` package.
    
    The previous files still exist as deprecated aliases.

Python
""""""

*   Many classes/predicates/modules with upper-case acronyms in their name have been renamed to follow our style-guide.
    The old name still exists as a deprecated alias.
*   The utility files previously in the :code:`semmle.python.security.performance` package have been moved to the :code:`semmle.python.security.regexp` package.
    
    The previous files still exist as deprecated aliases.

Ruby
""""

*   The utility files previously in the :code:`codeql.ruby.security.performance` package have been moved to the :code:`codeql.ruby.security.regexp` package.
    
    The previous files still exist as deprecated aliases.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added support for getting the link targets of global and namespace variables.
*   Added a :code:`BlockAssignExpr` class, which models a :code:`memcpy`\ -like operation used in compiler generated copy/move constructors and assignment operations.

Java
""""

*   Added a new predicate, :code:`requiresPermissions`, in the :code:`AndroidComponentXmlElement` and :code:`AndroidApplicationXmlElement` classes to detect if the element has explicitly set a value for its :code:`android:permission` attribute.
*   Added a new predicate, :code:`hasAnIntentFilterElement`, in the :code:`AndroidComponentXmlElement` class to detect if a component contains an intent filter element.
*   Added a new predicate, :code:`hasExportedAttribute`, in the :code:`AndroidComponentXmlElement` class to detect if a component has an :code:`android:exported` attribute.
*   Added a new class, :code:`AndroidCategoryXmlElement`, to represent a category element in an Android manifest file.
*   Added a new predicate, :code:`getACategoryElement`, in the :code:`AndroidIntentFilterXmlElement` class to get a category element of an intent filter.
*   Added a new predicate, :code:`isInBuildDirectory`, in the :code:`AndroidManifestXmlFile` class. This predicate detects if the manifest file is located in a build directory.
*   Added a new predicate, :code:`isDebuggable`, in the :code:`AndroidApplicationXmlElement` class. This predicate detects if the application element has its :code:`android:debuggable` attribute enabled.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.2.rst
.. _codeql-cli-2.16.2:

==========================
CodeQL 2.16.2 (2024-02-12)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.2 runs a total of 406 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 131 queries (covering 34 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

There are no user-facing CLI changes in this release.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Corrected 2 false positive with :code:`cpp/incorrect-string-type-conversion`\ : conversion of byte arrays to wchar and new array allocations converted to wchar.
*   The "Incorrect return-value check for a 'scanf'-like function" query (:code:`cpp/incorrectly-checked-scanf`) no longer reports an alert when an explicit check for EOF is added.
*   The "Incorrect return-value check for a 'scanf'-like function" query (:code:`cpp/incorrectly-checked-scanf`) now recognizes more EOF checks.
*   The "Potentially uninitialized local variable" query (:code:`cpp/uninitialized-local`) no longer reports an alert when the local variable is used as a qualifier to a static member function call.
*   The diagnostic query :code:`cpp/diagnostics/successfully-extracted-files` now considers any C/C++ file seen during extraction, even one with some errors, to be extracted / scanned. This affects the Code Scanning UI measure of scanned C/C++ files.

C#
""

*   Added string interpolation expressions and :code:`string.Format` as possible sanitizers for the :code:`cs/web/unvalidated-url-redirection` query.

Ruby
""""

*   Added new unsafe deserialization sinks for the ox gem.
*   Added an additional unsafe deserialization sink for the oj gem.

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query :code:`java/android/sensitive-text` to detect instances of sensitive data being exposed through text fields without being properly masked.
*   Added a new query :code:`java/android/sensitive-notification` to detect instances of sensitive data being exposed through Android notifications.

Ruby
""""

*   Added a new experimental query, :code:`rb/insecure-randomness`, to detect when application uses random values that are not cryptographically secure.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Python
""""""

*   Fixed the :code:`a` (ASCII) inline flag not being recognized by the regular expression library.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   Added a new database relation to store compiler arguments specified inside :code:`@[...].rsp` file arguments. The arguments are returned by :code:`Compilation::getExpandedArgument/1` and :code:`Compilation::getExpandedArguments/0`.
*   C# 12: Added extractor, QL library and data flow support for collection expressions like :code:`[1, y, 4, .. x]`.
*   The C# extractor now accepts an extractor option :code:`logging.verbosity` that specifies the verbosity of the logs. The option is added via :code:`codeql database create --language=csharp -Ologging.verbosity=debug ...` or by setting the corresponding environment variable :code:`CODEQL_EXTRACTOR_CSHARP_OPTION_LOGGING_VERBOSITY`.

Java
""""

*   Added models for the following packages:

    *   com.fasterxml.jackson.databind
    *   javax.servlet
    
*   Added the :code:`java.util.Date` and :code:`java.util.UUID` classes to the list of types in the :code:`SimpleTypeSanitizer` class in :code:`semmle.code.java.security.Sanitizers`.

Python
""""""

*   Added :code:`html.escape` as a sanitizer for HTML.

Ruby
""""

*   Flow is now tracked through Rails :code:`render` calls, when the argument is a :code:`ViewComponent`. In this case, data flow is tracked into the accompanying :code:`.html.erb` file.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added the :code:`PreprocBlock.qll` library to this repository.  This library offers a view of :code:`#if`, :code:`#elif`, :code:`#else` and similar directives as a tree with navigable parent-child relationships.
*   Added a new :code:`ThrowingFunction` abstract class that can be used to model an external function that may throw an exception.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.0.rst
.. _codeql-cli-2.14.0:

==========================
CodeQL 2.14.0 (2023-07-13)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.0 runs a total of 390 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 127 queries (covering 33 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The legacy option :code:`--search-path` will now be used, if provided, when searching for the dependencies of packages that have no lock file.
*   CodeQL query packs that specify their dependencies using the legacy
    :code:`libraryPathDependencies` property in :code:`qlpack.yml`\ /\ :code:`codeql-pack.yml` files are no longer permitted to contain a :code:`codeql-pack.lock.yml` lock file.
    This will lead to a compilation error. This change is intended to prevent confusing behavior arising from a mix of legacy (unversioned) and modern
    (versioned) package dependencies. To fix this error, either delete the lock file, or convert :code:`libraryPathDependencies` to :code:`dependencies`.
*   CodeQL CLI commands that create packages or update package lock files, such as :code:`codeql pack publish` and :code:`codeql pack create`, will no longer work on query packs that specify their dependencies using the legacy
    :code:`libraryPathDependencies` property. To fix this error, convert
    :code:`libraryPathDependencies` to :code:`dependencies`.

Bug Fixes
~~~~~~~~~

*   Fixed super calls on final base classes (or final aliases) so that they are now dispatched the same way as super calls on instanceof supertypes.
*   Fixed a bug where running :code:`codeql database finalize` with a large number of threads would fail due to running out of file descriptors.
*   Fixed a bug where :code:`codeql database create --overwrite` would not work with database clusters.
*   Fixed a bug where the CodeQL documentation coverage statistics were incorrect.
*   Fixed a bug where the generated CodeQL libarary documentation could generate invalid uris on windows.

Deprecations
~~~~~~~~~~~~

*   Missing override annotations on class member predicates now raise errors rather than warnings. This is to avoid confusion with the shadowing behaviour in the presence of final member predicates.

    ..  code-block:: ql
    
        class Foo extends Base {
          final predicate foo() { ... }
        
          predicate bar() { ... }
        }
        
        class Bar extends Foo {
          // This method shadows Foo::foo.
          predicate foo() { ... }
        
          // This used to override Foo::bar with a warning, now raises error.
          predicate bar() { ... }
        }

Improvements
~~~~~~~~~~~~

*   Unqualified imports can now be marked as deprecated to indicate that the import may be removed in the future. Usage of names only reachable through deprecated imports will generate deprecation warnings.
*   Classes declared inside a parameterized modules can final extend parameters of the module as well as types that are declared outside the parameterized module.
*   Fields are fully functional when extending types from within a module instantiation.
*   Files with a :code:`.yaml` extension will now be included in compiled CodeQL packs. Previously, files with this extension were excluded even though :code:`.yml` files were included.
*   When interpreting results (e.g., using :code:`bqrs interpret` or
    :code:`database interpret-results`), extra placeholders in alert messages are treated as normal text. Previously, results with more placeholders than placeholder values were skipped.
*   Windows users of the CodeQL extension for VS Code will see faster start times.
*   In VS Code, errors in the current file are rechecked when dependencies change.
*   In VS Code, autocomplete in large QL files is now faster.
*   Member predicates can shadow final member predicates of the same arity even when the signatures are not fully matching.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

C#
""

*   The query "Arbitrary file write during zip extraction ("Zip Slip")" (:code:`cs/zipslip`) has been renamed to "Arbitrary file access during archive extraction ("Zip Slip")."

Golang
""""""

*   The query "Arbitrary file write during zip extraction ("zip slip")" (:code:`go/zipslip`) has been renamed to "Arbitrary file access during archive extraction ("Zip Slip")."

Java
""""

*   The query "Arbitrary file write during archive extraction ("Zip Slip")" (:code:`java/zipslip`) has been renamed to "Arbitrary file access during archive extraction ("Zip Slip")."

JavaScript/TypeScript
"""""""""""""""""""""

*   The query "Arbitrary file write during zip extraction ("Zip Slip")" (:code:`js/zipslip`) has been renamed to "Arbitrary file access during archive extraction ("Zip Slip")."

Python
""""""

*   The query "Arbitrary file write during archive extraction ("Zip Slip")" (:code:`py/zipslip`) has been renamed to "Arbitrary file access during archive extraction ("Zip Slip")."

Ruby
""""

*   The experimental query "Arbitrary file write during zipfile/tarfile extraction" (:code:`ruby/zipslip`) has been renamed to "Arbitrary file access during archive extraction ("Zip Slip")."

Swift
"""""

*   Functions and methods modeled as flow summaries are no longer shown in the path of :code:`path-problem` queries. This results in more succinct paths for most security queries.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/comparison-with-wider-type` query now correctly handles relational operations on signed operators. As a result the query may find more results.

Java
""""

*   New models have been added for :code:`org.apache.commons.lang`.
*   The query :code:`java/unsafe-deserialization` has been updated to take into account :code:`SerialKiller`, a library used to prevent deserialization of arbitrary classes.

Ruby
""""

*   Fixed a bug in how :code:`map_filter` calls are analyzed. Previously, such calls would appear to the return the receiver of the call, but now the return value of the callback is properly taken into account.

New Queries
~~~~~~~~~~~

C#
""

*   Added a new query, :code:`cs/web/missing-function-level-access-control`, to find instances of missing authorization checks.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

Swift
"""""

*   The :code:`BraceStmt` AST node's :code:`AstNode getElement(index)` member predicate no longer returns :code:`VarDecl`\ s after the :code:`PatternBindingDecl` that declares them. Instead, a new :code:`VarDecl getVariable(index)` predicate has been introduced for accessing the variables declared in a :code:`BraceStmt`.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The data flow library now performs type strengthening. This increases precision for all data flow queries by excluding paths that can be inferred to be impossible due to incompatible types.

Java
""""

*   The data flow library now performs type strengthening. This increases precision for all data flow queries by excluding paths that can be inferred to be impossible due to incompatible types.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Deleted the deprecated :code:`getURL` predicate from the :code:`Container`, :code:`Folder`, and :code:`File` classes. Use the :code:`getLocation` predicate instead.

C#
""

*   Additional support for :code:`command-injection`, :code:`ldap-injection`, :code:`log-injection`, and :code:`url-redirection` sink kinds for Models as Data.

Golang
""""""

*   When a result of path query flows through a function modeled using :code:`DataFlow::FunctionModel` or :code:`TaintTracking::FunctionModel`, the path now includes nodes corresponding to the input and output to the function. This brings it in line with functions modeled using Models-as-Data.

Java
""""

*   Added automatically-generated dataflow models for :code:`javax.portlet`.
*   Added a missing summary model for the method :code:`java.net.URL.toString`.
*   Added automatically-generated dataflow models for the following frameworks and libraries:

    *   :code:`hudson`
    *   :code:`jenkins`
    *   :code:`net.sf.json`
    *   :code:`stapler`
    
*   Added more models for the Hudson framework.
*   Added more models for the Stapler framework.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added models for the Webix Framework.

Python
""""""

*   Deleted many models that used the old dataflow library, the new models can be found in the :code:`python/ql/lib/semmle/python/frameworks` folder.
*   More precise modeling of several container functions (such as :code:`sorted`, :code:`reversed`) and methods (such as :code:`set.add`, :code:`list.append`).
*   Added modeling of taint flow through the template argument of :code:`flask.render_template_string` and :code:`flask.stream_template_string`.
*   Deleted many deprecated predicates and classes with uppercase :code:`API`, :code:`HTTP`, :code:`XSS`, :code:`SQL`, etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`getName()` predicate from the :code:`Container` class, use :code:`getAbsolutePath()` instead.
*   Deleted many deprecated module names that started with a lowercase letter, use the versions that start with an uppercase letter instead.
*   Deleted many deprecated predicates in :code:`PointsTo.qll`.
*   Deleted many deprecated files from the :code:`semmle.python.security` package.
*   Deleted the deprecated :code:`BottleRoutePointToExtension` class from :code:`Extensions.qll`.
*   Type tracking is now aware of flow summaries. This leads to a richer API graph, and may lead to more results in some queries.

Ruby
""""

*   More kinds of rack applications are now recognized.
*   Rack::Response instances are now recognized as potential responses from rack applications.
*   HTTP redirect responses from Rack applications are now recognized as a potential sink for open redirect alerts.
*   Additional sinks for :code:`rb/unsafe-deserialization` have been added. This includes various methods from the :code:`yaml` and :code:`plist` gems, which deserialize YAML and Property List data, respectively.

Swift
"""""

*   Added a data flow model for :code:`swap(_:_:)`.

Deprecated APIs
~~~~~~~~~~~~~~~

Golang
""""""

*   The :code:`LogInjection::Configuration` taint flow configuration class has been deprecated. Use the :code:`LogInjection::Flow` module instead.

Java
""""

*   The :code:`ExecCallable` class in :code:`ExternalProcess.qll` has been deprecated.

Ruby
""""

*   The :code:`Configuration` taint flow configuration class from :code:`codeql.ruby.security.InsecureDownloadQuery` has been deprecated. Use the :code:`Flow` module instead.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   The :code:`ProductFlow::StateConfigSig` signature now includes default predicates for :code:`isBarrier1`, :code:`isBarrier2`, :code:`isAdditionalFlowStep1`, and :code:`isAdditionalFlowStep1`. Hence, it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

Python
""""""

*   It is now possible to specify flow summaries in the format "MyPkg;Member[list_map];Argument[1].ListElement;Argument[0].Parameter[0];value"

Swift
"""""

*   Added new libraries :code:`Regex.qll` and :code:`RegexTreeView.qll` for reasoning about regular expressions in Swift code and places where they are evaluated.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.4.6.rst
.. _codeql-cli-2.4.6:

=========================
CodeQL 2.4.6 (2021-03-19)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.4.6 runs a total of 237 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE).

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.1.rst
.. _codeql-cli-2.14.1:

==========================
CodeQL 2.14.1 (2023-07-27)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.1 runs a total of 392 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 127 queries (covering 33 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

There are no user-facing CLI changes in this release.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/uninitialized-local` query now excludes uninitialized uses that are explicitly cast to void and are expression statements. As a result, the query will report less false positives.

Java
""""

*   The query "Unsafe resource fetching in Android WebView" (:code:`java/android/unsafe-android-webview-fetch`) now recognizes WebViews where :code:`setJavascriptEnabled`, :code:`setAllowFileAccess`, :code:`setAllowUniversalAccessFromFileURLs`, and/or :code:`setAllowFileAccessFromFileURLs` are set inside the function block of the Kotlin :code:`apply` function.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`fs/promises` package is now recognised as an alias for :code:`require('fs').promises`.
*   The :code:`js/path-injection` query can now track taint through calls to :code:`path.join()` with a spread argument, such as :code:`path.join(baseDir, ...args)`.

Python
""""""

*   Fixed modeling of :code:`aiohttp.ClientSession` so we properly handle :code:`async with` uses. This can impact results of server-side request forgery queries (:code:`py/full-ssrf`, :code:`py/partial-ssrf`).

Ruby
""""

*   Improved resolution of calls performed on an object created with :code:`Proc.new`.

New Queries
~~~~~~~~~~~

Ruby
""""

*   Added a new experimental query, :code:`rb/xpath-injection`, to detect cases where XPath statements are constructed from user input in an unsafe manner.

Swift
"""""

*   Added new query "Regular expression injection" (:code:`swift/regex-injection`). The query finds places where user input is used to construct a regular expression without proper escaping.
*   Added new query "Inefficient regular expression" (:code:`swift/redos`). This query finds regular expressions that require exponential time to match certain inputs and may make an application vulnerable to denial-of-service attacks.

Language Libraries
------------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Ruby
""""

*   The API graph library (:code:`codeql.ruby.ApiGraphs`) has been significantly improved, with better support for inheritance,
    and data-flow nodes can now be converted to API nodes by calling :code:`.track()` or :code:`.backtrack()` on the node.
    API graphs allow for efficient modelling of how a given value is used by the code base, or how values produced by the code base are consumed by a library. See the documentation for :code:`API::Node` for details and examples.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.
*   The :code:`IRGuards` library has improved handling of pointer addition and subtraction operations.

C#
""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.

Golang
""""""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.
*   Parameter nodes now exist for unused parameters as well as used parameters.
*   Add support for v4 of the `Go Micro framework <https://github.com/go-micro/go-micro>`__.
*   Support for the `Bun framework <https://bun.uptrace.dev/>`__ has been added.
*   Support for `gqlgen <https://github.com/99designs/gqlgen>`__ has been added.
*   Support for the `go-pg framework <https://github.com/go-pg/pg>`__ has been improved.

Java
""""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.
    
*   Added models for Apache Commons Lang3 :code:`ToStringBuilder.reflectionToString` method.
    
*   Added support for the Kotlin method :code:`apply`.
    
*   Added models for the following packages:

    *   java.io
    *   java.lang
    *   java.net
    *   java.nio.channels
    *   java.nio.file
    *   java.util.zip
    *   okhttp3
    *   org.gradle.api.file
    *   retrofit2

Python
""""""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.
*   Add support for Models as Data for Reflected XSS query
*   Parameters with a default value are now considered a :code:`DefinitionNode`. This improvement was motivated by allowing type-tracking and API graphs to follow flow from such a default value to a use by a captured variable.

Ruby
""""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.
*   The :code:`'QUERY_STRING'` field of a Rack :code:`env` parameter is now recognized as a source of remote user input.
*   Query parameters and cookies from :code:`Rack::Response` objects are recognized as potential sources of remote flow input.
*   Calls to :code:`Rack::Utils.parse_query` now propagate taint.

Swift
"""""

*   Data flow configurations can now include a predicate :code:`neverSkip(Node node)` in order to ensure inclusion of certain nodes in the path explanations. The predicate defaults to the end-points of the additional flow steps provided in the configuration, which means that such steps now always are visible by default in path explanations.
*   The regular expression library now understands mode flags specified by :code:`Regex` methods and the :code:`NSRegularExpression` initializer.
*   The regular expression library now understands mode flags specified at the beginning of a regular expression (for example :code:`(?is)`).
*   Added detail to the taint model for :code:`URL`.
*   Added new heuristics to :code:`SensitiveExprs.qll`, enhancing detection from the library.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The library :code:`semmle.code.cpp.dataflow.DataFlow` has been deprecated. Please use :code:`semmle.code.cpp.dataflow.new.DataFlow` instead.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

C#
""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

Golang
""""""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

Java
""""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.
*   A :code:`Class.isFileClass()` predicate, to identify Kotlin file classes, has been added.

Python
""""""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

Ruby
""""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

Swift
"""""

*   The :code:`DataFlow::StateConfigSig` signature module has gained default implementations for :code:`isBarrier/2` and :code:`isAdditionalFlowStep/4`.
    Hence it is no longer needed to provide :code:`none()` implementations of these predicates if they are not needed.

Shared Libraries
----------------

Deprecated APIs
~~~~~~~~~~~~~~~

Utility Classes
"""""""""""""""

*   The :code:`InlineExpectationsTest` class has been deprecated. Use :code:`TestSig` and :code:`MakeTest` instead.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.3.rst
.. _codeql-cli-2.16.3:

==========================
CodeQL 2.16.3 (2024-02-22)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.3 runs a total of 408 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 131 queries (covering 34 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug where CodeQL may produce an invalid database when it exhausts all available ID numbers. Now it detects the condition and reports an error instead.

New Features
~~~~~~~~~~~~

*   A new extractor option has been added to the Python extractor:
    :code:`python_executable_name`. You can use this option to override the default process the extractor uses to find and select a Python executable. Pass one of
    :code:`--extractor-option python_executable_name=py` or :code:`--extractor-option python_executable_name=python` or :code:`--extractor-option python_executable_name=python3` to commands that run the extractor, for example: :code:`codeql database create`.
    
    On Windows machines, the Python extractor will expect to find :code:`py.exe` on the system :code:`PATH` by default. If the Python executable has a different name, you can set the new extractor option to override this value and look for
    :code:`python.exe` or :code:`python3.exe`.
    
    For more information about using the extractor option with the CodeQL CLI, see
    \ `Extractor options <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/extractor-options>`__.

Security Updates
~~~~~~~~~~~~~~~~

*   Fixes CVE-2024-25129, a limited data exfiltration vulnerability that could be triggered by untrusted databases or QL packs.  See the
    \ `security advisory <https://github.com/github/codeql-cli-binaries/security/advisories/GHSA-gf8p-v3g3-3wph>`__ for more information.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The left operand of the :code:`&&` operator no longer propagates data flow by default.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   The query "Use of a hardcoded key for signing JWT" (:code:`go/hardcoded-key`) has been promoted from experimental to the main query pack. Its results will now appear by default as part of :code:`go/hardcoded-credentials`. This query was originally `submitted as an experimental query by @porcupineyhairs <https://github.com/github/codeql/pull/9378>`__.

Java
""""

*   The sinks of the queries :code:`java/path-injection` and :code:`java/path-injection-local` have been reworked. Path creation sinks have been converted to summaries instead, while sinks now are actual file read/write operations only. This has reduced the false positive ratio of both queries.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The "non-constant format string" query (:code:`cpp/non-constant-format`) has been updated to produce fewer false positives.
*   Added dataflow models for the :code:`gettext` function variants.

C#
""

*   Added sanitizers for relative URLs, :code:`List.Contains()`, and checking the :code:`.Host` property on an URI to the :code:`cs/web/unvalidated-url-redirection` query.

Java
""""

*   The sanitizer for the path injection queries has been improved to handle more cases where :code:`equals` is used to check an exact path match.
*   The query :code:`java/unvalidated-url-redirection` now sanitizes results following the same logic as the query :code:`java/ssrf`. URLs where the destination cannot be controlled externally are no longer reported.

New Queries
~~~~~~~~~~~

Golang
""""""

*   The query "Missing JWT signature check" (:code:`go/missing-jwt-signature-check`) has been promoted from experimental to the main query pack. Its results will now appear by default. This query was originally `submitted as an experimental query by @am0o0 <https://github.com/github/codeql/pull/14075>`__.

Java
""""

*   Added a new query :code:`java/android/insecure-local-authentication` for finding uses of biometric authentication APIs that do not make use of a :code:`KeyStore`\ -backed key and thus may be bypassed.

Swift
"""""

*   Added a new experimental query, :code:`swift/unsafe-unpacking`, that detects unpacking user controlled zips without validating the destination file path is within the destination directory.

Query Metadata Changes
~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The :code:`security-severity` score of the query :code:`java/relative-path-command` has been reduced to better adjust it to the specific conditions needed for exploitation.

Language Libraries
------------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   C# 12: The QL and data flow library now support primary constructors.
*   Added a new database relation to store key-value pairs corresponding to compilations. The new relation is used in buildless mode to surface information related to dependency fetching.

Java
""""

*   An extension point for sanitizers of the query :code:`java/unvalidated-url-redirection` has been added.
    
*   Added models for the following packages:

    *   java.io
    *   java.lang
    *   java.net
    *   java.net.http
    *   java.nio.file
    *   java.util.zip
    *   javax.servlet
    *   org.apache.commons.io
    *   org.apache.hadoop.fs
    *   org.apache.hadoop.fs.s3a
    *   org.eclipse.jetty.client
    *   org.gradle.api.file

JavaScript/TypeScript
"""""""""""""""""""""

*   The name "certification" is no longer seen as possibly being a certificate, and will therefore no longer be flagged in queries like "clear-text-logging" which look for sensitive data.

Python
""""""

*   The name "certification" is no longer seen as possibly being a certificate, and will therefore no longer be flagged in queries like "clear-text-logging" which look for sensitive data.
*   Added modeling of the :code:`psycopg` PyPI package as a SQL database library.

Ruby
""""

*   Raw output ERB tags of the form :code:`<%== ... %>` are now recognised as cross-site scripting sinks.
*   The name "certification" is no longer seen as possibly being a certificate, and will therefore no longer be flagged in queries like "clear-text-logging" which look for sensitive data.

Swift
"""""

*   The name "certification" is no longer seen as possibly being a certificate, and will therefore no longer be flagged in queries like "clear-text-logging" which look for sensitive data.

Deprecated APIs
~~~~~~~~~~~~~~~

Java
""""

*   The :code:`PathCreation` class in :code:`PathCreation.qll` has been deprecated.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   A :code:`getInitialization` predicate was added to the :code:`RangeBasedForStmt` class that yields the C++20-style initializer of the range-based :code:`for` statement when it exists.

Shared Libraries
----------------

Breaking Changes
~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The :code:`edges` predicate contained in :code:`PathGraph` now contains two additional columns for propagating model provenance information. This is primarily an internal change without any impact on any APIs, except for specialised queries making use of :code:`MergePathGraph` in conjunction with custom :code:`PathGraph` implementations. Such queries will need to be updated to reference the two new columns. This is expected to be very rare, as :code:`MergePathGraph` is an advanced feature, but it is a breaking change for any such affected queries.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.10.5.rst
.. _codeql-cli-2.10.5:

==========================
CodeQL 2.10.5 (2022-09-13)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.10.5 runs a total of 352 security queries when configured with the Default suite (covering 146 CWE). The Extended suite enables an additional 106 queries (covering 30 more CWE).

CodeQL CLI
----------

New Features
~~~~~~~~~~~~

*   You can now define which registries should be used for downloading and publishing CodeQL packs on a per-workspace basis by creating a :code:`codeql-workspace.yml` file and adding a :code:`registries` block. For more infomation, see `About CodeQL Workspaces <https://codeql.github.com/docs/codeql-cli/about-codeql-workspaces/>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.7.rst
.. _codeql-cli-2.12.7:

==========================
CodeQL 2.12.7 (2023-04-18)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.7 runs a total of 386 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 124 queries (covering 31 more CWE).

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fixed a bug in :code:`codeql database upload-results` where the subcommand would fail with "A fatal error occurred: Invalid SARIF.", reporting an :code:`InvalidDefinitionException`. This issue occurred when the SARIF file contained certain kinds of diagnostic information.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.5.rst
.. _codeql-cli-2.12.5:

==========================
CodeQL 2.12.5 (2023-03-21)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.5 runs a total of 385 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 124 queries (covering 31 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Bug Fixes
~~~~~~~~~

*   Fix a bug in :code:`codeql query run` where queries whose path contain colons cannot be run.

New Features
~~~~~~~~~~~~

*   The :code:`codeql pack install` command now accepts a :code:`--additional-packs` option. This option takes a list of directories to search for locally available packs when resolving which packs to install. Any pack that is found locally through :code:`--additional-packs` will override any other version of a pack found in the package registry.
    Locally resolved packs are not added to the lock file.
    
    Because the use of :code:`--additional-packs` when running
    :code:`codeql pack install` makes running queries dependent on the local state of the machine initially invoking :code:`codeql pack install`, a warning is emitted if any pack is found outside of the package registry. This warning can be suppressed by using the
    :code:`--no-strict-mode` option.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The following queries now recognize HTML sanitizers as propagating taint: :code:`js/sql-injection`,
    :code:`js/path-injection`, :code:`js/server-side-unvalidated-url-redirection`, :code:`js/client-side-unvalidated-url-redirection`,
    and :code:`js/request-forgery`.

Deprecated Queries
~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`NetworkToBufferSizeConfiguration` and :code:`UntrustedDataToExternalApiConfig` dataflow configurations have been deprecated. Please use :code:`NetworkToBufferSizeFlow` and :code:`UntrustedDataToExternalApiFlow`.
*   The :code:`LeapYearCheckConfiguration`, :code:`FiletimeYearArithmeticOperationCheckConfiguration`, and :code:`PossibleYearArithmeticOperationCheckConfiguration` dataflow configurations have been deprecated. Please use :code:`LeapYearCheckFlow`, :code:`FiletimeYearArithmeticOperationCheckFlow` and :code:`PossibleYearArithmeticOperationCheckFlow`.

New Queries
~~~~~~~~~~~

Java
""""

*   Added a new query, :code:`java/android/arbitrary-apk-installation`, to detect installation of APKs from untrusted sources.

Python
""""""

*   Added a new query, :code:`py/shell-command-constructed-from-input`, to detect libraries that unsafely construct shell commands from their inputs.

Ruby
""""

*   Added a new query, :code:`rb/zip-slip`, to detect arbitrary file writes during extraction of zip/tar archives.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`semmle.code.cpp.commons.Buffer` and :code:`semmle.code.cpp.commons.NullTermination` libraries no longer expose :code:`semmle.code.cpp.dataflow.DataFlow`. Please import :code:`semmle.code.cpp.dataflow.DataFlow` directly.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   A new C/C++ dataflow library (:code:`semmle.code.cpp.dataflow.new.DataFlow`) has been added.
    The new library behaves much more like the dataflow library of other CodeQL supported languages by following use-use dataflow paths instead of def-use dataflow paths.
    The new library also better supports dataflow through indirections, and new predicates such as :code:`Node::asIndirectExpr` have been added to facilitate working with indirections.
    
    The :code:`semmle.code.cpp.ir.dataflow.DataFlow` library is now identical to the new
    :code:`semmle.code.cpp.dataflow.new.DataFlow` library.
    
*   The main data flow and taint tracking APIs have been changed. The old APIs remain in place for now and translate to the new through a backwards-compatible wrapper. If multiple configurations are in scope simultaneously, then this may affect results slightly. The new API is quite similar to the old, but makes use of a configuration module instead of a configuration class.

C#
""

*   The main data flow and taint tracking APIs have been changed. The old APIs remain in place for now and translate to the new through a backwards-compatible wrapper. If multiple configurations are in scope simultaneously, then this may affect results slightly. The new API is quite similar to the old, but makes use of a configuration module instead of a configuration class.

Golang
""""""

*   The main data flow and taint tracking APIs have been changed. The old APIs remain in place for now and translate to the new through a backwards-compatible wrapper. If multiple configurations are in scope simultaneously, then this may affect results slightly. The new API is quite similar to the old, but makes use of a configuration module instead of a configuration class.

Java
""""

*   Removed low-confidence call edges to known neutral call targets from the call graph used in data flow analysis. This includes, for example, custom :code:`List.contains` implementations when the best inferrable type at the call site is simply :code:`List`.
*   Added more sink and summary dataflow models for the following packages:

    *   :code:`java.io`
    *   :code:`java.lang`
    *   :code:`java.sql`
    *   :code:`javafx.scene.web`
    *   :code:`org.apache.commons.compress.archivers.tar`
    *   :code:`org.apache.http.client.utils`
    *   :code:`org.codehaus.cargo.container.installer`
    
*   The main data flow and taint tracking APIs have been changed. The old APIs remain in place for now and translate to the new through a backwards-compatible wrapper. If multiple configurations are in scope simultaneously, then this may affect results slightly. The new API is quite similar to the old, but makes use of a configuration module instead of a configuration class.

Python
""""""

*   The main data flow and taint tracking APIs have been changed. The old APIs remain in place for now and translate to the new through a backwards-compatible wrapper. If multiple configurations are in scope simultaneously, then this may affect results slightly. The new API is quite similar to the old, but makes use of a configuration module instead of a configuration class.

Ruby
""""

*   The main data flow and taint tracking APIs have been changed. The old APIs remain in place for now and translate to the new through a backwards-compatible wrapper. If multiple configurations are in scope simultaneously, then this may affect results slightly. The new API is quite similar to the old, but makes use of a configuration module instead of a configuration class.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Deleted the deprecated :code:`hasGeneratedCopyConstructor` and :code:`hasGeneratedCopyAssignmentOperator` predicates from the :code:`Folder` class.
*   Deleted the deprecated :code:`getPath` and :code:`getFolder` predicates from the :code:`XmlFile` class.
*   Deleted the deprecated :code:`getMustlockFunction`, :code:`getTrylockFunction`, :code:`getLockFunction`, and :code:`getUnlockFunction` predicates from the :code:`MutexType` class.
*   Deleted the deprecated :code:`getPosInBasicBlock` predicate from the :code:`SubBasicBlock` class.
*   Deleted the deprecated :code:`getExpr` predicate from the :code:`PointerDereferenceExpr` class.
*   Deleted the deprecated :code:`getUseInstruction` and :code:`getDefinitionInstruction` predicates from the :code:`Operand` class.
*   Deleted the deprecated :code:`isInParameter`, :code:`isInParameterPointer`, and :code:`isInQualifier` predicates from the :code:`FunctionInput` class.
*   Deleted the deprecated :code:`isOutParameterPointer`, :code:`isOutQualifier`, :code:`isOutReturnValue`, and :code:`isOutReturnPointer` predicate from the :code:`FunctionOutput` class.
*   Deleted the deprecated 3-argument :code:`isGuardPhi` predicate from the :code:`RangeSsaDefinition` class.

C#
""

*   Deleted the deprecated :code:`getPath` and :code:`getFolder` predicates from the :code:`XmlFile` class.
*   Deleted the deprecated :code:`getAssertionIndex`, and :code:`getAssertedParameter` predicates from the :code:`AssertMethod` class.
*   Deleted the deprecated :code:`OverridableMethod` and :code:`OverridableAccessor` classes.
*   The :code:`unsafe` predicate for :code:`Modifiable` has been extended to cover delegate return types and identify pointer-like types at any nest level. This is relevant for :code:`unsafe` declarations extracted from assemblies.

Java
""""

*   Deleted the deprecated :code:`getPath` and :code:`getFolder` predicates from the :code:`XmlFile` class.
*   Deleted the deprecated :code:`getRepresentedString` predicate from the :code:`StringLiteral` class.
*   Deleted the deprecated :code:`ServletWriterSource` class.
*   Deleted the deprecated :code:`getGroupID`, :code:`getArtefactID`, and :code:`artefactMatches` predicates from the :code:`MavenRepoJar` class.

JavaScript/TypeScript
"""""""""""""""""""""

*   Deleted the deprecated :code:`getPath` and :code:`getFolder` predicates from the :code:`XmlFile` class.
*   Deleted the deprecated :code:`getId` from the :code:`Function`, :code:`NamespaceDefinition`, and :code:`ImportEqualsDeclaration` classes.
*   Deleted the deprecated :code:`flowsTo` predicate from the :code:`HTTP::Servers::RequestSource` and :code:`HTTP::Servers::ResponseSource` class.
*   Deleted the deprecated :code:`getEventName` predicate from the :code:`SocketIO::ReceiveNode`, :code:`SocketIO::SendNode`, :code:`SocketIOClient::SendNode` classes.
*   Deleted the deprecated :code:`RateLimitedRouteHandlerExpr` and :code:`RouteHandlerExpressionWithRateLimiter` classes.
*   \ `Import assertions <https://github.com/tc39/proposal-import-assertions>`__ are now supported.
    Previously this feature was only supported in TypeScript code, but is now supported for plain JavaScript as well and is also accessible in the AST.

Python
""""""

*   Deleted the deprecated :code:`getPath` and :code:`getFolder` predicates from the :code:`XmlFile` class.

Ruby
""""

*   Data flow through :code:`initialize` methods is now taken into account also when the receiver of a :code:`new` call is an (implicit or explicit) :code:`self`.
*   The Active Record query methods :code:`reorder` and :code:`count_by_sql` are now recognized as SQL executions.
*   Calls to :code:`ActiveRecord::Connection#execute`, including those via subclasses, are now recognized as SQL executions.
*   Data flow through :code:`ActionController::Parameters#require` is now tracked properly.
*   The severity of parse errors was reduced to warning (previously error).
*   Deleted the deprecated :code:`getQualifiedName` predicate from the :code:`ConstantWriteAccess` class.
*   Deleted the deprecated :code:`getWhenBranch` and :code:`getAWhenBranch` predicates from the :code:`CaseExpr` class.
*   Deleted the deprecated :code:`Self`, :code:`PatternParameter`, :code:`Pattern`, :code:`VariablePattern`, :code:`TuplePattern`, and :code:`TuplePatternParameter` classes.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`WriteConfig` taint tracking configuration has been deprecated. Please use :code:`WriteFlow`.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   Added support for merging two :code:`PathGraph`\ s via disjoint union to allow results from multiple data flow computations in a single :code:`path-problem` query.

C#
""

*   Added support for merging two :code:`PathGraph`\ s via disjoint union to allow results from multiple data flow computations in a single :code:`path-problem` query.

Golang
""""""

*   Added support for merging two :code:`PathGraph`\ s via disjoint union to allow results from multiple data flow computations in a single :code:`path-problem` query.

Java
""""

*   Added support for merging two :code:`PathGraph`\ s via disjoint union to allow results from multiple data flow computations in a single :code:`path-problem` query.

Python
""""""

*   Added support for merging two :code:`PathGraph`\ s via disjoint union to allow results from multiple data flow computations in a single :code:`path-problem` query.

Ruby
""""

*   Added support for merging two :code:`PathGraph`\ s via disjoint union to allow results from multiple data flow computations in a single :code:`path-problem` query.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.1.rst
.. _codeql-cli-2.16.1:

==========================
CodeQL 2.16.1 (2024-01-25)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.1 runs a total of 406 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 129 queries (covering 34 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

Improvements
~~~~~~~~~~~~

*   When executing the :code:`codeql database init` command, the CodeQL runner executable path is now stored in the :code:`CODEQL_RUNNER` environment variable.
    Users of indirect tracing on MacOS with System Integrity Protection enabled who previously had trouble with indirect tracing should prefix their build command with this path. For example, :code:`$CODEQL_RUNNER build.sh`.

QL Language
~~~~~~~~~~~

*   Name clashes between weak aliases (i.e. aliases that are not final aliases of non-final entities) of the same target no longer cause ambiguity errors.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/include-non-header` style query will now ignore the :code:`.def` extension for textual header inclusions.

C#
""

*   Modelled additional flow steps to track flow from handler methods of a :code:`PageModel` class to the corresponding Razor Page (:code:`.cshtml`) file, which may result in additional results for queries such as :code:`cs/web/xss`.

Golang
""""""

*   The query :code:`go/insecure-randomness` now recognizes the selection of candidates from a predefined set using a weak RNG when the result is used in a sensitive operation. Also, false positives have been reduced by adding more sink exclusions for functions in the :code:`crypto` package not related to cryptographic operations.
*   Added more sources and sinks to the query :code:`go/clear-text-logging`.

Java
""""

*   A manual neutral summary model for a callable now blocks all generated summary models for that callable from having any effect.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added support for `doT <https://github.com/olado/doT>`__ templates.

Python
""""""

*   Added modeling of YARL's :code:`is_absolute` method and checks of the :code:`netloc` of a parsed URL as sanitizers for the :code:`py/url-redirection` query, leading to fewer false positives.

Swift
"""""

*   The diagnostic query :code:`swift/diagnostics/successfully-extracted-files` now considers any Swift file seen during extraction, even one with some errors, to be extracted / scanned. This affects the Code Scanning UI measure of scanned Swift files.

New Queries
~~~~~~~~~~~

Java
""""

*   Added the :code:`java/exec-tainted-environment` query, to detect the injection of environment variables names or values from remote input.

Swift
"""""

*   Added new query "Use of an inappropriate cryptographic hashing algorithm on passwords" (:code:`swift/weak-password-hashing`). This query detects use of inappropriate hashing algorithms for password hashing. Some of the results of this query are new, others would previously have been reported by the "Use of a broken or weak cryptographic hashing algorithm on sensitive data" (:code:`swift/weak-sensitive-data-hashing`) query.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Java
""""

*   Fixed regular expressions containing flags not being parsed correctly in some cases.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Deleted many deprecated predicates and classes with uppercase :code:`XML`, :code:`SSA`, :code:`SAL`, :code:`SQL`, etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`StrcatFunction` class, use :code:`semmle.code.cpp.models.implementations.Strcat.qll` instead.

C#
""

*   Deleted many deprecated predicates and classes with uppercase :code:`SSL`, :code:`XML`, :code:`URI`, :code:`SSA` etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`getALocalFlowSucc` predicate and :code:`TaintType` class from the dataflow library.
*   Deleted the deprecated :code:`Newobj` and :code:`Rethrow` classes, use :code:`NewObj` and :code:`ReThrow` instead.
*   Deleted the deprecated :code:`getAFirstRead`, :code:`hasAdjacentReads`, :code:`lastRefBeforeRedef`, and :code:`hasLastInputRef` predicates from the SSA library.
*   Deleted the deprecated :code:`getAReachableRead` predicate from the :code:`AssignableRead` and :code:`VariableRead` classes.
*   Deleted the deprecated :code:`hasQualifiedName` predicate from the :code:`NamedElement` class.
*   C# 12: Add extractor support and QL library support for inline arrays.
*   Fixed a Log forging false positive when logging the value of a nullable simple type. This fix also applies to all other queries that use the simple type sanitizer.
*   The diagnostic query :code:`cs/diagnostics/successfully-extracted-files`, and therefore the Code Scanning UI measure of scanned C# files, now considers any C# file seen during extraction, even one with some errors, to be extracted / scanned.
*   Added a new library :code:`semmle.code.csharp.security.dataflow.flowsources.FlowSources`, which provides a new class :code:`ThreatModelFlowSource`. The :code:`ThreatModelFlowSource` class can be used to include sources which match the current *threat model* configuration.
*   A manual neutral summary model for a callable now blocks all generated summary models for that callable from having any effect.
*   C# 12: Add extractor support for lambda expressions with parameter defaults like :code:`(int x, int y = 1) => ...` and lambda expressions with a :code:`param` parameter like :code:`(params int[] x) => ...)`.

Golang
""""""

*   Deleted many deprecated predicates and classes with uppercase :code:`TLD`, :code:`HTTP`, :code:`SQL`, :code:`URL` etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated and unused :code:`Source` class from the :code:`SharedXss` module of :code:`Xss.qll`
*   Support for flow sources in `AWS Lambda function handlers <https://docs.aws.amazon.com/lambda/latest/dg/golang-handler.html>`__ has been added.
*   Support for the `fasthttp framework <https://github.com/valyala/fasthttp/>`__ has been added.

Java
""""

*   Deleted many deprecated predicates and classes with uppercase :code:`EJB`, :code:`JMX`, :code:`NFE`, :code:`DNS` etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`semmle/code/java/security/OverlyLargeRangeQuery.qll`, :code:`semmle/code/java/security/regexp/ExponentialBackTracking.qll`, :code:`semmle/code/java/security/regexp/NfaUtils.qll`, and :code:`semmle/code/java/security/regexp/NfaUtils.qll` files.
*   Improved models for :code:`java.lang.Throwable` and :code:`java.lang.Exception`, and the :code:`valueOf` method of :code:`java.lang.String`.
*   Added taint tracking for the following GSON methods:

    *   :code:`com.google.gson.stream.JsonReader` constructor
    *   :code:`com.google.gson.stream.JsonWriter` constructor
    *   :code:`com.google.gson.JsonObject.getAsJsonArray`
    *   :code:`com.google.gson.JsonObject.getAsJsonObject`
    *   :code:`com.google.gson.JsonObject.getAsJsonPrimitive`
    *   :code:`com.google.gson.JsonParser.parseReader`
    *   :code:`com.google.gson.JsonParser.parseString`
    
*   Added a dataflow model for :code:`java.awt.Desktop.browse(URI)`.

JavaScript/TypeScript
"""""""""""""""""""""

*   Deleted many deprecated predicates and classes with uppercase :code:`CPU`, :code:`TLD`, :code:`SSA`, :code:`ASM` etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`getMessageSuffix` predicates in :code:`CodeInjectionCustomizations.qll`.
*   Deleted the deprecated :code:`semmle/javascript/security/dataflow/ExternalAPIUsedWithUntrustedData.qll` file.
*   Deleted the deprecated :code:`getANonHtmlHeaderDefinition` and :code:`nonHtmlContentTypeHeader` predicates from :code:`ReflectedXssCustomizations.qll`.
*   Deleted the deprecated :code:`semmle/javascript/security/OverlyLargeRangeQuery.qll`, :code:`semmle/javascript/security/regexp/ExponentialBackTracking.qll`, :code:`semmle/javascript/security/regexp/NfaUtils.qll`, and :code:`semmle/javascript/security/regexp/NfaUtils.qll` files.
*   Deleted the deprecated :code:`Expressions/TypoDatabase.qll` file.
*   The diagnostic query :code:`js/diagnostics/successfully-extracted-files`, and therefore the Code Scanning UI measure of scanned JavaScript and TypeScript files, now considers any JavaScript and TypeScript file seen during extraction, even one with some errors, to be extracted / scanned.

Python
""""""

*   Deleted many deprecated predicates and classes with uppercase :code:`LDAP`, :code:`HTTP`, :code:`URL`, :code:`CGI` etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`localSourceStoreStep` predicate, use :code:`flowsToStoreStep` instead.
*   Deleted the deprecated :code:`iteration_defined_variable` predicate from the :code:`SSA` library.
*   Deleted various deprecated predicates from the points-to libraries.
*   Deleted the deprecated :code:`semmle/python/security/OverlyLargeRangeQuery.qll`, :code:`semmle/python/security/regexp/ExponentialBackTracking.qll`, :code:`semmle/python/security/regexp/NfaUtils.qll`, and :code:`semmle/python/security/regexp/NfaUtils.qll` files.
*   The diagnostic query :code:`py/diagnostics/successfully-extracted-files`, and therefore the Code Scanning UI measure of scanned Python files, now considers any Python file seen during extraction, even one with some errors, to be extracted / scanned.

Ruby
""""

*   Deleted many deprecated predicates and classes with uppercase :code:`HTTP`, :code:`CSRF` etc. in their names. Use the PascalCased versions instead.
*   Deleted the deprecated :code:`getAUse` and :code:`getARhs` predicates from :code:`API::Node`, use :code:`getASource` and :code:`getASink` instead.
*   Deleted the deprecated :code:`disablesCertificateValidation` predicate from the :code:`Http` module.
*   Deleted the deprecated :code:`ParamsCall`, :code:`CookiesCall`, and :code:`ActionControllerControllerClass` classes from :code:`ActionController.qll`, use the simarly named classes from :code:`codeql.ruby.frameworks.Rails::Rails` instead.
*   Deleted the deprecated :code:`HtmlSafeCall`, :code:`HtmlEscapeCall`, :code:`RenderCall`, and :code:`RenderToCall` classes from :code:`ActionView.qll`, use the simarly named classes from :code:`codeql.ruby.frameworks.Rails::Rails` instead.
*   Deleted the deprecated :code:`HtmlSafeCall` class from :code:`Rails.qll`.
*   Deleted the deprecated :code:`codeql/ruby/security/BadTagFilterQuery.qll`, :code:`codeql/ruby/security/OverlyLargeRangeQuery.qll`, :code:`codeql/ruby/security/regexp/ExponentialBackTracking.qll`, :code:`codeql/ruby/security/regexp/NfaUtils.qll`, :code:`codeql/ruby/security/regexp/RegexpMatching.qll`, and :code:`codeql/ruby/security/regexp/SuperlinearBackTracking.qll` files.
*   Deleted the deprecated :code:`localSourceStoreStep` predicate from :code:`TypeTracker.qll`, use :code:`flowsToStoreStep` instead.
*   The diagnostic query :code:`rb/diagnostics/successfully-extracted-files`, and therefore the Code Scanning UI measure of scanned Ruby files, now considers any Ruby file seen during extraction, even one with some errors, to be extracted / scanned.

Swift
"""""

*   Swift upgraded to 5.9.2
*   The control flow graph library (:code:`codeql.swift.controlflow`) has been transitioned to use the shared implementation from the :code:`codeql/controlflow` qlpack. No result changes are expected due to this change.

Deprecated APIs
~~~~~~~~~~~~~~~

Golang
""""""

*   The class :code:`Fmt::AppenderOrSprinter` of the :code:`Fmt.qll` module has been deprecated. Use the new :code:`Fmt::AppenderOrSprinterFunc` class instead. Its taint flow features have been migrated to models-as-data.

New Features
~~~~~~~~~~~~

Java
""""

*   Added a new library :code:`semmle.code.java.security.Sanitizers` which contains a new sanitizer class :code:`SimpleTypeSanitizer`, which represents nodes which cannot realistically carry taint for most queries (e.g. primitives, their boxed equivalents, and numeric types).
*   Converted definitions of :code:`isBarrier` and sanitizer classes to use :code:`SimpleTypeSanitizer` instead of checking if :code:`node.getType()` is :code:`PrimitiveType` or :code:`BoxedType`.

Shared Libraries
----------------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Static Single Assignment (SSA)
""""""""""""""""""""""""""""""

*   Deleted the deprecated :code:`adjacentDefNoUncertainReads`, :code:`lastRefRedefNoUncertainReads`, and :code:`lastRefNoUncertainReads` predicates.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.3.rst
.. _codeql-cli-2.14.3:

==========================
CodeQL 2.14.3 (2023-08-25)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.3 runs a total of 393 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 127 queries (covering 33 more CWE).

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The :code:`<run>.tool.extensions` property in the SARIF generated by :code:`codeql database analyze` now contains the following packs:

    *   The containing query pack for each query that was evaluated.
    *   Each model pack that was specified via the :code:`--model-packs` option, regardless of whether that model pack affected any of the evaluated queries.
    
    Library packs are no longer included in the list.
    
    Previously, this property contained every query and library pack that was available on the search path, regardless of whether that pack was used during the evaluation.

Miscellaneous
~~~~~~~~~~~~~

*   The build of Eclipse Temurin OpenJDK that is bundled with the CodeQL CLI has been updated to version 17.0.8.
    
*   When :code:`codeql test` generates :code:`.actual` files, they will in some cases list the query predicates in a different order than past versions.
    There is no need to update :code:`.expected` files, as :code:`codeql test` sorts their results accordingly before diffing.
    However, when there are genuine changes in expected results, the generated :code:`.actual` file can show additional changes against the
    :code:`.expected` due to the reordering.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

Python
""""""

*   Fixed the computation of locations for imports with aliases in jump-to-definition.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   Improved support for flow through captured variables that properly adheres to inter-procedural control flow.

Swift
"""""

*   Added :code:`DataFlow::CollectionContent`, which will enable more accurate flow through collections.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The query library for :code:`cs/hardcoded-credentials` now excludes benign properties such as :code:`UserNameClaimType` and :code:`AllowedUserNameCharacters` from :code:`Microsoft.AspNetCore.Identity` options classes.

Java
""""

*   Modified the :code:`getSecureAlgorithmName` predicate in :code:`Encryption.qll` to also include :code:`SHA-256` and :code:`SHA-512`. Previously only the versions of the names without dashes were considered secure.
*   Add support for :code:`WithElement` and :code:`WithoutElement` for MaD access paths.

Python
""""""

*   Support analyzing packages (folders with python code) that do not have :code:`__init__.py` files, although this is technically required, we see real world projects that don't have this.
*   Added modeling of AWS Lambda handlers that can be identified with :code:`AWS::Serverless::Function` in YAML files, where the event parameter is modeled as a remote-flow-source.
*   Improvements of the :code:`aiohttp` models including remote-flow-sources from type annotations, new path manipulation, and SSRF sinks.

Ruby
""""

*   Flow between positional arguments and splat parameters (:code:`*args`) is now tracked more precisely.
*   Flow between splat arguments (:code:`*args`) and positional parameters is now tracked more precisely.

Swift
"""""

*   Added local flow sources for :code:`UITextInput` and related classes.
*   Flow through forced optional unwrapping (:code:`!`) on the left side of assignment now works in most cases.
*   :code:`Type.getName` now gets the name of the type alone without any enclosing types. Use :code:`Type.getFullName` for the old behaviour.

Shared Libraries
----------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   Initial release. Adds a library to implement flow through captured variables that properly adheres to inter-procedural control flow.

New Features
~~~~~~~~~~~~

YAML Data Analysis
""""""""""""""""""

*   Added library for serverless functions. Currently used by JavaScript and Python.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.4.4.rst
.. _codeql-cli-2.4.4:

=========================
CodeQL 2.4.4 (2021-02-12)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.4.4 runs a total of 235 security queries when configured with the Default suite (covering 106 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE). 3 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The :code:`name` property in :code:`qlpack.yml` must now meet the following requirements:

    *   Only lowercase ASCII letters, ASCII digits, and hyphens (:code:`-`) are allowed.
    *   A hyphen is not allowed as the first or last character of the name.
    *   The name must be at least one character long, and no longer than 128 characters.

Bug Fixes
~~~~~~~~~

*   The default value of the :code:`--working-dir` options for the
    :code:`index-files` and :code:`trace-command` subcommands of :code:`codeql database` has been fixed to match the documentation; previously, it would erroneously use the process' current working directory rather than the database source root.
    
*   :code:`codeql test run` will not crash if database extraction in a test directory fails. Instead only the tests in that directory will be marked as failing, and tests in other directories will continue executing.

New Features
~~~~~~~~~~~~

*   Alert and path queries can now give a score to each alert they produce. You can incorporate alert scores in an alert or path query by first adding the :code:`@scored` property to the query metadata. You can then introduce a new numeric column at the end of the :code:`select` statement structure to represent the score of each alert.
    Alert scores are exposed in the SARIF output of commands like
    :code:`codeql database analyze` as the :code:`score` property in the property bags of result objects.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.4.5.rst
.. _codeql-cli-2.4.5:

=========================
CodeQL 2.4.5 (2021-03-08)
=========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.4.5 runs a total of 237 security queries when configured with the Default suite (covering 108 CWE). The Extended suite enables an additional 79 queries (covering 26 more CWE). 2 security queries have been added with this release.

CodeQL CLI
----------

There are no user-facing CLI changes in this release.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.14.2.rst
.. _codeql-cli-2.14.2:

==========================
CodeQL 2.14.2 (2023-08-11)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.14.2 runs a total of 393 security queries when configured with the Default suite (covering 155 CWE). The Extended suite enables an additional 127 queries (covering 33 more CWE). 1 security query has been added with this release.

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The functionality provided by the :code:`codeql execute query-server` subcommand has been removed. The subcommand now responds to all JSON RPC requests with an error response. Correspondingly, this release is no longer compatible with versions of the CodeQL extension for Visual Studio Code prior to 1.7.6.
    
    This change also breaks third-party CodeQL IDE integrations that still rely on the :code:`codeql execute query-server` subcommand. Maintainers of such CodeQL IDE integrations should migrate to the :code:`codeql execute query-server2` subcommand at the earliest opportunity.

Bug Fixes
~~~~~~~~~

*   Fixed bug that made the :code:`--warnings=hide` option do nothing in
    :code:`codeql database analyze` and other commands that *evaluate* queries.

Improvements
~~~~~~~~~~~~

*   Switched from prefix filtering of autocomplete suggestions in the language server to client-side filtering. This improves autocomplete suggestions in contexts with an autocompletion prefix.
    
*   The CodeQL language server now checks query metadata for errors. This allows Visual Studio Code users to see errors in their query metadata without needing to compile the query.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Java
""""

*   The sanitizer in :code:`java/potentially-weak-cryptographic-algorithm` has been improved, so the query may yield additional results.

New Queries
~~~~~~~~~~~

Ruby
""""

*   Added a new experimental query, :code:`rb/ldap-injection`, to detect cases where user input is incorporated into LDAP queries without proper validation or sanitization, potentially leading to LDAP injection vulnerabilities.

Swift
"""""

*   Added new query "Command injection" (:code:`swift/command-line-injection`). The query finds places where user input is used to execute system commands without proper escaping.
*   Added new query "Bad HTML filtering regexp" (:code:`swift/bad-tag-filter`). This query finds regular expressions that match HTML tags in a way that is not robust and can easily lead to security issues.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`shouldPrintFunction` predicate from :code:`PrintAstConfiguration` has been replaced by :code:`shouldPrintDeclaration`. Users should now override :code:`shouldPrintDeclaration` if they want to limit the declarations that should be printed.
*   The :code:`shouldPrintFunction` predicate from :code:`PrintIRConfiguration` has been replaced by :code:`shouldPrintDeclaration`. Users should now override :code:`shouldPrintDeclaration` if they want to limit the declarations that should be printed.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`PrintAST` library now also prints global and namespace variables and their initializers.

Swift
"""""

*   Added :code:`DataFlow::ArrayContent`, which will provide more accurate flow through arrays.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`_Float128x` type is no longer exposed as a builtin type. As this type could not occur any code base, this should only affect queries that explicitly looked at the builtin types.

Golang
""""""

*   Logrus' :code:`WithContext` methods are no longer treated as if they output the values stored in that context to a log message.

Java
""""

*   Fixed a typo in the :code:`StdlibRandomSource` class in :code:`RandomDataSource.qll`, which caused the class to improperly model calls to the :code:`nextBytes` method. Queries relying on :code:`StdlibRandomSource` may see an increase in results.
*   Improved the precision of virtual dispatch of :code:`java.io.InputStream` methods. Now, calls to these methods will not dispatch to arbitrary implementations of :code:`InputStream` if there is a high-confidence alternative (like a models-as-data summary).
*   Added more dataflow steps for :code:`java.io.InputStream`\ s that wrap other :code:`java.io.InputStream`\ s.
*   Added models for the Struts 2 framework.
*   Improved the modeling of Struts 2 sources of untrusted data by tainting the whole object graph of the objects unmarshaled from an HTTP request.

JavaScript/TypeScript
"""""""""""""""""""""

*   Added :code:`log-injection` as a customizable sink kind for log injection.

Swift
"""""

*   Flow through forced optional unwrapping (:code:`!`) is modelled more accurately.
*   Added flow models for :code:`Sequence.withContiguousStorageIfAvailable`.
*   Added taint flow for :code:`NSUserActivity.referrerURL`.

New Features
~~~~~~~~~~~~

Java
""""

*   A :code:`Diagnostic.getCompilationInfo()` predicate has been added.

Shared Libraries
----------------

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Control Flow Analysis
"""""""""""""""""""""

*   Initial release. Adds a shared library for control flow analyses.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   Initial release. Moves the shared inter-procedural data-flow library into its own qlpack.

New Features
~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The :code:`StateConfigSig` signature now supports a unary :code:`isSink` predicate that does not specify the :code:`FlowState` for which the given node is a sink. Instead, any :code:`FlowState` is considered a valid :code:`FlowState` for such a sink.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.16.0.rst
.. _codeql-cli-2.16.0:

==========================
CodeQL 2.16.0 (2024-01-16)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.16.0 runs a total of 405 security queries when configured with the Default suite (covering 160 CWE). The Extended suite enables an additional 128 queries (covering 33 more CWE). 4 security queries have been added with this release.

CodeQL CLI
----------

Potentially Breaking Changes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   The Python extractor will no longer extract dependencies by default. See https://github.blog/changelog/2023-07-12-code-scanning-with-codeql-no-longer-installs-python-dependencies-automatically-for-new-users/ for more context. In versions until 2.17.0, it will be possible to restore the old behavior by setting :code:`CODEQL_EXTRACTOR_PYTHON_FORCE_ENABLE_LIBRARY_EXTRACTION_UNTIL_2_17_0=1`.
    
*   The :code:`--ram` option to :code:`codeql database run-queries` and other commands that execute queries is now interpreted more strictly.
    Previously it was mostly a rough hint for how much memory to use,
    and the actual memory footprint of the CodeQL process could be hundreds of megabytes higher. From this release, CodeQL tries harder to keep its *total* memory consumption during evaluation below the given limit.
    
    The new behavior yields more predictable memory use, but since it works by allocating less RAM, it can lead to more use of *disk*
    storage for intermediate results compared to earlier releases with the same :code:`--ram` value, and consequently a slight performance loss. In rare cases, for large databases, analysis may fail with a Java :code:`OutOfMemoryError`.
    
    The cure for this is to increase :code:`--ram` to be closer to the amount of memory actually available for CodeQL. As a rule of thumb, it will usually be possible to increase the value of :code:`--ram` by 700 MB or more, without actually using more resources than release 2.15.x would with the old setting. An exact amount cannot stated, however,
    since the actual memory footprint in earlier releases depended on factors such as the size of the databases that were not fully taken into account.
    
    If you use the CodeQL Action, you do not need to do anything unless you have manually overridden the Action's RAM setting. The Action will automatically select a :code:`--ram` setting that matches the version of the CLI it uses.

New Features
~~~~~~~~~~~~

*   Users specifying extra tracing configurations may now use the :code:`GetRegisteredMatchers(languageId)` Lua function to retrieve the existing table of matchers registered to a given language.

Improvements
~~~~~~~~~~~~

*   The :code:`Experimental` flag has been removed from all packaging and related commands.
*   The RA pretty-printer omits names of internal RA nodes and pretty-prints binary unions with nested internal unions as n-ary unions. VS Code extension v1.11.0 or newer is required to compute join order badness metrics in VS Code for the new RA format.

Query Packs
-----------

Bug Fixes
~~~~~~~~~

Java
""""

*   The three queries :code:`java/insufficient-key-size`, :code:`java/server-side-template-injection`, and :code:`java/android/implicit-pendingintents` had accidentally general extension points allowing arbitrary string-based flow state. This has been fixed and the old extension points have been deprecated where possible, and otherwise updated.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`cpp/badly-bounded-write` query could report false positives when a pointer was first initialized with a literal and later assigned a dynamically allocated array. These false positives now no longer occur.

C#
""

*   Fixed a Log forging false positive when using :code:`String.Replace` to sanitize the input.
*   Fixed a URL redirection from remote source false positive when guarding a redirect with :code:`HttpRequestBase.IsUrlLocalToHost()`

Golang
""""""

*   There was a bug in the query :code:`go/incorrect-integer-conversion` which meant that upper bound checks using a strict inequality (:code:`<`) and comparing against :code:`math.MaxInt` or :code:`math.MaxUint` were not considered correctly, which led to false positives. This has now been fixed.

Java
""""

*   Modified the :code:`java/potentially-weak-cryptographic-algorithm` query to include the use of weak cryptographic algorithms from configuration values specified in properties files.
*   The query :code:`java/android/missing-certificate-pinning` should no longer alert about requests pointing to the local filesystem.
*   Removed some spurious sinks related to :code:`com.opensymphony.xwork2.TextProvider.getText` from the query :code:`java/ognl-injection`.

Swift
"""""

*   Added additional sinks for the "Cleartext logging of sensitive information" (:code:`swift/cleartext-logging`) query. Some of these sinks are heuristic (imprecise) in nature.

New Queries
~~~~~~~~~~~

C/C++
"""""

*   Added a new query, :code:`cpp/use-of-unique-pointer-after-lifetime-ends`, to detect uses of the contents unique pointers that will be destroyed immediately.
*   The :code:`cpp/incorrectly-checked-scanf` query has been added. This finds results where the return value of scanf is not checked correctly. Some of these were previously found by :code:`cpp/missing-check-scanf` and will no longer be reported there.

Java
""""

*   Added the :code:`java/insecure-randomness` query to detect uses of weakly random values which an attacker may be able to predict. Also added the :code:`crypto-parameter` sink kind for sinks which represent the parameters and keys of cryptographic operations.

Language Libraries
------------------

Bug Fixes
~~~~~~~~~

C/C++
"""""

*   Under certain circumstances a function declaration that is not also a definition could be associated with a :code:`Function` that did not have the definition as a :code:`FunctionDeclarationEntry`. This is now fixed when only one definition exists, and a unique :code:`Function` will exist that has both the declaration and the definition as a :code:`FunctionDeclarationEntry`.

Python
""""""

*   We would previously confuse all captured variables into a single scope entry node. Now they each get their own node so they can be tracked properly.
*   The dataflow graph no longer contains SSA variables. Instead, flow is directed via the corresponding controlflow nodes. This should make the graph and the flow simpler to understand. Minor improvements in flow computation has been observed, but in general negligible changes to alerts are expected.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   Added support for global data-flow through captured variables.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C/C++
"""""

*   Changed the output of :code:`Node.toString` to better reflect how many indirections a given dataflow node has.
*   Added a new predicate :code:`Node.asDefinition` on :code:`DataFlow::Node`\ s for selecting the dataflow node corresponding to a particular definition.
*   The deprecated :code:`DefaultTaintTracking` library has been removed.
*   The :code:`Guards` library has been replaced with the API-compatible :code:`IRGuards` implementation, which has better precision in some cases.

C#
""

*   The :code:`Call::getArgumentForParameter` predicate has been reworked to add support for arguments passed to :code:`params` parameters.
*   The dataflow models for the :code:`System.Text.StringBuilder` class have been reworked. New summaries have been added for :code:`Append` and :code:`AppendLine`. With the changes, we expect queries that use taint tracking to find more results when interpolated strings or :code:`StringBuilder` instances are passed to :code:`Append` or :code:`AppendLine`.
*   Additional support for :code:`Amazon.Lambda` SDK

Golang
""""""

*   The diagnostic query :code:`go/diagnostics/successfully-extracted-files`, and therefore the Code Scanning UI measure of scanned Go files, now considers any Go file seen during extraction, even one with some errors, to be extracted / scanned.
*   The XPath library, which is used for the XPath injection query (:code:`go/xml/xpath-injection`), now includes support for :code:`Parser` sinks from the `libxml2 <https://github.com/lestrrat-go/libxml2>`__ package.
*   :code:`CallNode::getACallee` and related predicates now recognise more callees accessed via a function variable, in particular when the callee is stored into a global variable or is captured by an anonymous function. This may lead to new alerts where data-flow into such a callee is relevant.

Java
""""

*   Added the :code:`Map#replace` and :code:`Map#replaceAll` methods to the :code:`MapMutator` class in :code:`semmle.code.java.Maps`.
    
*   Taint tracking now understands Kotlin's :code:`Array.get` and :code:`Array.set` methods.
    
*   Added a sink model for the :code:`createRelative` method of the :code:`org.springframework.core.io.Resource` interface.
    
*   Added source models for methods of the :code:`org.springframework.web.util.UrlPathHelper` class and removed their taint flow models.
    
*   Added models for the following packages:

    *   com.google.common.io
    *   hudson
    *   hudson.console
    *   java.lang
    *   java.net
    *   java.util.logging
    *   javax.imageio.stream
    *   org.apache.commons.io
    *   org.apache.hadoop.hive.ql.exec
    *   org.apache.hadoop.hive.ql.metadata
    *   org.apache.tools.ant.taskdefs
    
*   Added models for the following packages:

    *   com.alibaba.druid.sql.repository
    *   jakarta.persistence
    *   jakarta.persistence.criteria
    *   liquibase.database.jvm
    *   liquibase.statement.core
    *   org.apache.ibatis.mapping
    *   org.keycloak.models.map.storage

Python
""""""

*   Captured subclass relationships ahead-of-time for most popular PyPI packages so we are able to resolve subclass relationships even without having the packages installed. For example we have captured that :code:`flask_restful.Resource` is a subclass of :code:`flask.views.MethodView`, so our Flask modeling will still consider a function named :code:`post` on a :code:`class Foo(flask_restful.Resource):` as a HTTP request handler.
*   Python now makes use of the shared type tracking library, exposed as :code:`semmle.python.dataflow.new.TypeTracking`. The existing type tracking library, :code:`semmle.python.dataflow.new.TypeTracker`, has consequently been deprecated.

Ruby
""""

*   Parsing of division operators (:code:`/`) at the end of a line has been improved. Before they were wrongly interpreted as the start of a regular expression literal (:code:`/.../`) leading to syntax errors.
*   Parsing of :code:`case` statements that are formatted with the value expression on a different line than the :code:`case` keyword  has been improved and should no longer lead to syntax errors.
*   Ruby now makes use of the shared type tracking library, exposed as :code:`codeql.ruby.typetracking.TypeTracking`. The existing type tracking library, :code:`codeql.ruby.typetracking.TypeTracker`, has consequently been deprecated.

Swift
"""""

*   Expanded flow models for :code:`UnsafePointer` and similar classes.
*   Added flow models for non-member :code:`withUnsafePointer` and similar functions.
*   Added flow models for :code:`withMemoryRebound`, :code:`assumingMemoryBound` and :code:`bindMemory` member functions of library pointer classes.
*   Added a sensitive data model for :code:`SecKeyCopyExternalRepresentation`.
*   Added imprecise flow models for :code:`append` and :code:`insert` methods, and initializer calls with a :code:`data` argument.
*   Tyes for patterns are now included in the database and made available through the :code:`Pattern::getType()` method.

Deprecated APIs
~~~~~~~~~~~~~~~

C/C++
"""""

*   The :code:`isUserInput`, :code:`userInputArgument`, and :code:`userInputReturned` predicates from :code:`SecurityOptions` have been deprecated. Use :code:`FlowSource` instead.

Java
""""

*   Imports of the old dataflow libraries (e.g. :code:`semmle.code.java.dataflow.DataFlow2`) have been deprecated in the libraries under the :code:`semmle.code.java.security` namespace.

New Features
~~~~~~~~~~~~

C/C++
"""""

*   :code:`UserDefineLiteral` and :code:`DeductionGuide` classes have been added, representing C++11 user defined literals and C++17 deduction guides.

Shared Libraries
----------------

Deprecated APIs
~~~~~~~~~~~~~~~

Dataflow Analysis
"""""""""""""""""

*   The old configuration-class based data flow api has been deprecated. The configuration-module based api should be used instead. For details, see https://github.blog/changelog/2023-08-14-new-dataflow-api-for-writing-custom-codeql-queries/.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-overview/codeql-changelog/codeql-cli-2.12.4.rst
.. _codeql-cli-2.12.4:

==========================
CodeQL 2.12.4 (2023-03-09)
==========================

.. contents:: Contents
   :depth: 2
   :local:
   :backlinks: none

This is an overview of changes in the CodeQL CLI and relevant CodeQL query and library packs. For additional updates on changes to the CodeQL code scanning experience, check out the `code scanning section on the GitHub blog <https://github.blog/tag/code-scanning/>`__, `relevant GitHub Changelog updates <https://github.blog/changelog/label/code-scanning/>`__, `changes in the CodeQL extension for Visual Studio Code <https://marketplace.visualstudio.com/items/GitHub.vscode-codeql/changelog>`__, and the `CodeQL Action changelog <https://github.com/github/codeql-action/blob/main/CHANGELOG.md>`__.

Security Coverage
-----------------

CodeQL 2.12.4 runs a total of 385 security queries when configured with the Default suite (covering 154 CWE). The Extended suite enables an additional 122 queries (covering 31 more CWE).

CodeQL CLI
----------

Breaking Changes
~~~~~~~~~~~~~~~~

*   The default value of the :code:`--mode` switch to :code:`codeql pack install` has changed. The default is now :code:`--mode minimal-update`.
    Previously, it was :code:`use-lock`.

Deprecations
~~~~~~~~~~~~

*   The :code:`--freeze` switch for :code:`codeql pack create`, :code:`codeql pack bundle`, and :code:`codeql pack publish` is now deprecated and ignored, as there is no longer a cache within a pack.
*   The :code:`--mode update` switch to :code:`codeql pack resolve-dependencies` is now deprecated. Instead, use the new :code:`--mode upgrade` switch, which has identical behavior.
*   The :code:`--mode` switch to :code:`codeql pack install` is now deprecated.

    *   Instead of :code:`--mode update`, use :code:`codeql pack upgrade`.
    *   Instead of :code:`--mode verify`, use :code:`codeql pack ci`.

New Features
~~~~~~~~~~~~

*   The per-pack compilation cache has been replaced with a global compilation cache found within :code:`~/.codeql`.
*   :code:`codeql pack install` now uses a new algorithm to determine which versions of the pack's dependencies to use, based on the `PubGrub <https://nex3.medium.com/pubgrub-2fb6470504f>`__ algorithm. The new algorithm is able to find a solution for many cases that the previous algorithm would fail to solve. When the new algorithm is unable to find a valid solution, it generates a detailed error message explaining why there is no valid solution.
*   Added a new command, :code:`codeql pack upgrade`. This command is similar to :code:`codeql pack install`,
    except that it ignores any existing lock file, installs the latest compatible version of each dependency, and writes a new lock file. This is equivalent to :code:`codeql pack install --mode update`.
    Note that the :code:`--mode` switch to :code:`codeql pack install` is now deprecated.
*   Added a new command, :code:`codeql pack ci`. This command is similar to :code:`codeql pack install`,
    except if the existing lock file is missing, or if it conflicts with the version constraints in the :code:`qlpack.yml` file, the command generates an error. This is equivalent to
    :code:`codeql pack install --mode verify`. Note that the :code:`--mode` switch to :code:`codeql pack install` is now deprecated.

Query Packs
-----------

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Golang
""""""

*   The query :code:`go/incorrect-integer-conversion` now correctly recognizes guards of the form :code:`if val <= x` to protect a conversion :code:`uintX(val)` when :code:`x` is in the range :code:`(math.MaxIntX, math.MaxUintX]`.

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`js/regex-injection` query now recognizes environment variables and command-line arguments as sources.

Language Libraries
------------------

Breaking Changes
~~~~~~~~~~~~~~~~

JavaScript/TypeScript
"""""""""""""""""""""

*   The :code:`CryptographicOperation` concept has been changed to use a range pattern. This is a breaking change and existing implementations of :code:`CryptographicOperation` will need to be updated in order to compile. These implementations can be updated by:

    #.  Extending :code:`CryptographicOperation::Range` rather than :code:`CryptographicOperation`
    #.  Renaming the :code:`getInput()` member predicate as :code:`getAnInput()`
    #.  Implementing the :code:`BlockMode getBlockMode()` member predicate. The implementation for this can be :code:`none()` if the operation is a hashing operation or an encryption operation using a stream cipher.

Major Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python
""""""

*   We use a new analysis for the call-graph (determining which function is called). This can lead to changed results. In most cases this is much more accurate than the old call-graph that was based on points-to, but we do lose a few valid edges in the call-graph, especially around methods that are not defined inside its class.

Minor Analysis Improvements
~~~~~~~~~~~~~~~~~~~~~~~~~~~

C#
""

*   The query :code:`cs/static-field-written-by-instance` is updated to handle properties.
*   C# 11: Support for explicit interface member implementation of operators.
*   The extraction of member modifiers has been generalized, which could lead to the extraction of more modifiers.
*   C# 11: Added extractor and library support for :code:`file` scoped types.
*   C# 11: Added extractor support for :code:`required` fields and properties.
*   C# 11: Added library support for :code:`checked` operators.

Java
""""

*   Added new sinks for :code:`java/hardcoded-credential-api-call` to identify the use of hardcoded secrets in the creation and verification of JWT tokens using :code:`com.auth0.jwt`. These sinks are from `an experimental query submitted by @luchua <https://github.com/github/codeql/pull/9036>`__.
*   The Java extractor now supports builds against JDK 20.
*   The query :code:`java/hardcoded-credential-api-call` now recognizes methods that accept user and password from the SQLServerDataSource class of the Microsoft JDBC Driver for SQL Server.

Python
""""""

*   Fixed module resolution so we properly recognize definitions made within if-then-else statements.
*   Added modeling of cryptographic operations in the :code:`hmac` library.

Ruby
""""

*   Flow is now tracked between ActionController :code:`before_filter` and :code:`after_filter` callbacks and their associated action methods.
*   Calls to :code:`ApplicationController#render` and :code:`ApplicationController::Renderer#render` are recognized as Rails rendering calls.
*   Support for `Twirp framework <https://twitchtv.github.io/twirp/docs/intro.html>`__.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/customizing-settings.rst
:tocdepth: 1

.. _customizing-settings:

Customizing settings
====================

.. include:: ../reusables/vs-code-deprecation-note.rst

You can edit the settings for the CodeQL extension to suit your needs.

About CodeQL extension settings
---------------------------------

The CodeQL extension comes with a number of settings that you can edit. These determine how the extension behaves, including: which version of the CodeQL CLI the extension uses, how the extension displays previous queries, and how it runs queries.

Editing settings
-----------------

1. Open the Extensions view and right click **CodeQL**.

2. Click **Extension Settings**.

   .. image:: ../images/codeql-for-visual-studio-code/open-extension-settings.png
      :width: 400
      :alt: Open the CodeQL extension settings

3. Edit a setting. The new settings are saved automatically.

Alternatively, you can edit the settings in JSON format by opening the command palette and selecting **Preferences: Open User Settings (JSON)**.

Choosing a version of the CodeQL CLI
--------------------------------------

The CodeQL extension uses the CodeQL CLI to run commands. If you already have the CLI installed and added to your ``PATH``, the extension uses that version. This might be the case if you create your own CodeQL databases instead of downloading them from GitHub.com. Otherwise, the extension automatically manages access to the executable of the CLI for you. For more information about creating databases, see "`Creating CodeQL databases <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/creating-codeql-databases>`__" in the CLI help.

To override the default behavior and use a different CLI, you can specify the CodeQL CLI **Executable Path**.

Changing the labels of query history items
--------------------------------------------

The query history **Format** setting controls how the extension lists queries in the query history. By default, each item has a label with the following format::
    
    %q on %d - %s %r [%t]

- ``%q`` is the query name
- ``%d`` is the database name
- ``%s`` is a status string
- ``%r`` is the number of results
- ``%t`` is the time the query was run

To override the default label, you can specify a different format for the query history items.


Changing the retention period for query history items
-----------------------------------------------------

By default, items in the query history view are retained for 30 days. You can set a different time to live (TTL) by changing the "Code QL > Query History: TTL" setting. To retain items indefinitely, set the value to 0.

.. _configuring-settings-for-running-queries:

Configuring settings for running queries locally
------------------------------------------------

There are a number of settings for **Running Queries**. If your queries run too slowly and time out frequently, you may want to increase the memory. 

.. include:: ../reusables/running-queries-debug.rst

To save query server logs in a custom location, edit the **Running Queries: Custom Log Directory** setting. If you use a custom log directory, the extension saves the logs permanently, instead of deleting them automatically after each workspace session. This is useful if you want to investigate these logs to improve the performance of your queries.

Configuring settings for variant analysis
------------------------------------------

You can define or edit lists of GitHub repositories for variant analysis, and change to a different controller repository using the **Variant analysis** settings.

For information on the purpose and requirements for a controller repository, see ":ref:`Setting up a controller repository for variant analysis <controller-repository>`."

You can also edit the items shown in the Variant Analysis Repositories panel by editing a file in your Visual Studio Code workspace called ``databases.json``. This file contains a JSON representation of all the items displayed in the panel. To open your ``databases.json`` file in an editor window, click the **{ }** icon in the top right of the Variant Analysis Repositories panel. You can then see a structured representation of the repos, orgs and lists in your panel. For example:

.. code-block:: json

  {
    "version": 1,
    "databases": {
      "variantAnalysis": {
        "repositoryLists": [
          {
            "name": "My favorite JavaScript repos",
            "repositories": [
              "facebook/react",
              "babel/babel",
              "angular/angular"
            ]
          }
        ],
        "owners": [
          "microsoft"
        ],
        "repositories": [
          "apache/hadoop"
        ]
      }
    },
    "selected": {
      "kind": "variantAnalysisSystemDefinedList",
      "listName": "top_10"
    }
  }

You can change the items shown in the panel or add new items by directly editing this file.

Configuring settings for adding databases
------------------------------------------------

To automatically add database source folders to your workspace, you can enable the **Adding Databases > Add Database Source to Workspace** setting.

This setting is disabled by default. You may want to enable the setting if you regularly browse the source code of databases, for example to view the abstract syntax tree of the code. For more information, see ":ref:`Exploring the structure of your source code <exploring-the-structure-of-your-source-code>`."

.. pull-quote:: Note

   If you are in a single-folder workspace, adding database source folders will cause the workspace to reload as a multi-root workspace. This may cause query history and database lists to be reset.

   Before enabling this setting, we recommend that you save your workspace as a multi-root workspace. For more information, see "`Multi-root Workspaces <https://code.visualstudio.com/docs/editor/multi-root-workspaces>`__" in the Visual Studio Code help.

Configuring settings for testing queries locally
------------------------------------------------

To increase the number of threads used for testing queries, you can update the **Running Tests > Number Of Threads** setting.

To pass additional arguments to the CodeQL CLI when running tests, you can update the **Running Tests > Additional Test Arguments** setting. For more information about the available arguments, see `test run <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-manual/test-run/>`_ in the documentation for CodeQL CLI. 

Configuring settings for telemetry and data collection
--------------------------------------------------------

You can configure whether the CodeQL extension collects telemetry data. This is disabled by default. For more information, see ":doc:`About telemetry in CodeQL for Visual Studio Code <about-telemetry-in-codeql-for-visual-studio-code>`."

Further reading
----------------

- `User and workspace settings <https://code.visualstudio.com/docs/getstarted/settings>`__ in the Visual Studio Code help
- "`CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__"


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/exploring-the-structure-of-your-source-code.rst
:tocdepth: 1

.. _exploring-the-structure-of-your-source-code:

Exploring the structure of your source code
=================================================

.. include:: ../reusables/vs-code-deprecation-note.rst

You can use the AST viewer to display the abstract syntax tree of a CodeQL database.

About the abstract syntax tree
-------------------------------

The abstract syntax tree (AST) of a program represents the program's syntactic structure. Nodes on the AST represent elements such as statements and expressions.
A CodeQL database encodes these program elements and the relationships between them through a :ref:`database schema <codeql-database-schema>`.

CodeQL for Visual Studio Code contains an AST viewer. The viewer consists of a graph visualization view that lets you explore the AST of a file in a CodeQL database. This helps you see which CodeQL classes correspond to which parts of your source files.

Viewing the abstract syntax tree of a source file
--------------------------------------------------

1. Open the CodeQL Databases view and right-click the database that you want to explore. Click **Add Database Source to Workspace**.

   .. image:: ../images/codeql-for-visual-studio-code/add-database-source-to-workspace.png
      :width: 350
      :alt: Add database source to workspace

2. Navigate to a CodeQL database's source file in the File Explorer.

   .. image:: ../images/codeql-for-visual-studio-code/open-source-file.png
      :width: 350
      :alt: Open a source file

3. Run **CodeQL: View AST** from the Command Palette. This runs a CodeQL query (usually called ``printAST.ql``) over the active file, which may take a few seconds.
   
   .. pull-quote:: Note

      If you don't have an appropriate ``printAST.ql`` query in your workspace, the **CodeQL: View AST** command won't work. To fix this, you can update your copy of the `CodeQL <https://github.com/github/codeql>`__ repository from ``main``. If you do this, you may need to upgrade your databases. Also, query caches may be discarded and your next query runs could be slower.

4. Once the query has run, the AST viewer displays the structure of the source file.
5. To see the nested structure, click the arrows and expand the nodes.

   .. image:: ../images/codeql-for-visual-studio-code/explore-ast.png
      :alt: Explore the AST

You can click a node in the AST viewer to jump to it in the source code. Conversely, if you click a section of the source code, the AST viewer displays the corresponding node.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/index.rst
.. _codeql-for-visual-studio-code:

CodeQL for Visual Studio Code
=============================

.. include:: ../reusables/vs-code-deprecation-note.rst

The CodeQL extension for Visual Studio Code adds rich language support for CodeQL and allows you to easily find problems in codebases.

- :doc:`About CodeQL for Visual Studio Code
  <about-codeql-for-visual-studio-code>`: CodeQL for Visual Studio
  Code is an extension that lets you write, run, and test CodeQL queries in Visual
  Studio Code.

- :doc:`Setting up CodeQL in Visual Studio Code
  <setting-up-codeql-in-visual-studio-code>`: You can install and configure 
  the CodeQL extension in Visual Studio Code.

- :doc:`Analyzing your projects
  <analyzing-your-projects>`: You can run queries on CodeQL
  databases and view the results in Visual Studio Code.

- :doc:`Exploring the structure of your source code
  <exploring-the-structure-of-your-source-code>`: 
  You can use the AST viewer to display the abstract syntax tree of a CodeQL database.

- :doc:`Exploring data flow with path queries
  <exploring-data-flow-with-path-queries>`: You can run CodeQL queries in
  VS Code to help you track the flow of data through a program, highlighting
  areas that are potential security vulnerabilities.  

- :doc:`Running CodeQL queries at scale with multi-repository variant analysis
  <running-codeql-queries-at-scale-with-mrva>`: You can run queries against groups
  of repositories on GitHub.com and view results in Visual Studio Code as each analysis
  finishes. 

- :doc:`Testing CodeQL queries in Visual Studio Code
  <testing-codeql-queries-in-visual-studio-code>`: You can run unit tests for
  CodeQL queries using the Visual Studio Code extension.

- :doc:`Working with CodeQL packs in Visual Studio Code
  <working-with-codeql-packs-in-visual-studio-code>`: You can view, create, and edit all types of CodeQL pack in Visual Studio Code.

- :doc:`Using the CodeQL model editor
  <using-the-codeql-model-editor>`: You can view, create, and edit CodeQL model packs using a dedicated editor.

- :doc:`Customizing settings
  <customizing-settings>`: You can edit the settings for the 
  CodeQL extension to suit your needs.

- :doc:`Troubleshooting CodeQL for Visual Studio Code
  <troubleshooting-codeql-for-visual-studio-code>`: You can use the detailed 
  information written to the extension's log files if you need to troubleshoot problems with
  analysis of local CodeQL databases.

- :doc:`Troubleshooting variant analysis
  <troubleshooting-variant-analysis>`: You can use the detailed 
  information written to workflow log files in your controller repository if you need to
  troubleshoot problems with analysis of CodeQL databases stored on GitHub.com.

- :doc:`About telemetry in CodeQL for Visual Studio Code <about-telemetry-in-codeql-for-visual-studio-code>`: If you specifically opt in to permit GitHub to do so, GitHub will collect usage data and metrics for the purposes of helping the core developers to improve the CodeQL extension for VS Code.

.. toctree::
   :hidden:
   :titlesonly:

   about-codeql-for-visual-studio-code
   setting-up-codeql-in-visual-studio-code
   analyzing-your-projects
   exploring-the-structure-of-your-source-code
   exploring-data-flow-with-path-queries
   running-codeql-queries-at-scale-with-mrva
   testing-codeql-queries-in-visual-studio-code
   working-with-codeql-packs-in-visual-studio-code
   using-the-codeql-model-editor
   customizing-settings
   troubleshooting-codeql-for-visual-studio-code
   troubleshooting-variant-analysis
   about-telemetry-in-codeql-for-visual-studio-code



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/running-codeql-queries-at-scale-with-mrva.rst
:tocdepth: 1

.. _running-codeql-queries-at-scale-with-mrva:

Running CodeQL queries at scale with multi-repository variant analysis
======================================================================

.. include:: ../reusables/vs-code-deprecation-note.rst

.. include:: ../reusables/beta-note-mrva.rst

About multi-repository variant analysis
---------------------------------------

When you write a query to find variants of a security vulnerability and finish testing it locally, the next step is to run it on a large group of repositories. Multi-repository variant analysis (variant analysis) makes it easy run a query on up to 1000 repositories without leaving Visual Studio Code.

The core functionality of the CodeQL extension helps you write queries and run them locally against a CodeQL database. In contrast, variant analysis allows you to send your CodeQL query to GitHub.com to be tested against a list of repositories.

When you run variant analysis against a list of repositories, your query is run against each repository that has a CodeQL database available to analyze. GitHub creates and stores the latest CodeQL database for the default branch of thousands of public repositories, including every repository that runs code scanning using CodeQL. 

If you want to run variant analysis on your repositories, you need to enable code scanning using CodeQL on GitHub.com before adding your repository to a list for analysis (either default setup, or advanced setup using the CodeQL action). For information about enabling code scanning using CodeQL, see "`Configuring code scanning automatically <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning-for-a-repository#configuring-code-scanning-automatically>`__."

.. _controller-repository:

Setting a controller repository for variant analysis
----------------------------------------------------

When you run variant analysis, the analysis is run entirely using GitHub Actions. You don't need to create any workflows, but you must specify which GitHub repository the CodeQL extension should use as the "controller repository." Controller repositories can be empty, but they must have at least one commit. 

.. pull-quote::
   
   Note

   - The controller repository visibility can be "public" if you plan to analyze public repositories. The variant analysis will be free.
   - The controller repository visibility must be "private" if you need to analyze any private or internal repositories. Any actions minutes used by variant analysis, above the free limit, will be charged to the repository owner. For more information about free minutes and billing, see "`About billing for GitHub Actions <https://docs.github.com/en/billing/managing-billing-for-github-actions/about-billing-for-github-actions>`__." 

You must define a controller repository before you can run your first variant analysis.

.. image:: ../images/codeql-for-visual-studio-code/controller-repository.png
    :width: 350
    :alt: Screenshot of the CodeQL extension in Visual Studio Code. The "Variant Analysis Repositories" section is expanded and the "Set up controller repository" button is highlighted with a dark orange outline.

#. In Visual Studio Code, click **QL** in the left sidebar to display the CodeQL extension.

#. Expand **Variant Analysis Repositories** and click **Set up controller repository** to display a field for the controller repository.

#. Type the owner and name of the repository on GitHub.com that you want to use as your controller repository and press the **Enter** key.

#. If you are prompted to authenticate with GitHub, follow the instructions and sign into your personal or organization account. When you have finished following the process, a prompt from GitHub Authentication may ask for permission to open a URI in Visual Studio Code, click **Open**.

The name of the controller repository is saved in your settings for the CodeQL extension. For information on how to edit the controller repository, see ":ref:`Customizing settings <customizing-settings>`."

Running a query at scale using variant analysis
-----------------------------------------------

#. Expand the **Variant Analysis Repositories** section, to show the default lists which include a selection of 10, 100, and 1,000 public repositories on GitHub.com for the language that you are analyzing.

#. Select which GitHub repository or repositories you want to run your query against. Click a row to highlight it, and then click **Select** to select that repository, organization, or list of repositories. If you want to add a new repository, organization, or list, use the options in the header panel. For information, see ":ref:`Creating custom lists of repositories <custom-lists>`", later in this article.

    .. image:: ../images/codeql-for-visual-studio-code/variant-analysis-repo-lists.png
        :width: 350
        :alt: Screenshot of the CodeQL extension in Visual Studio Code. The "Variant Analysis Repositories" section is expanded. The "Top 10 repositories" item has a checkmark to show that it is currently selected for analysis. The user has clicked on the row for a single repository "octo-org/octo-repo" and it is highlighted blue. The "Select" button for that row is highlighted with a dark orange highlight.

#. Open the query you want to run, right-click in the query file, and select **CodeQL: Run Variant Analysis** to start variant analysis.

The CodeQL extension builds a CodeQL pack with your library and any library dependencies. The CodeQL pack and your selected repository list are posted to an API endpoint on GitHub.com which triggers a GitHub Actions dynamic workflow in your controller repository. The workflow spins up multiple parallel jobs to execute the CodeQL query against the repositories in the list, optimizing query execution. As each repository is analyzed, the results are processed and displayed in a Variant Analysis Results view in Visual Studio Code.

.. pull-quote::

    Note

    If you need to cancel the variant analysis run for any reason, click **Stop query** in the Variant Analysis Results view.

Exploring your results
----------------------

When you run variant analysis, as soon as a workflow to run your analysis on GitHub is running, a Variant Analysis Results view opens to display the results as they are ready. You can use this view to monitor progress, see any errors, and access the workflow logs in your controller repository.

.. image:: ../images/codeql-for-visual-studio-code/variant-analysis-results-view.png
    :alt: Screenshot of the "Variant Analysis Results" view showing a partially complete run. Analysis of ``angular/angular`` is still running but all other results are displayed. ``facebook/create-react-app`` has three results for this query.

When your variant analysis run is scheduled, the results view automatically opens. Initially the view shows a list of every repository that was scheduled for analysis. As each repository is analyzed, the view is updated to show a summary of the number of results. To view the detailed results for a repository (including results paths), click the repository name.

For each repository, you can see:

- Number of results found by the query
- Visibility of the repository
- Whether analysis is still running (black, moving circle) or finished (green checkmark)
- Number of stars the repository has on GitHub

To see the results for a repository:

.. image:: ../images/codeql-for-visual-studio-code/variant-analysis-result.png
    :alt: Screenshot of an example result in the "Variant Analysis Results" view. The result has blue links to the source files in GitHub so you can go straight to the repository to fix the problem. There is also a "Show paths" link because this is a data flow query.

#. Click the repository name to show a summary of each result.

#. Explore the information available for each result using links to the source files in GitHub.com and, for data flow queries, the **Show paths** link. For more information, see ":ref:`Exploring data flow with path queries <exploring-data-flow-with-path-queries>`."

Exporting your results
----------------------

You can export your results for further analysis or to discuss them with collaborators. In the results view, click **Export results** to export the results to a secret gist on GitHub.com or to a markdown file in your workspace.

.. _custom-lists:

Creating custom lists of repositories
-------------------------------------

After you have defined a controller repository, the Variant Analysis Repositories panel shows the lists of repositories that you can select for variant analysis. You can use the options in the panel header to add a specific repository or organization to the panel, and to create and manage custom lists of repositories for variant analysis.

.. pull-quote::

    Note

    CodeQL analysis always requires a CodeQL database to run queries against. When you run variant analysis against a list of repositories, your query will only be executed against the repositories that currently have a CodeQL database available to download.  The best way to make a repository available for variant analysis is to enable code scanning with CodeQL. For information about enabling code scanning using CodeQL, see "`Configuring code scanning automatically <https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning-for-a-repository#configuring-code-scanning-automatically>`__."

Selecting a single GitHub repository or organization for analysis
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. In the Variant Analysis Repositories panel, click the **+**, add new database, icon. 

#. From the dropdown menu, click **From a GitHub repository** or **All repositories of GitHub org or owner**.

#. Type the identifier of the repository or organization that you want to use into the field.

    .. image:: ../images/codeql-for-visual-studio-code/variant-analysis-repo-and-org.png
        :width: 350
        :alt: Screenshot of the CodeQL extension in Visual Studio Code. The "Variant Analysis Repositories" section is expanded to show a repository (octo-org/octo-repo) and an organization (octo-org). These items are highlighted with a dark orange outline.

Creating a custom list of repositories
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

#. In the Variant Analysis Repositories panel, click the |add-list| icon.

#. Type a name for the new list and press **Enter**.

#. Select your list in the panel and then click **+**, to add a repository to your list.

You can manage and edit your custom lists by right-clicking on either the list name, or a repository name within the list, and selecting an option from the context menu.

The custom lists are stored in your workspace in a ``databases.json`` file. If you want to edit this file directly, you can open it by clicking **{ }** in the panel header. 

For example, if you want to continue analyzing a set of repositories that had results for your query, click **Copy repository list** in the Variant Analysis Results view to add a list of only the repositories that have results to the clipboard as JSON. For example:

.. code-block:: json

    {
        "name": "new-repo-list",
        "repositories": [
            "facebook/create-react-app"
        ]
    }

You can then insert the ``new-repo-list`` of repositories into your list of custom repository lists for easy access in the Variant Analysis Repositories panel.

Using GitHub code search to add repositories to a custom list 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use code search directly in the CodeQL extension to add a subset of repositories from GitHub.com to a custom list. 

.. pull-quote::

    Note

    This feature uses the legacy code search via the code search API. For more information on the syntax to use, see "`Searching code (legacy) <https://docs.github.com/en/search-github/searching-on-github/searching-code>`__."

For example, to add all repositories in the ``rails`` organization on GitHub, you can search ``org:rails``. 

You can add a maximum of 1000 repositories to a custom list per search. 

#. In the Variant Analysis Repositories panel, choose the list that you want to add repositories to. You can create a new list or choose an existing list that already contains repositories.

#. Right-click on the list you have chosen and then click **Add repositories with GitHub Code Search**. 

#. In the pop-up that appears at the top of the application, under the search bar, select a language for your search from the choices in the dropdown. 

    .. image:: ../images/codeql-for-visual-studio-code/variant-analysis-code-search-language.png
        :alt: Screenshot of the search bar for using code search to add repositories to a custom list. The search bar asks you to choose a language for your search and has a dropdown list of languages to choose from.

#. In the search bar, type the search query that you want to use and press **Enter**.

You can view the progress of your search in the bottom right corner of the application in a box with the text "Searching for repositories...". If you click **Cancel**, no repositories will be added to your list. Once complete, you will see the resulting repositories appear in the dropdown under your custom list in the Variant Analysis Repositories panel.

Some of the resulting repositories will not have CodeQL databases and some may not allow access by the CodeQL extension for Visual Studio Code. When you run an analysis on the list, the Variant Analysis Results view will show you which repositories were analyzed, which denied access, and which had no CodeQL database.

Troubleshooting variant analysis
--------------------------------

For information on troubleshooting variant analysis, see
":ref:`Troubleshooting variant analysis <troubleshooting-variant-analysis>`."

.. |add-list| image:: ../images/codeql-for-visual-studio-code/variant-analysis-add-list.png
    :height: 2ex



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/testing-codeql-queries-in-visual-studio-code.rst
:tocdepth: 1

.. _testing-codeql-queries-in-visual-studio-code:

Testing CodeQL queries in Visual Studio Code
============================================

.. include:: ../reusables/vs-code-deprecation-note.rst

You can run unit tests for CodeQL queries using the Visual Studio Code extension. When you are sure that your query finds the results you want to identify, you can use variant analysis to run it at scale. For information on running analysis at scale across many CodeQL databases, see ":ref:`Running CodeQL queries at scale with multi-repository variant analysis <running-codeql-queries-at-scale-with-mrva>`."

About testing queries in VS Code
---------------------------------

To ensure that your CodeQL queries produce the expected results, you can run tests that compare the expected query results with the actual results.

The CodeQL extension automatically registers itself with the **Testing** view. The **Testing** view displays all tests found in your current workspace and provides a UI for exploring and running tests in your workspace.

For more information about how CodeQL tests work, see "`Testing custom queries <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/testing-custom-queries>`__" in the CLI help.

Testing the results of your queries
-----------------------------------

1. Open the **Testing** view in the sidebar.

   .. image:: ../images/codeql-for-visual-studio-code/open-testing-view.png
      :width: 350
      :alt: Open the Testing view

2. To run a specific test, hover over the file or folder name and click the play button. To run all tests in your workspace, click the play button at the top of the view. If a test takes too long to run, you can click the stop button at the top of the view to cancel the test.
3. The icons show whether a test passed or failed. If it failed, click the test in the **Test Results** panel to display the differences between the expected output and the actual output.

   .. image:: ../images/codeql-for-visual-studio-code/test-results-panel.png
      :width: 800
      :alt: View the Test Results panel

4. Compare the results. If you want to update the test with the actual output, right-click the test in the **Testing** view and click **Accept Test Output**.

   .. image:: ../images/codeql-for-visual-studio-code/accept-test-output.png
      :width: 400
      :alt: Acccept test output in the Testing view

Monitoring the performance of your queries
------------------------------------------

Query performance is important when you want to run a query on large databases, or as part of your continuous integration system. 

.. include:: ../reusables/running-queries-debug.rst

When a query is evaluated, the query server caches the predicates that it calculates. So when you want to compare the performance of two evaluations, you should clear the query server's cache before each run (**CodeQL: Clear Cache** command). This ensures that you're comparing equivalent data.

For more information, see ":ref:`Troubleshooting query performance <troubleshooting-query-performance>`" and ":ref:`Evaluation of QL programs <evaluation-of-ql-programs>`."


Further reading
----------------

* "`Testing custom queries <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/testing-custom-queries>`__"



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/exploring-data-flow-with-path-queries.rst
:tocdepth: 1

.. _exploring-data-flow-with-path-queries:

Exploring data flow with path queries
=====================================

.. include:: ../reusables/vs-code-deprecation-note.rst

You can run CodeQL queries in VS Code to help you track the flow of data through a program, highlighting areas that are potential security vulnerabilities.

About path queries
--------------------

A path query is a CodeQL query with the property ``@kind path-problem``. 
You can find a number of these in the standard CodeQL libraries, for example, a security query that finds cross-site scripting vulnerabilities in Java projects:
`Cross-site scripting <https://github.com/github/codeql/blob/main/java/ql/src/Security/CWE/CWE-079/XSS.ql>`__.

You can run the standard CodeQL path queries to identify security vulnerabilities and manually look through the results.
You can also modify the existing queries to model data flow more precisely for the specific framework of your project, or write completely new path queries to find a different vulnerability.

To ensure that your path query uses the correct format and metadata, follow the instructions in ":ref:`Creating path queries <creating-path-queries>`."
This topic also contains detailed information about how to define new sources and sinks, as well as templates and examples of how to extend the CodeQL libraries to suit your analysis.

Running path queries in VS Code locally
---------------------------------------

#. Open a path query in the editor.
#. Right-click in the query window and select **CodeQL: Run Query on Selected Database**. (Alternatively, run the command from the Command Palette.)
#. Once the query has finished running, you can see the results in the Results view as usual (under ``alerts`` in the dropdown menu). Each query result describes the flow of information between a source and a sink.
#. Expand the result to see the individual steps that the data follows. 
#. Click each step to jump to it in the source code and investigate the problem further.
#. To navigate the results from your keyboard, you can bind shortcuts to the **CodeQL: Navigate Up/Down/Left/Right in Result Viewer** commands.

When you are ready to run a path query at scale, you can use the Variant Analysis Repositories panel to run the query against up to 1,000 repositories on GitHub.com. For information on running analysis at scale across many CodeQL databases, see ":ref:`Running CodeQL queries at scale with multi-repository variant analysis <running-codeql-queries-at-scale-with-mrva>`."

Further reading
-----------------

- ":ref:`About data flow analysis <about-data-flow-analysis>`"
- ":ref:`Creating path queries <creating-path-queries>`"


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code.rst
:tocdepth: 1

.. _setting-up-codeql-in-visual-studio-code:

Setting up CodeQL in Visual Studio Code
=================================================

.. include:: ../reusables/vs-code-deprecation-note.rst

You can install and configure the CodeQL extension in Visual Studio Code.

.. include:: ../reusables/license-note.rst

Prerequisites
-----------------

The CodeQL extension requires a minimum of Visual Studio Code 1.39. Older versions are not supported.

Installing the extension
------------------------

You can install the CodeQL extension using any of the normal methods for installing a VS Code extension:

* Go to the `Visual Studio Code Marketplace <https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql>`__ in your browser and click **Install**.
* In the Extensions view (**Ctrl+Shift+X** or **Cmd+Shift+X**), search for ``CodeQL``, then select **Install**.
* Download the `CodeQL VSIX file <https://github.com/github/vscode-codeql/releases>`__. Then, in the Extensions view, click the ellipsis representing the **Views and More Actions...** menu, select **Install from VSIX**, then select the CodeQL VSIX file.

Configuring access to the CodeQL CLI
------------------------------------

The extension uses the CodeQL CLI to compile and run queries.

If you already have the CLI installed and added to your ``PATH``, the extension uses that version. This might be the case if you create your own CodeQL databases instead of downloading them from GitHub.com. For more information, see `CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__."

Otherwise, the extension automatically manages access to the executable of the CLI for you. This ensures that the CLI is compatible with the CodeQL extension. You can also check for updates with the **CodeQL: Check for CLI Updates** command.

.. pull-quote:: Note

   The extension-managed CLI is not accessible from the terminal.
   If you intend to use the CLI outside of the extension (for example to create databases), we recommend that you install your own copy of the CLI.
   To avoid having two copies of the CLI on your machine, you can point the CodeQL CLI **Executable Path** setting to your existing copy of the CLI.

If you want the extension to use a specific version of the CLI, set the CodeQL CLI **Executable Path** to the location of the executable file for the CLI.
That is, the file named ``codeql`` (Linux/Mac) or ``codeql.exe`` (Windows). For more information, see ":ref:`Customizing settings <customizing-settings>`."

If you have any difficulty setting up access to the CodeQL CLI, check the CodeQL Extension Log for error messages. For more information, see ":doc:`Troubleshooting CodeQL for Visual Studio Code <troubleshooting-codeql-for-visual-studio-code>`."

Setting up a CodeQL workspace
-----------------------------

When you're working with CodeQL, you need access to the standard CodeQL libraries. This also makes a wide variety of queries available to explore.

There are two ways to do this:

* Recommended, use the "starter" workspace. This is maintained as a Git repository which makes it easy to keep up to date with changes to the libraries. For more information, see ":ref:`Using the starter workspace <starter-workspace>`" below.
* More advanced, add the CodeQL libraries and queries to an existing workspace. For more information, see ":ref:`Updating an existing workspace for CodeQL <existing-workspace>`" below.

.. pull-quote:: Note

   For CLI users there is a third option: If you have followed the instructions in "`Getting started with the CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/getting-started-with-the-codeql-cli>`__" to create a CodeQL directory (for example ``codeql-home``) containing the CodeQL libraries, you can open this directory in VS Code. This also gives the extension access to the CodeQL libraries.

.. _starter-workspace:

Using the starter workspace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The starter workspace is a Git repository. It contains:

* The `repository of CodeQL libraries and queries <https://github.com/github/codeql>`__ for all supported languages. This is included as a submodule, so it can be updated without affecting your custom queries.
* A series of folders named ``codeql-custom-queries-<language>``. These are ready for you to start developing your own custom queries for each language, using the standard libraries. There are some example queries to get you started.

To use the starter workspace:

#. Clone the https://github.com/github/vscode-codeql-starter/ repository to your computer:
    * Make sure you include the submodules, either by using ``git clone --recursive``, or using by ``git submodule update --init --remote`` after cloning.
    * Use ``git submodule update --remote`` regularly to keep the submodules up to date.

#. In VS Code, use the **File** > **Open Workspace** option to open the ``vscode-codeql-starter.code-workspace`` file from your checkout of the workspace repository.

Remember to update the ``ql`` submodule in the starter workspace periodically to ensure that it remains compatible with newer versions of the VS Code extension and the CodeQL CLI.

.. _existing-workspace:

Updating an existing workspace for CodeQL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
You can add the CodeQL libraries to an existing workspace by making a local clone of the CodeQL repository directly: https://github.com/github/codeql.

To make the standard libraries available in your workspace:

#. Select **File** > **Add Folder to Workspace**, and choose your local checkout of the ``github/codeql`` repository.

#. Create one new folder per target language, using either the **New Folder** or **Add Folder to Workspace** options, to hold custom queries and libraries.

#. Create a ``qlpack.yml`` file in each target language folder. This tells the CodeQL CLI the target language for that folder and what its dependencies are. (The ``main`` branch of ``github/codeql`` already has these files.) CodeQL will look for the dependencies in all the open workspace folders, or on the user's search path.

For example, to make a custom CodeQL folder called ``my-custom-cpp-pack`` depend on the CodeQL standard library for C++, create a ``qlpack.yml`` file with the following contents:

.. code-block:: yaml

    name: my-custom-cpp-pack
    version: 0.0.0
    libraryPathDependencies: codeql/cpp-all

For more information about why you need to add a ``qlpack.yml`` file, see "`About CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs>`__."

Further reading
----------------

* ":doc:`Analyzing your projects <analyzing-your-projects>`"
* "`CodeQL CLI <https://docs.github.com/en/code-security/codeql-cli>`__"



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/working-with-codeql-packs-in-visual-studio-code.rst
:tocdepth: 1

.. _working-with-codeql-packs-in-visual-studio-code:

Working with CodeQL packs in Visual Studio Code
===============================================

.. include:: ../reusables/vs-code-deprecation-note.rst

.. include:: ../reusables/beta-note-package-management.rst

You can view, write, and edit all types of CodeQL packs in Visual Studio Code using the CodeQL extension. 

About CodeQL packs
------------------
You use CodeQL packs to share your expertise in query writing, CodeQL library development, and modeling dependencies with other users. The CodeQL package management system ensures that when you publish a CodeQL pack it is ready to use, without any compilation. Anything the CodeQL pack depends on is explicitly defined within the pack. You can publish your own CodeQL packs and download packs created by others. For more information, see "`About CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs>`__."

There are three types of CodeQL packs, each with a specific purpose.

- Query packs are designed to be run. When a query pack is published, the bundle includes all the transitive dependencies and pre-compiled representations of each query, in addition to the query sources. This ensures consistent and efficient execution of the queries in the pack.
- Model packs are used to model dependencies that are not supported by the standard CodeQL libraries. When you add a model pack to your analysis, all relevant queries also recognize the sources, sinks and flow steps of the dependencies defined in the pack.
- Library packs are designed to be used by query packs (or other library packs) and do not contain queries themselves. The libraries are not compiled separately.

Using the CodeQL packs shipped with the CLI in Visual Studio Code
-----------------------------------------------------------------
To install dependencies for a CodeQL pack in your Visual Studio Code workspace, run the **CodeQL: Install Pack Dependencies** command from the Command Palette and select the packs you want to install dependencies for.

You can write and run query packs that depend on the CodeQL standard libraries, without needing to check out the standard libraries in your workspace. Instead, you can install only the dependencies required by the query packs you want to use.

Working with CodeQL query packs
-------------------------------

One of the main benefits of working with a CodeQL query pack is that all dependencies are resolved, not just those defined within the query and standard libraries.

Creating and editing CodeQL query packs 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To create a new query pack, you will need to use the CodeQL CLI from a terminal, which you can do within Visual Studio Code or outside of it with the ``codeql pack init`` command. Once you create an empty pack, you can edit the ``qlpack.yml`` file or run the ``codeql pack add`` command to add dependencies or change the name or version. For detailed information, see "`Creating and working with CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/creating-and-working-with-codeql-packs>`__."

You can create or edit queries in a CodeQL pack in Visual Studio Code as you would with any CodeQL query, using the standard code editing features such as autocomplete suggestions to find elements to use from the pack's dependencies. 

You can then use the CodeQL CLI to publish your pack to share with others. For detailed information, see "`Publishing and using CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/publishing-and-using-codeql-packs>`__."

Viewing CodeQL query packs and their dependencies
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To download a query pack that someone else has created, run the **CodeQL: Download Packs** command from the Command Palette.
You can download all the core query packs, or enter the full name of a specific pack to download. For example, to download the core queries for analyzing Java and Kotlin, enter ``codeql/java-queries``.

Whether you have downloaded a CodeQL pack or created your own, you can open the ``qlpack.yml`` file in the root of a CodeQL pack directory in Visual Studio Code and view the dependencies section to see what libraries the pack depends on.

If you want to understand a query in a CodeQL pack better, you can open the query file and view the code, using the IntelliSense code editing features of Visual Studio Code. For example, if you hover over an element from a library depended on by the pack, Visual Studio Code will resolve it so you can see documentation about the element. 

To view the full definition of an element of a query, you can right-click and choose **Go to Definition**. If the library pack is present within the same Visual Studio Code workspace, this will take you to the definition within the workspace. Otherwise it will take you to the definition within your package cache, the shared location where downloaded dependencies are stored, which is in your home directory by default.

Working with CodeQL model packs
-------------------------------

The CodeQL extension for Visual Studio Code includes a dedicated editor for creating and editing model packs. For information on using the model editor, see ":ref:`Using the CodeQL model editor <using-the-codeql-model-editor>`."



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/about-telemetry-in-codeql-for-visual-studio-code.rst
:tocdepth: 1

.. _about-telemetry-in-codeql-for-visual-studio-code:

About telemetry in CodeQL for Visual Studio Code
=================================================

.. include:: ../reusables/vs-code-deprecation-note.rst

If you specifically opt in to permit GitHub to do so, GitHub will collect usage data and metrics for the purposes of helping the core developers to improve the CodeQL extension for VS Code.

This data will not be shared with any parties outside of GitHub. IP addresses and installation IDs will be retained for a maximum of 30 days. Anonymous data will be retained for a maximum of 180 days.

Why we collect data
--------------------------------------

GitHub collects aggregated, anonymous usage data and metrics to help us improve CodeQL for VS Code. IP addresses and installation IDs are collected only to ensure that anonymous data is not duplicated during aggregation.

What data is collected
--------------------------------------

If you opt in, GitHub collects the following information related to the usage of the extension. The data collected are:

- The identifiers of any CodeQL-related VS Code commands that are run.
    - For each command: the timestamp, time taken, and whether or not the command completed successfully.
- Interactions with UI elements, including buttons, links, and other inputs.
    - Link targets and text inputs are not recorded.
    - Mouse movement and hovering are not recorded.
- Occurrence of exceptions and errors.
    - All sensitive information such as file paths and non-static exception message content are removed before uploading.
- VS Code and extension version.
- Randomly generated GUID that uniquely identifies a CodeQL extension installation. (Discarded before aggregation.)
- IP address of the client sending the telemetry data. (Discarded before aggregation.)
- Whether or not the ``codeQL.canary`` setting is enabled and set to ``true``.
- Whether any :doc:`CodeQL extension settings <customizing-settings>` are configured.

How long data is retained
--------------------------

IP address and GUIDs will be retained for a maximum of 30 days. Anonymous, aggregated data that includes command identifiers, run times, and timestamps will be retained for a maximum of 180 days.

Access to the data
-------------------

IP address and GUIDs will only be available to the core developers of CodeQL. Aggregated data will be available to GitHub employees.

What data is **NOT** collected
--------------------------------

We only collect the minimal amount of data we need to answer the questions about how our users are experiencing this product. To that end, we do not collect the following information:

- No GitHub user ID
- No CodeQL database names or contents
- No contents of CodeQL queries
- No filesystem paths
- No user-input text
- No mouse interactions, such as movement or hovers

Disabling telemetry reporting
------------------------------

Telemetry collection is *disabled* by default.

When telemetry collection is disabled, no data will be sent to GitHub servers.

You can disable telemetry collection by setting ``codeQL.telemetry.enableTelemetry`` to ``false`` in your settings. For more information about CodeQL settings, see ":doc:`Customizing settings <customizing-settings>`." 

Additionally, telemetry collection will be disabled if the global ``telemetry.telemetryLevel`` setting is set to ``off``. For more information about global telemetry collection, see "`Microsoft's documentation <https://code.visualstudio.com/docs/supporting/faq#_how-to-disable-telemetry-reporting>`__."

Further reading
----------------

For more information, see GitHub's "`Privacy Statement <https://docs.github.com/github/site-policy/github-privacy-statement>`__" and "`Terms of Service <https://docs.github.com/github/site-policy/github-terms-of-service>`__."



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/troubleshooting-codeql-for-visual-studio-code.rst
:tocdepth: 1

.. _troubleshooting-codeql-for-visual-studio-code:

Troubleshooting CodeQL for Visual Studio Code
=============================================

.. include:: ../reusables/vs-code-deprecation-note.rst

This article explains how to debug problems with the analysis of CodeQL databases that are stored on your local
machine. For information on troubleshooting variant analysis, which runs on GitHub.com, see
":ref:`Troubleshooting variant analysis <troubleshooting-variant-analysis>`."

You can use the detailed information written to the extension's log files if you need to troubleshoot problems
analyzing CodeQL databases that are stored locally.

About the log files
--------------------

Progress and error messages are displayed as notifications in the bottom right corner of the workspace.
These link to more detailed logs and error messages in the Output panel.
You can use the dropdown list to select the logs you need.

   .. image:: ../images/codeql-for-visual-studio-code/select-logs.png
      :alt: Select the logs in the Output view

Troubleshooting installation and configuration problems
------------------------------------------------------------

If you encounter any problems when installing and configuring the extension, check the CodeQL Extension Log to see general extension logging messages, including details about the CodeQL CLI and the commands invoked by the extension.

In particular, you can see the location of the CLI that is being used. This is useful if you want to see whether this is an extension-managed CLI or an external one.

If you use the extension-managed CLI, the extension checks for updates automatically (or with the **CodeQL: Check for CLI Updates** command) and prompts you to accept the updated version.
If you use an external CLI, you need to update it manually (when updates are necessary).

Exploring problems with queries and databases
----------------------------------------------

For details about compiling and running queries, as well as information about database upgrades, check the CodeQL Query Server log.

If you see behavior or errors that suggest problems, you can use the **CodeQL: Restart Query Server** command to restart the query server. This restarts the server without affecting your CodeQL session history.
You are most likely to need to restart the query server if you make external changes to files that the extension is using. For example, regenerating a CodeQL database that's open in VS Code. In addition to problems in the log, you might also see: errors in code highlighting, incorrect results totals, or duplicate notifications that a query is running.

To see the logs from running a particular query, right-click the query in the Query History and select **Show Query Log**.
If the log file is too large for the extension to open in the VS Code editor, the file will be displayed in your file explorer so you can open it with an external program.

By default, the extension deletes logs after each workspace session. To override this behavior, you can specify a custom directory for query server logs. For more information, see ":ref:`Customizing settings <configuring-settings-for-running-queries>`."

Exploring problems with running tests
----------------------------------------------

To see more detailed output from running unit tests, open the CodeQL Tests log.
For more information about tests, see ":doc:`Testing CodeQL queries in Visual Studio Code <testing-codeql-queries-in-visual-studio-code>`."

Generating a bug report for GitHub
--------------------------------------

The CodeQL Language Server contains more advanced debug logs for CodeQL language maintainers. You should only need these to provide details in a bug report.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/about-codeql-for-visual-studio-code.rst
:tocdepth: 1

.. _about-codeql-for-visual-studio-code:

About CodeQL for Visual Studio Code
=================================================

.. include:: ../reusables/vs-code-deprecation-note.rst

CodeQL for Visual Studio Code is an extension that lets you write, run, and test CodeQL queries in Visual Studio Code.

Features
----------

CodeQL for Visual Studio Code provides an easy way to run queries from the large, open source repository of `CodeQL security queries <https://github.com/github/codeql>`__.
With these queries, or your own custom queries, you can analyze databases generated from source code to find errors and security vulnerabilities.
The Results view shows the flow of data through the results of path queries, which is essential for triaging security results.

The CodeQL extension also adds a **CodeQL** sidebar view to VS Code. This contains a list of local CodeQL databases, an overview of the queries that you have run in the current session, and a variant analysis view for large scale analysis.

The extension provides standard `IntelliSense <https://code.visualstudio.com/docs/editor/intellisense>`__
features for query files (extension ``.ql``) and library files (extension ``.qll``) that you open in the Visual Studio Code editor.

- Syntax highlighting
- Right-click options (such as **Go To Definition**)
- Autocomplete suggestions
- Hover information

You can also use the VS Code **Format Document** command to format your code according to the `CodeQL style guide <https://github.com/github/codeql/blob/main/docs/ql-style-guide.md>`__.

Data and telemetry
-------------------

If you specifically opt in to permit GitHub to do so, GitHub will collect usage data and metrics for the purposes of helping the core developers to improve the CodeQL extension for VS Code.
For more information, see ":doc:`About telemetry in CodeQL for Visual Studio Code <about-telemetry-in-codeql-for-visual-studio-code>`."

Further reading
-------------------

- ":doc:`Setting up CodeQL in Visual Studio Code <setting-up-codeql-in-visual-studio-code>`"
- ":doc:`Analyzing your projects <analyzing-your-projects>`"
- ":doc:`Running CodeQL queries at scale with multi-repository variant analysis <running-codeql-queries-at-scale-with-mrva>`"



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/analyzing-your-projects.rst
:tocdepth: 1

.. _analyzing-your-projects:

Analyzing your projects
=================================================

.. include:: ../reusables/vs-code-deprecation-note.rst

You can run queries on CodeQL databases and view the results in Visual Studio Code. This article explains how to get a CodeQL database and analyze it on your local machine. For information on running analysis at scale across many CodeQL databases, see ":ref:`Running CodeQL queries at scale with multi-repository variant analysis <running-codeql-queries-at-scale-with-mrva>`."

Choosing a database
------------------------

To analyze a project, you need to add a :ref:`CodeQL database <codeql-database>` for that project.

#. Open the CodeQL Databases view in the sidebar.

#. Hover over the **Databases** title bar and click the appropriate icon to add your database. You can add a database from a local ZIP archive or folder, from a public URL, or from a project's URL on GitHub.com.

   .. image:: ../images/codeql-for-visual-studio-code/choose-database.png
      :width: 350
      :alt: Choose a database to analyze

   For more information about obtaining a local database, see below.

#. Once you've chosen a database, it is displayed in the Databases view. To see the menu options for interacting with a database, right-click an entry in the list. You can select multiple databases using **Ctrl/Cmd+click**.

Importing a local database
~~~~~~~~~~~~~~~~~~~~~~~~~~

If you have a CodeQL database saved locally, as an unarchived folder or as a ZIP file, you can add it to Visual Studio Code. There are several ways to obtain a local CodeQL database.

- To create a database with the CodeQL CLI, see "`Creating CodeQL databases <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/creating-codeql-databases>`__."

- To analyze a test database, add a ``.testproj`` folder to the Databases view.
  Test databases (that is, folders with a ``.testproj`` extension) are generated when you run regression tests on custom queries using the CodeQL CLI.
  If a query fails a regression test, you may want to analyze the test database in Visual Studio Code to debug the failure.

  For more information about running query tests, see "`Testing custom queries <https://docs.github.com/en/code-security/codeql-cli/using-the-codeql-cli/testing-custom-queries>`__" in the CodeQL CLI help.

Downloading a database from GitHub
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. include:: ../reusables/download-github-database.rst

.. _filtering-databases-and-queries-by-language:

Filtering databases and queries by language
-------------------------------------------

Optionally, to see databases containing a specific language and queries written for that language, you can apply a language filter using the language selector.

#. To see available language filters, in the sidebar, click the **Language** title bar.
#. Hover over the language filter you would like to apply, then click **Select**.

   .. image:: ../images/codeql-for-visual-studio-code/choose-language-filter.png
      :width: 350
      :alt: Screenshot of the language selector. The "Select" button for a language filter is outlined in dark orange.

Creating a custom query
------------------------

You can generate a query template for a specific language from the queries panel, then write your own code to quickly create a custom query.

#. Optionally, to create a custom query in an existing directory, in the sidebar, click the **Queries** title bar to expand the queries panel, then select the desired directory.
#. In the sidebar, hover over the **Queries** title bar, then click the **Create query** icon.

   .. image:: ../images/codeql-for-visual-studio-code/create-query-icon.png
      :width: 350
      :alt: Screenshot of the queries panel. The "Create query" icon is outlined in dark orange.

#. In the Command Palette, select the target language for your query. If you've chosen not to create your custom query in an existing directory, selecting a language will autogenerate a directory labeled ``codeql-custom-queries-<language>``, where ``<language>`` is the name of the selected language. A query template labeled ``example.ql`` will then be added to the existing or autogenerated directory.
#. In the template, write your custom query, then save the file. Once your query is finished, you can run it from the queries panel.

Running a query
------------------------

The `CodeQL repository <https://github.com/github/codeql>`__ on GitHub contains lots of example queries.
You can access any existing queries in your workspace through the queries panel.

#. In the sidebar, to expand the queries panel, click the **Queries** title bar.
#. To run a query against the selected database, hover over the desired query, then click the **Run local query** icon.

   .. image:: ../images/codeql-for-visual-studio-code/run-local-query-icon.png
      :width: 350
      :alt: Screenshot of the mouse pointer hovering over a query in the queries panel. The "Run local query" icon is outlined in dark orange.

The CodeQL extension runs the query on the current database and reports progress in the bottom right corner of the application.
When the results are ready, they're displayed in the Results view.

If there are any problems running a query, a notification is displayed in the bottom right corner of the application.
In addition to the error message, the notification includes details of how to fix the problem.
For more information, see ":doc:`Troubleshooting CodeQL for Visual Studio Code <troubleshooting-codeql-for-visual-studio-code>`."

Running multiple queries
--------------------------

You can quickly run multiple queries against the database you've selected using the queries panel or a single command.

Running all queries in a directory
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can easily run every query in a directory using the queries panel.

#. In the sidebar, to expand the queries panel, click the **Queries** title bar.
#. Hover over the desired directory of queries, then click the **Run local queries** icon.

   .. image:: ../images/codeql-for-visual-studio-code/run-local-queries-icon.png
      :width: 350
      :alt: Screenshot of the mouse pointer hovering over a directory of queries in the queries panel. The "Run local queries" icon is outlined in dark orange.

Running a selection of queries
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can run multiple queries with a single command.

#. Go to the File Explorer.
#. Select multiple files or folders that contain queries.
#. Right-click and select **CodeQL: Run Queries in Selected Files**.

   .. image:: ../images/codeql-for-visual-studio-code/run-multiple-queries.png
      :width: 350
      :alt: Run multiple queries from the File Explorer

Running a quick query
------------------------

When working on a new query, you can open a "quick query" tab to easily execute your code and view the results, without having to save a ``.ql`` file in your workspace.
Open a quick query editing tab by selecting **CodeQL: Quick Query** from the Command Palette.
To run the query, use **CodeQL: Run Query on Selected Database**.

You can see all quick queries that you've run in the current session in the Query History view. Click an entry to see the exact text of the quick query that produced the results.

Once you're happy with your quick query, you should save it in a CodeQL pack so you can access it later. For more information, see "`About CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/about-codeql-packs>`__."

.. _running-a-specific-part-of-a-query-or-library:

Running a specific part of a query or library
----------------------------------------------

This is helpful if you're debugging a query or library and you want to locate the part that is wrong.
Instead of using **CodeQL: Run Query on Selected Database** to run the whole query (the :ref:`select clause <select-clauses>` and any :ref:`query predicates <query-predicates>`), you can use **CodeQL: Quick Evaluation** to run a specific part of a ``.ql`` or ``.qll`` file.

**CodeQL: Quick Evaluation** evaluates a code snippet (instead of the whole query) and displays results of that selection in the Results view.
Possible targets for quick evaluation include:

- Selecting the name of a CodeQL entity (such as a :ref:`class <classes>` or :ref:`predicate <predicates>`) to evaluate that entity.
- Selecting a :ref:`formula <formulas>` or :ref:`expression <expressions>` with free variables to evaluate that formula or expression.

For example, in the following snippet, you could select the predicate name ``foo`` or the formula ``s = "bar"`` for quick evaluation.

.. code-block:: ql

   predicate foo(string s) { s = "bar" }

Running a query on multiple databases
--------------------------------------

This is helpful if you want to test your query on multiple codebases, or find a vulnerability in multiple projects.

#. Open a query (``.ql``) file.
#. Right-click and select **CodeQL: Run Query on Multiple Databases**.
#. From the dropdown menu, select the databases that you want to run the query on.

Viewing previous queries
--------------------------

To see the queries that you have run in the current session, open the Query History view.

   .. image:: ../images/codeql-for-visual-studio-code/query-history.png
      :width: 350
      :alt: See a list of previous queries

The Query History contains information including the date and time when the query was run, the name of the query, the database on which it was run, and how long it took to run the query.
To customize the information that is displayed, right-click an entry and select **Rename**.
You can also filter the Query History view by language using the language selector. For more information, see ":ref:`Filtering databases and queries by language <filtering-databases-and-queries-by-language>`."

Click an entry to display the corresponding results in the Query Results view, and double-click
to display the query itself in the editor (or right-click and select **View Query**).
To display the exact text that produced the results for a particular entry, right-click it and select **View Query Text**. This can differ from **View Query** as the query file may have been modified since you last ran it.

To remove queries from the Query History view, select all the queries you want to remove, then right-click and select **Delete**.

.. _viewing-query-results:

Viewing query results
-----------------------

#. Click a query in the Query History view to display its results in the Results view.

   .. pull-quote:: Note

      Depending on the query, you can also choose different views such as CSV, `SARIF <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-reference/sarif-output>`__, or :ref:`DIL format <dil>`. For example, to view the DIL format, right-click a result and select **View DIL**.
      The available output views are determined by the format and the metadata of the query. For more information, see ":ref:`CodeQL queries <codeql-queries>`."

#. Use the dropdown menu in the Results view to choose which results to display, and in what form to display them, such as a formatted alert message or a table of raw results.

#. To sort the results by the entries in a particular column, click the column header.

If a result links to a source code element, you can click it to display it in the source.

To use standard code navigation features in the source code, you can right-click an element and use the commands **Go to Definition** or **Go to References**. This runs a CodeQL query over the active file, which may take a few seconds. This query needs to run once for every file, so any additional references from the same file will be fast.

  .. pull-quote:: Note

     If you're using an older database, code navigation commands such as **Go to Definition** and **Go to References** may not work.
     To use code navigation, try unzipping the database and running ``codeql database cleanup <database>`` on the unzipped database using the CodeQL CLI. Then, re-add the database to Visual Studio Code.
     For more information, see `database cleanup <https://docs.github.com/en/code-security/codeql-cli/codeql-cli-manual/database-cleanup>`__ in the documentation for CodeQL CLI.

Comparing query results
------------------------

When you're writing or debugging a query, it's useful to see how your changes affect the results.
You can compare two sets of results to see exactly what has changed.
To compare results, the two queries must be run on the same database.

#. Right-click a query in the Query History view and select **Compare Results**.
#. A Quick Pick menu shows all valid queries to compare with. Select a query.
#. The Compare view shows the differences in the results of the two queries.

Further reading
------------------------

- ":ref:`CodeQL queries <codeql-queries>`"
- ":doc:`Exploring data flow with path queries <exploring-data-flow-with-path-queries>`"



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/using-the-codeql-model-editor.rst
:tocdepth: 1

.. _using-the-codeql-model-editor:

Using the CodeQL model editor
=============================

.. include:: ../reusables/vs-code-deprecation-note.rst

.. include:: ../reusables/beta-note-model-pack-editor-vsc.rst

You can view, write, and edit CodeQL packs in Visual Studio Code using the CodeQL extension. The model editor is designed to help you model external dependencies of your codebase that are not supported by the standard CodeQL Libraries.

About the CodeQL model editor
-----------------------------

The CodeQL model editor guides you through modeling the calls to external dependencies in your application or fully modeling all the public entry and exit points in an external dependency.

When you open the model editor, it analyzes the currently selected CodeQL database and identifies where the application uses external APIs and all public methods. An external (or third party) API is any API that is not part of the CodeQL database you have selected.

The model editor has two different modes:

- **Application mode (default view):** The editor lists each external framework used by the selected CodeQL database. When you expand a framework, a list of all calls to and from the external API is shown with the options available to model dataflow through each call. This mode is most useful for improving the CodeQL results for a specific codebase.

- **Dependency mode:** The editor identifies all of the publicly accessible APIs in the selected CodeQL database. This view guides you through modeling each public API that the codebase makes available. When you have finished modeling the entire API, you can save the model and use it to improve the CodeQL analysis for all codebases that use the dependency.

Displaying the CodeQL model editor
----------------------------------

#. Open your CodeQL workspace in VS Code, for example, the ``vscode-codeql-starter`` workspace.
   If you haven't updated the ``ql`` submodule for a while, update it from ``main`` to ensure that you have the queries used to gather data for the model editor.
#. Open the CodeQL extension and select the CodeQL database that you want to model from the "Databases" section of the left side pane.
#. In the left side panel, expand the "CodeQL method modeling" section and click **Start modeling** to display the model editor. Alternatively, use the command palette to run the “CodeQL: Open Model Editor (Beta)” command.
#. The CodeQL model editor runs a series of telemetry queries to identify APIs in the code and the editor is displayed in a new tab.
#. When the telemetry queries are complete, the APIs that have been identified are shown in the editor.

.. pull-quote:: Tip

   The "CodeQL method modeling" section is a view that you can move from the primary sidebar to the secondary sidebar, when you want more space while you are modeling calls or methods. If you close the view, you can reopen it from the "Open Views" option in the **View** menu.

Modeling the calls your codebase makes to external APIs
-------------------------------------------------------

You typically use this approach when you are looking at a specific codebase where you want to improve the precision of CodeQL results. This is useful when the codebase uses frameworks or libraries that are not supported by CodeQL and if the source code of the framework or library is not included in the analysis.

This section uses an open source Java project called "sofa-jraft" as an example. The experience of modeling calls to external APIs written in other static languages is similar.

#. Select the CodeQL database that you want to improve CodeQL coverage for.
#. Display the CodeQL model editor. By default the editor runs in application mode, so the list of external APIs used by the selected codebase is shown.

   .. image:: ../images/codeql-for-visual-studio-code/model-application-mode.png
      :width: 800
      :alt: Screenshot of the "Application mode" view of the CodeQL model pack editor in Visual Studio Code showing two of the external Java frameworks used by the "sofa-jraft" codebase.

#. Click to expand an external API and view the list of calls from the codebase to the external dependency.

   .. image:: ../images/codeql-for-visual-studio-code/model-application-mode-expanded.png
      :width: 800
      :alt: Screenshot of the "Application mode" view of the CodeQL model pack editor in Visual Studio Code showing the calls to the "rocksdbjni" framework ready for modeling. The "View" option for the first call is highlighted with a dark orange outline.

#. Click **View** associated with an API call or method to show where it is used in your codebase.

   .. image:: ../images/codeql-for-visual-studio-code/model-application-mode-view-code.png
      :width: 800
      :alt: Screenshot of a file showing a place where your codebase calls the API is highlighted with a dark orange outline.

#. The file containing the first call from your codebase to the API is opened and a "CodeQL methods usage" view is displayed in the VS Code Panel (where the "Problems" and "Terminal" views are usually displayed). The "CodeQL methods usage" view lists of all the calls from your code to the API, grouped by method. You can click through each use to decide how to model your use of the method.

   .. image:: ../images/codeql-for-visual-studio-code/model-application-mode-view-list.png
      :width: 800
      :alt: Screenshot of the "CodeQL methods usage" view. The currently displayed call to an external method is highlighted blue.

#. When you have determined how to model your use of the method, you can define the **Model type** in the "CodeQL method modeling" tab of the CodeQL extension. This change is automatically reflected in the main model editor.
#. The remaining fields are updated with available options:

   - **Source**: choose the **Output** element to model.
   - **Sink**: choose the **Input** element to model.
   - **Flow summary**: choose the **Input** and **Output** elements to model.

#. Define the **Kind** of dataflow for the model.
#. When you have finished modeling, display the main model editor and click **Save all** or **Save** (shown at the bottom right of each expanded list of methods). The percentage of methods modeled in the editor is updated.

The models are stored in your workspace at ``.github/codeql/extensions/<codeql-model-pack>``, where ``<codeql-model-pack>`` is the name of the CodeQL database that you selected. That is, the name of the repository, hyphen, the language analyzed by CodeQL. For more information, see "`Using CodeQL model packs with code scanning <#using-codeql-model-packs-with-code-scanning>`__".

The models are stored in a series of YAML data extension files, one for each external API. For example:

.. code-block:: none

   .github/codeql/extensions/sofa-jraft-java # the model pack directory
      models
         jmh-core.model.yml                  # models calls to jmh-core@1.20
         rocksdbjni.model.yml                # models calls to rocksdbjni@7.7.3

Modeling the public API of a codebase
-------------------------------------

This section uses an open source Java project called "sofa-jraft" as an example. The experience of modeling the public API written using other static languages is similar.

You typically use this method when you want to model a framework or library that your organization uses in more than one codebase. Once you have finished creating and testing the model, you can publish the CodeQL model pack to the GitHub Container Registry for your whole organization to use.

#. Select the CodeQL database that you want to model.
#. Display the CodeQL model editor. By default the editor runs in application mode. Click **Model as dependency** to display dependency mode. The screen changes to show the public API of the framework or library.

   .. image:: ../images/codeql-for-visual-studio-code/model-dependency-mode.png
      :width: 800
      :alt: Screenshot of the "Dependency mode" view of the CodeQL model pack editor in Visual Studio Code showing three of the packages published by the "sofa-jraft" codebase.

#. Click to expand a package and view the list of available methods.
#. Click **View** associated with a method to show its definition.

   .. image:: ../images/codeql-for-visual-studio-code/model-dependency-mode-expanded.png
      :width: 800
      :alt: Screenshot of the "Dependency mode" view of the CodeQL model pack editor in Visual Studio Code showing the public methods available in the "com.alipay.soft.jraft.option" package ready for modeling. The "View" option for the first method is highlighted with a dark orange outline.

#. When you have determined how to model the method, define the **Model type**.
#. The remaining fields are updated with available options:

   - **Source**: choose the **Output** element to model.
   - **Sink**: choose the **Input** element to model.
   - **Flow summary**: choose the **Input** and **Output** elements to model.

#. Define the **Kind** of dataflow for the model.
#. When you have finished modeling, click **Save all** or **Save** (shown at the bottom right of each expanded list of calls). The percentage of calls modeled in the editor is updated.

The models are stored in your workspace at ``.github/codeql/extensions/<codeql-model-pack>``, where ``<codeql-model-pack>`` is the name of the CodeQL database that you selected. That is, the name of the repository, hyphen, the language analyzed by CodeQL. For more information, see "`Using CodeQL model packs with code scanning <#using-codeql-model-packs-with-code-scanning>`__".

The models are stored in a series of YAML data extension files, one for each public method. For example:

.. code-block:: none

   .github/codeql/extensions/sofa-jraft-java          # the model pack directory
      models
         com.alipay.sofa.jraft.option.model.yml       # models public methods in package
         com.alipay.sofa.jraft.rhea.options.model.yml # models public methods in package

The editor will create a separate model file for each package that you model.

Modeling methods with multiple potential flows
----------------------------------------------

Some methods support more than one data flow. It is important to model all the data flows for a method, otherwise you cannot detect all the potential problems associated with using the method. First you model one data flow for the method, and then use the **+** button in the method row to specify a second data flow model.

   .. image:: ../images/codeql-for-visual-studio-code/model-dependency-mode-plus.png
      :width: 800
      :alt: Screenshot of the "Dependency mode" view of the CodeQL model pack editor in Visual Studio Code showing one model for the ``com.alipay.sofa.jraft.option.BallotBoxOptions.getClosureQueue()`` method. The "+" button is outlined in dark orange. Click this button to create a second model for the method.

Testing CodeQL model packs in VS Code
-------------------------------------

You can test any CodeQL model packs you create in VS Code by turning the "use model packs" setting on and off. This method works for both databases and for variant analysis repositories.

- To run queries on a CodeQL database with any model packs that are stored within the ``.github/codeql/extensions`` directory of the workspace, update your ``settings.json`` file with: ``"codeQL.runningQueries.useExtensionPacks": "all",``
- To run queries on a CodeQL database without using model packs, update your ``settings.json`` file with: ``"codeQL.runningQueries.useExtensionPacks": "none",``

If your model is working well, you should see a difference in the results of the two different runs. If you don't see any differences in results, you may need to introduce a known bug to verify that the model behaves as expected.

Using CodeQL model packs with code scanning
-------------------------------------------

There are two methods for using CodeQL model packs with code scanning:

#. Copy the model pack directory into the ``.github/codeql/extensions`` directory of the repository. It will automatically be used by all future code scanning analysis for the repository (default setup or advanced setup).
#. Publish the model pack to the GitHub Container Registry as a CodeQL model pack. This can be downloaded and used by advanced setup for code scanning or by the CodeQL CLI running in an external CI system.

For more information, see the following articles on the GitHub Docs site:

- Default setup of code scanning: `Extending CodeQL coverage with CodeQL model packs in default setup <https://docs.github.com/en/code-security/code-scanning/managing-your-code-scanning-configuration/editing-your-configuration-of-default-setup#extending-codeql-coverage-with-codeql-model-packs-in-default-setup>`__
- Advanced setup of code scanning: `Extending CodeQL coverage with CodeQL model packs <https://docs.github.com/en/code-security/code-scanning/creating-an-advanced-setup-for-code-scanning/customizing-your-advanced-setup-for-code-scanning#extending-codeql-coverage-with-codeql-model-packs>`__
- CodeQL CLI setup in external CI system: `Using model packs to analyze calls to custom dependencies <https://docs.github.com/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/customizing-analysis-with-codeql-packs#using-model-packs-to-analyze-calls-to-custom-dependencies>`__



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-for-visual-studio-code/troubleshooting-variant-analysis.rst
:tocdepth: 1

.. _troubleshooting-variant-analysis:

Troubleshooting variant analysis
================================

.. include:: ../reusables/vs-code-deprecation-note.rst

.. include:: ../reusables/beta-note-mrva.rst

This article explains how to debug problems with variant analysis, that is, analysis run using GitHub Actions
and not locally on your machine.
For information on troubleshooting local analysis, see
":ref:`Troubleshooting CodeQL for Visual Studio Code <troubleshooting-codeql-for-visual-studio-code>`."

When you run variant analysis, there are two key places where errors and warnings are displayed:

#. **Visual Studio Code errors** - any problems with creating a CodeQL pack and sending the analysis to GitHub.com are reported as Visual Studio Code errors in the bottom right corner of the application. The problem information is also available in the **Problems** view.
#. **Variant Analysis Results** - any problems with the variant analysis run are reported in this view.

Variant analysis warning: Problem with controller repository
------------------------------------------------------------

If there are problems with the variant analysis run, you will see a warning banner at the top of the Variant Analysis Results tab. For example:

.. image:: ../images/codeql-for-visual-studio-code/variant-analysis-results-warning.png
    :width: 600
    :alt: Screenshot of the "Variant Analysis Results" view showing a warning banner with the text "warning: Problem with controller repository" and "Publicly visible controller repository can't be used to analyze private repositories. 1 private repository was not analyzed." The "View logs" button is highlighted with a dark orange outline.

In this example, the user ran variant analysis on a custom list of two repositories. One of the repositories was a private repository and could not be analyzed because they had a public controller repository. Only the public repository was analyzed. To analyze both repositories, this user needs to edit their settings and update the controller repository to a private repository. For information on how to edit the controller repository, see ":ref:`Customizing settings <customizing-settings>`."




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-go.rst
.. _codeql-for-go:

CodeQL for Go
=============

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from Go codebases.

.. toctree::
   :hidden:

   basic-query-for-go-code
   codeql-library-for-go
   abstract-syntax-tree-classes-for-working-with-go-programs
   modeling-data-flow-in-go-libraries

-  :doc:`Basic query for Go code <basic-query-for-go-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for Go <codeql-library-for-go>`: When you're analyzing a Go program, you can make use of the large collection of classes in the CodeQL library for Go.

-  :doc:`Abstract syntax tree classes for working with Go programs <abstract-syntax-tree-classes-for-working-with-go-programs>`: CodeQL has a large selection of classes for representing the abstract syntax tree of Go programs.

-  :doc:`Modeling data flow in Go libraries <modeling-data-flow-in-go-libraries>`: When analyzing a Go program, CodeQL does not examine the source code for external packages. 
   To track the flow of untrusted data through a library, you can create a model of the library.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/annotations-in-java.rst
.. _annotations-in-java:

Annotations in Java and Kotlin
==============================

CodeQL databases of Java/Kotlin projects contain information about all annotations attached to program elements.

About working with annotations
------------------------------

Annotations are represented by these CodeQL classes:

-  The class ``Annotatable`` represents all entities that may have an annotation attached to them (that is, packages, reference types, fields, methods, and local variables).
-  The class ``AnnotationType`` represents a Java annotation type, such as ``java.lang.Override``; annotation types are interfaces.
-  The class ``AnnotationElement`` represents an annotation element, that is, a member of an annotation type.
-  The class ``Annotation`` represents an annotation such as ``@Override``; annotation values can be accessed through member predicate ``getValue``.

For example, the Java/Kotlin standard library defines an annotation ``SuppressWarnings`` that instructs the compiler not to emit certain kinds of warnings:

.. code-block:: java

   package java.lang;

   public @interface SuppressWarnings {
       String[] value;
   }

``SuppressWarnings`` is represented as an ``AnnotationType``, with ``value`` as its only ``AnnotationElement``.

A typical usage of ``SuppressWarnings`` would be this annotation for preventing a warning about using raw types:

.. code-block:: java

   class A {
       @SuppressWarnings("rawtypes")
       public A(java.util.List rawlist) {
       }
   }

The expression ``@SuppressWarnings("rawtypes")`` is represented as an ``Annotation``. The string literal ``"rawtypes"`` is used to initialize the annotation element ``value``, and its value can be extracted from the annotation by means of the ``getValue`` predicate.

We could then write this query to find all ``@SuppressWarnings`` annotations attached to constructors, and return both the annotation itself and the value of its ``value`` element:

.. code-block:: ql

   import java

   from Constructor c, Annotation ann, AnnotationType anntp
   where ann = c.getAnAnnotation() and
       anntp = ann.getType() and
       anntp.hasQualifiedName("java.lang", "SuppressWarnings")
   select ann, ann.getValue("value")

If the codebase you are analyzing uses the ``@SuppressWarnings`` annotation, you can check the ``value``\ s of the annotation element returned by the query. They should use the ``"rawtypes"`` value described above.

As another example, this query finds all annotation types that only have a single annotation element, which has name ``value``:

.. code-block:: ql

   import java

   from AnnotationType anntp
   where forex(AnnotationElement elt |
       elt = anntp.getAnAnnotationElement() |
       elt.getName() = "value"
   )
   select anntp

Example: Finding missing ``@Override`` annotations
--------------------------------------------------

In newer versions of Java, it's recommended (though not required) that you annotate methods that override another method with an ``@Override`` annotation. These annotations, which are checked by the compiler, serve as documentation, and also help you avoid accidental overloading where overriding was intended.

For example, consider this example program:

.. code-block:: java

   class Super {
       public void m() {}
   }

   class Sub1 extends Super {
       @Override public void m() {}
   }

   class Sub2 extends Super {
       public void m() {}
   }

Here, both ``Sub1.m`` and ``Sub2.m`` override ``Super.m``, but only ``Sub1.m`` is annotated with ``@Override``.

We'll now develop a query for finding methods like ``Sub2.m`` that should be annotated with ``@Override``, but are not.

As a first step, let's write a query that finds all ``@Override`` annotations. Annotations are expressions, so their type can be accessed using ``getType``. Annotation types, on the other hand, are interfaces, so their qualified name can be queried using ``hasQualifiedName``. Therefore we can implement the query like this:

.. code-block:: ql

   import java

   from Annotation ann
   where ann.getType().hasQualifiedName("java.lang", "Override")
   select ann

As always, it is a good idea to try this query on a CodeQL database for a Java/Kotlin project to make sure it actually produces some results. On the earlier example, it should find the annotation on ``Sub1.m``. Next, we encapsulate the concept of an ``@Override`` annotation as a CodeQL class:

.. code-block:: ql

   class OverrideAnnotation extends Annotation {
       OverrideAnnotation() {
           this.getType().hasQualifiedName("java.lang", "Override")
       }
   }

This makes it very easy to write our query for finding methods that override another method, but don't have an ``@Override`` annotation: we use predicate ``overrides`` to find out whether one method overrides another, and predicate ``getAnAnnotation`` (available on any ``Annotatable``) to retrieve some annotation.

.. code-block:: ql

   import java

   from Method overriding, Method overridden
   where overriding.overrides(overridden) and
       not overriding.getAnAnnotation() instanceof OverrideAnnotation
   select overriding, "Method overrides another method, but does not have an @Override annotation."

In practice, this query may yield many results from compiled library code, which aren't very interesting. It's therefore a good idea to add another conjunct ``overriding.fromSource()`` to restrict the result to only report methods for which source code is available.

Example: Finding calls to deprecated methods
--------------------------------------------

As another example, we can write a query that finds calls to methods marked with a ``@Deprecated`` annotation.

For example, consider this example program:

.. code-block:: java

   class A {
       @Deprecated void m() {}

       @Deprecated void n() {
           m();
       }

       void r() {
           m();
       }
   }

Here, both ``A.m`` and ``A.n`` are marked as deprecated. Methods ``n`` and ``r`` both call ``m``, but note that ``n`` itself is deprecated, so we probably should not warn about this call.

As in the previous example, we'll start by defining a class for representing ``@Deprecated`` annotations:

.. code-block:: ql

   class DeprecatedAnnotation extends Annotation {
       DeprecatedAnnotation() {
           this.getType().hasQualifiedName("java.lang", "Deprecated")
       }
   }

Now we can define a class for representing deprecated methods:

.. code-block:: ql

   class DeprecatedMethod extends Method {
       DeprecatedMethod() {
           this.getAnAnnotation() instanceof DeprecatedAnnotation
       }
   }

Finally, we use these classes to find calls to deprecated methods, excluding calls that themselves appear in deprecated methods:

.. code-block:: ql

   import java

   from Call call
   where call.getCallee() instanceof DeprecatedMethod
       and not call.getCaller() instanceof DeprecatedMethod
   select call, "This call invokes a deprecated method."

In our example, this query flags the call to ``A.m`` in ``A.r``, but not the one in ``A.n``.

For more information about the class ``Call``, see ":doc:`Navigating the call graph <navigating-the-call-graph>`."

Improvements
~~~~~~~~~~~~

The Java/Kotlin standard library provides another annotation type ``java.lang.SupressWarnings`` that can be used to suppress certain categories of warnings. In particular, it can be used to turn off warnings about calls to deprecated methods. Therefore, it makes sense to improve our query to ignore calls to deprecated methods from inside methods that are marked with ``@SuppressWarnings("deprecation")``.

For instance, consider this slightly updated example:

.. code-block:: java

   class A {
       @Deprecated void m() {}

       @Deprecated void n() {
           m();
       }

       @SuppressWarnings("deprecation")
       void r() {
           m();
       }
   }

Here, the programmer has explicitly suppressed warnings about deprecated calls in ``A.r``, so our query should not flag the call to ``A.m`` any more.

To do so, we first introduce a class for representing all ``@SuppressWarnings`` annotations where the string ``deprecation`` occurs among the list of warnings to suppress:

.. code-block:: ql

   class SuppressDeprecationWarningAnnotation extends Annotation {
       SuppressDeprecationWarningAnnotation() {
           this.getType().hasQualifiedName("java.lang", "SuppressWarnings") and
           this.getAStringArrayValue("value").regexpMatch(".*deprecation.*")
       }
   }

Here, we use ``getAStringArrayValue("value")`` to retrieve any of the suppressed warnings: ``@SuppressWarnings`` defines the warnings to suppress using the annotation element named ``value`` of type ``String[]``, and ``getAStringArrayValue`` retrieves all of the array values; the CodeQL class ``Annotation`` also has similar convenience predicates for the other possible annotation element types. Afterwards we check whether one of the values is the string ``deprecation`` using a regular expression match.

For real-world use, this check would have to be generalized a bit: for example, the OpenJDK Java compiler allows ``@SuppressWarnings("all")`` annotations to suppress all warnings. We may also want to make sure that ``deprecation`` is matched as an entire word, and not as part of another word, by changing the regular expression to ``".*\\bdeprecation\\b.*"``.

Now we can extend our query to filter out calls in methods carrying a ``SuppressDeprecationWarningAnnotation``:

.. code-block:: ql

   import java

   // Insert the class definitions from above

   from Call call
   where call.getCallee() instanceof DeprecatedMethod
       and not call.getCaller() instanceof DeprecatedMethod
       and not call.getCaller().getAnAnnotation() instanceof SuppressDeprecationWarningAnnotation
   select call, "This call invokes a deprecated method."

It's fairly common for projects to contain calls to methods that appear to be deprecated.

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/abstract-syntax-tree-classes-for-working-with-javascript-and-typescript-programs.rst
.. _abstract-syntax-tree-classes-for-working-with-javascript-and-typescript-programs:

Abstract syntax tree classes for working with JavaScript and TypeScript programs
================================================================================

CodeQL has a large selection of classes for representing the abstract syntax tree of JavaScript and TypeScript programs.

.. include:: ../reusables/abstract-syntax-tree.rst

Statement classes
-----------------

This table lists subclasses of Stmt_ representing ECMAScript and TypeScript statements.

+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
|                               Statement syntax                                |          CodeQL class          |                        Superclasses                         |                                            Remarks                                             |
+===============================================================================+================================+=============================================================+================================================================================================+
| Expr_  ``;``                                                                  | ExprStmt_                      |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| Label_ ``:`` Stmt_                                                            | LabeledStmt_                   |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``;``                                                                         | EmptyStmt_                     |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``break`` Label_ ``;``                                                        | BreakStmt_                     | JumpStmt_, BreakOrContinueStmt_                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``case`` Expr_ ``:`` Stmt_...                                                 | Case_                          |                                                             | can only occur as child of a SwitchStmt_                                                       |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``catch(`` Identifier_ ``)`` ``{`` Stmt_... ``}``                             | CatchClause_                   | ControlStmt_                                                | can only occur as child of a TryStmt_                                                          |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``class`` Identifier_ ``extends`` Expr_ ``{`` MemberDeclaration_... ``}``     | ClassDeclStmt_                 | ClassDefinition_, ClassOrInterface_, TypeParameterized_     |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``const`` Identifier_ ``=`` Expr_ ``;``                                       | ConstDeclStmt_                 | DeclStmt_                                                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``continue`` Label_ ``;``                                                     | ContinueStmt_                  | JumpStmt_, BreakOrContinueStmt_                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``debugger;``                                                                 | DebuggerStmt_                  |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``declare`` ``global`` ``{`` Stmt_... ``}``                                   | GlobalAugmentationDeclaration_ |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``declare`` ``module`` StringLiteral_ ``{`` Stmt_... ``}``                    | ExternalModuleDeclaration_     |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``default:`` Stmt_...                                                         | Case_                          |                                                             | can only occur as child of a SwitchStmt_; use `isDefault` to distinguish `default` from `case` |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``do`` Stmt_ ``while`` ``(`` Expr_ ``)``                                      | DoWhileStmt_                   | ControlStmt_, LoopStmt_                                     |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``enum`` Identifier_ ``{`` MemberDeclaration_... ``}``                        | EnumDeclaration_               | NamespaceDefinition_                                        |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export * from`` StringLiteral_                                              | BulkReExportDeclaration_       | ReExportDeclaration_, ExportDeclaration_                    |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export default`` ClassDeclStmt_                                             | ExportDefaultDeclaration_      | ExportDeclaration_                                          |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export default`` Expr_ ``;``                                                | ExportDefaultDeclaration_      | ExportDeclaration_                                          |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export default`` FunctionDeclStmt_                                          | ExportDefaultDeclaration_      | ExportDeclaration_                                          |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export {`` ExportSpecifier_... ``};``                                       | ExportNamedDeclaration_        | ExportDeclaration_                                          |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export`` DeclStmt_                                                          | ExportNamedDeclaration_        | ExportDeclaration_                                          |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export`` ``=`` Expr_ ``;``                                                  | ExportAssignDeclaration_       |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``export`` ``as`` ``namespace`` Identifier_ ``;``                             | ExportAsNamespaceDeclaration_  |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``for`` ``(`` Expr_ ``;`` Expr_ ``;`` Expr_ ``)`` Stmt_                       | ForStmt_                       | ControlStmt_, LoopStmt_                                     |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``for`` ``(`` VarAccess_ ``in`` Expr_ ``)`` Stmt_                             | ForInStmt_                     | ControlStmt_, LoopStmt_, EnhancedForLoop_                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``for`` ``(`` VarAccess_ ``of`` Expr_ ``)`` Stmt_                             | ForOfStmt_                     | ControlStmt_, LoopStmt_, EnhancedForLoop_                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``function`` Identifier_ ``(`` Parameter_... ``)`` ``{`` Stmt_... ``}``       | FunctionDeclStmt_              | Function_                                                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``if`` ``(`` Expr_ ``)`` Stmt_ ``else`` Stmt_                                 | IfStmt_                        | ControlStmt_                                                |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``import {`` ImportSpecifier_... ``from`` StringLiteral_                      | ImportDeclaration_             | Import_                                                     |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``import`` Identifier_ ``=`` Expr_ ``;``                                      | ImportEqualsDeclaration_       |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``interface`` Identifier_ ``{`` MemberDeclaration_... ``}``                   | InterfaceDeclaration_          | InterfaceDefinition_, ClassOrInterface_, TypeParameterized_ |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``let`` Identifier_ ``=`` Expr_ ``;``                                         | LetStmt_                       | DeclStmt_                                                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``namespace`` Identifier_ ``{`` Stmt_... ``}``                                | NamespaceDeclaration_          | NamespaceDefinition_                                        |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``return`` Expr_ ``;``                                                        | ReturnStmt_                    | JumpStmt_                                                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``switch`` ``(`` Expr_ ``) {`` Case_... ``}``                                 | SwitchStmt_                    | ControlStmt_                                                |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``throw`` Expr_ ``;``                                                         | ThrowStmt_                     | JumpStmt_                                                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``try`` ``{`` Stmt_... ``}`` CatchClause_... ``finally`` ``{`` Stmt_... ``}`` | TryStmt_                       | ControlStmt_                                                |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``type`` Identifier_ ``=`` TypeExpr_ ``;``                                    | TypeAliasDeclaration_          | TypeParameterized_                                          |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``var`` Identifier_ ``=`` Expr_ ``;``                                         | VarDeclStmt_                   | DeclStmt_                                                   |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``while`` ``(`` Expr_ ``)`` Stmt_                                             | WhileStmt_                     | ControlStmt_, LoopStmt_                                     |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``with`` ``(`` Expr_ ``)`` Stmt_                                              | WithStmt_                      | ControlStmt_                                                |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+
| ``{`` Stmt_... ``}``                                                          | BlockStmt_                     |                                                             |                                                                                                |
+-------------------------------------------------------------------------------+--------------------------------+-------------------------------------------------------------+------------------------------------------------------------------------------------------------+

Expression classes
------------------

There is a large number of expression classes, so we present them by category. All classes in this section are subclasses of Expr_, except where noted otherwise.

Literals
~~~~~~~~

All classes in this subsection are subclasses of Literal_.

+-------------------+-----------------+
| Expression syntax |  CodeQL class   |
+===================+=================+
| ``true``          | BooleanLiteral_ |
+-------------------+-----------------+
| ``23``            | NumberLiteral_  |
+-------------------+-----------------+
| ``4.2``           | NumberLiteral_  |
+-------------------+-----------------+
| ``"Hello"``       | StringLiteral_  |
+-------------------+-----------------+
| ``/ab*c?/``       | RegExpLiteral_  |
+-------------------+-----------------+
| ``null``          | NullLiteral_    |
+-------------------+-----------------+

Identifiers
~~~~~~~~~~~

All identifiers are represented by the class Identifier_, which has subclasses to represent specific kinds of identifiers:

- VarAccess_: an identifier that refers to a variable
- VarDecl_: an identifier that declares a variable, for example ``x`` in ``var x = "hi"`` or in ``function(x) { }``
- VarRef_: a VarAccess_ or a VarDecl_
- Label_: an identifier that refers to a statement label or a property, not a variable; in the following examples, ``l`` and ``p`` are labels:

  - ``break l;``
  - ``l: for(;;) {}``
  - ``x.p``
  - ``{ p: 42 }``


Primary expressions
~~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of Expr_.

+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|                      Expression syntax                      |    CodeQL class     | Superclasses |                                                                                                  Remarks                                                                                                   |
+=============================================================+=====================+==============+============================================================================================================================================================================================================+
| ``this``                                                    | ThisExpr_           |              |                                                                                                                                                                                                            |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``[`` Expr_... ``]``                                        | ArrayExpr_          |              |                                                                                                                                                                                                            |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``{`` Property_... ``}``                                    | ObjectExpr_         |              |                                                                                                                                                                                                            |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``function`` ``(`` Parameter_... ``)`` ``{`` Stmt_... ``}`` | FunctionExpr_       | Function_    |                                                                                                                                                                                                            |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``(`` Parameter_... ``)`` ``=>`` Expr_                      | ArrowFunctionExpr_  | Function_    |                                                                                                                                                                                                            |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ``(`` Expr_ ``)``                                           | ParExpr_            |              |                                                                                                                                                                                                            |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ````` ... `````                                             | TemplateLiteral_    |              | an element in a TemplateLiteral_ is either a TemplateElement_ representing a constant template element, or some other expression representing an interpolated expression of the form ``${`` Expr_ ``}``    |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Expr_ ````` ... `````                                       | TaggedTemplateExpr_ |              | an element in a TaggedTemplateExpr_ is either a TemplateElement_ representing a constant template element, or some other expression representing an interpolated expression of the form ``${`` Expr_ ``}`` |
+-------------------------------------------------------------+---------------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Properties
~~~~~~~~~~

All classes in this subsection are subclasses of Property_. Note that Property_ is not a subclass of Expr_.

+------------------------------------------------------------------+-----------------+-------------------+
|                         Property syntax                          |  CodeQL class   |   Superclasses    |
+==================================================================+=================+===================+
| Identifier_ ``:`` Expr_                                          | ValueProperty_  |                   |
+------------------------------------------------------------------+-----------------+-------------------+
| ``get`` Identifier_ ``()`` ``{`` Stmt_... ``}``                  | PropertyGetter_ | PropertyAccessor_ |
+------------------------------------------------------------------+-----------------+-------------------+
| ``set`` Identifier_ ``(`` Identifier_ ``)`` ``{`` Stmt_... ``}`` | PropertySetter_ | PropertyAccessor_ |
+------------------------------------------------------------------+-----------------+-------------------+

Property accesses
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of PropAccess_.

+-------------------------+--------------+
|    Expression syntax    | CodeQL class |
+=========================+==============+
| Expr_ ``.`` Identifier_ | DotExpr_     |
+-------------------------+--------------+
| Expr_ ``[`` Expr_ ``]`` | IndexExpr_   |
+-------------------------+--------------+

Function calls and ``new``
~~~~~~~~~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of InvokeExpr_.

+-----------------------------------------------+-----------------+-----------------------------------------------------------------------------------+
|               Expression syntax               |  CodeQL class   |                                      Remarks                                      |
+===============================================+=================+===================================================================================+
| Expr_ ``(`` Expr_... ``)``                    | CallExpr_       |                                                                                   |
+-----------------------------------------------+-----------------+-----------------------------------------------------------------------------------+
| Expr_ ``.`` Identifier_  ``(`` Expr_... ``)`` | MethodCallExpr_ | this also includes calls of the form Expr_ ``[`` Expr_ ``]`` ``(`` Expr_... ``)`` |
+-----------------------------------------------+-----------------+-----------------------------------------------------------------------------------+
| ``new`` Expr_ ``(`` Expr_... ``)``            | NewExpr_        |                                                                                   |
+-----------------------------------------------+-----------------+-----------------------------------------------------------------------------------+

Unary expressions
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of UnaryExpr_.

+-------------------+----------------+
| Expression syntax |  CodeQL class  |
+===================+================+
| ``~`` Expr_       | BitNotExpr_    |
+-------------------+----------------+
| ``-`` Expr_       | NegExpr_       |
+-------------------+----------------+
| ``+`` Expr_       | PlusExpr_      |
+-------------------+----------------+
| ``!`` Expr_       | LogNotExpr_    |
+-------------------+----------------+
| ``typeof`` Expr_  | TypeofExpr_    |
+-------------------+----------------+
| ``void`` Expr_    | VoidExpr_      |
+-------------------+----------------+
| ``delete`` Expr_  | DeleteExpr_    |
+-------------------+----------------+
| ``...`` Expr_     | SpreadElement_ |
+-------------------+----------------+

Binary expressions
~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of BinaryExpr_.

+----------------------------+-----------------+----------------------------+
|     Expression syntax      |  CodeQL class   |        Superclasses        |
+============================+=================+============================+
| Expr_ ``*`` Expr_          | MulExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``/`` Expr_          | DivExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``%`` Expr_          | ModExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``**`` Expr_         | ExpExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``+`` Expr_          | AddExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``-`` Expr_          | SubExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``<<`` Expr_         | LShiftExpr_     |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``>>`` Expr_         | RShiftExpr_     |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``>>>`` Expr_        | URShiftExpr_    |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``&&`` Expr_         | LogAndExpr_     |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``||`` Expr_         | LogOrExpr_      |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``<`` Expr_          | LTExpr_         | Comparison_                |
+----------------------------+-----------------+----------------------------+
| Expr_ ``>`` Expr_          | GTExpr_         | Comparison_                |
+----------------------------+-----------------+----------------------------+
| Expr_ ``<=`` Expr_         | LEExpr_         | Comparison_                |
+----------------------------+-----------------+----------------------------+
| Expr_ ``>=`` Expr_         | GEExpr_         | Comparison_                |
+----------------------------+-----------------+----------------------------+
| Expr_ ``==`` Expr_         | EqExpr_         | EqualityTest_, Comparison_ |
+----------------------------+-----------------+----------------------------+
| Expr_ ``!=`` Expr_         | NEqExpr_        | EqualityTest_, Comparison_ |
+----------------------------+-----------------+----------------------------+
| Expr_ ``===`` Expr_        | StrictEqExpr_   | EqualityTest_, Comparison_ |
+----------------------------+-----------------+----------------------------+
| Expr_ ``!==`` Expr_        | StrictNEqExpr_  | EqualityTest_, Comparison_ |
+----------------------------+-----------------+----------------------------+
| Expr_ ``&`` Expr_          | BitAndExpr_     |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``|`` Expr_          | BitOrExpr_      |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``^`` Expr_          | XOrExpr_        |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``in`` Expr_         | InExpr_         |                            |
+----------------------------+-----------------+----------------------------+
| Expr_ ``instanceof`` Expr_ | InstanceofExpr_ |                            |
+----------------------------+-----------------+----------------------------+

Assignment expressions
~~~~~~~~~~~~~~~~~~~~~~

All classes in this table are subclasses of Assignment_.

+----------------------+--------------------+---------------------+
|  Expression syntax   |    CodeQL class    |    Superclasses     |
+======================+====================+=====================+
| Expr_ ``=`` Expr_    | AssignExpr_        |                     |
+----------------------+--------------------+---------------------+
| Expr_ ``+=`` Expr_   | AssignAddExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``-=`` Expr_   | AssignSubExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``*=`` Expr_   | AssignMulExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``**=`` Expr_  | AssignExpExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``/=`` Expr_   | AssignDivExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``%=`` Expr_   | AssignModExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``&=`` Expr_   | AssignAndExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``|=`` Expr_   | AssignOrExpr_      | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``^=`` Expr_   | AssignXOrExpr_     | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``<<=`` Expr_  | AssignLShiftExpr_  | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``>>=`` Expr_  | AssignRShiftExpr_  | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+
| Expr_ ``>>>=`` Expr_ | AssignURShiftExpr_ | CompoundAssignExpr_ |
+----------------------+--------------------+---------------------+

Update expressions
~~~~~~~~~~~~~~~~~~

All classes in this table are subclasses of UpdateExpr_.

+-------------------+--------------+
| Expression syntax | CodeQL class |
+===================+==============+
| Expr_ ``++``      | PostIncExpr_ |
+-------------------+--------------+
| Expr_ ``--``      | PostDecExpr_ |
+-------------------+--------------+
| ``++`` Expr_      | PreIncExpr_  |
+-------------------+--------------+
| ``--`` Expr_      | PreDecExpr_  |
+-------------------+--------------+

Miscellaneous
~~~~~~~~~~~~~

All classes in this table are subclasses of Expr_.

+-------------------------------+------------------+
|       Expression syntax       |   CodeQL class   |
+===============================+==================+
| Expr_ ``?`` Expr_ ``:`` Expr_ | ConditionalExpr_ |
+-------------------------------+------------------+
| Expr_ ``,`` ... ``,`` Expr_   | SeqExpr_         |
+-------------------------------+------------------+
| ``await`` Expr_               | AwaitExpr_       |
+-------------------------------+------------------+
| ``yield`` Expr_               | YieldExpr_       |
+-------------------------------+------------------+

Further reading
---------------

.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst


.. Links used in tables. For information about using these links, see
   https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#hyperlinks.

.. _Stmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html
.. _Expr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html
.. _ExprStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ExprStmt.html
.. _Label: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Label.html
.. _LabeledStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$LabeledStmt.html
.. _EmptyStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$EmptyStmt.html
.. _BreakStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$BreakStmt.html
.. _JumpStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$JumpStmt.html
.. _BreakOrContinueStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$BreakOrContinueStmt.html
.. _Case: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Case.html
.. _SwitchStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$SwitchStmt.html
.. _Identifier: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Identifier.html
.. _CatchClause: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$CatchClause.html
.. _ControlStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ControlStmt.html
.. _TryStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$TryStmt.html
.. _MemberDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$MemberDeclaration.html
.. _ClassDeclStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassDeclStmt.html
.. _ClassDefinition: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassDefinition.html
.. _ClassOrInterface: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassOrInterface.html
.. _TypeParameterized: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeParameterized.html
.. _ConstDeclStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ConstDeclStmt.html
.. _DeclStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$DeclStmt.html
.. _ContinueStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ContinueStmt.html
.. _DebuggerStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$DebuggerStmt.html
.. _GlobalAugmentationDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$GlobalAugmentationDeclaration.html
.. _StringLiteral: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$StringLiteral.html
.. _ExternalModuleDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExternalModuleDeclaration.html
.. _DoWhileStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$DoWhileStmt.html
.. _LoopStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$LoopStmt.html
.. _EnumDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$EnumDeclaration.html
.. _NamespaceDefinition: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceDefinition.html
.. _BulkReExportDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$BulkReExportDeclaration.html
.. _ReExportDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ReExportDeclaration.html
.. _ExportDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ExportDeclaration.html
.. _ExportDefaultDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ExportDefaultDeclaration.html
.. _FunctionDeclStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$FunctionDeclStmt.html
.. _ExportSpecifier: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ExportSpecifier.html
.. _ExportNamedDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ExportNamedDeclaration.html
.. _ExportAssignDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExportAssignDeclaration.html
.. _ExportAsNamespaceDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExportAsNamespaceDeclaration.html
.. _ForStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ForStmt.html
.. _VarAccess: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarAccess.html
.. _ForInStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ForInStmt.html
.. _EnhancedForLoop: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$EnhancedForLoop.html
.. _ForOfStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ForOfStmt.html
.. _Parameter: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Parameter.html
.. _Function: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Functions.qll/type.Functions$Function.html
.. _IfStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$IfStmt.html
.. _ImportSpecifier: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ImportSpecifier.html
.. _ImportDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ImportDeclaration.html
.. _Import: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Modules.qll/type.Modules$Import.html
.. _ImportEqualsDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ImportEqualsDeclaration.html
.. _InterfaceDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$InterfaceDeclaration.html
.. _InterfaceDefinition: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$InterfaceDefinition.html
.. _LetStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$LetStmt.html
.. _NamespaceDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceDeclaration.html
.. _ReturnStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ReturnStmt.html
.. _ThrowStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ThrowStmt.html
.. _TypeExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeExpr.html
.. _TypeAliasDeclaration: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAliasDeclaration.html
.. _VarDeclStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$VarDeclStmt.html
.. _WhileStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$WhileStmt.html
.. _WithStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$WithStmt.html
.. _BlockStmt: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$BlockStmt.html
.. _Literal: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Literal.html
.. _BooleanLiteral: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BooleanLiteral.html
.. _NumberLiteral: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NumberLiteral.html
.. _RegExpLiteral: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$RegExpLiteral.html
.. _NullLiteral: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NullLiteral.html
.. _VarDecl: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarDecl.html
.. _VarRef: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarRef.html
.. _ThisExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ThisExpr.html
.. _ArrayExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ArrayExpr.html
.. _Property: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Property.html
.. _ObjectExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ObjectExpr.html
.. _FunctionExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$FunctionExpr.html
.. _ArrowFunctionExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ArrowFunctionExpr.html
.. _ParExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ParExpr.html
.. _TemplateLiteral: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Templates.qll/type.Templates$TemplateLiteral.html
.. _TemplateElement: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Templates.qll/type.Templates$TemplateElement.html
.. _TaggedTemplateExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Templates.qll/type.Templates$TaggedTemplateExpr.html
.. _ValueProperty: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ValueProperty.html
.. _PropertyGetter: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertyGetter.html
.. _PropertyAccessor: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertyAccessor.html
.. _PropertySetter: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertySetter.html
.. _PropAccess: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropAccess.html
.. _DotExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$DotExpr.html
.. _IndexExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$IndexExpr.html
.. _InvokeExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$InvokeExpr.html
.. _CallExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$CallExpr.html
.. _MethodCallExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$MethodCallExpr.html
.. _NewExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NewExpr.html
.. _UnaryExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$UnaryExpr.html
.. _BitNotExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BitNotExpr.html
.. _NegExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NegExpr.html
.. _PlusExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PlusExpr.html
.. _LogNotExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LogNotExpr.html
.. _TypeofExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$TypeofExpr.html
.. _VoidExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$VoidExpr.html
.. _DeleteExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$DeleteExpr.html
.. _SpreadElement: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$SpreadElement.html
.. _BinaryExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BinaryExpr.html
.. _MulExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$MulExpr.html
.. _DivExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$DivExpr.html
.. _ModExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ModExpr.html
.. _ExpExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ExpExpr.html
.. _AddExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AddExpr.html
.. _SubExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$SubExpr.html
.. _LShiftExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LShiftExpr.html
.. _RShiftExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$RShiftExpr.html
.. _URShiftExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$URShiftExpr.html
.. _LogAndExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LogAndExpr.html
.. _LogOrExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LogOrExpr.html
.. _LTExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LTExpr.html
.. _Comparison: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Comparison.html
.. _GTExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$GTExpr.html
.. _LEExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LEExpr.html
.. _GEExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$GEExpr.html
.. _EqExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$EqExpr.html
.. _EqualityTest: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$EqualityTest.html
.. _NEqExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NEqExpr.html
.. _StrictEqExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$StrictEqExpr.html
.. _StrictNEqExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$StrictNEqExpr.html
.. _BitAndExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BitAndExpr.html
.. _BitOrExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BitOrExpr.html
.. _XOrExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$XOrExpr.html
.. _InExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$InExpr.html
.. _InstanceofExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$InstanceofExpr.html
.. _Assignment: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Assignment.html
.. _AssignExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignExpr.html
.. _AssignAddExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignAddExpr.html
.. _CompoundAssignExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$CompoundAssignExpr.html
.. _AssignSubExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignSubExpr.html
.. _AssignMulExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignMulExpr.html
.. _AssignExpExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignExpExpr.html
.. _AssignDivExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignDivExpr.html
.. _AssignModExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignModExpr.html
.. _AssignAndExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignAndExpr.html
.. _AssignOrExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignOrExpr.html
.. _AssignXOrExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignXOrExpr.html
.. _AssignLShiftExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignLShiftExpr.html
.. _AssignRShiftExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignRShiftExpr.html
.. _AssignURShiftExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignURShiftExpr.html
.. _UpdateExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$UpdateExpr.html
.. _PostIncExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PostIncExpr.html
.. _PostDecExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PostDecExpr.html
.. _PreIncExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PreIncExpr.html
.. _PreDecExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PreDecExpr.html
.. _ConditionalExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ConditionalExpr.html
.. _SeqExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$SeqExpr.html
.. _AwaitExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AwaitExpr.html
.. _YieldExpr: https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$YieldExpr.html




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/index.rst
.. _codeql-language-guides:

CodeQL language guides
======================

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from the languages supported in CodeQL analysis.

.. toctree::

   codeql-for-cpp
   codeql-for-csharp
   codeql-for-go
   codeql-for-java
   codeql-for-javascript
   codeql-for-python
   codeql-for-ruby
   codeql-for-swift



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-csharp-code.rst
.. _basic-query-for-csharp-code:

Basic query for C# code
=======================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run performs a basic search of the code for ``if`` statements that are redundant, in the sense that they have an empty then branch. For example, code such as:

.. code-block:: csharp

   if (error) { }

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete ``select ""`` and paste the following query beneath the import statement ``import csharp``.

   .. code-block:: ql

      from IfStmt ifstmt, BlockStmt block
      where ifstmt.getThen() = block and
        block.isEmpty()
      select ifstmt, "This 'if' statement is redundant."  

 .. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-csharp-query-results-1.png
    :align: center

If any matching code is found, click a link in the ``ifstmt`` column to open the file and highlight the matching ``if`` statement.

.. image:: ../images/codeql-for-visual-studio-code/basic-csharp-query-results-2.png
    :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| Query part                                                    | Purpose                                                                                                           | Details                                                                                                                |
+===============================================================+===================================================================================================================+========================================================================================================================+
| ``import csharp``                                             | Imports the standard CodeQL libraries for C#.                                                                     | Every query begins with one or more ``import`` statements.                                                             |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``from IfStmt ifstmt, BlockStmt block``                       | Defines the variables for the query.                                                                              | We use:                                                                                                                |
|                                                               | Declarations are of the form:                                                                                     |                                                                                                                        |
|                                                               | ``<type> <variable name>``                                                                                        | - an ``IfStmt`` variable for ``if`` statements                                                                         |
|                                                               |                                                                                                                   | - a ``BlockStmt`` variable for the then block                                                                          |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``where ifstmt.getThen() = block and block.isEmpty()``        | Defines a condition on the variables.                                                                             | ``ifstmt.getThen() = block`` relates the two variables. The block must be the ``then`` branch of the ``if`` statement. |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               |                                                                                                                   | ``block.isEmpty()`` states that the block must be empty (that is, it contains no statements).                          |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``select ifstmt, "This 'if' statement is redundant."``        | Defines what to report for each match.                                                                            | Reports the resulting ``if`` statement with a string that explains the problem.                                        |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                                        |
|                                                               | ``select <program element>, "<alert message>"``                                                                   |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find examples of ``if`` statements with an ``else`` branch, where an empty ``then`` branch does serve a purpose. For example:

.. code-block:: csharp

   if (...)
   {
       ...
   }
   else if (option == "-verbose")
   {
       // nothing to do - handled earlier
   }
   else
   {
       error("unrecognized option");
   }

In this case, identifying the ``if`` statement with the empty ``then`` branch as redundant is a false positive. One solution to this is to modify the query to ignore empty ``then`` branches if the ``if`` statement has an ``else`` branch.

To exclude ``if`` statements that have an ``else`` branch:

#. Add the following to the where clause:

   .. code-block:: ql

      and not exists(ifstmt.getElse())

   The ``where`` clause is now:

   .. code-block:: ql

      where ifstmt.getThen() = block and
        block.isEmpty() and
        not exists(ifstmt.getElse())

#. Re-run the query.

   There are now fewer results because ``if`` statements with an ``else`` branch are no longer included.

Further reading
---------------

.. include:: ../reusables/csharp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions
.. |language-text| replace:: C#

.. |language-code| replace:: ``csharp``

.. |example-url| replace:: https://github.com/PowerShell/PowerShell

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-csharp.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``ifstmt`` and is linked to the location in the source code of the project where ``ifstmt`` occurs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/using-the-guards-library-in-cpp.rst
.. _using-the-guards-library-in-cpp:

Using the guards library in C and C++
=====================================

You can use the CodeQL guards library to identify conditional expressions that control the execution of other parts of a program in C and C++ codebases. 

About the guards library
------------------------

The guards library (defined in ``semmle.code.cpp.controlflow.Guards``) provides a class `GuardCondition <https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/controlflow/IRGuards.qll/type.IRGuards$GuardCondition.html>`__ representing Boolean values that are used to make control flow decisions.
A ``GuardCondition`` is considered to guard a basic block if the block can only be reached if the ``GuardCondition`` is evaluated a certain way. For instance, in the following code, ``x < 10`` is a ``GuardCondition``, and it guards all the code before the return statement.

.. code-block:: cpp

    if(x < 10) {
      f(x);
    } else if (x < 20) {
      g(x);
    } else {
      h(x);
    }
    return 0;


The ``controls`` predicate
--------------------------

The ``controls`` predicate helps determine which blocks are only run when the ``GuardCondition`` evaluates a certain way. ``guard.controls(block, testIsTrue)`` holds if ``block`` is only entered if the value of this condition is ``testIsTrue``.

In the following code sample, the call to ``isValid`` controls the calls to ``performAction`` and ``logFailure`` but not the return statement.

.. code-block:: cpp

    if(isValid(accessToken)) {
      performAction();
      succeeded = 1;
    } else {
      logFailure();
      succeeded = 0;
    }
    return succeeded;

In the following code sample, the call to ``isValid`` controls the body of the
``if`` statement, and also the code after the ``if``.

.. code-block:: cpp

    if(!isValid(accessToken)) {
      logFailure();
      return 0;
    }
    performAction();
    return succeeded;

The ``ensuresEq`` and ``ensuresLt`` predicates
----------------------------------------------

The ``ensuresEq`` and ``ensuresLt`` predicates are the main way of determining what, if any, guarantees the ``GuardCondition`` provides for a given basic block.

The ``ensuresEq`` predicate
***************************


When ``ensuresEq(left, right, k, block, true)`` holds, then ``block`` is only executed if ``left`` was equal to ``right + k`` at their last evaluation. When ``ensuresEq(left, right, k, block, false)`` holds, then ``block`` is only executed if ``left`` was not equal to ``right + k`` at their last evaluation.

The ``ensuresLt`` predicate
***************************

When ``ensuresLt(left, right, k, block, true)`` holds, then ``block`` is only executed if ``left`` was strictly less than ``right + k`` at their last evaluation. When ``ensuresLt(left, right, k, block, false)`` holds, then ``block`` is only executed if ``left`` was greater than or equal to ``right + k`` at their last evaluation.

In the following code sample, the comparison on the first line ensures that ``index`` is less than ``size`` in the "then" block, and that ``index`` is greater than or equal to ``size`` in the "else" block.

.. code-block:: cpp

    if(index < size) {
      ret = array[index];
    } else {
      ret = nullptr
    }
    return ret;

The ``comparesEq`` and ``comparesLt`` predicates
------------------------------------------------

The ``comparesEq`` and ``comparesLt`` predicates help determine if the ``GuardCondition`` evaluates to true.

The ``comparesEq`` predicate
****************************

``comparesEq(left, right, k, true, testIsTrue)`` holds if ``left`` equals ``right + k`` when the expression evaluates to ``testIsTrue``.

The ``comparesLt`` predicate
****************************

``comparesLt(left, right, k, isLessThan, testIsTrue)`` holds if ``left < right + k`` evaluates to ``isLessThan`` when the expression evaluates to ``testIsTrue``.

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-swift.rst
.. _analyzing-data-flow-in-swift:

Analyzing data flow in Swift
============================

You can use CodeQL to track the flow of data through a Swift program to places where the data is used.

About this article
------------------

This article describes how data flow analysis is implemented in the CodeQL libraries for Swift and includes examples to help you write your own data flow queries.
The following sections describe how to use the libraries for local data flow, global data flow, and taint tracking.
For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

Local data flow
---------------

Local data flow tracks the flow of data within a single function. Local data flow is easier, faster, and more precise than global data flow. Before looking at more complex tracking, you should always consider local tracking because it is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

You can use the local data flow library by importing the ``DataFlow`` module. The library uses the class ``Node`` to represent any element through which data can flow.
The ``Node`` class has a number of useful subclasses, such as ``ExprNode`` for expressions and ``ParameterNode`` for parameters. You can map between data flow nodes and expressions/control-flow nodes using the member predicates ``asExpr`` and ``getCfgNode``:

.. code-block:: ql

     class Node {
       /**
        * Gets the expression that corresponds to this node, if any.
        */
       Expr asExpr() { ... }

       /**
        * Gets the control flow node that corresponds to this data flow node.
        */
       ControlFlowNode getCfgNode() { ... }

       ...
     }

You can use the predicates ``exprNode`` and ``parameterNode`` to map from expressions and parameters to their data-flow node:

.. code-block:: ql

     /**
      * Gets a node corresponding to expression `e`.
      */
     ExprNode exprNode(DataFlowExpr e) { result.asExpr() = e }

     /**
      * Gets the node corresponding to the value of parameter `p` at function entry.
      */
     ParameterNode parameterNode(DataFlowParameter p) { result.getParameter() = p }

There can be multiple data-flow nodes associated with a single expression node in the AST.

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``.
You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localFlow``.

For example, you can find flow from an expression ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     DataFlow::localFlow(DataFlow::exprNode(source), DataFlow::exprNode(sink))

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow to include flow steps where values are not preserved, such as string manipulation.
For example:

.. code-block:: swift

     temp = x
     y = temp + ", " + temp

If ``x`` is a tainted string then ``y`` is also tainted.

The local taint tracking library is in the module ``TaintTracking``.
Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``.
You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localTaint``.

For example, you can find taint propagation from an expression ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     TaintTracking::localTaint(DataFlow::exprNode(source), DataFlow::exprNode(sink))

Examples of local data flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~

This query finds the ``format`` argument passed into each call to ``String.init(format:_:)``:

.. code-block:: ql

    import swift

    from CallExpr call, Method method
    where
      call.getStaticTarget() = method and
      method.hasQualifiedName("String", "init(format:_:)")
    select call.getArgument(0).getExpr()

Unfortunately this will only give the expression in the argument, not the values which could be passed to it.
So we use local data flow to find all expressions that flow into the argument:

.. code-block:: ql

    import swift
    import codeql.swift.dataflow.DataFlow

    from CallExpr call, Method method, Expr sourceExpr, Expr sinkExpr
    where
      call.getStaticTarget() = method and
      method.hasQualifiedName("String", "init(format:_:)") and
      sinkExpr = call.getArgument(0).getExpr() and
      DataFlow::localFlow(DataFlow::exprNode(sourceExpr), DataFlow::exprNode(sinkExpr))
    select sourceExpr, sinkExpr

We can vary the source, for example, making the source the parameter of a function rather than an expression. The following query finds where a parameter is used for the format:

.. code-block:: ql

    import swift
    import codeql.swift.dataflow.DataFlow

    from CallExpr call, Method method, ParamDecl sourceParam, Expr sinkExpr
    where
      call.getStaticTarget() = method and
      method.hasQualifiedName("String", "init(format:_:)") and
      sinkExpr = call.getArgument(0).getExpr() and
      DataFlow::localFlow(DataFlow::parameterNode(sourceParam), DataFlow::exprNode(sinkExpr))
    select sourceParam, sinkExpr

The following example finds calls to ``String.init(format:_:)`` where the format string is not a hard-coded string literal:

.. code-block:: ql

    import swift
    import codeql.swift.dataflow.DataFlow

    from CallExpr call, Method method, DataFlow::Node sinkNode
    where
      call.getStaticTarget() = method and
      method.hasQualifiedName("String", "init(format:_:)") and
      sinkNode.asExpr() = call.getArgument(0).getExpr() and
      not exists(StringLiteralExpr sourceLiteral |
        DataFlow::localFlow(DataFlow::exprNode(sourceLiteral), sinkNode)
      )
    select call, "Format argument to " + method.getName() + " isn't hard-coded."

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow.
However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

You can use the global data flow library by implementing the module ``DataFlow::ConfigSig``:

.. code-block:: ql

   import codeql.swift.dataflow.DataFlow

   module MyDataFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyDataFlow = DataFlow::Global<MyDataFlowConfiguration>;

These predicates are defined in the configuration:

-  ``isSource`` - defines where data may flow from.
-  ``isSink`` - defines where data may flow to.
-  ``isBarrier`` - optionally, restricts the data flow.
-  ``isAdditionalFlowStep`` - optionally, adds additional flow steps.

The last line (``module MyDataFlow = ...``) instantiates the parameterized module for data flow analysis by passing the configuration to the parameterized module. Data flow analysis can then be performed using ``MyDataFlow::flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyDataFlow::flow(source, sink)
   select source, "Dataflow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow what local taint tracking is to local data flow.
That is, global taint tracking extends global data flow with additional non-value-preserving steps.
The global taint tracking library uses the same configuration module as the global data flow library. You can perform taint flow analysis using ``TaintTracking::Global``:

.. code-block:: ql

   module MyTaintFlow = TaintTracking::Global<MyDataFlowConfiguration>;

   from DataFlow::Node source, DataFlow::Node sink
   where MyTaintFlow::flow(source, sink)
   select source, "Taint flow to $@.", sink, sink.toString()

Predefined sources
~~~~~~~~~~~~~~~~~~

The data flow library module ``codeql.swift.dataflow.FlowSources`` contains a number of predefined sources that you can use to write security queries to track data flow and taint flow.

-  The class ``RemoteFlowSource`` represents data flow from remote network inputs and from other applications.
-  The class ``LocalFlowSource`` represents data flow from local user input.
-  The class ``FlowSource`` includes both of the above.

Examples of global data flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following global taint-tracking query finds places where a string literal is used in a function call argument named "password".
  - Since this is a taint-tracking query, the ``TaintTracking::Global`` module is used.
  - The ``isSource`` predicate defines sources as any ``StringLiteralExpr``.
  - The ``isSink`` predicate defines sinks as arguments to a ``CallExpr`` called "password".
  - The sources and sinks may need tuning to a particular use, for example, if passwords are represented by a type other than ``String`` or passed in arguments of a different name than "password".

.. code-block:: ql

   import swift
   import codeql.swift.dataflow.DataFlow
   import codeql.swift.dataflow.TaintTracking

   module ConstantPasswordConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node node) { node.asExpr() instanceof StringLiteralExpr }

     predicate isSink(DataFlow::Node node) {
       // any argument called `password`
       exists(CallExpr call | call.getArgumentWithLabel("password").getExpr() = node.asExpr())
     }

   module ConstantPasswordFlow = TaintTracking::Global<ConstantPasswordConfig>;

   from DataFlow::Node sourceNode, DataFlow::Node sinkNode
   where ConstantPasswordFlow::flow(sourceNode, sinkNode)
   select sinkNode, "The value $@ is used as a constant password.", sourceNode, sourceNode.toString()


The following global taint-tracking query finds places where a value from a remote or local user input is used as an argument to the SQLite ``Connection.execute(_:)`` function.
  - Since this is a taint-tracking query, the ``TaintTracking::Global`` module is used.
  - The ``isSource`` predicate defines sources as a ``FlowSource`` (remote or local user input).
  - The ``isSink`` predicate defines sinks as the first argument in any call to ``Connection.execute(_:)``.

.. code-block:: ql

   import swift
   import codeql.swift.dataflow.DataFlow
   import codeql.swift.dataflow.TaintTracking
   import codeql.swift.dataflow.FlowSources

   module SqlInjectionConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node node) { node instanceof FlowSource }

     predicate isSink(DataFlow::Node node) {
       exists(CallExpr call |
         call.getStaticTarget().(Method).hasQualifiedName("Connection", "execute(_:)") and
         call.getArgument(0).getExpr() = node.asExpr()
       )
     }
   }

   module SqlInjectionFlow = TaintTracking::Global<SqlInjectionConfig>;

   from DataFlow::Node sourceNode, DataFlow::Node sinkNode
   where SqlInjectionFlow::flow(sourceNode, sinkNode)
   select sinkNode, "This query depends on a $@.", sourceNode, "user-provided value"

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/swift-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/expressions-and-statements-in-python.rst
.. _expressions-and-statements-in-python:

Expressions and statements in Python
====================================

You can use syntactic classes from the CodeQL library to explore how Python expressions and statements are used in a code base.

Statements
----------

The bulk of Python code takes the form of statements. Each different type of statement in Python is represented by a separate CodeQL class.

Here is the full class hierarchy:

-  ``Stmt`` – A statement

   -  ``Assert`` – An ``assert`` statement
   -  ``Assign``

      -  ``AssignStmt`` – An assignment statement, ``x = y``
      -  ``ClassDef`` – A class definition statement
      -  ``FunctionDef`` – A function definition statement

   -  ``AugAssign`` – An augmented assignment, ``x += y``
   -  ``Break`` – A ``break`` statement
   -  ``Continue`` – A ``continue`` statement
   -  ``Delete`` – A ``del`` statement
   -  ``ExceptStmt`` – The ``except`` part of a ``try`` statement
   -  ``Exec`` – An ``exec`` statement
   -  ``For`` – A ``for`` statement
   -  ``Global`` – A ``global`` statement
   -  ``If`` – An ``if`` statement
   -  ``ImportStar`` – A ``from xxx import *`` statement
   -  ``Import`` – Any other ``import`` statement
   -  ``Nonlocal`` – A ``nonlocal`` statement
   -  ``Pass`` – A ``pass`` statement
   -  ``Print`` – A ``print`` statement (Python 2 only)
   -  ``Raise`` – A ``raise`` statement
   -  ``Return`` – A ``return`` statement
   -  ``Try`` – A ``try`` statement
   -  ``While`` – A ``while`` statement
   -  ``With`` – A ``with`` statement

Example finding redundant 'global' statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``global`` statement in Python declares a variable with a global (module-level) scope, when it would otherwise be local. Using the ``global`` statement outside a class or function is redundant as the variable is already global.

.. code-block:: ql

   import python

   from Global g
   where g.getScope() instanceof Module
   select g

The line: ``g.getScope() instanceof Module`` ensures that the ``Scope`` of ``Global g`` is a ``Module``, rather than a class or function.

Example finding 'if' statements with redundant branches
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

An ``if`` statement where one branch is composed of just ``pass`` statements could be simplified by negating the condition and dropping the ``else`` clause.

.. code-block:: python

   if cond():
       pass
   else:
       do_something

To find statements like this that could be simplified we can write a query.

.. code-block:: ql

   import python

   from If i, StmtList l
   where (l = i.getBody() or l = i.getOrelse())
     and forall(Stmt p | p = l.getAnItem() | p instanceof Pass)
   select i

Many codebases have some ``if`` statements that match this pattern.

The line: ``(l = i.getBody() or l = i.getOrelse())`` restricts the ``StmtList l`` to branches of the ``if`` statement.

The line: ``forall(Stmt p | p = l.getAnItem() | p instanceof Pass)`` ensures that all statements in ``l`` are ``pass`` statements.

Expressions
-----------

Each kind of Python expression has its own class. Here is the full class hierarchy:

-  ``Expr`` – An expression

   -  ``Attribute`` – An attribute, ``obj.attr``
   -  ``BinaryExpr`` – A binary operation, ``x+y``
   -  ``BoolExpr`` – Short circuit logical operations, ``x and y``, ``x or y``
   -  ``Bytes`` – A bytes literal, ``b"x"`` or (in Python 2) ``"x"``
   -  ``Call`` – A function call, ``f(arg)``
   -  ``Compare`` – A comparison operation, ``0 < x < 10``
   -  ``Dict`` – A dictionary literal, ``{'a': 2}``
   -  ``DictComp`` – A dictionary comprehension, ``{k: v for ...}``
   -  ``Ellipsis`` – An ellipsis expression, ``...``
   -  ``GeneratorExp`` – A generator expression
   -  ``IfExp`` – A conditional expression, ``x if cond else y``
   -  ``ImportExpr`` – An artificial expression representing the module imported
   -  ``ImportMember – A``\ n artificial expression representing importing a value from a module (part of an ``from xxx import *`` statement)
   -  ``Lambda – A lambda expression``
   -  ``List`` – A list literal, ``['a', 'b']``
   -  ``ListComp`` – A list comprehension, ``[x for ...]``
   -  ``Name`` – A reference to a variable, ``var``
   -  ``Num`` – A numeric literal, ``3`` or ``4.2``

      -  ``FloatLiteral``
      -  ``ImaginaryLiteral``
      -  ``IntegerLiteral``

   -  ``Repr`` – A backticks expression, ``x`` (Python 2 only)
   -  ``Set`` – A set literal, ``{'a', 'b'}``
   -  ``SetComp`` – A set comprehension, ``{x for ...}``
   -  ``Slice`` – A slice; the ``0:1`` in the expression ``seq[0:1]``
   -  ``Starred`` – A starred expression, ``*x`` in the context of a multiple assignment: ``y, *x = 1,2,3`` (Python 3 only)
   -  ``StrConst`` – A string literal. In Python 2 either bytes or unicode. In Python 3 only unicode.
   -  ``Subscript`` – A subscript operation, ``seq[index]``
   -  ``UnaryExpr`` – A unary operation, ``-x``
   -  ``Unicode`` – A unicode literal, ``u"x"`` or (in Python 3) ``"x"``
   -  ``Yield`` – A ``yield`` expression
   -  ``YieldFrom`` – A ``yield from`` expression (Python 3.3+)

Example finding comparisons to integer or string literals using 'is'
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Python implementations commonly cache small integers and single character strings, which means that comparisons such as the following often work correctly, but this is not guaranteed and we might want to check for them.

.. code-block:: python

   x is 10
   x is "A"

We can check for these using a query.

.. code-block:: ql

   import python

   from Compare cmp, Expr literal
   where (literal instanceof StrConst or literal instanceof Num)
     and cmp.getOp(0) instanceof Is and cmp.getComparator(0) = literal
   select cmp

The clause ``cmp.getOp(0) instanceof Is and cmp.getComparator(0) = literal`` checks that the first comparison operator is "is" and that the first comparator is a literal.

.. pull-quote::

   Tip

   We have to use ``cmp.getOp(0)`` and ``cmp.getComparator(0)``\ as there is no ``cmp.getOp()`` or ``cmp.getComparator()``. The reason for this is that a ``Compare`` expression can have multiple operators. For example, the expression ``3 < x < 7`` has two operators and two comparators. You use ``cmp.getComparator(0)`` to get the first comparator (in this example the ``x``) and ``cmp.getComparator(1)`` to get the second comparator (in this example the ``7``).

Example finding duplicates in dictionary literals
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If there are duplicate keys in a Python dictionary, then the second key will overwrite the first, which is almost certainly a mistake. We can find these duplicates with CodeQL, but the query is more complex than previous examples and will require us to write a ``predicate`` as a helper.

.. code-block:: ql

   import python

   predicate same_key(Expr k1, Expr k2) {
     k1.(Num).getN() = k2.(Num).getN()
     or
     k1.(StrConst).getText() = k2.(StrConst).getText()
   }

   from Dict d, Expr k1, Expr k2
   where k1 = d.getAKey() and k2 = d.getAKey()
     and k1 != k2 and same_key(k1, k2)
   select k1, "Duplicate key in dict literal"

When we ran this query on some test codebases, we found examples of duplicate dictionary keys. The results were also highlighted as alerts by the standard "Duplicate key in dict literal" query. For more information, see `Duplicate key in dict literal <https://codeql.github.com/codeql-query-help/python/py-duplicate-key-dict-literal/>`__.

The supporting predicate ``same_key`` checks that the keys have the same identifier. Separating this part of the logic into a supporting predicate, instead of directly including it in the query, makes it easier to understand the query as a whole. The casts defined in the predicate restrict the expression to the type specified and allow predicates to be called on the type that is cast-to. For example:

.. code-block:: ql

   x = k1.(Num).getN()

is equivalent to

.. code-block:: ql

   exists(Num num | num = k1 | x = num.getN())

The short version is usually used as this is easier to read.

Example finding Java-style getters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Returning to the example from ":doc:`Functions in Python <functions-in-python>`," the query identified all methods with a single line of code and a name starting with ``get``.

.. code-block:: ql

   import python

   from Function f
   where f.getName().matches("get%") and f.isMethod()
       and count(f.getAStmt()) = 1
   select f, "This function is (probably) a getter."

This basic query can be improved by checking that the one line of code is a Java-style getter of the form ``return self.attr``.

.. code-block:: ql

   import python

   from Function f, Return ret, Attribute attr, Name self
   where f.getName().matches("get%") and f.isMethod()
       and ret = f.getStmt(0) and ret.getValue() = attr
       and attr.getObject() = self and self.getId() = "self"
   select f, "This function is a Java-style getter."

.. code-block:: ql

   ret = f.getStmt(0) and ret.getValue() = attr

This condition checks that the first line in the method is a return statement and that the expression returned (``ret.getValue()``) is an ``Attribute`` expression. Note that the equality ``ret.getValue() = attr`` means that ``ret.getValue()`` is restricted to ``Attribute``\ s, since ``attr`` is an ``Attribute``.

.. code-block:: ql

   attr.getObject() = self and self.getId() = "self"

This condition checks that the value of the attribute (the expression to the left of the dot in ``value.attr``) is an access to a variable called ``"self"``.

Class and function definitions
------------------------------

As Python is a dynamically typed language, class, and function definitions are executable statements. This means that a class statement is both a statement and a scope containing statements. To represent this cleanly the class definition is broken into a number of parts. At runtime, when a class definition is executed a class object is created and then assigned to a variable of the same name in the scope enclosing the class. This class is created from a code-object representing the source code for the body of the class. To represent this the ``ClassDef`` class (which represents a ``class`` statement) subclasses ``Assign``. The ``Class`` class, which represents the body of the class, can be accessed via the ``ClassDef.getDefinedClass()``. ``FunctionDef`` and ``Function`` are handled similarly.

Here is the relevant part of the class hierarchy:

-  ``Stmt``

   -  ``Assign``

      -  ``ClassDef``
      -  ``FunctionDef``

-  ``Scope``

   -  ``Class``
   -  ``Function``

Further reading
---------------

.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/abstract-syntax-tree-classes-for-working-with-ruby-programs.rst
.. _abstract-syntax-tree-classes-for-working-with-ruby-programs:

Abstract syntax tree classes for working with Ruby programs
===========================================================

CodeQL has a large selection of classes for representing the abstract syntax tree of Ruby programs.

.. include:: ../reusables/abstract-syntax-tree.rst

The descriptions below use the following conventions and placeholders.

* An ``IDENTIFIER`` denotes an arbitrary identifier.
* A ``CNAME`` denotes a class or module name.
* An ``FNAME`` denotes a method name.
* A ``TERM`` is either a semicolon or a newline used to terminate a statement.
* Elements enclosed in ``« »`` are grouped and may be suffixed by ``?``, ``*``, or ``+`` to denote 0 or 1 occurrences, 0 or more occurrences, and 1 or more occurrences respectively.

Statement classes
~~~~~~~~~~~~~~~~~

This table lists subclasses of Stmt_ that represent Ruby statements.

+---------------------------------+--------------+----------------+---------+
| Statement syntax                | CodeQL class | Superclasses   | Remarks |
+=================================+==============+================+=========+
| ``alias`` FNAME FNAME           | AliasStmt_   | Stmt_          |         |
+---------------------------------+--------------+----------------+---------+
| ``BEGIN {`` StmtSequence_ ``}`` | BeginBlock_  | StmtSequence_  |         |
+---------------------------------+--------------+----------------+---------+
| ``begin`` StmtSequence_ ``end`` | BeginExpr_   | StmtSequence_  |         |
+---------------------------------+--------------+----------------+---------+
| ``break`` «Expr_»?              | BreakStmt_   | ReturningStmt_ |         |
+---------------------------------+--------------+----------------+---------+
| ``;``                           | EmptyStmt_   | Stmt_          |         |
+---------------------------------+--------------+----------------+---------+
| ``END {`` StmtSequence_ ``}``   | EndBlock_    | StmtSequence_  |         |
+---------------------------------+--------------+----------------+---------+
| ``next`` «Expr_»?               | NextStmt_    | ReturningStmt_ |         |
+---------------------------------+--------------+----------------+---------+
| ``redo``                        | RedoStmt_    | Stmt_          |         |
+---------------------------------+--------------+----------------+---------+
| ``retry``                       | RetryStmt_   | Stmt_          |         |
+---------------------------------+--------------+----------------+---------+
| ``return`` «Expr_»?             | ReturnStmt_  | ReturningStmt_ |         |
+---------------------------------+--------------+----------------+---------+
| ``undef`` «FNAME ``,``»+        | UndefStmt_   | Stmt_          |         |
+---------------------------------+--------------+----------------+---------+

Calls
~~~~~

This table lists subclasses of Call_ as well as some expressions that appear as call arguments.

+----------------------------+---------------------+----------------+-------------------------------+
| Expression syntax          | CodeQL class        | Superclasses   | Remarks                       |
+============================+=====================+================+===============================+
| Expr_ ``[`` Expr_ ``]``    | ElementReference_   | MethodCall_    |                               |
+----------------------------+---------------------+----------------+-------------------------------+
| MethodName_ «Expr_ ``,``»* | MethodCall_         | Call_          |                               |
+----------------------------+---------------------+----------------+-------------------------------+
| LhsExpr_ ``=`` Expr_       | SetterMethodCall_   | MethodCall_    |                               |
+----------------------------+---------------------+----------------+-------------------------------+
| ``super``                  | SuperCall_          | MethodCall_    |                               |
+----------------------------+---------------------+----------------+-------------------------------+
| ``yield`` «Expr_ ``,``»*   | YieldCall_          | Call_          |                               |
+----------------------------+---------------------+----------------+-------------------------------+
| ``&`` IDENTIFIER           | BlockArgument_      | Expr_          | Used as an argument to a call |
+----------------------------+---------------------+----------------+-------------------------------+
| ``...``                    | ForwardedArguments_ | Expr_          | Used as an argument to a call |
+----------------------------+---------------------+----------------+-------------------------------+

Constant accesses
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of ConstantAccess_.

+----------------------------------------+----------------------+----------------------+-------------------+
| Expression syntax                      | CodeQL class         | Superclasses         | Remarks           |
+========================================+======================+======================+===================+
| CNAME                                  | ConstantReadAccess_  | ConstantAccess_      |                   |
+----------------------------------------+----------------------+----------------------+-------------------+
| CNAME ``=`` Expr_                      | ConstantAssignment_  | ConstantWriteAccess_ |                   |
+----------------------------------------+----------------------+----------------------+-------------------+

Control expressions
~~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of ControlExpr_.

+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| Expression syntax                                                                                                               | CodeQL class        | Superclasses                   | Remarks |
+=================================================================================================================================+=====================+================================+=========+
| ``if`` Expr_ ``then`` StmtSequence_  «``elsif`` Expr_ ``then`` StmtSequence_»* «``else`` StmtSequence_»? ``end``                | IfExpr_             | ConditionalExpr_, ControlExpr_ |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| ``while`` Expr_ ``do`` StmtSequence_ ``end``                                                                                    | WhileExpr_          | ConditionalLoop_               |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| ``until`` Expr_ ``do`` StmtSequence_ ``end``                                                                                    | UntilExpr_          | ConditionalLoop_               |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| ``for`` LhsExpr_ ``in`` Expr_ ``do`` StmtSequence_ ``end``                                                                      | ForExpr_            | Loop_                          |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| Stmt_ ``while`` Expr_                                                                                                           | WhileModifierExpr_  | ConditionalLoop_               |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| Stmt_ ``until`` Expr_                                                                                                           | UntilModifierExpr_  | ConditionalLoop_               |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| Stmt_ ``if`` Expr_                                                                                                              | IfModifierExpr_     | ConditionalExpr_, ControlExpr_ |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| Stmt_ ``unless`` Expr_                                                                                                          | UnlessModifierExpr_ | ConditionalExpr_, ControlExpr_ |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| Expr_ ``?`` Stmt_ ``:`` Stmt_                                                                                                   | TernaryIfExpr_      | ConditionalExpr_, ControlExpr_ |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| ``case`` Expr_ ``when`` Expr_ ``then`` StmtSequence_ «``when`` Expr_ ``then`` StmtSequence_»* «``else`` StmtSequence_»? ``end`` | CaseExpr_           | ControlExpr_                   |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| ``case when`` Expr_ ``then`` StmtSequence_ «``else`` StmtSequence_»? ``end``                                                    | CaseExpr_           | ControlExpr_                   |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+
| ``case`` Expr_ ``in`` «TERM CaseExpr_»+ ``end`` f                                                                               | CaseExpr_           | ControlExpr_                   |         |
+---------------------------------------------------------------------------------------------------------------------------------+---------------------+--------------------------------+---------+

Unary operations
~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of UnaryOperation_.

+--------------------+-----------------+---------------------------+-------------------+
| Expression syntax  |  CodeQL class  | Superclasses               | Remarks           |
+====================+=================+===========================+===================+
| ``~`` Expr_        | ComplementExpr_ | UnaryBitwiseOperation_    |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``defined?`` Expr_ | DefinedExpr_    | UnaryOperation_           |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``**`` Expr_       | HashSplatExpr_  | UnaryOperation_           |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``!`` Expr_        | NotExpr_        | UnaryOperation_           |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``not`` Expr_      | NotExpr_        | UnaryOperation_           |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``*`` Expr_        | SplatExpr_      | UnaryOperation_           |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``-`` Expr_        | UnaryMinusExpr_ | UnaryArithmeticOperation_ |                   |
+--------------------+-----------------+---------------------------+-------------------+
| ``+`` Expr_        | UnaryPlusExpr_  | UnaryArithmeticOperation_ |                   |
+--------------------+-----------------+---------------------------+-------------------+

Binary operations
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of BinaryOperation_.

+------------------------+--------------------------+----------------------------+-------------------+
| Expression syntax      |  CodeQL class            | Superclasses               | Remarks           |
+========================+==========================+============================+===================+
| Expr_ ``+`` Expr_      | AddExpr_                 | BinaryArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``+=`` Expr_  | AssignAddExpr_           | AssignArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``&=`` Expr_  | AssignBitwiseAndExpr_    | AssignBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``|=`` Expr_  | AssignBitwiseOrExpr_     | AssignBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``^=`` Expr_  | AssignBitwiseXorExpr_    | AssignBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``/=`` Expr_  | AssignDivExpr_           | AssignArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``**=`` Expr_ | AssignExponentExpr_      | AssignArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``<<=`` Expr_ | AssignLShiftExpr_        | AssignBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``&&=`` Expr_ | AssignLogicalAndExpr_    | BinaryLogicalOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``||=`` Expr_ | AssignLogicalOrExpr_     | BinaryLogicalOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``%=`` Expr_  | AssignModuloExpr_        | AssignArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``*=`` Expr_  | AssignMulExpr_           | AssignArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``>>=`` Expr_ | AssignRShiftExpr_        | AssignBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``-=`` Expr_  | AssignSubExpr_           | AssignArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``&`` Expr_      | BitwiseAndExpr_          | BinaryBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``|`` Expr_      | BitwiseOrExpr_           | BinaryBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``^`` Expr_      | BitwiseXorExpr_          | BinaryBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``===`` Expr_    | CaseEqExpr_              | EqualityOperation_         |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``/`` Expr_      | DivExpr_                 | BinaryArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``===`` Expr_    | EqExpr_                  | EqualityOperation_         |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``^`` Expr_      | ExponentExpr_            | BinaryArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``>=`` Expr_     | GEExpr_                  | RelationalOperation_       |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``>`` Expr_      | GTExpr_                  | RelationalOperation_       |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``<=`` Expr_     | LEExpr_                  | RelationalOperation_       |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``<<`` Expr_     | LShiftExpr_              | BinaryBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``<`` Expr_      | LTExpr_                  | RelationalOperation_       |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``&&`` Expr_     | LogicalAndExpr_          | BinaryLogicalOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``and`` Expr_    | LogicalAndExpr_          | BinaryLogicalOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``||`` Expr_     | LogicalOrExpr_           | BinaryLogicalOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``or`` Expr_     | LogicalOrExpr_           | BinaryLogicalOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``%`` Expr_      | ModuloExpr_              | BinaryArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``*`` Expr_      | MulExpr_                 | BinaryArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``!=`` Expr_     | NEExpr_                  | RelationalOperation_       |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``!~`` Expr_     | NoRegExpMatchExpr_       | BinaryOperation_           |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``>>`` Expr_     | RShiftExpr_              | BinaryBitwiseOperation_    |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``=~`` Expr_     | RegExpMatchExpr_         | BinaryOperation_           |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``<=>`` Expr_    | SpaceshipExpr_           | BinaryOperation_           |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| Expr_ ``-`` Expr_      | SubExpr_                 | BinaryArithmeticOperation_ |                   |
+------------------------+--------------------------+----------------------------+-------------------+
| LhsExpr_ ``=`` Expr_   | AssignExpr_              | Assignment_                |                   |
+------------------------+--------------------------+----------------------------+-------------------+

Literals
~~~~~~~~

All classes in this subsection are subclasses of Literal_.

+----------------------------+-------------------+----------------------------+-------------------+
| Example expression syntax  |  CodeQL class     | Superclasses               | Remarks           |
+============================+===================+============================+===================+
| ``[1, 2]``                 | ArrayLiteral_     | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``true``                   | BooleanLiteral_   | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``?a``                     | CharacterLiteral_ | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``__ENCODING__``           | EncodingLiteral_  | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``__FILE__``               | FileLiteral_      | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``{ foo: 123, bar: 456 }`` | HashLiteral_      | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| | ``<<FOO``                | HereDoc_          | StringlikeLiteral_         |                   |
| | ``hello world``          |                   |                            |                   |
| | ``FOO``                  |                   |                            |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``23``                     | IntegerLiteral_   | NumericLiteral_            |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``3.1``                    | FloatLiteral_     | NumericLiteral_            |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``3+2i``                   | ComplexLiteral_   | NumericLiteral_            |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``2/3r``                   | RationalLiteral_  | NumericLiteral_            |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``__LINE__``               | LineLiteral_      | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``nil``                    | NilLiteral_       | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``(1..10)``                | RangeLiteral_     | Literal_                   |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``/[a-z]+/``               | RegExpLiteral_    | StringlikeLiteral_         |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``"hello world"``          | StringLiteral_    | StringlikeLiteral_         |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ```ls -l```                | SubshellLiteral_  | StringlikeLiteral_         |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``%x(/bin/sh foo.sh)``     | SubshellLiteral_  | StringlikeLiteral_         |                   |
+----------------------------+-------------------+----------------------------+-------------------+
| ``:foo``                   | SymbolLiteral_    | StringlikeLiteral_         |                   |
+----------------------------+-------------------+----------------------------+-------------------+

Modules and Ruby classes
~~~~~~~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of BodyStmt_ and Scope_.

+----------------------------------------------------------------+--------------------+----------------------------------+-------------------+
| Expression syntax                                              | CodeQL class       | Superclasses                     | Remarks           |
+================================================================+====================+==================================+===================+
| ``class`` CNAME «``<`` Expr_»? TERM StmtSequence_ TERM ``end`` | ClassDeclaration_  | Namespace_, ConstantWriteAccess_ |                   |
+----------------------------------------------------------------+--------------------+----------------------------------+-------------------+
| ``module`` CNAME TERM StmtSequence_ TERM ``end``               | ModuleDeclaration_ | Namespace_, ConstantWriteAccess_ |                   |
+----------------------------------------------------------------+--------------------+----------------------------------+-------------------+
| ``class <<`` Expr_ TERM StmtSequence_ TERM ``end``             | SingletonClass_    | ModuleBase_                      |                   |
+----------------------------------------------------------------+--------------------+----------------------------------+-------------------+

Callable classes
~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of Callable_.

+----------------------------------------------------------------------+----------------------+----------------------+-------------------+
| Expression syntax                                                    | CodeQL class         | Superclasses         | Remarks           |
+======================================================================+======================+======================+===================+
| ``{`` «``|`` «Parameter_ ``,``»* ``|``»? StmtSequence_ ``}``         | BraceBlock_          | Block_               |                   |
+----------------------------------------------------------------------+----------------------+----------------------+-------------------+
| ``do`` «``|`` «Parameter_ ``,``»* ``|``»? BodyStmt_ ``end``          | DoBlock_             | Block_, BodyStmt_    |                   |
+----------------------------------------------------------------------+----------------------+----------------------+-------------------+
| ``-> (`` «Parameter_ ``,``»* ``)`` ``{`` StmtSequence_ ``}``         | Lambda_              | Callable_, BodyStmt_ |                   |
+----------------------------------------------------------------------+----------------------+----------------------+-------------------+
| ``-> (`` «Parameter_ ``,``»* ``)`` ``do`` BodyStmt_ ``end``          | Lambda_              | Callable_, BodyStmt_ |                   |
+----------------------------------------------------------------------+----------------------+----------------------+-------------------+
| ``def`` FNAME «Parameter_ ``,``»* TERM BodyStmt_ TERM ``end``        | Method_              | MethodBase_          |                   |
+----------------------------------------------------------------------+----------------------+----------------------+-------------------+
| ``def self.`` FNAME «Parameter_ ``,``»* TERM BodyStmt_ TERM ``end``  | SingletonMethod_     | MethodBase_          |                   |
+----------------------------------------------------------------------+----------------------+----------------------+-------------------+

Parameter classes
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of Parameter_.

+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| Expression syntax                                          | CodeQL class           | Superclasses         | Remarks                                                            |
+============================================================+========================+======================+====================================================================+
| ``&`` IDENTIFIER                                           | BlockParameter_        | NamedParameter_      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| ``(`` «IDENTIFIER ``,``»+ ``)``                            | DestructuredParameter_ |                      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| ``...``                                                    | ForwardParameter_      |                      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| ``**nil``                                                  | HashSplatNilParameter_ |                      | Indicates that there are no keyword parameters or keyword patterns |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| ``**`` IDENTIFIER                                          | HashSplatParameter_    | NamedParameter_      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| IDENTIFIER ``:`` «Expr_»?                                  | KeywordParameter_      | NamedParameter_      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| IDENTIFIER ``=`` Expr_                                     | OptionalParameter_     | NamedParameter_      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| IDENTIFIER                                                 | SimpleParameter_       | NamedParameter_      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+
| ``*`` IDENTIFIER                                           | SplatParameter_        | NamedParameter_      |                                                                    |
+------------------------------------------------------------+------------------------+----------------------+--------------------------------------------------------------------+

Pattern classes
~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of CasePattern_. These expressions typically occur when a ``case`` uses pattern matching syntax.

+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| Expression syntax                                                              | CodeQL class          | Superclasses | Remarks           |
+================================================================================+=======================+==============+===================+
| CasePattern_ «``|`` CasePattern_»+                                             | AlternativePattern_   | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| ``[`` «CasePattern ``,``»* «``*`` IDENTIFIER»? ``]``                           | ArrayPattern_         | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| CasePattern_ ``=>`` IDENTIFIER                                                 | AsPattern_            | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| ``[`` ``*`` «IDENTIFIER»? (``,`` CasePattern)* ``,`` ``*`` «IDENTIFIER»? ``]`` | FindPattern_          | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| ``{`` «StringlikeLiteral_ ``:`` CasePattern ``,``»* «``**`` IDENTIFIER»? ``}`` | HashPattern_          | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| ``(`` CasePattern_ ``)``                                                       | ParenthesizedPattern_ | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+
| ``^`` Expr_                                                                    | ReferencePattern_     | CasePattern_ |                   |
+--------------------------------------------------------------------------------+-----------------------+--------------+-------------------+

Expression classes
~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of Expr_.

+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| Expression syntax                                                                    | CodeQL class         | Superclasses  | Remarks                                                                                |
+======================================================================================+======================+===============+========================================================================================+
| «Expr_ ``,``»+                                                                       | ArgumentList_        | Expr_         | The right-hand side of an assignment or a ``return``, ``break``, or ``next`` statement |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| StmtSequence_ «RescueClause_»? «``else`` StmtSequence_»? «``ensure`` StmtSequence_»? | BodyStmt_            | StmtSequence_ |                                                                                        |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| Expr_ «``,`` Expr_»+                                                                 | DestructuredLhsExpr_ | LhsExpr_      |                                                                                        |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| Expr_                                                                                | LhsExpr_             | Expr_         | An Expr_ appearing on the left-hand side of various operations. Can take many forms.   |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| Expr_ ``:`` Expr_                                                                    | Pair_                | Expr_         | Such as in a hash or as a keyword argument                                             |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| ``(`` StmtSequence_ ``)``                                                            | ParenthesizedExpr_   | StmtSequence_ |                                                                                        |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| ``rescue`` StmtSequence_                                                             | RescueClause_        | Expr_         |                                                                                        |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| Stmt_ ``rescue`` Stmt_                                                               | RescueModifierExpr_  | Expr_         |                                                                                        |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| StmtSequence_ TERM Stmt_                                                             | StmtSequence_        | Expr_         | A sequence of 0 or more statements, separated by semicolons or newlines                |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+
| StringLiteral_ StringLiteral_                                                        | StringConcatenation_ | Expr_         | Implicit concatenation of consecutive string literals                                  |
+--------------------------------------------------------------------------------------+----------------------+---------------+----------------------------------------------------------------------------------------+

Variable classes
~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of VariableAccess_.

+----------------------------+------------------------------+-----------------------------------------------+------------------+
| Example expression syntax  |  CodeQL class                | Superclasses                                  | Remarks          |
+============================+==============================+===============================================+==================+
| ``@@foo``                  | ClassVariableReadAccess_     | VariableReadAccess_, ClassVariableAccess_     |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``@@foo = 'str'``          | ClassVariableWriteAccess_    | VariableWriteAccess_, ClassVariableAccess_    |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``$foo``                   | GlobalVariableReadAccess_    | VariableReadAccess_, GlobalVariableAccess_    |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``$foo = 'str'``           | GlobalVariableWriteAccess_   | VariableWriteAccess_, GlobalVariableAccess_   |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``@foo``                   | InstanceVariableReadAccess_  | VariableReadAccess_, InstanceVariableAccess_  |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``@foo = 'str'``           | InstanceVariableWriteAccess_ | VariableWriteAccess_, InstanceVariableAccess_ |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``foo``                    | LocalVariableReadAccess_     | VariableReadAccess_, LocalVariableAccess_     |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``foo = 'str'``            | LocalVariableWriteAccess_    | VariableWriteAccess_, LocalVariableAccess_    |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+
| ``self``                   | SelfVariableReadAccess_      | VariableReadAccess_, SelfVariableAccess_      |                  |
+----------------------------+------------------------------+-----------------------------------------------+------------------+

Syntactic sugar and desugaring
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Certain Ruby language features are shorthands for common operations that could also be expressed in other, more verbose, forms.
Such language features are typically referred to as "syntactic sugar", and make it easier for programmers to write and read code. This is
great for programmers. For source code analyzers, however, this leads to additional work as they need to understand the shorthand notation as well as the long form. To make analysis easier, CodeQL automatically "desugars" Ruby code, effectively rewriting
rich syntactic constructs into equivalent code that uses simpler syntactic constructs.

For example, supposing that ``x`` is an object with an attribute ``foo``, the assignment::

   x.foo = y

is desugared to code similar to::

  x.foo=(__synth_0 = y);
  __synth_0;

In other words, there is effectively a call to the SetterMethodCall_ ``foo=`` on ``x`` with argument ``__synth_0 = y``, followed by a read of the ``__synth_0`` variable.

In CodeQL, this is implemented by synthesizing AstNode_ instances corresponding to this desugared version of the code.

Note that the original AssignExpr_ and the desugared SetterMethodCall_ versions are both available to use in CodeQL queries, and you do not usually need to be aware of any desugaring that may take place. However, if a codebase explicitly uses ``x.foo=(y)`` SetterMethodCall_ syntax, you cannot find this syntax by searching for instances of AssignExpr_ .

Other synthesized AstNode_ instances exist, see the isSynthesized_ and getDesugared_ predicates for details.

Further reading
---------------

.. include:: ../reusables/ruby-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. _BlockArgument: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$BlockArgument.html
.. _Call: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$Call.html
.. _ElementReference: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$ElementReference.html
.. _ForwardedArguments: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$ForwardedArguments.html
.. _MethodCall: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$MethodCall.html
.. _SetterMethodCall: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$SetterMethodCall.html
.. _SuperCall: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$SuperCall.html
.. _UnknownMethodCall: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$UnknownMethodCall.html
.. _YieldCall: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Call.qll/type.Call$YieldCall.html
.. _ConstantAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Constant.qll/type.Constant$ConstantAccess.html
.. _ConstantReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Constant.qll/type.Constant$ConstantReadAccess.html
.. _ConstantWriteAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Constant.qll/type.Constant$ConstantWriteAccess.html
.. _ConstantAssignment: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Constant.qll/type.Constant$ConstantAssignment.html
.. _ArgumentList: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$ArgumentList.html
.. _BodyStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$BodyStmt.html
.. _DestructuredLhsExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$DestructuredLhsExpr.html
.. _Expr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$Expr.html
.. _LhsExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$LhsExpr.html
.. _Pair: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$Pair.html
.. _ParenthesizedExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$ParenthesizedExpr.html
.. _RescueClause: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$RescueClause.html
.. _RescueModifierExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$RescueModifierExpr.html
.. _StmtSequence: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$StmtSequence.html
.. _StringConcatenation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Expr.qll/type.Expr$StringConcatenation.html
.. _ControlExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$ControlExpr.html
.. _ConditionalExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$ConditionalExpr.html
.. _Loop: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$Loop.html
.. _ConditionalLoop: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$ConditionalLoop.html
.. _ForExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$ForExpr.html
.. _IfExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$IfExpr.html
.. _WhileExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$WhileExpr.html
.. _UntilExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$UntilExpr.html
.. _IfModifierExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$IfModifierExpr.html
.. _UnlessModifierExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$UnlessModifierExpr.html
.. _WhileModifierExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$WhileModifierExpr.html
.. _UntilModifierExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$UntilModifierExpr.html
.. _TernaryIfExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$TernaryIfExpr.html
.. _CaseExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Control.qll/type.Control$CaseExpr.html
.. _AstNode: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/AST.qll/type.AST$AstNode.html
.. _ArrayLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$ArrayLiteral.html
.. _BooleanLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$BooleanLiteral.html
.. _CharacterLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$CharacterLiteral.html
.. _ComplexLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$ComplexLiteral.html
.. _EncodingLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$EncodingLiteral.html
.. _FileLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$FileLiteral.html
.. _FloatLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$FloatLiteral.html
.. _HashLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$HashLiteral.html
.. _HereDoc: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$HereDoc.html
.. _IntegerLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$IntegerLiteral.html
.. _LineLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$LineLiteral.html
.. _Literal: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$Literal.html
.. _MethodName: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$MethodName.html
.. _NilLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$NilLiteral.html
.. _NumericLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$NumericLiteral.html
.. _RangeLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RangeLiteral.html
.. _RationalLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RationalLiteral.html
.. _RegExpComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RegExpComponent.html
.. _RegExpEscapeSequenceComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RegExpEscapeSequenceComponent.html
.. _RegExpInterpolationComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RegExpInterpolationComponent.html
.. _RegExpLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RegExpLiteral.html
.. _RegExpTextComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$RegExpTextComponent.html
.. _StringComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$StringComponent.html
.. _StringEscapeSequenceComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$StringEscapeSequenceComponent.html
.. _StringInterpolationComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$StringInterpolationComponent.html
.. _StringLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$StringLiteral.html
.. _StringTextComponent: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$StringTextComponent.html
.. _StringlikeLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$StringlikeLiteral.html
.. _SubshellLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$SubshellLiteral.html
.. _SymbolLiteral: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Literal.qll/type.Literal$SymbolLiteral.html
.. _Block: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$Block.html
.. _BraceBlock: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$BraceBlock.html
.. _Callable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$Callable.html
.. _DoBlock: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$DoBlock.html
.. _Lambda: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$Lambda.html
.. _Method: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$Method.html
.. _MethodBase: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$MethodBase.html
.. _SingletonMethod: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Method.qll/type.Method$SingletonMethod.html
.. _ClassDeclaration: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$ClassDeclaration.html
.. _Module: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$Module.html
.. _ModuleBase: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$ModuleBase.html
.. _ModuleDeclaration: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$ModuleDeclaration.html
.. _Namespace: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$Namespace.html
.. _SingletonClass: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$SingletonClass.html
.. _Toplevel: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Module.qll/type.Module$Toplevel.html
.. _AddExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AddExpr.html
.. _AssignAddExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignAddExpr.html
.. _AssignArithmeticOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignArithmeticOperation.html
.. _AssignBitwiseAndExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignBitwiseAndExpr.html
.. _AssignBitwiseOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignBitwiseOperation.html
.. _AssignBitwiseOrExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignBitwiseOrExpr.html
.. _AssignBitwiseXorExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignBitwiseXorExpr.html
.. _AssignDivExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignDivExpr.html
.. _AssignExponentExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignExponentExpr.html
.. _AssignExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignExpr.html
.. _AssignLShiftExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignLShiftExpr.html
.. _AssignLogicalAndExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignLogicalAndExpr.html
.. _AssignLogicalOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignLogicalOperation.html
.. _AssignLogicalOrExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignLogicalOrExpr.html
.. _AssignModuloExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignModuloExpr.html
.. _AssignMulExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignMulExpr.html
.. _AssignOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignOperation.html
.. _AssignRShiftExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignRShiftExpr.html
.. _AssignSubExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$AssignSubExpr.html
.. _Assignment: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$Assignment.html
.. _BinaryArithmeticOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BinaryArithmeticOperation.html
.. _BinaryBitwiseOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BinaryBitwiseOperation.html
.. _BinaryLogicalOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BinaryLogicalOperation.html
.. _BinaryOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BinaryOperation.html
.. _BitwiseAndExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BitwiseAndExpr.html
.. _BitwiseOrExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BitwiseOrExpr.html
.. _BitwiseXorExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$BitwiseXorExpr.html
.. _CaseEqExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$CaseEqExpr.html
.. _ComparisonOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$ComparisonOperation.html
.. _ComplementExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$ComplementExpr.html
.. _DefinedExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$DefinedExpr.html
.. _DivExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$DivExpr.html
.. _EqExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$EqExpr.html
.. _EqualityOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$EqualityOperation.html
.. _ExponentExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$ExponentExpr.html
.. _GEExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$GEExpr.html
.. _GTExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$GTExpr.html
.. _HashSplatExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$HashSplatExpr.html
.. _LEExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$LEExpr.html
.. _LShiftExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$LShiftExpr.html
.. _LTExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$LTExpr.html
.. _LogicalAndExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$LogicalAndExpr.html
.. _LogicalOrExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$LogicalOrExpr.html
.. _ModuloExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$ModuloExpr.html
.. _MulExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$MulExpr.html
.. _NEExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$NEExpr.html
.. _NoRegExpMatchExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$NoRegExpMatchExpr.html
.. _NotExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$NotExpr.html
.. _Operation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$Operation.html
.. _RShiftExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$RShiftExpr.html
.. _RegExpMatchExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$RegExpMatchExpr.html
.. _RelationalOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$RelationalOperation.html
.. _SpaceshipExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$SpaceshipExpr.html
.. _SplatExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$SplatExpr.html
.. _SubExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$SubExpr.html
.. _UnaryArithmeticOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$UnaryArithmeticOperation.html
.. _UnaryBitwiseOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$UnaryBitwiseOperation.html
.. _UnaryLogicalOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$UnaryLogicalOperation.html
.. _UnaryMinusExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$UnaryMinusExpr.html
.. _UnaryOperation: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$UnaryOperation.html
.. _UnaryPlusExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Operation.qll/type.Operation$UnaryPlusExpr.html
.. _BlockParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$BlockParameter.html
.. _DestructuredParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$DestructuredParameter.html
.. _ForwardParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$ForwardParameter.html
.. _HashSplatNilParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$HashSplatNilParameter.html
.. _HashSplatParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$HashSplatParameter.html
.. _KeywordParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$KeywordParameter.html
.. _NamedParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$NamedParameter.html
.. _OptionalParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$OptionalParameter.html
.. _Parameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$Parameter.html
.. _SimpleParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$SimpleParameter.html
.. _SplatParameter: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Parameter.qll/type.Parameter$SplatParameter.html
.. _AlternativePattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$AlternativePattern.html
.. _ArrayPattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$ArrayPattern.html
.. _AsPattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$AsPattern.html
.. _CasePattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$CasePattern.html
.. _FindPattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$FindPattern.html
.. _HashPattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$HashPattern.html
.. _ParenthesizedPattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$ParenthesizedPattern.html
.. _ReferencePattern: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Pattern.qll/type.Pattern$ReferencePattern.html
.. _Scope: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Scope.qll/type.Scope$Scope.html
.. _SelfScope: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Scope.qll/type.Scope$SelfScope.html
.. _AliasStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$AliasStmt.html
.. _BeginBlock: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$BeginBlock.html
.. _BeginExpr: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$BeginExpr.html
.. _BreakStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$BreakStmt.html
.. _EmptyStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$EmptyStmt.html
.. _EndBlock: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$EndBlock.html
.. _NextStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$NextStmt.html
.. _RedoStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$RedoStmt.html
.. _RetryStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$RetryStmt.html
.. _ReturnStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$ReturnStmt.html
.. _ReturningStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$ReturningStmt.html
.. _Stmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$Stmt.html
.. _UndefStmt: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Statement.qll/type.Statement$UndefStmt.html
.. _ClassVariable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$ClassVariable.html
.. _ClassVariableAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$ClassVariableAccess.html
.. _ClassVariableReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$ClassVariableReadAccess.html
.. _ClassVariableWriteAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$ClassVariableWriteAccess.html
.. _GlobalVariable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$GlobalVariable.html
.. _GlobalVariableAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$GlobalVariableAccess.html
.. _GlobalVariableReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$GlobalVariableReadAccess.html
.. _GlobalVariableWriteAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$GlobalVariableWriteAccess.html
.. _InstanceVariable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$InstanceVariable.html
.. _InstanceVariableAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$InstanceVariableAccess.html
.. _InstanceVariableReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$InstanceVariableReadAccess.html
.. _InstanceVariableWriteAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$InstanceVariableWriteAccess.html
.. _LocalVariable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$LocalVariable.html
.. _LocalVariableAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$LocalVariableAccess.html
.. _LocalVariableReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$LocalVariableReadAccess.html
.. _LocalVariableWriteAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$LocalVariableWriteAccess.html
.. _SelfVariable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$SelfVariable.html
.. _SelfVariableAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$SelfVariableAccess.html
.. _SelfVariableReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$SelfVariableReadAccess.html
.. _Variable: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$Variable.html
.. _VariableAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$VariableAccess.html
.. _VariableReadAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$VariableReadAccess.html
.. _VariableWriteAccess: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/ast/Variable.qll/type.Variable$VariableWriteAccess.html
.. _isSynthesized: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/AST.qll/predicate.AST$AstNode$isSynthesized.0.html
.. _getDesugared: https://codeql.github.com/codeql-standard-libraries/ruby/codeql/ruby/AST.qll/predicate.AST$AstNode$getDesugared.0.html



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/javadoc.rst
.. _javadoc:

Javadoc
=======

You can use CodeQL to find errors in Javadoc comments in Java code.

About analyzing Javadoc
-----------------------

To access Javadoc associated with a program element, we use member predicate ``getDoc`` of class ``Element``, which returns a ``Documentable``. Class ``Documentable``, in turn, offers a member predicate ``getJavadoc`` to retrieve the Javadoc attached to the element in question, if any.

Javadoc comments are represented by class ``Javadoc``, which provides a view of the comment as a tree of ``JavadocElement`` nodes. Each ``JavadocElement`` is either a ``JavadocTag``, representing a tag, or a ``JavadocText``, representing a piece of free-form text.

The most important member predicates of class ``Javadoc`` are:

-  ``getAChild`` - retrieves a top-level ``JavadocElement`` node in the tree representation.
-  ``getVersion`` - returns the value of the ``@version`` tag, if any.
-  ``getAuthor`` - returns the value of the ``@author`` tag, if any.

For example, the following query finds all classes that have both an ``@author`` tag and a ``@version`` tag, and returns this information:

.. code-block:: ql

   import java

   from Class c, Javadoc jdoc, string author, string version
   where jdoc = c.getDoc().getJavadoc() and
       author = jdoc.getAuthor() and
       version = jdoc.getVersion()
   select c, author, version

``JavadocElement`` defines member predicates ``getAChild`` and ``getParent`` to navigate up and down the tree of elements. It also provides a predicate ``getTagName`` to return the tag's name, and a predicate ``getText`` to access the text associated with the tag.

We could rewrite the above query to use this API instead of ``getAuthor`` and ``getVersion``:

.. code-block:: ql

   import java
    
   from Class c, Javadoc jdoc, JavadocTag authorTag, JavadocTag versionTag
   where jdoc = c.getDoc().getJavadoc() and
       authorTag.getTagName() = "@author" and authorTag.getParent() = jdoc and
       versionTag.getTagName() = "@version" and versionTag.getParent() = jdoc
   select c, authorTag.getText(), versionTag.getText()

The ``JavadocTag`` has several subclasses representing specific kinds of Javadoc tags:

-  ``ParamTag`` represents ``@param`` tags; member predicate ``getParamName`` returns the name of the parameter being documented.
-  ``ThrowsTag`` represents ``@throws`` tags; member predicate ``getExceptionName`` returns the name of the exception being documented.
-  ``AuthorTag`` represents ``@author`` tags; member predicate ``getAuthorName`` returns the name of the author.

Example: Finding spurious @param tags
-------------------------------------

As an example of using the CodeQL Javadoc API, let's write a query that finds ``@param`` tags that refer to a non-existent parameter.

For example, consider this program:

.. code-block:: java

   class A {
       /**
       * @param lst a list of strings
       */
       public String get(List<String> list) {
           return list.get(0);
       }
   }

Here, the ``@param`` tag on ``A.get`` misspells the name of parameter ``list`` as ``lst``. Our query should be able to find such cases.

To begin with, we write a query that finds all callables (that is, methods or constructors) and their ``@param`` tags:

.. code-block:: ql

   import java

   from Callable c, ParamTag pt
   where c.getDoc().getJavadoc() = pt.getParent()
   select c, pt

It's now easy to add another conjunct to the ``where`` clause, restricting the query to ``@param`` tags that refer to a non-existent parameter: we simply need to require that no parameter of ``c`` has the name ``pt.getParamName()``.

.. code-block:: ql

   import java

   from Callable c, ParamTag pt
   where c.getDoc().getJavadoc() = pt.getParent() and
       not c.getAParameter().hasName(pt.getParamName())
   select pt, "Spurious @param tag."

Example: Finding spurious @throws tags
--------------------------------------

A related, but somewhat more involved, problem is finding ``@throws`` tags that refer to an exception that the method in question cannot actually throw.

For example, consider this Java program:

.. code-block:: java

   import java.io.IOException;

   class A {
       /**
       * @throws IOException thrown if some IO operation fails
       * @throws RuntimeException thrown if something else goes wrong
       */
       public void foo() {
           // ...
       }
   }

Notice that the Javadoc comment of ``A.foo`` documents two thrown exceptions: ``IOException`` and ``RuntimeException``. The former is clearly spurious: ``A.foo`` doesn't have a ``throws IOException`` clause, and therefore can't throw this kind of exception. On the other hand, ``RuntimeException`` is an unchecked exception, so it can be thrown even if there is no explicit ``throws`` clause listing it. So our query should flag the ``@throws`` tag for ``IOException``, but not the one for ``RuntimeException.``

Remember that the CodeQL library represents ``@throws`` tags using class ``ThrowsTag``. This class doesn't provide a member predicate for determining the exception type that is being documented, so we first need to implement our own version. A simple version might look like this:

.. code-block:: ql

   RefType getDocumentedException(ThrowsTag tt) {
       result.hasName(tt.getExceptionName())
   }

Similarly, ``Callable`` doesn't come with a member predicate for querying all exceptions that the method or constructor may possibly throw. We can, however, implement this ourselves by using ``getAnException`` to find all ``throws`` clauses of the callable, and then use ``getType`` to resolve the corresponding exception types:

.. code-block:: ql

   predicate mayThrow(Callable c, RefType exn) {
       exn.getASupertype*() = c.getAnException().getType()
   }

Note the use of ``getASupertype*`` to find both exceptions declared in a ``throws`` clause and their subtypes. For instance, if a method has a ``throws IOException`` clause, it may throw ``MalformedURLException``, which is a subtype of ``IOException``.

Now we can write a query for finding all callables ``c`` and ``@throws`` tags ``tt`` such that:

-  ``tt`` belongs to a Javadoc comment attached to ``c``.
-  ``c`` can't throw the exception documented by ``tt``.

.. code-block:: ql

   import java

   // Insert the definitions from above

   from Callable c, ThrowsTag tt, RefType exn
   where c.getDoc().getJavadoc() = tt.getParent+() and
       exn = getDocumentedException(tt) and
       not mayThrow(c, exn)
   select tt, "Spurious @throws tag."

Improvements
~~~~~~~~~~~~

Currently, there are two problems with this query:

#. ``getDocumentedException`` is too liberal: it will return *any* reference type with the right name, even if it's in a different package and not actually visible in the current compilation unit.
#. ``mayThrow`` is too restrictive: it doesn't account for unchecked exceptions, which do not need to be declared.

To see why the former is a problem, consider this program:

.. code-block:: java

   class IOException extends Exception {}

   class B {
       /** @throws IOException an IO exception */
       void bar() throws IOException {}
   }

This program defines its own class ``IOException``, which is unrelated to the class ``java.io.IOException`` in the standard library: they are in different packages. Our ``getDocumentedException`` predicate doesn't check packages, however, so it will consider the ``@throws`` clause to refer to both ``IOException`` classes, and thus flag the ``@param`` tag as spurious, since ``B.bar`` can't actually throw ``java.io.IOException``.

As an example of the second problem, method ``A.foo`` from our previous example was annotated with a ``@throws RuntimeException`` tag. Our current version of ``mayThrow``, however, would think that ``A.foo`` can't throw a ``RuntimeException``, and thus flag the tag as spurious.

We can make ``mayThrow`` less restrictive by introducing a new class to represent unchecked exceptions, which are just the subtypes of ``java.lang.RuntimeException`` and ``java.lang.Error``:

.. code-block:: ql

   class UncheckedException extends RefType {
       UncheckedException() {
           this.getASupertype*().hasQualifiedName("java.lang", "RuntimeException") or
           this.getASupertype*().hasQualifiedName("java.lang", "Error")
       }
   }

Now we incorporate this new class into our ``mayThrow`` predicate:

.. code-block:: ql

   predicate mayThrow(Callable c, RefType exn) {
       exn instanceof UncheckedException or
       exn.getASupertype*() = c.getAnException().getType()
   }

Fixing ``getDocumentedException`` is more complicated, but we can easily cover three common cases:

#. The ``@throws`` tag specifies the fully qualified name of the exception.
#. The ``@throws`` tag refers to a type in the same package.
#. The ``@throws`` tag refers to a type that is imported by the current compilation unit.

The first case can be covered by changing ``getDocumentedException`` to use the qualified name of the ``@throws`` tag. To handle the second and the third case, we can introduce a new predicate ``visibleIn`` that checks whether a reference type is visible in a compilation unit, either by virtue of belonging to the same package or by being explicitly imported. We then rewrite ``getDocumentedException`` as:

.. code-block:: ql

   predicate visibleIn(CompilationUnit cu, RefType tp) {
       cu.getPackage() = tp.getPackage()
       or
       exists(ImportType it | it.getCompilationUnit() = cu | it.getImportedType() = tp)
   }

   RefType getDocumentedException(ThrowsTag tt) {
       result.getQualifiedName() = tt.getExceptionName()
       or
       (result.hasName(tt.getExceptionName()) and visibleIn(tt.getFile(), result))
   }

This query should find many fewer, more interesting results.

Currently, ``visibleIn`` only considers single-type imports, but you could extend it with support for other kinds of imports.

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/modeling-data-flow-in-go-libraries.rst
.. _modeling-data-flow-in-go-libraries:

Modeling data flow in Go libraries
==================================

When analyzing a Go program, CodeQL does not examine the source code for
external packages. To track the flow of untrusted data through a library, you
can create a model of the library.

You can find existing models in the ``go/ql/lib/semmle/go/frameworks/`` folder of the
`CodeQL repository <https://github.com/github/codeql/tree/main/go/ql/lib/semmle/go/frameworks>`__.
To add a new model, you should make a new file in that folder, named after the library.

Sources
-------

To mark a source of data that is controlled by an untrusted user, we
create a class extending ``RemoteFlowSource::Range``. Inheritance and
the characteristic predicate of the class should be used to specify
exactly the dataflow node that introduces the data. Here is a short
example from ``Mux.qll``.

.. code-block:: ql

   class RequestVars extends DataFlow::RemoteFlowSource::Range, DataFlow::CallNode {
     RequestVars() { this.getTarget().hasQualifiedName("github.com/gorilla/mux", "Vars") }
   }

This has the effect that all calls to `the function Vars from the
package mux <https://github.com/gorilla/mux>`__ are
treated as sources of untrusted data.

Flow propagation
----------------

By default, we assume that all functions in libraries do not have
any data flow. To indicate that a particular function does have data flow,
create a class extending ``TaintTracking::FunctionModel`` (or
``DataFlow::FunctionModel`` if the untrusted user data is passed on
without being modified).

Inheritance and the characteristic predicate of the class should specify
the function. The class should also have a member predicate with the signature
``override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp)``
(or
``override predicate hasDataFlow(FunctionInput inp, FunctionOutput outp)``
if extending ``DataFlow::FunctionModel``). The body should constrain
``inp`` and ``outp``.

``FunctionInput`` is an abstract representation of the inputs to a
function. The options are:

* the receiver (``inp.isReceiver()``)
* one of the parameters (``inp.isParameter(i)``)
* one of the results (``inp.isResult(i)``, or ``inp.isResult`` if there is only one result)

Note that it may seem strange that the result of a function could be
considered as a function input, but it is needed in some cases. For
instance, the function ``bufio.NewWriter`` returns a writer ``bw`` that
buffers write operations to an underlying writer ``w``. If tainted data
is written to ``bw``, then it makes sense to propagate that taint back
to the underlying writer ``w``, which can be modeled by saying that
``bufio.NewWriter`` propagates taint from its result to its first
argument.

Similarly, ``FunctionOutput`` is an abstract representation of the
outputs to a function. The options are:

* the receiver (``outp.isReceiver()``)
* one of the parameters (``outp.isParameter(i)``)
* one of the results (``outp.isResult(i)``, or ``outp.isResult`` if there is only one result)

Here is an example from ``Gin.qll``, which has been slightly simplified.

.. code-block:: ql

   private class ParamsGet extends TaintTracking::FunctionModel, Method {
     ParamsGet() { this.hasQualifiedName("github.com/gin-gonic/gin", "Params", "Get") }

     override predicate hasTaintFlow(FunctionInput inp, FunctionOutput outp) {
       inp.isReceiver() and outp.isResult(0)
     }
   }

This has the effect that calls to the ``Get`` method with receiver type
``Params`` from the ``gin-gonic/gin`` package allow taint to flow from
the receiver to the first result. In other words, if ``p`` has type
``Params`` and taint can flow to it, then after the line
``x := p.Get("foo")`` taint can also flow to ``x``.

Sanitizers
----------

It is not necessary to indicate that library functions are sanitizers.
Their bodies are not analyzed, so it is assumed that data does not
flow through them.

Sinks
-----

Data-flow sinks are specified by queries rather than by library models.
However, you can use library models to indicate when functions belong to
special categories. Queries can then use these categories when specifying
sinks. Classes representing these special categories are contained in
``go/ql/lib/semmle/go/Concepts.qll`` in the `CodeQL repository
<https://github.com/github/codeql/blob/main/go/ql/lib/semmle/go/Concepts.qll>`__.
``Concepts.qll`` includes classes for logger mechanisms,
HTTP response writers, HTTP redirects, and marshaling and unmarshaling
functions.

Here is a short example from ``Stdlib.qll``, which has been slightly simplified.

.. code-block:: ql

   private class PrintfCall extends LoggerCall::Range, DataFlow::CallNode {
     PrintfCall() { this.getTarget().hasQualifiedName("fmt", ["Print", "Printf", "Println"]) }

     override DataFlow::Node getAMessageComponent() { result = this.getAnArgument() }
   }

This has the effect that any call to ``Print``, ``Printf``, or
``Println`` in the package ``fmt`` is recognized as a logger call.
Any query that uses logger calls as a sink will then identify when tainted data 
has been passed as an argument to ``Print``, ``Printf``, or ``Println``.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/refining-a-query-to-account-for-edge-cases.rst
.. _refining-a-query-to-account-for-edge-cases:

Refining a query to account for edge cases
==========================================

You can improve the results generated by a CodeQL query by adding conditions to remove false positive results caused by common edge cases.

Overview
--------

This topic describes how a C++ query was developed. The example introduces recursive predicates and demonstrates the typical workflow used to refine a query. For a full overview of the topics available for learning to write queries for C/C++ code, see ":ref:`CodeQL for C and C++ <codeql-for-cpp>`."

Finding every private field and checking for initialization
-----------------------------------------------------------

Writing a query to check if a constructor initializes all private fields seems like a simple problem, but there are several edge cases to account for.

Basic query
-----------

We can start by looking at every private field in a class and checking that every constructor in that class initializes them. Once you are familiar with the library for C++ this is not too hard to do.

.. code-block:: ql

   import cpp

   from Constructor c, Field f
   where f.getDeclaringType() = c.getDeclaringType() and f.isPrivate() 
       and not exists(Assignment a | a = f.getAnAssignment() and a.getEnclosingFunction() = c)
   select c, "Constructor does not initialize fields $@.", f, f.getName()

#. ``f.getDeclaringType() = c.getDeclaringType()`` asserts that the field and constructor are both part of the same class.
#. ``f.isPrivate()`` checks if the field is private.
#. ``not exists(Assignment a | a = f.getAnAssignment() and a.getEnclosingFunction() = c)`` checks that there is no assignment to the field in the constructor.

This code looks fairly complete, but when you test it on a project, there are several results that contain examples that we have overlooked.

Refinement 1—excluding fields initialized by lists
--------------------------------------------------

You may see that the results contain fields that are initialized by constructor initialization lists, instead of by assignment statements. For example, the following class:

.. code-block:: cpp

   class BoxedInt {
   public:
     BoxedInt(int value) : m_value(value) {}

   private:
     int m_value;
   };

These can be excluded by adding an extra condition to check for this special constructor-only form of assignment.

.. code-block:: ql

   import cpp

   from Constructor c, Field f
   where f.getDeclaringType() = c.getDeclaringType() and f.isPrivate() 
       and not exists(Assignment a | a = f.getAnAssignment() and a.getEnclosingFunction() = c)
       // check for constructor initialization lists as well
       and not exists(ConstructorFieldInit i | i.getTarget() = f and i.getEnclosingFunction() = c)
   select c, "Constructor does not initialize fields $@.", f, f.getName()

Refinement 2—excluding fields initialized by external libraries
---------------------------------------------------------------

When you test the revised query, you may discover that fields from classes in external libraries are over-reported. This is often because a header file declares a constructor that is defined in a source file that is not analyzed (external libraries are often excluded from analysis). When the source code is analyzed, the CodeQL database is populated with a ``Constructor`` entry with no body. This ``constructor`` therefore contains no assignments and consequently the query reports that any fields initialized by the constructor are "uninitialized." There is no particular reason to be suspicious of these cases, and we can exclude them from the results by defining a condition to exclude constructors that have no body:

.. code-block:: ql

   import cpp

   from Constructor c, Field f
   where f.getDeclaringType() = c.getDeclaringType() and f.isPrivate() 
       and not exists(Assignment a | a = f.getAnAssignment() and a.getEnclosingFunction() = c)
       // check for constructor initialization lists as well
       and not exists(ConstructorFieldInit i | i.getTarget() = f and i.getEnclosingFunction() = c)
       // ignore cases where the constructor source code is not available
       and exists(c.getBlock())
   select c, "Constructor does not initialize fields $@.", f, f.getName()

This is a reasonably precise query—most of the results that it reports are interesting. However, you could make further refinements.

Refinement 3—excluding fields initialized indirectly
----------------------------------------------------

You may also wish to consider methods called by constructors that assign to the fields, or even to the methods called by those methods. As a concrete example of this, consider the following class.

.. code-block:: cpp

   class BoxedInt {
   public:
     BoxedInt(int value) {
       setValue(value);
     }

     void setValue(int value) {
       m_value = value;
     }

   private:
     int m_value;
   };

This case can be excluded by creating a recursive predicate. The recursive predicate is given a function and a field, then checks whether the function assigns to the field. The predicate runs itself on all the functions called by the function that it has been given. By passing the constructor to this predicate, we can check for assignments of a field in all functions called by the constructor, and then do the same for all functions called by those functions all the way down the tree of function calls. For more information, see ":ref:`Recursion <recursion>`" in the QL language reference.

.. code-block:: ql

   import cpp

   predicate getSubAssignment(Function c, Field f){
       exists(Assignment a | a = f.getAnAssignment() and a.getEnclosingFunction() = c)
       or exists(Function fun | c.calls(fun) and getSubAssignment(fun, f))
   }
   from Constructor c, Field f
   where f.getDeclaringType() = c.getDeclaringType() and f.isPrivate()
       // check for constructor initialization lists as well
       and not exists(ConstructorFieldInit i | i.getTarget() = f and i.getEnclosingFunction() = c)
       // check for initializations performed indirectly by methods called
       // as a result of the constructor being called
       and not getSubAssignment(c, f)
       // ignore cases where the constructor source code is not available
       and exists(c.getBlock())
   select c, "Constructor does not initialize fields $@.", f, f.getName()

Refinement 4—simplifying the query
----------------------------------

Finally we can simplify the query by using the transitive closure operator. In this final version of the query, ``c.calls*(fun)`` resolves to the set of all functions that are ``c`` itself, are called by ``c``, are called by a function that is called by ``c``, and so on. This eliminates the need to make a new predicate all together. For more information, see ":ref:`Transitive closures <transitive-closures>`" in the QL language reference.

.. code-block:: ql

   import cpp

   from Constructor c, Field f
   where f.getDeclaringType() = c.getDeclaringType() and f.isPrivate() 
       // check for constructor initialization lists as well
       and not exists(ConstructorFieldInit i | i.getTarget() = f and i.getEnclosingFunction() = c)
       // check for initializations performed indirectly by methods called
       // as a result of the constructor being called
       and not exists(Function fun, Assignment a |
         c.calls*(fun) and a = f.getAnAssignment() and a.getEnclosingFunction() = fun)
       // ignore cases where the constructor source code is not available
       and exists(c.getBlock())
   select c, "Constructor does not initialize fields $@.", f, f.getName()

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-javascript-code.rst
.. _basic-query-for-javascript-code:

Basic query for JavaScript and TypeScript code
===============================================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

In JavaScript and TypeScript, any expression can be turned into an expression statement. While this is sometimes convenient, it can be dangerous. For example, imagine a programmer wants to assign a new value to a variable ``x`` by means of an assignment ``x = 42``. However, they accidentally type two equals signs, producing the comparison statement ``x == 42``. This is valid JavaScript, so no error is generated. The statement simply compares ``x`` to ``42``, and then discards the result of the comparison.

The query you will run finds instances of this problem. The query searches for expressions ``e`` that are pure—that is, their evaluation does not lead to any side effects—but appear as an expression statement.

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete ``select ""`` and paste the following query beneath the import statement ``import javascript``.

   .. code-block:: ql

      from Expr e
      where e.isPure() and
        e.getParent() instanceof ExprStmt
      select e, "This expression has no effect."

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-js-query-results-1.png
   :align: center

If any matching code is found, click one of the links in the ``e`` column to open the file and highlight the matching expression.

.. image:: ../images/codeql-for-visual-studio-code/basic-js-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| Query part                                                    | Purpose                                                                                                           | Details                                                                                                                |
+===============================================================+===================================================================================================================+========================================================================================================================+
| ``import javascript``                                         | Imports the standard CodeQL libraries for JavaScript and TypeScript.                                              | Every query begins with one or more ``import`` statements.                                                             |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``from Expr e``                                               | Defines the variables for the query.                                                                              | ``e`` is declared as a variable that ranges over expressions.                                                          |
|                                                               | Declarations are of the form:                                                                                     |                                                                                                                        |
|                                                               | ``<type> <variable name>``                                                                                        |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``where e.isPure() and e.getParent() instanceof ExprStmt``    | Defines a condition on the variables.                                                                             | ``e.isPure()``: The expression is side-effect-free.                                                                    |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               |                                                                                                                   | ``e.getParent() instanceof ExprStmt``: The parent of the expression is an expression statement.                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``select e, "This expression has no effect."``                | Defines what to report for each match.                                                                            | Report the expression with a string that explains the problem.                                                         |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                                        |
|                                                               | ``select <program element>, "<alert message>"``                                                                   |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find ``use strict`` directives. These are interpreted specially by modern browsers with strict mode support and so these expressions *do* have an effect.

To remove directives from the results:

#. Extend the ``where`` clause to include the following extra condition:

   .. code-block:: ql

      and not e.getParent() instanceof Directive

   The ``where`` clause is now:

   .. code-block:: ql

      where e.isPure() and
        e.getParent() instanceof ExprStmt and 
        not e.getParent() instanceof Directive

#. Re-run the query.

   There are now fewer results as ``use strict`` directives are no longer reported.

The improved query finds several results on the example project including the result below:

.. image:: ../images/codeql-for-visual-studio-code/basic-js-query-results-1.png
   :align: center

.. code-block:: javascript

   point.bias == -1;

As written, this statement compares ``point.bias`` against ``-1`` and then discards the result. Most likely, it was instead meant to be an assignment ``point.bias = -1``.

Further reading
---------------

.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: JavaScript/TypeScript

.. |language-code| replace:: ``javascript``

.. |example-url| replace:: https://github.com/ajaxorg/ace

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-js.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``e`` and is linked to the location in the source code of the project where ``e`` occurs.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-go.rst
.. _codeql-library-for-go:

CodeQL library for Go
=====================

When you're analyzing a Go program, you can make use of the large collection of classes in the CodeQL library for Go.

Overview
--------

CodeQL ships with an extensive library for analyzing Go code.  The classes in this library present
the data from a CodeQL database in an object-oriented form and provide abstractions and predicates
to help you with common analysis tasks.

The library is implemented as a set of QL modules, that is, files with the extension ``.qll``. The
module ``go.qll`` imports most other standard library modules, so you can include the complete
library by beginning your query with:

.. code-block:: ql

   import go

Broadly speaking, the CodeQL library for Go provides two views of a Go code base: at the `syntactic
level`, source code is represented as an `abstract syntax tree
<https://en.wikipedia.org/wiki/Abstract_syntax_tree>`__ (AST), while at the `data-flow level` it is
represented as a `data-flow graph <https://en.wikipedia.org/wiki/Data-flow_analysis>`__ (DFG). In
between, there is also an intermediate representation of the program as a control-flow graph (CFG),
though this representation is rarely useful on its own and mostly used to construct the higher-level
DFG representation.

The AST representation captures the syntactic structure of the program. You can use it to reason
about syntactic properties such as the nesting of statements within each other, but also about the
types of expressions and which variable a name refers to.

The DFG, on the other hand, provides an approximation of how data flows through variables and
operations at runtime. It is used, for example, by the security queries to model the way
user-controlled input can propagate through the program. Additionally, the DFG contains information
about which function may be invoked by a given call (taking virtual dispatch through interfaces into
account), as well as control-flow information about the order in which different operations may be
executed at runtime.

As a rule of thumb, you normally want to use the AST only for superficial syntactic queries. Any
analysis involving deeper semantic properties of the program should be done on the DFG.

The rest of this tutorial briefly summarizes the most important classes and predicates provided by
this library, including references to the `detailed API documentation
<https://codeql.github.com/codeql-standard-libraries/go/>`__ where applicable. We start by giving an overview of the AST
representation, followed by an explanation of names and entities, which are used to represent
name-binding information, and of types and type information. Then we move on to control flow and the
data-flow graph, and finally the call graph and a few advanced topics.

Abstract syntax
---------------

The AST presents the program as a hierarchical structure of nodes, each of which corresponds to a
syntactic element of the program source text. For example, there is an AST node for each expression
and each statement in the program. These AST nodes are arranged into a parent-child relationship
reflecting the nesting of syntactic elements and the order in which inner elements appear in
enclosing ones.

For example, this is the AST for the expression ``(x + y) * z``:

|ast|

It is composed of six AST nodes, representing ``x``, ``y``, ``x + y``, ``(x + y)``, ``z`` and the
entire expression ``(x + y) * z``, respectively. The AST nodes representing ``x`` and ``y`` are
children of the AST node representing ``x + y``, ``x`` being the zeroth child and ``y`` being the
first child, reflecting their order in the program text. Similarly, ``x + y`` is the only child of
``(x + y)``, which is the zeroth child of ``(x + y) * z``, whose first child is ``z``.

All AST nodes belong to class `AstNode
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/AST.qll/type.AST$AstNode.html>`__, which defines generic
tree traversal predicates:

-  ``getChild(i)``: returns the ``i``\ th child of this AST node.
-  ``getAChild()``: returns any child of this AST node.
-  ``getParent()``: returns the parent node of this AST node, if any.

These predicates should only be used to perform generic AST traversal. To access children of
specific AST node types, the specialized predicates introduced below should be used instead. In
particular, queries should not rely on the numeric indices of child nodes relative to their parent
nodes: these are considered an implementation detail that may change between versions of the
library.

The predicate ``toString()`` in class ``AstNode`` nodes gives a short description of the AST node,
usually just indicating what kind of node it is. The ``toString()`` predicate does `not` provide
access to the source text corresponding to an AST node. The source text is not stored in the
dataset, and hence is not directly accessible to CodeQL queries.

The predicate ``getLocation()`` in class ``AstNode`` returns a `Location
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Locations.qll/type.Locations$Location.html>`__ entity
describing the source location of the program element represented by the AST node. You can use its
member predicates ``getFile()``, ``getStartLine()``, ``getStartColumn``, ``getEndLine()``, and
``getEndColumn()`` to obtain information about its file, start line and column, and end line and
column.

The most important subclasses of `AstNode
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/AST.qll/type.AST$AstNode.html>`__ are `Stmt
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$Stmt.html>`__ and `Expr
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$Expr.html>`__, which represent
statements and expressions, respectively. This section briefly discusses some of their more
important subclasses and predicates. For a full reference of all the subclasses of `Stmt
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$Stmt.html>`__ and `Expr
<https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$Expr.html>`__, see
:doc:`Abstract syntax tree classes for Go <abstract-syntax-tree-classes-for-working-with-go-programs>`.

Statements
~~~~~~~~~~

- ``ExprStmt``: an expression statement; use ``getExpr()`` to access the expression itself
- ``Assignment``: an assignment statement; use ``getLhs(i)`` to access the ``i``\ th left-hand side
  and ``getRhs(i)`` to access the ``i``\ th right-hand side; if there is only a single left-hand side
  you can use ``getLhs()`` instead, and similar for the right-hand side

  - ``SimpleAssignStmt``: an assignment statement that does not involve a compound operator

    - ``AssignStmt``: a plain assignment statement of the form ``lhs = rhs``
    - ``DefineStmt``: a short-hand variable declaration of the form ``lhs := rhs``

  - ``CompoundAssignStmt``: an assignment statement with a compound operator, such as ``lhs += rhs``

- ``IncStmt``, ``DecStmt``: an increment statement or a decrement statement, respectively; use
  ``getOperand()`` to access the expression being incremented or decremented
- ``BlockStmt``: a block of statements between curly braces; use ``getStmt(i)`` to access the
  ``i``\ th statement in a block
- ``IfStmt``: an ``if`` statement; use ``getInit()``, ``getCond()``, ``getThen()``, and
  ``getElse()`` to access the (optional) init statement, the condition being checked, the "then"
  branch to evaluate if the condition is true, and the (optional) "else" branch to evaluate
  otherwise, respectively
- ``LoopStmt``: a loop; use ``getBody()`` to access its body

  - ``ForStmt``: a ``for`` statement; use ``getInit()``, ``getCond()``, and ``getPost()`` to access
    the init statement, loop condition, and post statement, respectively, all of which are optional

  - ``RangeStmt``: a ``range`` statement; use ``getDomain()`` to access the iteration domain, and
    ``getKey()`` and ``getValue()`` to access the expressions to which successive keys and values
    are assigned, if any

- ``GoStmt``: a ``go`` statement; use ``getCall()`` to access the call expression that is evaluated
  in the new goroutine
- ``DeferStmt``: a ``defer`` statement; use ``getCall()`` to access the call expression being
  deferred
- ``SendStmt``: a send statement; use ``getChannel()`` and ``getValue()`` to access the channel and
  the value being sent over the channel, respectively
- ``ReturnStmt``: a ``return`` statement; use ``getExpr(i)`` to access the ``i``\ th returned
  expression; if there is only a single returned expression you can use ``getExpr()`` instead
- ``BranchStmt``: a statement that interrupts structured control flow; use ``getLabel()`` to get the
  optional target label

  - ``BreakStmt``: a ``break`` statement
  - ``ContinueStmt``: a ``continue`` statement
  - ``FallthroughStmt``: a ``fallthrough`` statement at the end of a switch case
  - ``GotoStmt``: a ``goto`` statement

- ``DeclStmt``: a declaration statement, use ``getDecl()`` to access the declaration in this
  statement; note that one rarely needs to deal with declaration statements directly, since
  reasoning about the entities they declare is usually easier
- ``SwitchStmt``: a ``switch`` statement; use ``getInit()`` to access the (optional) init statement,
  and ``getCase(i)`` to access the ``i``\ th ``case`` or ``default`` clause

  - ``ExpressionSwitchStmt``: a ``switch`` statement examining the value of an expression
  - ``TypeSwitchStmt``: a ``switch`` statement examining the type of an expression

- ``CaseClause``: a ``case`` or ``default`` clause in a ``switch`` statement; use ``getExpr(i)`` to
  access the ``i``\ th expression, and ``getStmt(i)`` to access the ``i``\ th statement in the body
  of this clause
- ``SelectStmt``: a ``select`` statement; use ``getCommClause(i)`` to access the ``i``\ th ``case``
  or ``default`` clause
- ``CommClause``: a ``case`` or ``default`` clause in a ``select`` statement; use ``getComm()`` to
  access the send/receive statement of this clause (not defined for ``default`` clauses), and
  ``getStmt(i)`` to access the ``i``\ th statement in the body of this clause
- ``RecvStmt``: a receive statement in a ``case`` clause of a ``select`` statement; use
  ``getLhs(i)`` to access the ``i``\ th left-hand side of this statement, and ``getExpr()`` to
  access the underlying receive expression

Expressions
~~~~~~~~~~~

Class ``Expression`` has a predicate ``isConst()`` that holds if the expression is a compile-time
constant. For such constant expressions, ``getNumericValue()`` and ``getStringValue()`` can be used
to determine their numeric value and string value, respectively. Note that these predicates are not
defined for expressions whose value cannot be determined at compile time. Also note that the result
type of ``getNumericValue()`` is the QL type ``float``. If an expression has a numeric value that
cannot be represented as a QL ``float``, this predicate is also not defined. In such cases, you can
use ``getExactValue()`` to obtain a string representation of the value of the constant.

- ``Ident``: an identifier; use ``getName()`` to access its name
- ``SelectorExpr``: a selector of the form ``base.sel``; use ``getBase()`` to access the part before
  the dot, and ``getSelector()`` for the identifier after the dot
- ``BasicLit``: a literal of a basic type; subclasses ``IntLit``, ``FloatLit``, ``ImagLit``,
  ``RuneLit``, and ``StringLit`` represent various specific kinds of literals
- ``FuncLit``: a function literal; use ``getBody()`` to access the body of the function
- ``CompositeLit``: a composite literal; use ``getKey(i)`` and ``getValue(i)`` to access the
  ``i``\ th key and the ``i``\ th value, respectively
- ``ParenExpr``: a parenthesized expression; use ``getExpr()`` to access the expression between the
  parentheses
- ``IndexExpr``: an index expression ``base[idx]``; use ``getBase()`` and ``getIndex()`` to access
  ``base`` and ``idx``, respectively
- ``SliceExpr``: a slice expression ``base[lo:hi:max]``; use ``getBase()``, ``getLow()``,
  ``getHigh()``, and ``getMax()`` to access ``base``, ``lo``, ``hi``, and ``max``, respectively;
  note that ``lo``, ``hi``, and ``max`` can be omitted, in which case the corresponding predicates are not defined
- ``ConversionExpr``: a conversion expression ``T(e)``; use ``getTypeExpr()`` and ``getOperand()``
  to access ``T`` and ``e``, respectively
- ``TypeAssertExpr``: a type assertion ``e.(T)``; use ``getExpr()`` and ``getTypeExpr()`` to access
  ``e`` and ``T``, respectively
- ``CallExpr``: a call expression ``callee(arg0, ..., argn)``; use ``getCalleeExpr()`` to access
  ``callee``, and ``getArg(i)`` to access the ``i``\ th argument
- ``StarExpr``: a star expression, which may be either a pointer-type expression or a
  pointer-dereference expression, depending on context; use ``getBase()`` to access the operand of
  the star
- ``TypeExpr``: an expression that denotes a type
- ``OperatorExpr``: an expression with a unary or binary operator; use ``getOperator()`` to access
  the operator

  - ``UnaryExpr``: an expression with a unary operator; use ``getAnOperand()`` to access the operand
    of the operator
  - ``BinaryExpr``: an expression with a binary operator; use ``getLeftOperand()`` and
    ``getRightOperand()`` to access the left and the right operand, respectively

    - ``ComparisonExpr``: a binary expression that performs a comparison, including both equality
      tests and relational comparisons

      - ``EqualityTestExpr``: an equality test, that is, either ``==`` or ``!=``; the predicate
        ``getPolarity()`` has result ``true`` for the former and ``false`` for the latter
      - ``RelationalComparisonExpr``: a relational comparison; use ``getLesserOperand()`` and
        ``getGreaterOperand()`` to access the lesser and greater operand of the comparison,
        respectively; ``isStrict()`` holds if this is a strict comparison using ``<`` or ``>``,
        as opposed to ``<=`` or ``>=``

Names
~~~~~

While ``Ident`` and ``SelectorExpr`` are very useful classes, they are often too general: ``Ident``
covers all identifiers in a program, including both identifiers appearing in a declaration as well
as references, and does not distinguish between names referring to packages, types, variables,
constants, functions, or statement labels. Similarly, a ``SelectorExpr`` might refer to a package, a
type, a function, or a method.

Class ``Name`` and its subclasses provide a more fine-grained mapping of this space, organized along
the two axes of structure and namespace. In terms of structure, a name can be a ``SimpleName``,
meaning that it is a simple identifier (and hence an ``Ident``), or it can be a ``QualifiedName``,
meaning that it is a qualified identifier (and hence a ``SelectorExpr``). In terms of namespacing, a
``Name`` can be a ``PackageName``, ``TypeName``, ``ValueName``, or ``LabelName``. A ``ValueName``,
in turn, can be either a ``ConstantName``, a ``VariableName``, or a ``FunctionName``, depending on
what sort of entity the name refers to.

A related abstraction is provided by class ``ReferenceExpr``: a reference expression is an
expression that refers to a variable, a constant, a function, a field, or an element of an array or
a slice. Use predicates ``isLvalue()`` and ``isRvalue()`` to determine whether a reference
expression appears in a syntactic context where it is assigned to or read from, respectively.

Finally, ``ValueExpr`` generalizes ``ReferenceExpr`` to include all other kinds of expressions that
can be evaluated to a value (as opposed to expressions that refer to a package, a type, or a
statement label).

Functions
~~~~~~~~~

At the syntactic level, functions appear in two forms: in function declarations (represented by
class ``FuncDecl``) and as function literals (represented by class ``FuncLit``). Since it is often
convenient to reason about functions of either kind, these two classes share a common superclass
``FuncDef``, which defines a few useful member predicates:

  - ``getBody()`` provides access to the function body
  - ``getName()`` gets the function name; it is undefined for function literals, which do not have a
    name
  - ``getParameter(i)`` gets the ``i``\ th parameter of the function
  - ``getResultVar(i)`` gets the ``i``\ th result variable of the function; if there is only
    one result, ``getResultVar()`` can be used to access it
  - ``getACall()`` gets a data-flow node (see below) representing a call to this function

Entities and name binding
-------------------------

Not all elements of a code base can be represented as AST nodes. For example, functions defined in
the standard library or in a dependency do not have a source-level definition within the source code
of the program itself, and built-in functions like ``len`` do not have a definition at all. Hence
functions cannot simply be identified with their definition, and similarly for variables, types,
and so on.

To smooth over this difference and provide a unified view of functions no matter where they are
defined, the Go library introduces the concept of an `entity`. An entity is a named program element,
that is, a package, a type, a constant, a variable, a field, a function, or a label. All entities
belong to class ``Entity``, which defines a few useful predicates:

  - ``getName()`` gets the name of the entity
  - ``hasQualifiedName(pkg, n)`` holds if this entity is declared in package ``pkg`` and has name
    ``n``; this predicate is only defined for types, functions, and package-level variables and
    constants (but not for methods or local variables)
  - ``getDeclaration()`` connects an entity to its declaring identifier, if any
  - ``getAReference()`` gets a ``Name`` that refers to this entity

Conversely, class ``Name`` defines a predicate ``getTarget()`` that gets the entity to which the
name refers.

Class ``Entity`` has several subclasses representing specific kinds of entities: ``PackageEntity``
for packages; ``TypeEntity`` for types; ``ValueEntity`` for constants (``Constant``), variables
(``Variable``), and functions (``Function``); and ``Label`` for statement labels.

Class ``Variable``, in turn, has a few subclasses representing specific kinds of variables: a
``LocalVariable`` is a variable declared in a local scope, that is, not at package level;
``ReceiverVariable``, ``Parameter`` and ``ResultVariable`` describe receivers, parameters and
results, respectively, and define a predicate ``getFunction()`` to access the corresponding
function. Finally, class ``Field`` represents struct fields, and provides a member predicate
``hasQualifiedName(pkg, tp, f)`` that holds if this field has name ``f`` and belongs to type ``tp``
in package ``pkg``. (Note that due to embedding the same field can belong to multiple types.)

Class ``Function`` has a subclass ``Method`` representing methods (including both interface methods
and methods defined on a named type). Similar to ``Field``, ``Method`` provides a member predicate
``hasQualifiedName(pkg, tp, m)`` that holds if this method has name ``m`` and belongs to type ``tp``
in package ``pkg``. Predicate ``implements(m2)`` holds if this method implements method ``m2``, that
is, it has the same name and signature as ``m2`` and it belongs to a type that implements the
interface to which ``m2`` belongs. For any function, ``getACall()`` provides access to call sites
that may call this function, possibly through virtual dispatch.

Finally, module ``Builtin`` provides a convenient way of looking up the entities corresponding to
built-in functions and types. For example, ``Builtin::len()`` is the entity representing the
built-in function ``len``, ``Builtin::bool()`` is the ``bool`` type, and ``Builtin::nil()`` is the
value ``nil``.

Type information
----------------

Types are represented by class ``Type`` and its subclasses, such as ``BoolType`` for the built-in
type ``bool``; ``NumericType`` for the various numeric types including ``IntType``, ``Uint8Type``,
``Float64Type`` and others; ``StringType`` for the type ``string``; ``NamedType``, ``ArrayType``,
``SliceType``, ``StructType``, ``InterfaceType``, ``PointerType``, ``MapType``, ``ChanType`` for
named types, arrays, slices, structs, interfaces, pointers, maps, and channels, respectively.
Finally, ``SignatureType`` represents function types.

Note that the type ``BoolType`` is distinct from the entity ``Builtin::bool()``: the latter views
``bool`` as a declared entity, the former as a type. You can, however, map from types to their
corresponding entity (if any) using the predicate ``getEntity()``.

Class ``Expr`` and class ``Entity`` both define a predicate ``getType()`` to determine the type of
an expression or entity. If the type of an expression or entity cannot be determined (for example
because some dependency could not be found during extraction), it will be associated with an invalid
type of class ``InvalidType``.

Control flow
------------

Most CodeQL query writers will rarely use the control-flow representation of a program directly, but
it is nevertheless useful to understand how it works.

Unlike the abstract syntax tree, which views the program as a hierarchy of AST nodes, the
control-flow graph views it as a collection of `control-flow nodes`, each representing a single
operation performed at runtime. These nodes are connected to each other by (directed) edges
representing the order in which operations are performed.

For example, consider the following code snippet:

.. code-block:: go

  x := 0
  if p != nil {
    x = p.f
  }
  return x

In the AST, this is represented as an ``IfStmt`` and a ``ReturnStmt``, with the former having an
``NeqExpr`` and a ``BlockStmt`` as its children, and so on. This provides a very detailed picture of
the syntactic structure of the code, but it does not immediately help us reason about the order
in which the various operations such as the comparison and the assignment are performed.

In the CFG, there are nodes corresponding to ``x := 0``, ``p != nil``, ``x = p.f``, and ``return
x``, as well as a few others. The edges between these nodes model the possible execution orders of
these statements and expressions, and look as follows (simplified somewhat for presentational
purposes):

|cfg|

For example, the edge from ``p != nil`` to ``x = p.f`` models the case where the comparison
evaluates to ``true`` and the "then" branch is evaluated, while the edge from ``p != nil`` to
``return x`` models the case where the comparison evaluates to ``false`` and the "then" branch is
skipped.

Note, in particular, that a CFG node can have multiple outgoing edges (like from ``p != nil``) as
well as multiple incoming edges (like into ``return x``) to represent control-flow branching at
runtime.

Also note that only AST nodes that perform some kind of operation on values have a corresponding CFG
node. This includes expressions (such as the comparison ``p != nil``), assignment statements (such
as ``x = p.f``) and return statements (such as ``return x``), but not statements that serve a purely
syntactic purpose (such as block statements) and statements whose semantics is already reflected by
the CFG edges (such as ``if`` statements).

It is important to point out that the control-flow graph provided by the CodeQL libraries for Go
only models `local` control flow, that is, flow within a single function. Flow from function calls
to the function they invoke, for example, is not represented by control-flow edges.

In CodeQL, control-flow nodes are represented by class ``ControlFlow::Node``, and the edges between
nodes are captured by the member predicates ``getASuccessor()`` and ``getAPredecessor()`` of
``ControlFlow::Node``. In addition to control-flow nodes representing runtime operations, each
function also has a synthetic entry node and an exit node, representing the start and end of an
execution of the function, respectively. These exist to ensure that the control-flow graph
corresponding to a function has a unique entry node and a unique exit node, which is required for
many standard control-flow analysis algorithms.

Data flow
---------

At the data-flow level, the program is thought of as a collection of `data-flow nodes`. These nodes
are connected to each other by (directed) edges representing the way data flows through the program
at runtime.

For example, there are data-flow nodes corresponding to expressions and other data-flow nodes
corresponding to variables (`SSA variables
<https://en.wikipedia.org/wiki/Static_single_assignment_form>`__, to be precise). Here is the
data-flow graph corresponding to the code snippet shown above, ignoring SSA conversion for
simplicity:

|dfg|

Note that unlike in the control-flow graph, the assignments ``x := 0`` and ``x = p.f`` are not
represented as nodes. Instead, they are expressed as edges between the node representing the
right-hand side of the assignment and the node representing the variable on the left-hand side. For
any subsequent uses of that variable, there is a data-flow edge from the variable to that use, so by
following the edges in the data-flow graph we can trace the flow of values through variables at
runtime.

It is important to point out that the data-flow graph provided by the CodeQL libraries for Go only
models `local` flow, that is, flow within a single function. Flow from arguments in a function call
to the corresponding function parameters, for example, is not represented by data-flow edges.

In CodeQL, data-flow nodes are represented by class ``DataFlow::Node``, and the edges between nodes
are captured by the predicate ``DataFlow::localFlowStep``. The predicate ``DataFlow::localFlow``
generalizes this from a single flow step to zero or more flow steps.

Most expressions have a corresponding data-flow node; exceptions include type expressions, statement
labels and other expressions that do not have a value, as well as short-circuiting operators. To map
from the AST node of an expression to the corresponding DFG node, use ``DataFlow::exprNode``. Note
that the AST node and the DFG node are different entities and cannot be used interchangeably.

There is also a predicate ``asExpr()`` on ``DataFlow::Node`` that allows you to recover the
expression underlying a DFG node. However, this predicate should be used with caution, since many
data-flow nodes do not correspond to an expression, and so this predicate will not be defined for
them.

Similar to ``Expr``, ``DataFlow::Node`` has a member predicate ``getType()`` to determine the type
of a node, as well as predicates ``getNumericValue()``, ``getStringValue()``, and
``getExactValue()`` to retrieve the value of a node if it is constant.

Important subclasses of ``DataFlow::Node`` include:

  - ``DataFlow::CallNode``: a function call or method call; use ``getArgument(i)`` and
    ``getResult(i)`` to obtain the data-flow nodes corresponding to the ``i``\ th argument and the
    ``i``\ th result of this call, respectively; if there is only a single result, ``getResult()``
    will return it
  - ``DataFlow::ParameterNode``: a parameter of a function; use ``asParameter()`` to access the
    corresponding AST node
  - ``DataFlow::BinaryOperationNode``: an operation involving a binary operator; each ``BinaryExpr``
    has a corresponding ``BinaryOperationNode``, but there are also binary operations that are not
    explicit at the AST level, such as those arising from compound assignments and
    increment/decrement statements; at the AST level, ``x + 1``, ``x += 1``, and ``x++`` are
    represented by different kinds of AST nodes, while at the DFG level they are all modeled as a
    binary operation node with operands ``x`` and ``1``
  - ``DataFlow::UnaryOperationNode``: analogous, but for unary operators

    - ``DataFlow::PointerDereferenceNode``: a pointer dereference, either explicit in an expression
      of the form ``*p``, or implicit in a field or method reference through a pointer
    - ``DataFlow::AddressOperationNode``: analogous, but for taking the address of an entity
    - ``DataFlow::RelationalComparisonNode``, ``DataFlow::EqualityTestNode``: data-flow nodes
      corresponding to ``RelationalComparisonExpr`` and ``EqualityTestExpr`` AST nodes

Finally, classes ``Read`` and ``Write`` represent, respectively, a read or a write of a variable, a
field, or an element of an array, a slice or a map. Use their member predicates ``readsVariable``,
``writesVariable``, ``readsField``, ``writesField``, ``readsElement``, and ``writesElement`` to
determine what the read/write refers to.

Call graph
----------

The call graph connects function (and method) calls to the functions they invoke. Call graph
information is made available by two member predicates on ``DataFlow::CallNode``: ``getTarget()``
returns the declared target of a call, while ``getACallee()`` returns all possible actual functions
a call may invoke at runtime.

These two predicates differ in how they handle calls to interface methods: while ``getTarget()``
will return the interface method itself, ``getACallee()`` will return all concrete methods that
implement the interface method.

Global data flow and taint tracking
-----------------------------------

The predicates ``DataFlow::localFlowStep`` and ``DataFlow::localFlow`` are useful for reasoning
about the flow of values in a single function. However, more advanced use cases, particularly in
security analysis, will invariably require reasoning about global data flow, including flow into,
out of, and across function calls, and through fields.

In CodeQL, such reasoning is expressed in terms of `data-flow configurations`. A data-flow
configuration has three ingredients: sources, sinks, and barriers (also called sanitizers), all of
which are sets of data-flow nodes. Given these three sets, CodeQL provides a general mechanism for
finding paths from a source to a sink, possibly going into and out of functions and fields, but
never flowing through a barrier.

To define a data-flow configuration, you can define a module implementing ``DataFlow::ConfigSig``,
including the predicates ``isSource``, ``isSink``, and ``isBarrier`` to define the sets of
sources, sinks, and barriers. Data flow is then computed by applying
``DataFlow::Global<..>`` to the configuration.

Going beyond pure data flow, many security analyses need to perform more general `taint tracking`,
which also considers flow through value-transforming operations such as string operations. To track
taint, you apply ``TaintTracking::Global<..>`` to your configuration instead.

A detailed exposition of global data flow and taint tracking is out of scope for this brief
introduction. For a general overview of data flow and taint tracking, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

Advanced libraries
------------------

Finally, we briefly describe a few concepts and libraries that are useful for advanced query
writers.

Basic blocks and dominance
~~~~~~~~~~~~~~~~~~~~~~~~~~

Many important control-flow analyses organize control-flow nodes into `basic blocks
<https://en.wikipedia.org/wiki/Basic_block>`__, which are maximal straight-line sequences of
control-flow nodes without any branching. In the CodeQL libraries, basic blocks are represented by
class ``BasicBlock``. Each control-flow node belongs to a basic block. You can use the predicate
``getBasicBlock()`` in class ``ControlFlow::Node`` and the predicate ``getNode(i)`` in
``BasicBlock`` to move from one to the other.

Dominance is a standard concept in control-flow analysis: a basic block ``dom`` is said to
`dominate` a basic block ``bb`` if any path through the control-flow graph from the entry node to
the first node of ``bb`` must pass through ``dom``. In other words, whenever program execution
reaches the beginning of ``bb``, it must have come through ``dom``. Each basic block is moreover
considered to dominate itself.

Dually, a basic block ``postdom`` is said to `post-dominate` a basic block ``bb`` if any path
through the control-flow graph from the last node of ``bb`` to the exit node must pass through
``postdom``. In other words, after program execution leaves ``bb``, it must eventually reach
``postdom``.

These two concepts are captured by two member predicates ``dominates`` and ``postDominates`` of class
``BasicBlock``.

Condition guard nodes
~~~~~~~~~~~~~~~~~~~~~

A condition guard node is a synthetic control-flow node that records the fact that at some point in
the control-flow graph the truth value of a condition is known. For example, consider again the code snippet we saw above:

.. code-block:: go

  x := 0
  if p != nil {
    x = p.f
  }
  return x

At the beginning of the "then" branch ``p`` is known not be ``nil``. This knowledge is encoded in
the control-flow graph by a condition guard node preceding the assignment to ``x``, recording the
fact that ``p != nil`` is ``true`` at this point:

|cfg2|

A typical use of this information would be in an analysis that looks for ``nil`` dereferences: such
an analysis would be able to conclude that the field read ``p.f`` is safe because it is immediately
preceded by a condition guard node guaranteeing that ``p`` is not ``nil``.

In CodeQL, condition guard nodes are represented by class ``ControlFlow::ConditionGuardNode`` which
offers a variety of member predicates to reason about which conditions a guard node guarantees.

Static single-assignment form
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`Static single-assignment form <https://en.wikipedia.org/wiki/Static_single_assignment_form>`__ (SSA
form for short) is a program representation in which the original program variables are mapped onto
more fine-grained `SSA variables`. Each SSA variable has exactly one definition, so program
variables with multiple assignments correspond to multiple SSA variables.

Most of the time query authors do not have to deal with SSA form directly. The data-flow graph uses
it under the hood, and so most of the benefits derived from SSA can be gained by simply using the
data-flow graph.

For example, the data-flow graph for our running example actually looks more like this:

|ssa|

Note that the program variable ``x`` has been mapped onto three distinct SSA variables ``x1``,
``x2``, and ``x3``. In this case there is not much benefit to such a representation, but in general
SSA form has well-known advantages for data-flow analysis for which we refer to the literature.

If you do need to work with raw SSA variables, they are represented by the class ``SsaVariable``.
Class ``SsaDefinition`` represents definitions of SSA variables, which have a one-to-one
correspondence with ``SsaVariable``\ s. Member predicates ``getDefinition()`` and ``getVariable()``
exist to map from one to the other. You can use member predicate ``getAUse()`` of ``SsaVariable`` to
look for uses of an SSA variable. To access the program variable underlying an SSA variable, use
member predicate ``getSourceVariable()``.

Global value numbering
~~~~~~~~~~~~~~~~~~~~~~

`Global value numbering <https://en.wikipedia.org/wiki/Value_numbering>`__ is a technique for
determining when two computations in a program are guaranteed to yield the same result. This is done
by associating with each data-flow node an abstract representation of its value (conventionally
called a `value number`, even though in practice it is not usually a number) such that identical
computations are represented by identical value numbers.

Since this is an undecidable problem, global value numbering is `conservative` in the sense that if
two data-flow nodes have the same value number they are guaranteed to have the same value at
runtime, but not conversely. (That is, there may be data-flow nodes that do, in fact, always
evaluate to the same value, but their value numbers are different.)

In the CodeQL libraries for Go, you can use the ``globalValueNumber(nd)`` predicate to compute the
global value number for a data-flow node ``nd``. Value numbers are represented as an opaque QL type
``GVN`` that provides very little information. Usually, all you need to do with global value numbers
is to compare them to each other to determine whether two data-flow nodes have the same value.

Further reading
---------------

.. include:: ../reusables/go-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. |ast| image:: ../images/codeql-for-go/ast.png
.. |cfg| image:: ../images/codeql-for-go/cfg.png
.. |dfg| image:: ../images/codeql-for-go/dfg.png
.. |cfg2| image:: ../images/codeql-for-go/cfg2.png
.. |ssa| image:: ../images/codeql-for-go/ssa.png



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-cpp.rst
.. _codeql-library-for-cpp:

CodeQL library for C and C++
============================

When analyzing C or C++ code, you can use the large collection of classes in the CodeQL library for C and C++.

About the CodeQL library for C and C++
--------------------------------------

There is an extensive library for analyzing CodeQL databases extracted from C/C++ projects. The classes in this library present the data from a database in an object-oriented form and provide abstractions and predicates to help you with common analysis tasks. 
The library is implemented as a set of QL modules, that is, files with the extension ``.qll``. The module ``cpp.qll`` imports all the core C/C++ library modules, so you can include the complete library by beginning your query with:

.. code-block:: ql

   import cpp

The rest of this topic summarizes the available CodeQL classes and corresponding C/C++ constructs.

Commonly-used library classes
------------------------------

The most commonly used standard library classes are listed below.  The listing is broken down by functionality. Each library class is annotated with a C/C++ construct it corresponds to.

Declaration classes
~~~~~~~~~~~~~~~~~~~

This table lists Declaration_ classes representing C/C++ declarations.

+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
|                                Example syntax                                 |             CodeQL class             |               Remarks               |
+===============================================================================+======================================+=====================================+
| ``int`` *var* ``;``                                                           | GlobalVariable_                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``namespace`` *N* ``{`` ... ``float`` *var* ``;`` ... ``}``                   | NamespaceVariable_                   |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``int`` *func* ``( void ) {`` ... ``float`` *var* ``;`` ... ``}``             | LocalVariable_                       | See also Initializer_               |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *C* ``{`` ... ``int`` *var* ``;`` ... ``}``                         | MemberVariable_                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``int`` *func* ``(const char`` *param* ``);``                                 | Function_                            |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``template < typename`` *T* ``>``                                           | TemplateFunction_                    |                                     |
| | ``void`` *func* ``(`` *T* ``param);``                                       |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``int`` *func* ``(const char*`` *format* ``, ...)``                         | FormattingFunction_                  |                                     |
| |    ``{`` ... ``}``                                                          |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| *func* ``< int, float > (`` ... ``);``                                        | FunctionTemplateInstantiation_       |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``template < typename`` *T* ``>``                                           | FunctionTemplateSpecialization_      |                                     |
| | *func* ``< int,`` *T* ``> (`` ... ``) {`` ... ``}``                         |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | MemberFunction_                      |                                     |
| |    ``int`` *func* ``( float`` *param* ``);`` ... ``};``                     |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | ConstMemberFunction_                 |                                     |
| |    ``int`` *func* ``( float`` *param* ``) const;`` ... ``};``               |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *C* ``{`` ... ``virtual int`` *func* ``(`` ... ``) {`` ... ``} };`` | VirtualFunction_                     |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *C* ``{`` ... *C* ``(`` ... ``) {`` ... ``}`` ... ``};``            | Constructor_                         |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``C::operator float () const;``                                               | ConversionOperator_                  |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *C* ``{`` ...  ``~`` *C* ``( void ) {`` ... ``}`` ... ``};``        | Destructor_                          |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | ConversionConstructor_               |                                     |
| |     *C* ``( const`` *D* ``&`` *d* ``) {`` ... ``}`` ... ``};``              |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| *C* ``&`` *C* ``:: operator= (const`` *C* ``& );``                            | CopyAssignmentOperator_              |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| *C* ``&`` *C* ``:: operator= (`` *C* ``&& );``                                | MoveAssignmentOperator_              |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| *C* ``::`` *C* ``(const`` *C* ``& );``                                        | CopyConstructor_                     |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| *C* ``::`` *C* ``(`` *C* ``&& );``                                            | MoveConstructor_                     |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| *C* ``::`` *C* ``(void);``                                                    | NoArgConstructor_                    | Default constructor                 |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``enum`` *en* ``{`` *val1* ``,`` *val2* ... ``}``                             | EnumConstant_                        |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``friend void`` *func* ``( int );``                                         | FriendDecl_                          |                                     |
| | ``friend class`` *B* ``;``                                                  |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``int`` *func* ``( void ) {`` ...                                           | LocalEnum_                           |                                     |
| |    ``enum`` *en* ``{`` *val1* ``,`` *val2* ... ``};`` ... ``}``             |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | NestedEnum_                          |                                     |
| |    ``enum`` *en* ``{`` *val1* ``,`` *val2* ... ``}`` ... ``}``              |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``enum class`` *en* ``: short {`` *val1* ``,`` *val2* ... ``}``               | ScopedEnum_                          |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | AbstractClass_                       |                                     |
| |    ``virtual void`` *func* ``( int ) = 0;`` ... ``};``                      |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``template < int , float > class`` *C* ``{`` ... ``};``                       | ClassTemplateInstantiation_          |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``template < > class`` *C* ``<`` Type_ ``> {`` ... ``};``                     | FullClassTemplateSpecialization_     |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``template < typename`` *T* ``>``                                           | PartialClassTemplateSpecialization_  |                                     |
| | ``class`` *C* ``<`` *T* ``,`` *5* ``> {`` ... ``};``                        |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``int`` *func* ``( void ) {`` ... ``class`` *C* ``{`` ... ``};`` ... ``}``    | LocalClass_                          |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *C* ``{`` ... ``class`` *D* ``{`` ... ``};`` ... ``};``             | NestedClass_                         |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{``                                                         | Class_                               |                                     |
| |      Type_ *var* ``;``                                                      |                                      |                                     |
| |      Type_ *func* ``(`` Parameter_... ``) {`` ... ``}``... ``};``           |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``struct`` *S* ``{`` ...                                                    | | Struct_                            |                                     |
| |      Type_ *var* ``;``                                                      | | Class_                             |                                     |
| |      Type_ *func* ``(`` Parameter_... ``) {`` ... ``}``... ``};``           | |                                    |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``union`` *U* ``{``                                                         | | Union_                             |                                     |
| |      Type_ *var1* ``;``                                                     | | Struct_                            |                                     |
| |      Type_ *var2* ``;`` ... ``};``                                          | | Class_                             |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``template < typename`` *T* ``>``                                           | ProxyClass_                          | Appears only in *uninstantiated*    |
| | ``struct`` *C* ``:`` *T* ``{`` ... ``};``                                   |                                      | templates                           |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``int`` *func* ``( void ) {`` ...                                           | LocalStruct_                         |                                     |
| |    ``struct`` *S* ``{`` ... ``};`` ... ``}``                                |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | NestedStruct_                        |                                     |
| |    ``struct`` *S* ``{`` ... ``};`` ... ``};``                               |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``int *`` *func* ``( void ) {`` ... ``union`` *U* ``{`` ... ``};`` ... ``}``  | LocalUnion_                          |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *C* ``{`` ... ``union`` *U* ``{`` ... ``};`` ... ``};``             | NestedUnion_                         |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``typedef int`` *T* ``;``                                                     | TypedefType_                         |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``int`` *func* ``( void ) {`` ...                                           | LocalTypedefType_                    |                                     |
| |    ``typedef int`` *T* ``;`` ... ``}``                                      |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``class`` *C* ``{`` ...                                                     | NestedTypedefType_                   |                                     |
| |    ``typedef int`` *T* ``;`` ... ``};``                                     |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *V* ``:`` ... ``public`` *B* ... ``{`` ... ``};``                   | ClassDerivation_                     |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``class`` *V* ``:`` ... ``virtual`` *B* ... ``{`` ... ``};``                  | VirtualClassDerivation_              |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| | ``template < typename`` *T* ``>``                                           | TemplateClass_                       |                                     |
| |    ``class`` *C* ``{`` ... ``};``                                           |                                      |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``int`` *foo* ``(`` Type_ *param1* ``,`` Type_ *param2* ... ``);``            | Parameter_                           |                                     |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+
| ``template <typename`` *T* ``>`` *T* *t* ``;``                                | TemplateVariable_                    | Since C++14                         |
+-------------------------------------------------------------------------------+--------------------------------------+-------------------------------------+

Statement classes
~~~~~~~~~~~~~~~~~

This table lists subclasses of Stmt_ representing C/C++ statements.

+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
|                      Example syntax                      |          CodeQL class          |                      Remarks                      |
+==========================================================+================================+===================================================+
| ``__asm__ ("`` *movb %bh, (%eax)* ``");``                | AsmStmt_                       | Specific to a given CPU instruction set           |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``{`` Stmt_... ``}``                                     | BlockStmt_                     |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``catch (`` Parameter_ ``)`` BlockStmt_                  | CatchBlock_                    |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``catch ( ... )`` BlockStmt_                             | CatchAnyBlock_                 |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``goto *`` *labelptr* ``;``                              | ComputedGotoStmt_              | GNU extension; use with LabelLiteral_             |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| Type_ *i* ``,`` *j* ``;``                                | DeclStmt_                      |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``if (`` Expr_ ``)`` Stmt_ ``else`` Stmt_                | IfStmt_                        |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``switch (`` Expr_ ``) {`` SwitchCase_... ``}``          | SwitchStmt_                    |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``do`` Stmt_ ``while (`` Expr_ ``)``                     | DoStmt_                        |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``for (`` DeclStmt_ ``;`` Expr_ ``;`` Expr_ ``)`` Stmt_  | ForStmt_                       |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``for (`` DeclStmt_ ``:`` Expr_ ``)`` Stmt_              | RangeBasedForStmt_             |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``while (`` Expr_ ``)`` Stmt_                            | WhileStmt_                     |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| Expr_ ``;``                                              | ExprStmt_                      |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``__try {`` ... ``} __except (`` Expr_ ``) {`` ... ``}`` | MicrosoftTryExceptStmt_        | Structured exception handling (SEH) under Windows |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``__try {`` ... ``} __finally {`` ... ``}``              | MicrosoftTryFinallyStmt_       | Structured exception handling (SEH) under Windows |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``return`` Expr_ ``;``                                   | ReturnStmt_                    |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``case`` Expr_ ``:``                                     | SwitchCase_                    |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``try {`` Stmt_... ``}`` CatchBlock_... CatchAnyBlock_   | TryStmt_                       |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| | ``void`` *func* ``(void) try {`` Stmt_... ``}``        | FunctionTryStmt_               |                                                   |
| |      CatchBlock_... CatchAnyBlock_                     |                                |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``;``                                                    | EmptyStmt_                     |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``break;``                                               | BreakStmt_                     |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``continue;``                                            | ContinueStmt_                  |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``goto`` LabelStmt_ ``;``                                | GotoStmt_                      |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| *slabel* ``:``                                           | LabelStmt_                     |                                                   |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+
| ``float`` *arr* ``[`` Expr_ ``] [`` Expr_ ``];``         | VlaDeclStmt_                   | C99 variable-length array                         |
+----------------------------------------------------------+--------------------------------+---------------------------------------------------+


Expression classes
~~~~~~~~~~~~~~~~~~

This table lists subclasses of Expr_ representing C/C++ expressions.

+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
|                    Example syntax                     |                  CodeQL class(es)                  |                  Remarks                  |
+=======================================================+====================================================+===========================================+
| ``{`` Expr_...  ``}``                                 | | ArrayAggregateLiteral_                           |                                           |
|                                                       | | ClassAggregateLiteral_                           |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``alignof (`` Expr_ ``)``                             | AlignofExprOperator_                               |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``alignof (`` Type_ ``)``                             | AlignofTypeOperator_                               |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``[`` Expr_ ``]``                               | ArrayExpr_                                         |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``__assume (`` Expr_ ``)``                            | AssumeExpr_                                        | Microsoft extension                       |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``static_assert (`` Expr_ ``,`` StringLiteral_ ``)``  | StaticAssert_                                      | | C++11                                   |
| ``_Static_assert (`` Expr_ ``,`` StringLiteral_ ``)`` |                                                    | | C11                                     |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``__noop;``                                           | BuiltInNoOp_                                       | Microsoft extension                       |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``(`` Expr_... ``)``                            | ExprCall_                                          |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | *func* ``(`` Expr_... ``)``                         | FunctionCall_                                      |                                           |
| | *instance* ``.`` *func* ``(`` Expr_... ``)``        |                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``,`` Expr_                                     | CommaExpr_                                         |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``if (`` Type_ *arg* ``=`` Expr_ ``)``                | ConditionDeclExpr_                                 |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``(`` Type_ ``)`` Expr_                               | CStyleCast_                                        |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``const_cast <`` Type_ ``> (`` Expr_ ``)``            | ConstCast_                                         |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``dynamic_cast <`` Type_ ``> (`` Expr_ ``)``          | DynamicCast_                                       |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``reinterpret_cast <`` Type_ ``> (`` Expr_ ``)``      | ReinterpretCast_                                   |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``static_cast <`` Type_ ``> (`` Expr_ ``)``           | StaticCast_                                        |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | ``template < typename...``  *T* ``>``               | FoldExpr_                                          | Appears only in *uninstantiated*          |
| | ``auto`` *sum* ``(`` *T* `...` *t* ``)``            |                                                    | templates                                 |
| |    ``{ return (`` *t* ``+ ... + 0 ); }``            |                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``int`` *func* ``(`` *format* ``, ... );``            | FormattingFunctionCall_                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | ``[ = ] ( float`` *b* ``) -> float``                | LambdaExpression_                                  | C++11                                     |
| |    ``{ return`` *captured* ``*`` *b* ``; }``        |                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | ``^ int ( int`` *x* ``, int`` *y* ``) {``           | BlockExpr_                                         | Apple extension                           |
| |    ``{`` Stmt_... ``; return`` *x* ``+`` *y* ``; }``|                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``void *`` *labelptr* ``= &&`` *label* ``;``          | LabelLiteral_                                      | GNU extension; use with ComputedGotoStmt_ |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| *"%3d %s\\n"*                                         | FormatLiteral_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| *0xdbceffca*                                          | HexLiteral_                                        |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| *0167*                                                | OctalLiteral_                                      |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| *'c'*                                                 | CharLiteral_                                       |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| *"abcdefgh"*, *L"wide"*                               | StringLiteral_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``new`` Type_ ``[`` Expr_ ``]``                       | NewArrayExpr_                                      |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``new`` Type_                                         | NewExpr_                                           |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``delete [ ]`` Expr_ ``;``                            | DeleteArrayExpr_                                   |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``delete`` Expr_ ``;``                                | DeleteExpr_                                        |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``noexcept (`` Expr_ ``)``                            | NoExceptExpr_                                      |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``=`` Expr_                                     | AssignExpr_                                        | See also Initializer_                     |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``+=`` Expr_                                    | | AssignAddExpr_                                   |                                           |
|                                                       | | AssignPointerAddExpr_                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``/=`` Expr_                                    | AssignDivExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``*=`` Expr_                                    | AssignMulExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``%=`` Expr_                                    | AssignRemExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``-=`` Expr_                                    | | AssignSubExpr_                                   |                                           |
|                                                       | | AssignPointerSubExpr_                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``&=`` Expr_                                    | AssignAndExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``<<=`` Expr_                                   | AssignLShiftExpr_                                  |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``                                              | =`` Expr_                                          | AssignOrExpr_                             |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``>>=`` Expr_                                   | AssignRShiftExpr_                                  |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``^=`` Expr_                                    | AssignXorExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``+`` Expr_                                     | | AddExpr_                                         | |                                         |
|                                                       | | PointerAddExpr_                                  | |                                         |
|                                                       | | ImaginaryRealAddExpr_                            | | C99                                     |
|                                                       | | RealImaginaryAddExpr_                            | | C99                                     |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``/`` Expr_                                     | | DivExpr_                                         | |                                         |
|                                                       | | ImaginaryDivExpr_                                | | C99                                     |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``>?`` Expr_                                    | MaxExpr_                                           | GNU extension                             |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``<?`` Expr_                                    | MinExpr_                                           | GNU extension                             |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``*`` Expr_                                     | | MulExpr_                                         | |                                         |
|                                                       | | ImaginaryMulExpr_                                | | C99                                     |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``%`` Expr_                                     | RemExpr_                                           |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``-`` Expr_                                     | | SubExpr_                                         | |                                         |
|                                                       | | PointerDiffExpr_                                 | |                                         |
|                                                       | | PointerSubExpr_                                  | |                                         |
|                                                       | | ImaginaryRealSubExpr_                            | | C99                                     |
|                                                       | | RealImaginarySubExpr_                            | | C99                                     |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``&`` Expr_                                     | BitwiseAndExpr_                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``|`` Expr_                                     | BitwiseOrExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``^`` Expr_                                     | BitwiseXorExpr_                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``<<`` Expr_                                    | LShiftExpr_                                        |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``>>`` Expr_                                    | RShiftExpr_                                        |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``&&`` Expr_                                    | LogicalAndExpr_                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``||`` Expr_                                    | LogicalOrExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``==`` Expr_                                    | EQExpr_                                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``!=`` Expr_                                    | NEExpr_                                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``>=`` Expr_                                    | GEExpr_                                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``>`` Expr_                                     | GTExpr_                                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``<=`` Expr_                                    | LEExpr_                                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``<`` Expr_                                     | LTExpr_                                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``?`` Expr_ ``:`` Expr_                         | ConditionalExpr_                                   |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``&`` Expr_                                           | AddressOfExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``*`` Expr_                                           | PointerDereferenceExpr_                            |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``--``                                          | PostfixDecrExpr_                                   |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``--`` Expr_                                          | PrefixDecrExpr_                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| Expr_ ``++``                                          | PostfixIncrExpr_                                   |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``++`` Expr_                                          | PrefixIncrExpr_                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``__imag (`` Expr_ ``)``                              | ImaginaryPartExpr_                                 | GNU extension                             |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``__real (`` Expr_ ``)``                              | RealPartExpr_                                      | GNU extension                             |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``-`` Expr_                                           | UnaryMinusExpr_                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``+`` Expr_                                           | UnaryPlusExpr_                                     |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``~`` Expr_                                           | | ComplementExpr_                                  | |                                         |
|                                                       | | ConjugationExpr_                                 | | GNU extension                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``!`` Expr_                                           | NotExpr_                                           |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | ``int`` *vect* ``__attribute__``                    | VectorFillOperation_                               | GNU extension                             |
| |    ``( ( vector_size (`` *16* ``) ) )``             |                                                    |                                           |
| |    ``= {`` *3* ``,`` *8* ``,`` *32* ``,``           |                                                    |                                           |
|      *33* ``};``                                      |                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``sizeof (`` Expr_ ``)``                              | SizeofExprOperator_                                |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``sizeof (`` Type_ ``)``                              | SizeofTypeOperator_                                |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | ``template < typename...`` *T* ``>``                | SizeofPackOperator_                                |                                           |
| | ``int`` *count* ``(`` *T*  ``&&...`` *t* ``)``      |                                                    |                                           |
| |    ``{ return sizeof... (`` *t* ``); }``            |                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``( {`` Stmt_... ``;`` Expr_ ``} )``                  | StmtExpr_                                          | GNU/Clang extension                       |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``this``                                              | ThisExpr_                                          |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``throw (`` Expr_ ``);``                              | ThrowExpr_                                         |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``throw;``                                            | ReThrowExpr_                                       |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| | ``typeid (`` Expr_ ``)``                            | TypeidOperator_                                    |                                           |
| | ``typeid (`` Type_ ``)``                            |                                                    |                                           |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+
| ``__uuidof (`` Expr_ ``)``                            | UuidofOperator_                                    | Microsoft extension                       |
+-------------------------------------------------------+----------------------------------------------------+-------------------------------------------+

Type classes
~~~~~~~~~~~~

This table lists subclasses of Type_ representing C/C++ types.

+-------------------------------------------------------------------+---------------------------------+-----------------+
|                          Example syntax                           |          CodeQL class           |     Remarks     |
+===================================================================+=================================+=================+
| ``void``                                                          | VoidType_                       |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``_Bool`` or ``bool``                                             | BoolType_                       |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``char16_t``                                                      | Char16Type_                     | C11, C++11      |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``char32_t``                                                      | Char32Type_                     | C11, C++11      |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``char``                                                          | PlainCharType_                  |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``signed char``                                                   | SignedCharType_                 |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``unsigned char``                                                 | UnsignedCharType_               |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``int``                                                           | IntType_                        |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``long long``                                                     | LongLongType_                   |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``long``                                                          | LongType_                       |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``short``                                                         | ShortType_                      |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``wchar_t``                                                       | WideCharType_                   |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``nullptr_t``                                                     | NullPointerType_                |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``double``                                                        | DoubleType_                     |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``long double``                                                   | LongDoubleType_                 |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``float``                                                         | FloatType_                      |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``auto``                                                          | AutoType_                       |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``decltype (`` Expr_ ``)``                                        | Decltype_                       |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``[`` *n* ``]``                                             | ArrayType_                      |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``( ^`` *blockptr* ``) (`` Parameter_... ``)``              | BlockType_                      | Apple extension |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``( *``  *funcptr* ``) (`` Parameter_... ``)``              | FunctionPointerType_            |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``( &`` *funcref* ``) (`` Parameter_... ``)``               | FunctionReferenceType_          |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``__attribute__ ( ( vector_size (`` *n* ``) ) )``           | GNUVectorType_                  |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_  ``*``                                                      | PointerType_                    |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``&``                                                       | LValueReferenceType_            |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``&&``                                                      | RValueReferenceType_            |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| Type_ ``(`` Class_ ``*::``  *membptr* ``) (`` Parameter_... ``)`` | PointerToMemberType_            |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``template < template < typename > class`` *C* ``>``              | TemplateTemplateParameter_      |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+
| ``template < typename`` *T* ``>``                                 | TemplateParameter_              |                 |
+-------------------------------------------------------------------+---------------------------------+-----------------+


Preprocessor classes
~~~~~~~~~~~~~~~~~~~~

This table lists Preprocessor_ classes representing C/C++ preprocessing directives.

+-------------------------------------+----------------------+----------------------+
|           Example syntax            |     CodeQL class     |       Remarks        |
+=====================================+======================+======================+
| ``#elif`` *condition*               | PreprocessorElif_    |                      |
+-------------------------------------+----------------------+----------------------+
| ``#if`` *condition*                 | PreprocessorIf_      |                      |
+-------------------------------------+----------------------+----------------------+
| ``#ifdef`` *macro*                  | PreprocessorIfdef_   |                      |
+-------------------------------------+----------------------+----------------------+
| ``#ifndef`` *macro*                 | PreprocessorIfndef_  |                      |
+-------------------------------------+----------------------+----------------------+
| ``#else``                           | PreprocessorElse_    |                      |
+-------------------------------------+----------------------+----------------------+
| ``#endif``                          | PreprocessorEndif_   |                      |
+-------------------------------------+----------------------+----------------------+
| ``#line`` *line_number* *file_name* | PreprocessorLine_    |                      |
+-------------------------------------+----------------------+----------------------+
| ``#pragma`` *pragma_property*       | PreprocessorPragma_  |                      |
+-------------------------------------+----------------------+----------------------+
| ``#undef`` *macro*                  | PreprocessorUndef_   |                      |
+-------------------------------------+----------------------+----------------------+
| ``#warning`` *message*              | PreprocessorWarning_ |                      |
+-------------------------------------+----------------------+----------------------+
| ``#error`` *message*                | PreprocessorError_   |                      |
+-------------------------------------+----------------------+----------------------+
| ``#include`` *file_name*            | Include_             |                      |
+-------------------------------------+----------------------+----------------------+
| ``#import`` *file_name*             | Import_              | Apple/NeXT extension |
+-------------------------------------+----------------------+----------------------+
| ``#include_next`` *file_name*       | IncludeNext_         | Apple/NeXT extension |
+-------------------------------------+----------------------+----------------------+
| ``#define`` *macro* ...             | Macro_               |                      |
+-------------------------------------+----------------------+----------------------+

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Links used in tables. For information about using these links, see
   https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#hyperlinks.

.. _Declaration: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Declaration.qll/type.Declaration$Declaration.html
.. _GlobalVariable: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Variable.qll/type.Variable$GlobalVariable.html
.. _NamespaceVariable: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Variable.qll/type.Variable$NamespaceVariable.html
.. _LocalVariable: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Variable.qll/type.Variable$LocalVariable.html
.. _Initializer: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Initializer.qll/type.Initializer$Initializer.html
.. _MemberVariable: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Variable.qll/type.Variable$MemberVariable.html
.. _Function: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Function.qll/type.Function$Function.html
.. _TemplateFunction: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Function.qll/type.Function$TemplateFunction.html
.. _FormattingFunction: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/models/interfaces/FormattingFunction.qll/type.FormattingFunction$FormattingFunction.html
.. _FunctionTemplateInstantiation: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Function.qll/type.Function$FunctionTemplateInstantiation.html
.. _FunctionTemplateSpecialization: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Function.qll/type.Function$FunctionTemplateSpecialization.html
.. _MemberFunction: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$MemberFunction.html
.. _ConstMemberFunction: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ConstMemberFunction.html
.. _VirtualFunction: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$VirtualFunction.html
.. _Constructor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$Constructor.html
.. _ConversionOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ConversionOperator.html
.. _Destructor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$Destructor.html
.. _ConversionConstructor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$ConversionConstructor.html
.. _CopyAssignmentOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$CopyAssignmentOperator.html
.. _MoveAssignmentOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$MoveAssignmentOperator.html
.. _CopyConstructor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$CopyConstructor.html
.. _MoveConstructor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$MoveConstructor.html
.. _NoArgConstructor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/MemberFunction.qll/type.MemberFunction$NoArgConstructor.html
.. _EnumConstant: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Enum.qll/type.Enum$EnumConstant.html
.. _FriendDecl: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/FriendDecl.qll/type.FriendDecl$FriendDecl.html
.. _LocalEnum: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Enum.qll/type.Enum$LocalEnum.html
.. _NestedEnum: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Enum.qll/type.Enum$NestedEnum.html
.. _ScopedEnum: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Enum.qll/type.Enum$ScopedEnum.html
.. _AbstractClass: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$AbstractClass.html
.. _ClassTemplateInstantiation: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$ClassTemplateInstantiation.html
.. _Type: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$Type.html
.. _FullClassTemplateSpecialization: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$FullClassTemplateSpecialization.html
.. _PartialClassTemplateSpecialization: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$PartialClassTemplateSpecialization.html
.. _LocalClass: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$LocalClass.html
.. _NestedClass: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$NestedClass.html
.. _Class: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$Class.html
.. _Parameter: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Parameter.qll/type.Parameter$Parameter.html
.. _Struct: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Struct.qll/type.Struct$Struct.html
.. _Union: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Union.qll/type.Union$Union.html
.. _ProxyClass: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$ProxyClass.html
.. _LocalStruct: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Struct.qll/type.Struct$LocalStruct.html
.. _NestedStruct: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Struct.qll/type.Struct$NestedStruct.html
.. _LocalUnion: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Union.qll/type.Union$LocalUnion.html
.. _NestedUnion: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Union.qll/type.Union$NestedUnion.html
.. _TypedefType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/TypedefType.qll/type.TypedefType$TypedefType.html
.. _LocalTypedefType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/TypedefType.qll/type.TypedefType$LocalTypedefType.html
.. _NestedTypedefType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/TypedefType.qll/type.TypedefType$NestedTypedefType.html
.. _ClassDerivation: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$ClassDerivation.html
.. _VirtualClassDerivation: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$VirtualClassDerivation.html
.. _TemplateClass: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Class.qll/type.Class$TemplateClass.html
.. _TemplateVariable: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Variable.qll/type.Variable$TemplateVariable.html
.. _Stmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$Stmt.html
.. _AsmStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$AsmStmt.html
.. _BlockStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Block.qll/type.Block$BlockStmt.html
.. _CatchBlock: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$CatchBlock.html
.. _CatchAnyBlock: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$CatchAnyBlock.html
.. _ComputedGotoStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ComputedGotoStmt.html
.. _LabelLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$LabelLiteral.html
.. _DeclStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$DeclStmt.html
.. _Expr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$Expr.html
.. _IfStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$IfStmt.html
.. _SwitchCase: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$SwitchCase.html
.. _SwitchStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$SwitchStmt.html
.. _DoStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$DoStmt.html
.. _ForStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ForStmt.html
.. _RangeBasedForStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$RangeBasedForStmt.html
.. _WhileStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$WhileStmt.html
.. _ExprStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ExprStmt.html
.. _MicrosoftTryExceptStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$MicrosoftTryExceptStmt.html
.. _MicrosoftTryFinallyStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$MicrosoftTryFinallyStmt.html
.. _ReturnStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ReturnStmt.html
.. _TryStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$TryStmt.html
.. _FunctionTryStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$FunctionTryStmt.html
.. _EmptyStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$EmptyStmt.html
.. _BreakStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$BreakStmt.html
.. _ContinueStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$ContinueStmt.html
.. _LabelStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$LabelStmt.html
.. _GotoStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$GotoStmt.html
.. _VlaDeclStmt: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/stmts/Stmt.qll/type.Stmt$VlaDeclStmt.html
.. _ArrayAggregateLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$ArrayAggregateLiteral.html
.. _ClassAggregateLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$ClassAggregateLiteral.html
.. _AlignofExprOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$AlignofExprOperator.html
.. _AlignofTypeOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$AlignofTypeOperator.html
.. _ArrayExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Access.qll/type.Access$ArrayExpr.html
.. _AssumeExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$AssumeExpr.html
.. _StringLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$StringLiteral.html
.. _StaticAssert: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Element.qll/type.Element$StaticAssert.html
.. _BuiltInNoOp: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$BuiltInNoOp.html
.. _ExprCall: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Call.qll/type.Call$ExprCall.html
.. _FunctionCall: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Call.qll/type.Call$FunctionCall.html
.. _CommaExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$CommaExpr.html
.. _ConditionDeclExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$ConditionDeclExpr.html
.. _CStyleCast: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$CStyleCast.html
.. _ConstCast: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$ConstCast.html
.. _DynamicCast: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$DynamicCast.html
.. _ReinterpretCast: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$ReinterpretCast.html
.. _StaticCast: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$StaticCast.html
.. _FoldExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$FoldExpr.html
.. _FormattingFunctionCall: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/commons/Printf.qll/type.Printf$FormattingFunctionCall.html
.. _LambdaExpression: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Lambda.qll/type.Lambda$LambdaExpression.html
.. _BlockExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$BlockExpr.html
.. _FormatLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/commons/Printf.qll/type.Printf$FormatLiteral.html
.. _HexLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$HexLiteral.html
.. _OctalLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$OctalLiteral.html
.. _CharLiteral: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Literal.qll/type.Literal$CharLiteral.html
.. _NewArrayExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$NewArrayExpr.html
.. _NewExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$NewExpr.html
.. _DeleteArrayExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$DeleteArrayExpr.html
.. _DeleteExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$DeleteExpr.html
.. _NoExceptExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$NoExceptExpr.html
.. _AssignExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignExpr.html
.. _AssignAddExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignAddExpr.html
.. _AssignPointerAddExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignPointerAddExpr.html
.. _AssignDivExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignDivExpr.html
.. _AssignMulExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignMulExpr.html
.. _AssignRemExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignRemExpr.html
.. _AssignSubExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignSubExpr.html
.. _AssignPointerSubExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignPointerSubExpr.html
.. _AssignAndExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignAndExpr.html
.. _AssignLShiftExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignLShiftExpr.html
.. _AssignOrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignOrExpr.html
.. _AssignRShiftExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignRShiftExpr.html
.. _AssignXorExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Assignment.qll/type.Assignment$AssignXorExpr.html
.. _AddExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$AddExpr.html
.. _PointerAddExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerAddExpr.html
.. _ImaginaryRealAddExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryRealAddExpr.html
.. _RealImaginaryAddExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RealImaginaryAddExpr.html
.. _DivExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$DivExpr.html
.. _ImaginaryDivExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryDivExpr.html
.. _MaxExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$MaxExpr.html
.. _MinExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$MinExpr.html
.. _MulExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$MulExpr.html
.. _ImaginaryMulExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryMulExpr.html
.. _RemExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RemExpr.html
.. _SubExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$SubExpr.html
.. _PointerDiffExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerDiffExpr.html
.. _PointerSubExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PointerSubExpr.html
.. _ImaginaryRealSubExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryRealSubExpr.html
.. _RealImaginarySubExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RealImaginarySubExpr.html
.. _BitwiseAndExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BitwiseAndExpr.html
.. _BitwiseOrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BitwiseOrExpr.html
.. _BitwiseXorExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$BitwiseXorExpr.html
.. _LShiftExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$LShiftExpr.html
.. _RShiftExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$RShiftExpr.html
.. _LogicalAndExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$LogicalAndExpr.html
.. _LogicalOrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$LogicalOrExpr.html
.. _EQExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$EQExpr.html
.. _NEExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$NEExpr.html
.. _GEExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$GEExpr.html
.. _GTExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$GTExpr.html
.. _LEExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$LEExpr.html
.. _LTExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ComparisonOperation.qll/type.ComparisonOperation$LTExpr.html
.. _ConditionalExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$ConditionalExpr.html
.. _AddressOfExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$AddressOfExpr.html
.. _PointerDereferenceExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$PointerDereferenceExpr.html
.. _PostfixDecrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PostfixDecrExpr.html
.. _PrefixDecrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PrefixDecrExpr.html
.. _PostfixIncrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PostfixIncrExpr.html
.. _PrefixIncrExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$PrefixIncrExpr.html
.. _ImaginaryPartExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ImaginaryPartExpr.html
.. _RealPartExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$RealPartExpr.html
.. _UnaryMinusExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$UnaryMinusExpr.html
.. _UnaryPlusExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$UnaryPlusExpr.html
.. _ComplementExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BitwiseOperation.qll/type.BitwiseOperation$ComplementExpr.html
.. _ConjugationExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/ArithmeticOperation.qll/type.ArithmeticOperation$ConjugationExpr.html
.. _NotExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/LogicalOperation.qll/type.LogicalOperation$NotExpr.html
.. _VectorFillOperation: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/BuiltInOperations.qll/type.BuiltInOperations$VectorFillOperation.html
.. _SizeofExprOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofExprOperator.html
.. _SizeofTypeOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofTypeOperator.html
.. _SizeofPackOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$SizeofPackOperator.html
.. _StmtExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$StmtExpr.html
.. _ThisExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$ThisExpr.html
.. _ThrowExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$ThrowExpr.html
.. _ReThrowExpr: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Expr.qll/type.Expr$ReThrowExpr.html
.. _TypeidOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$TypeidOperator.html
.. _UuidofOperator: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$UuidofOperator.html
.. _VoidType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$VoidType.html
.. _BoolType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$BoolType.html
.. _PlainCharType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$PlainCharType.html
.. _SignedCharType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$SignedCharType.html
.. _UnsignedCharType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$UnsignedCharType.html
.. _IntType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$IntType.html
.. _LongLongType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$LongLongType.html
.. _LongType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$LongType.html
.. _ShortType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$ShortType.html
.. _WideCharType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$WideCharType.html
.. _NullPointerType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$NullPointerType.html
.. _DoubleType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$DoubleType.html
.. _LongDoubleType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$LongDoubleType.html
.. _FloatType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$FloatType.html
.. _AutoType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$AutoType.html
.. _Decltype: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$Decltype.html
.. _ArrayType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$ArrayType.html
.. _BlockType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$BlockType.html
.. _FunctionPointerType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$FunctionPointerType.html
.. _FunctionReferenceType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$FunctionReferenceType.html
.. _GNUVectorType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$GNUVectorType.html
.. _PointerType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$PointerType.html
.. _LValueReferenceType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$LValueReferenceType.html
.. _RValueReferenceType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$RValueReferenceType.html
.. _PointerToMemberType: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$PointerToMemberType.html
.. _TemplateTemplateParameter: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$TemplateTemplateParameter.html
.. _TemplateParameter: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$TemplateParameter.html
.. _Preprocessor: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/module.Preprocessor.html
.. _PreprocessorElif: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorElif.html
.. _PreprocessorIf: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorIf.html
.. _PreprocessorIfdef: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorIfdef.html
.. _PreprocessorIfndef: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorIfndef.html
.. _PreprocessorElse: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorElse.html
.. _PreprocessorEndif: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorEndif.html
.. _PreprocessorLine: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorLine.html
.. _PreprocessorPragma: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorPragma.html
.. _PreprocessorUndef: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorUndef.html
.. _PreprocessorWarning: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorWarning.html
.. _PreprocessorError: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Preprocessor.qll/type.Preprocessor$PreprocessorError.html
.. _Include: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Include.qll/type.Include$Include.html
.. _Import: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Include.qll/type.Include$Import.html
.. _IncludeNext: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Include.qll/type.Include$IncludeNext.html
.. _Macro: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Macro.qll/type.Macro$Macro.html
.. _Char16Type: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$Char16Type.html
.. _Char32Type: https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/Type.qll/type.Type$Char32Type.html





# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/extensible-predicates.rst
.. _extensible-predicates:

:orphan:
:nosearch:

Extensible predicates and their interaction with data extensions
================================================================

You can use data extensions to model the methods and callables that control dataflow in any framework or library. This is especially useful for custom frameworks or niche libraries, that are not supported by the standard CodeQL libraries.

.. include:: ../reusables/beta-note-customizing-library-models.rst

About this article
------------------

This reference article describes the available inputs for the extensible predicates, including access paths, kinds, and provenance.

Sources, sinks, summaries, and neutrals are commonly known as models. These models support several shared arguments and a few model-specific arguments. The arguments populate a series of columns for each extensible predicate.

About extensible predicates
---------------------------

At a high level, there are two main components to using data extensions. The query writer defines one or more extensible predicates in their query libraries. CLI and code scanning users who want to augment these predicates supply one or more extension files whose data gets injected into the extensible predicate during evaluation. The extension files are either stored directly in the repository where the codebase to be analyzed is hosted, or downloaded as CodeQL model packs.

This example of an extensible predicate for a source is taken from the core Java libraries https://github.com/github/codeql/blob/main/java/ql/lib/semmle/code/java/dataflow/internal/ExternalFlowExtensions.qll#L8-L11

.. code-block:: ql

    extensible predicate sourceModel(
      string package, string type, boolean subtypes, string name, 
      string signature, string ext, string output, string kind, 
      string provenance
    );

An extensible predicate is a CodeQL predicate with the following restrictions:

- It uses the ``extensible`` keyword.
- It has no body.
- All predicate parameters have primitive types.
- It is not in a module.

Columns shared by all extensible predicates
-------------------------------------------

The semantics of many of the columns of the extensible predicates are shared. The columns ``package``, ``type``, ``subtypes``, ``name``, and ``signature`` define which element(s) the model applies to.

- ``package``: Name of the package containing the element(s) to be modeled.
- ``type``: Name of the type containing the element(s) to be modeled.
- ``subtypes``: A boolean flag indicating whether the model should also apply to all overrides of the selected element(s).
- ``name``: Name of the element (optional). If this is left blank, it means all elements matching the previous selection criteria.
- ``signature``: Type signature of the selected element (optional). If this is left blank, it means all elements matching the previous selection criteria.
- ``ext``: Specifies additional API-graph-like edges (mostly empty) and out of scope for this document.
- ``provenance``: Provenance (origin) of the model definition. For more information, see ":ref:`provenance`."

The sematics for access paths are also common to all extensible predicates. For more information, see ":ref:`access-paths`."

sourceModel(package, type, subtypes, name, signature, ext, output, kind, provenance)
------------------------------------------------------------------------------------

Taint source. Most taint tracking queries will use all sources added to this extensible predicate regardless of their kind.

- ``output``: Access path to the source, where the possibly tainted data flows from.
- ``kind``: Kind of the source.

As most sources are used by all taint tracking queries there are only a few different source kinds.
The following source kinds are supported:

- ``remote``: A remote source of possibly tainted data. This is the most common kind for a source. Sources of this kind are used for almost all taint tracking queries.
- ``contentprovider``, ``android-external-storage-dir``: These kinds are also supported but usage is advanced.

sinkModel(package, type, subtypes, name, signature, ext, input, kind, provenance)
---------------------------------------------------------------------------------

Taint sink. As opposed to source kinds, there are many different kinds of sinks as these tend to be more query specific.

- ``input``: Access path to the sink, where we want to check if tainted data can flow into.
- ``kind``: Kind of the sink.

The following sink kinds are supported:

- ``bean-validation``: A sink that can be used for insecure bean validation, such as in calls to ``ConstraintValidatorContext.buildConstraintViolationWithTemplate``.
- ``command-injection``: A sink that can be used to inject shell commands, such as in calls to ``Runtime.exec``.
- ``file-content-store``: A sink that can be used to control the contents of a file, such as in a ``Files.write`` call.
- ``fragment-injection``: A sink that can be used for Android fragment injection, such as in a ``FragmentTransaction.replace`` call.
- ``groovy-injection``: A sink that can be used for Groovy injection, such as in a ``GroovyShell.evaluate`` call.
- ``hostname-verification``: A sink that can be used for unsafe hostname verification, such as in calls to ``HttpsURLConnection.setHostnameVerifier``.
- ``html-injection``: A sink that can be used for XSS via HTML injection, such as in a ``ResponseStream.write`` call.
- ``information-leak``: A sink that can be used to leak information to an HTTP response, such as in calls to ``HttpServletResponse.sendError``.
- ``intent-redirection``: A sink that can be used for Android intent redirection, such as in a ``Context.startActivity`` call.
- ``jexl-injection``: A sink that can be used for JEXL expression injection, such as in a ``JexlExpression.evaluate`` call.
- ``jndi-injection``: A sink that can be used for JNDI injection, such as in a ``Context.lookup`` call.
- ``js-injection``: A sink that can be used for XSS via JavaScript injection, such as in a ``Webview.evaluateJavaScript`` call.
- ``ldap-injection``: A sink that can be used for LDAP injection, such as in a ``DirContext.search`` call.
- ``log-injection``: A sink that can be used for log injection, such as in a ``Logger.warn`` call.
- ``mvel-injection``: A sink that can be used for MVEL expression injection, such as in a ``MVEL.eval`` call.
- ``ognl-injection``: A sink that can be used for OGNL injection, such as in an ``Ognl.getValue`` call.
- ``path-injection``: A sink that can be used for path injection in a file system access, such as in calls to ``new FileReader``.
- ``pending-intents``: A sink that can be used to send an implicit and mutable `PendingIntent` to a third party, such as in an ``Activity.setResult`` call.
- ``request-forgery``: A sink that controls the URL of a request, such as in an ``HttpRequest.newBuilder`` call.
- ``response-splitting``: A sink that can be used for HTTP response splitting, such as in calls to ``HttpServletResponse.setHeader``.
- ``sql-injection``: A sink that can be used for SQL injection, such as in a ``Statement.executeQuery`` call.
- ``template-injection``: A sink that can be used for server-side template injection, such as in a ``Velocity.evaluate`` call.
- ``trust-boundary-violation``: A sink that can be used to cross a trust boundary, such as in a ``HttpSession.setAttribute`` call.
- ``url-redirection``: A sink that can be used to redirect the user to a malicious URL, such as in a ``Response.temporaryRedirect`` call.
- ``xpath-injection``: A sink that can be used for XPath injection, such as in a ``XPath.evaluate`` call.
- ``xslt-injection``: A sink that can be used for XSLT injection, such as in a ``Transformer.transform`` call.

summaryModel(package, type, subtypes, name, signature, ext, input, output, kind, provenance)
--------------------------------------------------------------------------------------------

Flow through (summary). This extensible predicate is used to model flow through elements.

- ``input``: Access path to the input of the element (where data will flow from to the output).
- ``output``: Access path to the output of the element (where data will flow to from the input).
- ``kind``: Kind of the flow through.

The following kinds are supported:

- ``taint``: This means the output is not necessarily equal to the input, but it was derived from the input in an unrestrictive way. An attacker who controls the input will have significant control over the output as well.
- ``value``: This means that the output equals the input or a copy of the input such that all of its properties are preserved.

neutralModel(package, type, name, signature, kind, provenance)
--------------------------------------------------------------

This extensible predicate is not typically needed externally, but is included here for completeness.
It has limited impact on dataflow analysis.
Manual neutrals are considered high-confidence dispatch call targets and can reduce the number of dispatch call targets during dataflow analysis (a performance optimization).

- ``kind``: Kind of the neutral. For neutrals the kind can be ``summary``, ``source``, or ``sink`` to indicate that the callable is neutral with respect to flow (no summary), source (is not a source) or sink (is not a sink).

.. _access-paths:

Access paths
------------
The ``input``, and ``output`` columns consist of a ``.``-separated list of components, which is evaluated from left to right, with each step selecting a new set of values derived from the previous set of values.

The following components are supported:

- ``Argument[``\ `n`\ ``]`` selects the argument at index `n` (zero-indexed).
- ``Argument[``\ `this`\ ``]`` selects the qualifier (instance parameter).
- ``Argument[``\ `n1..n2`\ ``]`` selects the arguments in the given range (both ends included).
- ``Parameter[``\ `n`\ ``]`` selects the parameter at index `n` (zero-indexed).
- ``Parameter[``\ `n1..n2`\ ``]`` selects the parameters in the given range (both ends included).
- ``ReturnValue`` selects the return value.
- ``Field[``\ `name`\ ``]`` selects the field with the fully qualified name `name`.
- ``SyntheticField[``\ `name`\ ``]`` selects the synthetic field with name `name`.
- ``SyntheticGlobal[``\ `name`\ ``]`` selects the synthetic global with name `name`.
- ``ArrayElement`` selects the elements of an array.
- ``Element`` selects the elements of a collection-like container.
- ``WithoutElement`` selects a collection-like container without its elements. This is for input only.
- ``WithElement`` selects the elements of a collection-like container, but points to the container itself. This is for input only.
- ``MapKey`` selects the element keys of a map.
- ``MapValue`` selects the element values of a map.

.. _provenance:

Provenance
----------

The ``provenance`` column is used to specify the provenance (origin) of the model definition and how the model was verified.
The following values are supported.

- ``manual``: The model was manually created and added to the extensible predicate.

Values can also take the form ``ORIGIN-VERIFICATION``, where ``ORIGIN`` is one of:

- ``ai``: The model was generated by artificial intelligence (AI).
- ``df``: The model was generated by the dataflow model generator.
- ``tb``: The model was generated by the type based model generator.
- ``hq``: The model was generated using a heuristic query.

And ``VERIFICATION`` is one of:

- ``manual``: The model was verified by a human.
- ``generated``: The model was generated, but not verified by a human.

The provenance is used to distinguish between models that are manually added (or verified) to the extensible predicate and models that are automatically generated.
Furthermore, it impacts the dataflow analysis in the following way:

- A ``manual`` model takes precedence over ``generated`` models. If a ``manual`` model exists for an element then all ``generated`` models are ignored.
- A ``generated`` model is ignored during analysis, if the source code of the element it is modeling is available.

That is, generated models are less trusted than manual models and only used if neither source code nor a manual model is available.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/customizing-library-models-for-cpp.rst
.. _customizing-library-models-for-cpp:

Customizing library models for C and C++
========================================

You can model the methods and callables that control data flow in any framework or library. This is especially useful for custom frameworks or niche libraries, that are not supported by the standard CodeQL libraries.

.. include:: ../reusables/beta-note-customizing-library-models.rst

About this article
------------------

This article contains reference material about how to define custom models for sources, sinks, and flow summaries for C and C++ dependencies in data extension files.

About data extensions
---------------------

You can customize analysis by defining models (summaries, sinks, and sources) of your code's C and C++ dependencies in data extension files. Each model defines the behavior of one or more elements of your library or framework, such as callables. When you run dataflow analysis, these models expand the potential sources and sinks tracked by dataflow analysis and improve the precision of results.

Many of the security queries search for paths from a source of untrusted input to a sink that represents a vulnerability. This is known as taint tracking. Each source is a starting point for dataflow analysis to track tainted data and each sink is an end point.

Taint tracking queries also need to know how data can flow through elements that are not included in the source code. These are modeled as summaries. A summary model enables queries to synthesize the flow behavior through elements in dependency code that is not stored in your repository.

Syntax used to define an element in an extension file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each model of an element is defined using a data extension where each tuple constitutes a model.
A data extension file to extend the standard CPP queries included with CodeQL is a YAML file with the form:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/cpp-all
         extensible: <name of extensible predicate>
       data:
         - <tuple1>
         - <tuple2>
         - ...

Each YAML file may contain one or more top-level extensions.

- ``addsTo`` defines the CodeQL pack name and extensible predicate that the extension is injected into.
- ``data`` defines one or more rows of tuples that are injected as values into the extensible predicate. The number of columns and their types must match the definition of the extensible predicate.

Data extensions use union semantics, which means that the tuples of all extensions for a single extensible predicate are combined, duplicates are removed, and all of the remaining tuples are queryable by referencing the extensible predicate.

Publish data extension files in a CodeQL model pack to share
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can group one or more data extension files into a CodeQL model pack and publish it to the GitHub Container Registry. This makes it easy for anyone to download the model pack and use it to extend their analysis. For more information, see `Creating a CodeQL model pack <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack>`__ and `Publishing and using CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/publishing-and-using-codeql-packs/>`__ in the CodeQL CLI documentation.

Extensible predicates used to create custom models in C and C++
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The CodeQL library for CPP analysis exposes the following extensible predicates:

- ``sourceModel(namespace, type, subtypes, name, signature, ext, output, kind, provenance)``. This is used to model sources of potentially tainted data. The ``kind`` of the sources defined using this predicate determine which threat model they are associated with. Different threat models can be used to customize the sources used in an analysis. For more information, see ":ref:`Threat models <threat-models-cpp>`."
- ``sinkModel(namespace, type, subtypes, name, signature, ext, input, kind, provenance)``. This is used to model sinks where tainted data may be used in a way that makes the code vulnerable.
- ``summaryModel(namespace, type, subtypes, name, signature, ext, input, output, kind, provenance)``. This is used to model flow through elements.

The extensible predicates are populated using the models defined in data extension files.

Example of custom model definitions
------------------------------------

The examples in this section are taken from the standard CodeQL CPP query pack published by GitHub. They demonstrate how to add tuples to extend extensible predicates that are used by the standard queries.

Example: Taint source from the ``boost::asio`` namespace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example shows how the CPP query pack models the return value from the ``read_until`` function as a ``remote`` source.

.. code-block:: cpp

   boost::asio::read_until(socket, recv_buffer, '\0', error);

We need to add a tuple to the ``sourceModel``\(namespace, type, subtypes, name, signature, ext, output, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/cpp-all
         extensible: sourceModel
       data:
         - ["boost::asio", "", False, "read_until", "", "", "Argument[*1]", "remote", "manual"]

Since we are adding a new source, we need to add a tuple to the ``sourceModel`` extensible predicate.
The first five values identify the callable (in this case a free function) to be modeled as a source.

- The first value ``"boost::asio"`` is the namespace name.
- The second value ``""`` is the name of the type (class) that contains the method. Because we're modelling a free function, the type is left blank.
- The third value ``False`` is a flag that indicates whether or not the sink also applies to all overrides of the method. For a free function, this should be ``False``.
- The fourth value ``"read_until"`` is the function name.
- The fifth value is the function input type signature, which can be used to narrow down between functions that have the same name. In this case, we want the model to include all functions in ``boost::asio`` called ``read_until``.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the output specification, the ``kind``, and the ``provenance`` (origin) of the source.

- The seventh value ``"Argument[*1]"`` is the output specification, which means in this case that the sink is the first indirection (or pointed-to value, ``*``) of the second argument (``Argument[1]``) passed to the function.
- The eighth value ``"remote"`` is the kind of the source. The source kind is used to define the threat model where the source is in scope. ``remote`` applies to many of the security related queries as it means a remote source of untrusted data. For more information, see ":ref:`Threat models <threat-models-cpp>`."
- The ninth value ``"manual"`` is the provenance of the source, which is used to identify the origin of the source model.

Example: Taint sink in the ``boost::asio`` namespace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example shows how the CPP query pack models the second argument of the ``boost::asio::write`` function as a remote flow sink. A remote flow sink is where data is transmitted to other machines across a network, which is used for example by the "Cleartext transmission of sensitive information" (`cpp/cleartext-transmission`) query.

.. code-block:: cpp

   boost::asio::write(socket, send_buffer, error);

We need to add a tuple to the ``sinkModel``\(namespace, type, subtypes, name, signature, ext, input, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/cpp-all
         extensible: sinkModel
       data:
         - ["boost::asio", "", False, "write", "", "", "Argument[*1]", "remote-sink", "manual"]

Since we want to add a new sink, we need to add a tuple to the ``sinkModel`` extensible predicate.
The first five values identify the callable (in this case a free function) to be modeled as a sink.

- The first value ``"boost::asio"`` is the namespace name.
- The second value ``""`` is the name of the type (class) that contains the method. Because we're modelling a free function, the type is left blank.
- The third value ``False`` is a flag that indicates whether or not the sink also applies to all overrides of the method. For a free function, this should be ``False``.
- The fourth value ``"write"`` is the function name.
- The fifth value is the function input type signature, which can be used to narrow down between functions that have the same name. In this case, we want the model to include all functions in ``boost::asio`` called ``write``.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the output specification, the ``kind``, and the ``provenance`` (origin) of the sink.

- The seventh value ``"Argument[*1]"`` is the output specification, which means in this case that the sink is the first indirection (or pointed-to value, ``*``) of the second argument (``Argument[1]``) passed to the function.
- The eighth value ``"remote-sink"`` is the kind of the sink. The sink kind is used to define the queries where the sink is in scope.
- The ninth value ``"manual"`` is the provenance of the sink, which is used to identify the origin of the sink model.

Example: Add flow through the ``boost::asio::buffer`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example shows how the CPP query pack models flow through a function for a simple case.

.. code-block:: cpp

   boost::asio::write(socket, boost::asio::buffer(send_str), error);

We need to add tuples to the ``summaryModel``\(namespace, type, subtypes, name, signature, ext, input, output, kind, provenance) extensible predicate by updating a data extension file:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/cpp-all
         extensible: summaryModel
       data:
         - ["boost::asio", "", False, "buffer", "", "", "Argument[*0]", "ReturnValue", "taint", "manual"]

Since we are adding flow through a function, we need to add tuples to the ``summaryModel`` extensible predicate.

The first five values identify the callable (in this case free function) to be modeled as a summary.

- The first value ``"boost::asio"`` is the namespace name.
- The second value ``""`` is the name of the type (class) that contains the method. Because we're modelling a free function, the type is left blank.
- The third value ``False`` is a flag that indicates whether or not the sink also applies to all overrides of the method. For a free function, this should be ``False``.
- The fourth value ``"buffer"`` is the function name.
- The fifth value is the function input type signature, which can be used to narrow down between functions that have the same name. In this case, we want the model to include all functions in ``boost::asio`` called ``buffer``.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the input and output specifications, the ``kind``, and the ``provenance`` (origin) of the summary.

- The seventh value is the input specification (where data flows from). ``Argument[*0]`` specifies the first indirection (or pointed-to value, ``*``) of the first argument (``Argument[0]``) passed to the function.
- The eighth value ``"ReturnValue"`` is the output specification (where data flows to), in this case the return value.
- The ninth value ``"taint"`` is the kind of the flow. ``taint`` means that taint is propagated through the call.
- The tenth value ``"manual"`` is the provenance of the summary, which is used to identify the origin of the summary model.

.. _threat-models-cpp:

Threat models
-------------

.. include:: ../reusables/threat-model-description.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-ruby.rst
.. _analyzing-data-flow-in-ruby:

Analyzing data flow in Ruby
=============================

You can use CodeQL to track the flow of data through a Ruby program to places where the data is used.

About this article
------------------

This article describes how data flow analysis is implemented in the CodeQL libraries for Ruby and includes examples to help you write your own data flow queries.
The following sections describe how to use the libraries for local data flow, global data flow, and taint tracking.
For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

.. include:: ../reusables/new-data-flow-api.rst

Local data flow
---------------

Local data flow tracks the flow of data within a single method or callable. Local data flow is easier, faster, and more precise than global data flow. Before looking at more complex tracking, you should always consider local tracking because it is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

You can use the local data flow library by importing the ``DataFlow`` module. The library uses the class ``Node`` to represent any element through which data can flow.
``Node``\ s are divided into expression nodes (``ExprNode``) and parameter nodes (``ParameterNode``).
You can map a data flow ``ParameterNode`` to its corresponding ``Parameter`` AST node using the ``asParameter`` member predicate.
Similarly, you can use the ``asExpr`` member predicate to map a data flow ``ExprNode`` to its corresponding ``ExprCfgNode`` in the control-flow library.

.. code-block:: ql

     class Node {
       /** Gets the expression corresponding to this node, if any. */
       CfgNodes::ExprCfgNode asExpr() { ... }

       /** Gets the parameter corresponding to this node, if any. */
       Parameter asParameter() { ... }

      ...
     }

You can use the predicates ``exprNode`` and ``parameterNode`` to map from expressions and parameters to their data-flow node:

.. code-block:: ql

     /**
      * Gets a node corresponding to expression `e`.
      */
     ExprNode exprNode(CfgNodes::ExprCfgNode e) { ... }

     /**
      * Gets the node corresponding to the value of parameter `p` at function entry.
      */
     ParameterNode parameterNode(Parameter p) { ... }

Note that since ``asExpr`` and ``exprNode`` map between data-flow and control-flow nodes, you then need to call the ``getExpr`` member predicate on the control-flow node to map to the corresponding AST node,
for example, by writing ``node.asExpr().getExpr()``.
A control-flow graph considers every way control can flow through code, consequently, there can be multiple data-flow and control-flow nodes associated with a single expression node in the AST.

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``.
You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localFlow``.

For example, you can find flow from an expression ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     DataFlow::localFlow(source, sink)

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow to include flow steps where values are not preserved, for example, string manipulation.
For example:

.. code-block:: ruby

     temp = x
     y = temp + ", " + temp

If ``x`` is a tainted string then ``y`` is also tainted.

The local taint tracking library is in the module ``TaintTracking``.
Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``.
You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localTaint``.

For example, you can find taint propagation from an expression ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     TaintTracking::localTaint(source, sink)


Using local sources
~~~~~~~~~~~~~~~~~~~

When exploring local data flow or taint propagation between two expressions as above, you would normally constrain the expressions to be relevant to your investigation.
The next section gives some concrete examples, but first it's helpful to introduce the concept of a local source.

A local source is a data-flow node with no local data flow into it.
As such, it is a local origin of data flow, a place where a new value is created.
This includes parameters (which only receive values from global data flow) and most expressions (because they are not value-preserving).
The class ``LocalSourceNode`` represents data-flow nodes that are also local sources.
It comes with a useful member predicate ``flowsTo(DataFlow::Node node)``, which holds if there is local data flow from the local source to ``node``.

Examples of local data flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~

This query finds the filename argument passed in each call to ``File.open``:

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call
    where call = API::getTopLevelMember("File").getAMethodCall("open")
    select call.getArgument(0)

Notice the use of the ``API`` module for referring to library methods.
For more information, see ":doc:`Using API graphs in Ruby <using-api-graphs-in-ruby>`."

Unfortunately this will only give the expression in the argument, not the values which could be passed to it.
So we use local data flow to find all expressions that flow into the argument:

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call, DataFlow::ExprNode expr
    where
      call = API::getTopLevelMember("File").getAMethodCall("open") and
      DataFlow::localFlow(expr, call.getArgument(0))
    select call, expr

Many expressions flow to the same call.
If you run this query, you may notice that you get several data-flow nodes for an expression as it flows towards a call (notice repeated locations in the ``call`` column).
We are mostly interested in the "first" of these, what might be called the local source for the file name.
To restrict the results to local sources for the file name, and to simultaneously make the analysis more efficient, we can use the CodeQL class ``LocalSourceNode``.
We can update the query to specify that ``expr`` is an instance of a ``LocalSourceNode``.

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call, DataFlow::ExprNode expr
    where
      call = API::getTopLevelMember("File").getAMethodCall("open") and
      DataFlow::localFlow(expr, call.getArgument(0)) and
      expr instanceof DataFlow::LocalSourceNode
    select call, expr

An alternative approach to limit the results to local sources for the file name is to enforce this by casting.
That would allow us to use the member predicate ``flowsTo`` on ``LocalSourceNode`` like so:

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call, DataFlow::ExprNode expr
    where
      call = API::getTopLevelMember("File").getAMethodCall("open") and
      expr.(DataFlow::LocalSourceNode).flowsTo(call.getArgument(0))
    select call, expr

As an alternative, we can ask more directly that ``expr`` is a local source of the first argument, via the predicate ``getALocalSource``:

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call, DataFlow::ExprNode expr
    where
      call = API::getTopLevelMember("File").getAMethodCall("open") and
      expr = call.getArgument(0).getALocalSource()
    select call, expr

All these three queries give identical results.
We now mostly have one expression per call.

We may still have cases of more than one expression flowing to a call, but then they flow through different code paths (possibly due to control-flow splitting).

We might want to make the source more specific, for example, a parameter to a method or block.
This query finds instances where a parameter is used as the name when opening a file:

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call, DataFlow::ParameterNode p
    where
      call = API::getTopLevelMember("File").getAMethodCall("open") and
      DataFlow::localFlow(p, call.getArgument(0))
    select call, p

Using the exact name supplied via the parameter may be too strict.
If we want to know if the parameter influences the file name, we can use taint tracking instead of data flow.
This query finds calls to ``File.open`` where the file name is derived from a parameter:

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.TaintTracking
    import codeql.ruby.ApiGraphs

    from DataFlow::CallNode call, DataFlow::ParameterNode p
    where
      call = API::getTopLevelMember("File").getAMethodCall("open") and
      TaintTracking::localTaint(p, call.getArgument(0))
    select call, p

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow.
However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

You can use the global data flow library by implementing the signature ``DataFlow::ConfigSig`` and applying the module ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import codeql.ruby.DataFlow

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = DataFlow::Global<MyFlowConfiguration>;

These predicates are defined in the configuration:

-  ``isSource`` - defines where data may flow from.
-  ``isSink`` - defines where data may flow to.
-  ``isBarrier`` - optionally, restricts the data flow.
-  ``isAdditionalFlowStep`` - optionally, adds additional flow steps.

The data flow analysis is performed using the predicate ``flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyFlow::flow(source, sink)
   select source, "Dataflow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow what local taint tracking is to local data flow.
That is, global taint tracking extends global data flow with additional non-value-preserving steps.
The global taint tracking library is used by applying the module ``TaintTracking::Global<ConfigSig>`` to your configuration instead of ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import codeql.ruby.DataFlow
   import codeql.ruby.TaintTracking

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = TaintTracking::Global<MyFlowConfiguration>;

The resulting module has an identical signature to the one obtained from ``DataFlow::Global<ConfigSig>``.

Predefined sources and sinks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The data flow library contains a number of predefined sources and sinks, providing a good starting point for defining data flow based security queries.

-  The class ``RemoteFlowSource`` (defined in module ``codeql.ruby.dataflow.RemoteFlowSources``) represents data flow from remote network inputs. This is useful for finding security problems in networked services.
-  The library ``Concepts`` (defined in module ``codeql.ruby.Concepts``) contains several subclasses of ``DataFlow::Node`` that are security relevant, such as ``FileSystemAccess`` and ``SqlExecution``.

For global flow, it is also useful to restrict sources to instances of ``LocalSourceNode``.
The predefined sources generally do that.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``DataFlow::Node`` - an element behaving as a data-flow node.
    -  ``DataFlow::LocalSourceNode`` - a local origin of data, as a data-flow node.
    -  ``DataFlow::ExprNode`` - an expression behaving as a data-flow node.
    -  ``DataFlow::ParameterNode`` - a parameter data-flow node representing the value of a parameter at method/block entry.

    -  ``RemoteFlowSource`` - data flow from network/remote input.
    -  ``Concepts::SystemCommandExecution`` - a data-flow node that executes an operating system command, for instance by spawning a new process.
    -  ``Concepts::FileSystemAccess`` - a data-flow node that performs a file system access, including reading and writing data, creating and deleting files and folders, checking and updating permissions, and so on.
    -  ``Concepts::Path::PathNormalization`` - a data-flow node that performs path normalization. This is often needed in order to safely access paths.
    -  ``Concepts::CodeExecution`` - a data-flow node that dynamically executes Ruby code.
    -  ``Concepts::SqlExecution`` - a data-flow node that executes SQL statements.
    -  ``Concepts::HTTP::Server::RouteSetup`` - a data-flow node that sets up a route on a server.
    -  ``Concepts::HTTP::Server::HttpResponse`` - a data-flow node that creates an HTTP response on a server.

Examples of global data flow
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The following global taint-tracking query finds path arguments in filesystem accesses that can be controlled by a remote user.
  - Since this is a taint-tracking query, the ``TaintTracking::Global<ConfigSig>`` module is used.
  - The ``isSource`` predicate defines sources as any data-flow nodes that are instances of ``RemoteFlowSource``.
  - The ``isSink`` predicate defines sinks as path arguments in any filesystem access, using ``FileSystemAccess`` from the ``Concepts`` library.

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.TaintTracking
    import codeql.ruby.Concepts
    import codeql.ruby.dataflow.RemoteFlowSources

    module RemoteToFileConfiguration implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node source) { source instanceof RemoteFlowSource }

      predicate isSink(DataFlow::Node sink) {
        sink = any(FileSystemAccess fa).getAPathArgument()
      }
    }

    module RemoteToFileFlow = TaintTracking::Global<RemoteToFileConfiguration>;

    from DataFlow::Node input, DataFlow::Node fileAccess
    where RemoteToFileFlow::flow(input, fileAccess)
    select fileAccess, "This file access uses data from $@.", input, "user-controllable input."

The following global data-flow query finds calls to ``File.open`` where the filename argument comes from an environment variable.
  - Since this is a data-flow query, the ``DataFlow::Global<ConfigSig>`` module is used.
  - The ``isSource`` predicate defines sources as expression nodes representing lookups on the ``ENV`` hash.
  - The ``isSink`` predicate defines sinks as the first argument in any call to ``File.open``.

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.controlflow.CfgNodes
    import codeql.ruby.ApiGraphs

    module EnvironmentToFileConfiguration implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node source) {
        exists(ExprNodes::ConstantReadAccessCfgNode env |
          env.getExpr().getName() = "ENV" and
          env = source.asExpr().(ExprNodes::ElementReferenceCfgNode).getReceiver()
        )
      }

      predicate isSink(DataFlow::Node sink) {
        sink = API::getTopLevelMember("File").getAMethodCall("open").getArgument(0)
      }
    }

    module EnvironmentToFileFlow = DataFlow::Global<EnvironmentToFileConfiguration>;

    from DataFlow::Node environment, DataFlow::Node fileOpen
    where EnvironmentToFileFlow::flow(environment, fileOpen)
    select fileOpen, "This call to 'File.open' uses data from $@.", environment,
      "an environment variable"

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/ruby-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-csharp.rst
.. _codeql-for-csharp:

CodeQL for C#
=============

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from C# codebases.

.. toctree::
   :hidden:

   basic-query-for-csharp-code
   codeql-library-for-csharp
   analyzing-data-flow-in-csharp
   customizing-library-models-for-csharp

-  :doc:`Basic query for C# code <basic-query-for-csharp-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for C# <codeql-library-for-csharp>`: When you're analyzing a C# program, you can make use of the large collection of classes in the CodeQL library for C#.

-  :doc:`Analyzing data flow in C# <analyzing-data-flow-in-csharp>`: You can use CodeQL to track the flow of data through a C# program to its use.

-  :doc:`Customizing library models for C# <customizing-library-models-for-csharp>`: You can model frameworks and libraries that your codebase depends on using data extensions and publish them as CodeQL model packs.




# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-cpp-code.rst
.. _basic-query-for-cpp-code:

Basic query for C and C++ code
==============================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run performs a basic search of the code for ``if`` statements that are redundant, in the sense that they have an empty then branch. For example, code such as:

.. code-block:: cpp

   if (error) { }

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete ``select ""`` and paste the following query beneath the import statement ``import cpp``.

   .. code-block:: ql

      from IfStmt ifstmt, BlockStmt block
      where ifstmt.getThen() = block and
        block.getNumStmt() = 0
      select ifstmt, "This 'if' statement is redundant."

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-cpp-query-results-1.png
   :align: center

If any matching code is found, click a link in the ``ifstmt`` column to open the file and highlight the matching ``if`` statement.

.. image:: ../images/codeql-for-visual-studio-code/basic-cpp-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| Query part                                                    | Purpose                                                                                                           | Details                                                                                                                |
+===============================================================+===================================================================================================================+========================================================================================================================+
| ``import cpp``                                                | Imports the standard CodeQL libraries for C/C++.                                                                  | Every query begins with one or more ``import`` statements.                                                             |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``from IfStmt ifstmt, BlockStmt block``                       | Defines the variables for the query.                                                                              | We use:                                                                                                                |
|                                                               | Declarations are of the form:                                                                                     |                                                                                                                        |
|                                                               | ``<type> <variable name>``                                                                                        | - an ``IfStmt`` variable for ``if`` statements                                                                         |
|                                                               |                                                                                                                   | - a ``BlockStmt`` variable for the statement block                                                                     |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``where ifstmt.getThen() = block and block.getNumStmt() = 0`` | Defines a condition on the variables.                                                                             | ``ifstmt.getThen() = block`` relates the two variables. The block must be the ``then`` branch of the ``if`` statement. |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               |                                                                                                                   | ``block.getNumStmt() = 0`` states that the block must be empty (that is, it contains no statements).                   |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``select ifstmt, "This 'if' statement is redundant."``        | Defines what to report for each match.                                                                            | Reports the resulting ``if`` statement with a string that explains the problem.                                        |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                                        |
|                                                               | ``select <program element>, "<alert message>"``                                                                   |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find examples of ``if`` statements with an ``else`` branch, where an empty ``then`` branch does serve a purpose. For example:

.. code-block:: cpp

   if (...) {
     ...
   } else if (!strcmp(option, "-verbose")) {
     // nothing to do - handled earlier
   } else {
     error("unrecognized option");
   }

In this case, identifying the ``if`` statement with the empty ``then`` branch as redundant is a false positive. One solution to this is to modify the query to ignore empty ``then`` branches if the ``if`` statement has an ``else`` branch.

To exclude ``if`` statements that have an ``else`` branch:

#. Edit your query and extend the ``where`` clause to include the following extra condition:

   .. code-block:: ql

      and not ifstmt.hasElse()

   The ``where`` clause is now:

   .. code-block:: ql

      where ifstmt.getThen() = block and
        block.getNumStmt() = 0 and
        not ifstmt.hasElse()

#. Re-run the query.

   There are now fewer results because ``if`` statements with an ``else`` branch are no longer reported.

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: C/C++

.. |language-code| replace:: ``cpp``

.. |example-url| replace:: https://github.com/protocolbuffers/protobuf

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-cpp.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``ifstmt`` and is linked to the location in the source code of the project where ``ifstmt`` occurs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-java.rst
.. _codeql-library-for-java:

CodeQL library for Java and Kotlin
==================================

When you're analyzing a Java/Kotlin program, you can make use of the large collection of classes in the CodeQL library for Java/Kotlin.

About the CodeQL library for Java and Kotlin
--------------------------------------------

There is an extensive library for analyzing CodeQL databases extracted from Java/Kotlin projects. The classes in this library present the data from a database in an object-oriented form and provide abstractions and predicates to help you with common analysis tasks.

The library is implemented as a set of QL modules, that is, files with the extension ``.qll``. The module ``java.qll`` imports all the core Java library modules, so you can include the complete library by beginning your query with:

.. code-block:: ql

   import java

The rest of this article briefly summarizes the most important classes and predicates provided by this library.

.. pull-quote::

   Note

   The example queries in this article illustrate the types of results returned by different library classes. The results themselves are not interesting but can be used as the basis for developing a more complex query. The other articles in this section of the help show how you can take a simple query and fine-tune it to find precisely the results you're interested in.

Summary of the library classes
------------------------------

The most important classes in the standard Java/Kotlin library can be grouped into five main categories:

#. Classes for representing program elements (such as classes and methods)
#. Classes for representing AST nodes (such as statements and expressions)
#. Classes for representing metadata (such as annotations and comments)
#. Classes for computing metrics (such as cyclomatic complexity and coupling)
#. Classes for navigating the program's call graph

We will discuss each of these in turn, briefly describing the most important classes for each category.

Program elements
----------------

These classes represent named program elements: packages (``Package``), compilation units (``CompilationUnit``), types (``Type``), methods (``Method``), constructors (``Constructor``), and variables (``Variable``).

Their common superclass is ``Element``, which provides general member predicates for determining the name of a program element and checking whether two elements are nested inside each other.

It's often convenient to refer to an element that might either be a method or a constructor; the class ``Callable``, which is a common superclass of ``Method`` and ``Constructor``, can be used for this purpose.

Types
~~~~~

Class ``Type`` has a number of subclasses for representing different kinds of types:

-  ``PrimitiveType`` represents a `primitive type <https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html>`__, that is, one of ``boolean``, ``byte``, ``char``, ``double``, ``float``, ``int``, ``long``, ``short``; QL also classifies ``void`` and ``<nulltype>`` (the type of the ``null`` literal) as primitive types.
-  ``RefType`` represents a reference (that is, non-primitive) type; it in turn has several subclasses:

   -  ``Class`` represents a Java class.
   -  ``Interface`` represents a Java interface.
   -  ``EnumType`` represents a Java ``enum`` type.
   -  ``Array`` represents a Java array type.

For example, the following query finds all variables of type ``int`` in the program:

.. code-block:: ql

   import java

   from Variable v, PrimitiveType pt
   where pt = v.getType() and
       pt.hasName("int")
   select v

You're likely to get many results when you run this query because most projects contain many variables of type ``int``.

Reference types are also categorized according to their declaration scope:

-  ``TopLevelType`` represents a reference type declared at the top-level of a compilation unit.
-  ``NestedType`` is a type declared inside another type.

For instance, this query finds all top-level types whose name is not the same as that of their compilation unit:

.. code-block:: ql

   import java

   from TopLevelType tl
   where tl.getName() != tl.getCompilationUnit().getName()
   select tl

You will typically see this pattern in the source code of a repository, with many more instances in the files referenced by the source code.

Several more specialized classes are available as well:

-  ``TopLevelClass`` represents a class declared at the top-level of a compilation unit.
-  ``NestedClass`` represents `a class declared inside another type <https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html>`__, such as:

   -  A ``LocalClass``, which is `a class declared inside a method or constructor <https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html>`__.
   -  An ``AnonymousClass``, which is an `anonymous class <https://docs.oracle.com/javase/tutorial/java/javaOO/anonymousclasses.html>`__.

Finally, the library also has a number of singleton classes that wrap frequently used Java standard library classes: ``TypeObject``, ``TypeCloneable``, ``TypeRuntime``, ``TypeSerializable``, ``TypeString``, ``TypeSystem`` and ``TypeClass``. Each CodeQL class represents the standard Java class suggested by its name.

As an example, we can write a query that finds all nested classes that directly extend ``Object``:

.. code-block:: ql

   import java

   from NestedClass nc
   where nc.getASupertype() instanceof TypeObject
   select nc

You're likely to get many results when you run this query because many projects include nested classes that extend ``Object`` directly.

Generics
~~~~~~~~

There are also several subclasses of ``Type`` for dealing with generic types.

A ``GenericType`` is either a ``GenericInterface`` or a ``GenericClass``. It represents a generic type declaration such as interface ``java.util.Map`` from the Java standard library:

.. code-block:: java

   package java.util.;

   public interface Map<K, V> {
       int size();

       // ...
   }

Type parameters, such as ``K`` and ``V`` in this example, are represented by class ``TypeVariable``.

A parameterized instance of a generic type provides a concrete type to instantiate the type parameter with, as in ``Map<String, File>``. Such a type is represented by a ``ParameterizedType``, which is distinct from the ``GenericType`` representing the generic type it was instantiated from. To go from a ``ParameterizedType`` to its corresponding ``GenericType``, you can use predicate ``getSourceDeclaration``.

For instance, we could use the following query to find all parameterized instances of ``java.util.Map``:

.. code-block:: ql

   import java

   from GenericInterface map, ParameterizedType pt
   where map.hasQualifiedName("java.util", "Map") and
       pt.getSourceDeclaration() = map
   select pt

In general, generic types may restrict which types a type parameter can be bound to. For instance, a type of maps from strings to numbers could be declared as follows:

.. code-block:: java

   class StringToNumMap<N extends Number> implements Map<String, N> {
       // ...
   }

This means that a parameterized instance of ``StringToNumberMap`` can only instantiate type parameter ``N`` with type ``Number`` or one of its subtypes but not, for example, with ``File``. We say that N is a bounded type parameter, with ``Number`` as its upper bound. In QL, a type variable can be queried for its type bound using predicate ``getATypeBound``. The type bounds themselves are represented by class ``TypeBound``, which has a member predicate ``getType`` to retrieve the type the variable is bounded by.

As an example, the following query finds all type variables with type bound ``Number``:

.. code-block:: ql

   import java

   from TypeVariable tv, TypeBound tb
   where tb = tv.getATypeBound() and
       tb.getType().hasQualifiedName("java.lang", "Number")
   select tv

For dealing with legacy code that is unaware of generics, every generic type has a "raw" version without any type parameters. In the CodeQL libraries, raw types are represented using class ``RawType``, which has the expected subclasses ``RawClass`` and ``RawInterface``. Again, there is a predicate ``getSourceDeclaration`` for obtaining the corresponding generic type. As an example, we can find variables of (raw) type ``Map``:

.. code-block:: ql

   import java

   from Variable v, RawType rt
   where rt = v.getType() and
       rt.getSourceDeclaration().hasQualifiedName("java.util", "Map")
   select v

For example, in the following code snippet this query would find ``m1``, but not ``m2``:

.. code-block:: java

   Map m1 = new HashMap();
   Map<String, String> m2 = new HashMap<String, String>();

Finally, variables can be declared to be of a `wildcard type <https://docs.oracle.com/javase/tutorial/java/generics/wildcards.html>`__:

.. code-block:: java

   Map<? extends Number, ? super Float> m;

The wildcards ``? extends Number`` and ``? super Float`` are represented by class ``WildcardTypeAccess``. Like type parameters, wildcards may have type bounds. Unlike type parameters, wildcards can have upper bounds (as in ``? extends Number``), and also lower bounds (as in ``? super Float``). Class ``WildcardTypeAccess`` provides member predicates ``getUpperBound`` and ``getLowerBound`` to retrieve the upper and lower bounds, respectively.

For dealing with generic methods, there are classes ``GenericMethod``, ``ParameterizedMethod`` and ``RawMethod``, which are entirely analogous to the like-named classes for representing generic types.

For more information on working with types, see the :doc:`Types in Java and Kotlin <types-in-java>`.

Variables
~~~~~~~~~

Class ``Variable`` represents a variable `in the Java sense <https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html>`__, which is either a member field of a class (whether static or not), or a local variable, or a parameter. Consequently, there are three subclasses catering to these special cases:

-  ``Field`` represents a Java field.
-  ``LocalVariableDecl`` represents a local variable.
-  ``Parameter`` represents a parameter of a method or constructor.

Abstract syntax tree
--------------------

Classes in this category represent abstract syntax tree (AST) nodes, that is, statements (class ``Stmt``) and expressions (class ``Expr``). For a full list of expression and statement types available in the standard QL library, see ":doc:`Abstract syntax tree classes for working with Java and Kotlin programs <abstract-syntax-tree-classes-for-working-with-java-programs>`."

Both ``Expr`` and ``Stmt`` provide member predicates for exploring the abstract syntax tree of a program:

-  ``Expr.getAChildExpr`` returns a sub-expression of a given expression.
-  ``Stmt.getAChild`` returns a statement or expression that is nested directly inside a given statement.
-  ``Expr.getParent`` and ``Stmt.getParent`` return the parent node of an AST node.

For example, the following query finds all expressions whose parents are ``return`` statements:

.. code-block:: ql

   import java

   from Expr e
   where e.getParent() instanceof ReturnStmt
   select e

Many projects have examples of ``return`` statements with child expressions.

Therefore, if the program contains a return statement ``return x + y;``, this query will return ``x + y``.

As another example, the following query finds statements whose parent is an ``if`` statement:

.. code-block:: ql

   import java

   from Stmt s
   where s.getParent() instanceof IfStmt
   select s

Many projects have examples of ``if`` statements with child statements.

This query will find both ``then`` branches and ``else`` branches of all ``if`` statements in the program.

Finally, here is a query that finds method bodies:

.. code-block:: ql

   import java

   from Stmt s
   where s.getParent() instanceof Method
   select s

As these examples show, the parent node of an expression is not always an expression: it may also be a statement, for example, an ``IfStmt``. Similarly, the parent node of a statement is not always a statement: it may also be a method or a constructor. To capture this, the QL Java library provides two abstract class ``ExprParent`` and ``StmtParent``, the former representing any node that may be the parent node of an expression, and the latter any node that may be the parent node of a statement.

For more information on working with AST classes, see the :doc:`article on overflow-prone comparisons in Java and Kotlin <overflow-prone-comparisons-in-java>`.

Metadata
--------

Java/Kotlin programs have several kinds of metadata, in addition to the program code proper. In particular, there are `annotations <https://docs.oracle.com/javase/tutorial/java/annotations/>`__ and `Javadoc <https://en.wikipedia.org/wiki/Javadoc>`__ comments. Since this metadata is interesting both for enhancing code analysis and as an analysis subject in its own right, the QL library defines classes for accessing it.

For annotations, class ``Annotatable`` is a superclass of all program elements that can be annotated. This includes packages, reference types, fields, methods, constructors, and local variable declarations. For every such element, its predicate ``getAnAnnotation`` allows you to retrieve any annotations the element may have. For example, the following query finds all annotations on constructors:

.. code-block:: ql

   import java

   from Constructor c
   select c.getAnAnnotation()

You may see examples where annotations are used to suppress warnings or to mark code as deprecated.

These annotations are represented by class ``Annotation``. An annotation is simply an expression whose type is an ``AnnotationType``. For example, you can amend this query so that it only reports deprecated constructors:

.. code-block:: ql

   import java

   from Constructor c, Annotation ann, AnnotationType anntp
   where ann = c.getAnAnnotation() and
       anntp = ann.getType() and
       anntp.hasQualifiedName("java.lang", "Deprecated")
   select ann

Only constructors with the ``@Deprecated`` annotation are reported this time.

For more information on working with annotations, see the :doc:`article on annotations <annotations-in-java>`.

For Javadoc, class ``Element`` has a member predicate ``getDoc`` that returns a delegate ``Documentable`` object, which can then be queried for its attached Javadoc comments. For example, the following query finds Javadoc comments on private fields:

.. code-block:: ql

   import java

   from Field f, Javadoc jdoc
   where f.isPrivate() and
       jdoc = f.getDoc().getJavadoc()
   select jdoc

You can see this pattern in many projects.

Class ``Javadoc`` represents an entire Javadoc comment as a tree of ``JavadocElement`` nodes, which can be traversed using member predicates ``getAChild`` and ``getParent``. For instance, you could edit the query so that it finds all ``@author`` tags in Javadoc comments on private fields:

.. code-block:: ql

   import java

   from Field f, Javadoc jdoc, AuthorTag at
   where f.isPrivate() and
       jdoc = f.getDoc().getJavadoc() and
       at.getParent+() = jdoc
   select at

.. pull-quote::

   Note

   On line 5 we used ``getParent+`` to capture tags that are nested at any depth within the Javadoc comment.

For more information on working with Javadoc, see the :doc:`article on Javadoc <javadoc>`.

Metrics
-------

The standard QL Java library provides extensive support for computing metrics on Java program elements. To avoid overburdening the classes representing those elements with too many member predicates related to metric computations, these predicates are made available on delegate classes instead.

Altogether, there are six such classes: ``MetricElement``, ``MetricPackage``, ``MetricRefType``, ``MetricField``, ``MetricCallable``, and ``MetricStmt``. The corresponding element classes each provide a member predicate ``getMetrics`` that can be used to obtain an instance of the delegate class, on which metric computations can then be performed.

For example, the following query finds methods with a `cyclomatic complexity <https://en.wikipedia.org/wiki/Cyclomatic_complexity>`__ greater than 40:

.. code-block:: ql

   import java

   from Method m, MetricCallable mc
   where mc = m.getMetrics() and
       mc.getCyclomaticComplexity() > 40
   select m

Most large projects include some methods with a very high cyclomatic complexity. These methods are likely to be difficult to understand and test.

Call graph
----------

CodeQL databases generated from Java and Kotlin code bases include precomputed information about the program's call graph, that is, which methods or constructors a given call may dispatch to at runtime.

The class ``Callable``, introduced above, includes both methods and constructors. Call expressions are abstracted using class ``Call``, which includes method calls, ``new`` expressions, and explicit constructor calls using ``this`` or ``super``.

We can use predicate ``Call.getCallee`` to find out which method or constructor a specific call expression refers to. For example, the following query finds all calls to methods called ``println``:

.. code-block:: ql

   import java

   from Call c, Method m
   where m = c.getCallee() and
       m.hasName("println")
   select c

Conversely, ``Callable.getAReference`` returns a ``Call`` that refers to it. So we can find methods and constructors that are never called using this query:

.. code-block:: ql

   import java

   from Callable c
   where not exists(c.getAReference())
   select c

Codebases often have many methods that are not called directly, but this is unlikely to be the whole story. To explore this area further, see ":doc:`Navigating the call graph <navigating-the-call-graph>`."

For more information about callables and calls, see the :doc:`article on the call graph <navigating-the-call-graph>`.

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-ruby.rst
.. _codeql-for-ruby:

CodeQL for Ruby
===============

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from Ruby codebases.

.. toctree::
   :hidden:

   basic-query-for-ruby-code
   codeql-library-for-ruby
   abstract-syntax-tree-classes-for-working-with-ruby-programs
   analyzing-data-flow-in-ruby
   using-api-graphs-in-ruby
   customizing-library-models-for-ruby

-  :doc:`Basic query for Ruby code <basic-query-for-ruby-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for Ruby <codeql-library-for-ruby>`: When you're analyzing a Ruby program, you can make use of the large collection of classes in the CodeQL library for Ruby.

-  :doc:`Analyzing data flow in Ruby <analyzing-data-flow-in-ruby>`: You can use CodeQL to track the flow of data through a Ruby program to places where the data is used.

-  :doc:`Using API graphs in Ruby <using-api-graphs-in-ruby>`: API graphs are a uniform interface for referring to functions, classes, and methods defined in external libraries.

-  :doc:`Abstract syntax tree classes for working with Ruby programs <abstract-syntax-tree-classes-for-working-with-ruby-programs>`: CodeQL has a large selection of classes for representing the abstract syntax tree of Ruby programs.

-  :doc:`Customizing library models for Ruby <customizing-library-models-for-ruby>`: You can model frameworks and libraries that your codebase depends on using data extensions and publish them as CodeQL model packs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/expressions-types-and-statements-in-cpp.rst
.. _expressions-types-and-statements-in-cpp:

Expressions, types, and statements in C and C++
===============================================

You can use CodeQL to explore expressions, types, and statements in C and C++ code to find, for example, incorrect assignments.

Expressions and types in CodeQL
-------------------------------

Each part of an expression in C becomes an instance of the ``Expr`` class. For example, the C code ``x = x + 1`` becomes an ``AssignExpr``, an ``AddExpr``, two instances of ``VariableAccess`` and a ``Literal``. All of these CodeQL classes extend ``Expr``.

Finding assignments to zero
~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the following example we find instances of ``AssignExpr`` which assign the constant value zero:

.. code-block:: ql

   import cpp

   from AssignExpr e
   where e.getRValue().getValue().toInt() = 0
   select e, "Assigning the value 0 to something."

The ``where`` clause in this example gets the expression on the right side of the assignment, ``getRValue()``, and compares it with zero. Notice that there are no checks to make sure that the right side of the assignment is an integer or that it has a value (that is, it is compile-time constant, rather than a variable). For expressions where either of these assumptions is wrong, the associated predicate simply does not return anything and the ``where`` clause will not produce a result. You could think of it as if there is an implicit ``exists(e.getRValue().getValue().toInt())`` at the beginning of this line.

It is also worth noting that the query above would find this C code:

.. code-block:: cpp

   yPtr = NULL;

This is because the database contains a representation of the code base after the preprocessor transforms have run. This means that any macro invocations, such as the ``NULL`` define used here, are expanded during the creation of the database. If you want to write queries about macros then there are some special library classes that have been designed specifically for this purpose (for example, the ``Macro``, ``MacroInvocation`` classes and predicates like ``Element.isInMacroExpansion()``). In this case, it is good that macros are expanded, but we do not want to find assignments to pointers. For more information, see `Database creation <https://codeql.github.com/docs/codeql-overview/about-codeql/#database-creation>`__.

Finding assignments of 0 to an integer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can make the query more specific by defining a condition for the left side of the expression. For example:

.. code-block:: ql

   import cpp

   from AssignExpr e
   where e.getRValue().getValue().toInt() = 0
     and e.getLValue().getType().getUnspecifiedType() instanceof IntegralType
   select e, "Assigning the value 0 to an integer."

This checks that the left side of the assignment has a type that is some kind of integer. Note the call to ``Type.getUnspecifiedType()``. This resolves ``typedef`` types to their underlying types so that the query finds assignments like this one:

.. code-block:: cpp

   typedef int myInt;
   myInt i;

   i = 0;

Statements in CodeQL
--------------------

We can refine the query further using statements. In this case we use the class ``ForStmt``:

-  ``Stmt`` - C/C++ statements

   -  ``Loop``

      -  ``WhileStmt``
      -  ``ForStmt``
      -  ``DoStmt``

   -  ``ConditionalStmt``

      -  ``IfStmt``
      -  ``SwitchStmt``

   -  ``TryStmt``
   -  ``ExprStmt`` - expressions used as a statement; for example, an assignment
   -  ``Block`` - { } blocks containing more statements

Finding assignments of 0 in 'for' loop initialization
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can restrict the previous query so that it only considers assignments inside ``for`` statements by adding the ``ForStmt`` class to the query. Then we want to compare the expression to ``ForStmt.getInitialization()``:

.. code-block:: ql

   import cpp

   from AssignExpr e, ForStmt f
   // the assignment is the for loop initialization
   where e = f.getInitialization()
   ...

Unfortunately this would not quite work, because the loop initialization is actually a ``Stmt`` not an ``Expr``—the ``AssignExpr`` class is wrapped in an ``ExprStmt`` class. Instead, we need to find the closest enclosing ``Stmt`` around the expression using ``Expr.getEnclosingStmt()``:

.. code-block:: ql

   import cpp

   from AssignExpr e, ForStmt f
   // the assignment is in the 'for' loop initialization statement
   where e.getEnclosingStmt() = f.getInitialization()
     and e.getRValue().getValue().toInt() = 0
     and e.getLValue().getType().getUnspecifiedType() instanceof IntegralType
   select e, "Assigning the value 0 to an integer, inside a for loop initialization."

Finding assignments of 0 within the loop body
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We can find assignments inside the loop body using similar code with the predicate ``Loop.getStmt():``

.. code-block:: ql

   import cpp

   from AssignExpr e, ForStmt f
   // the assignment is in the for loop body
   where e.getEnclosingStmt().getParentStmt*() = f.getStmt()
     and e.getRValue().getValue().toInt() = 0
     and e.getLValue().getType().getUnderlyingType() instanceof IntegralType
   select e, "Assigning the value 0 to an integer, inside a for loop body."

Note that we replaced ``e.getEnclosingStmt()`` with ``e.getEnclosingStmt().getParentStmt*()``, to find an assignment expression that is deeply nested inside the loop body. The transitive closure modifier ``*`` here indicates that ``Stmt.getParentStmt()`` may be followed zero or more times, rather than just once, giving us the statement, its parent statement, its parent's parent statement etc.

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-java.rst
.. _analyzing-data-flow-in-java:

Analyzing data flow in Java and Kotlin
======================================

You can use CodeQL to track the flow of data through a Java/Kotlin program to its use.

.. include:: ../reusables/kotlin-java-differences.rst

About this article
------------------

This article describes how data flow analysis is implemented in the CodeQL libraries for Java/Kotlin and includes examples to help you write your own data flow queries.
The following sections describe how to use the libraries for local data flow, global data flow, and taint tracking.

For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

.. include:: ../reusables/new-data-flow-api.rst

Local data flow
---------------

Local data flow is data flow within a single method or callable. Local data flow is usually easier, faster, and more precise than global data flow, and is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

To use the data flow library you need the following import:

.. code-block:: ql

   import semmle.code.java.dataflow.DataFlow

The ``DataFlow`` module defines the class ``Node`` denoting any element that data can flow through. ``Node``\ s are divided into expression nodes (``ExprNode``) and parameter nodes (``ParameterNode``). You can map between data flow nodes and expressions/parameters using the member predicates ``asExpr`` and ``asParameter``:

.. code-block:: ql

   class Node {
     /** Gets the expression corresponding to this node, if any. */
     Expr asExpr() { ... }

     /** Gets the parameter corresponding to this node, if any. */
     Parameter asParameter() { ... }

     ...
   }

or using the predicates ``exprNode`` and ``parameterNode``:

.. code-block:: ql

   /**
    * Gets the node corresponding to expression `e`.
    */
   ExprNode exprNode(Expr e) { ... }

   /**
    * Gets the node corresponding to the value of parameter `p` at function entry.
    */
   ParameterNode parameterNode(Parameter p) { ... }

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``. You can apply the predicate recursively by using the ``+`` and ``*`` operators, or by using the predefined recursive predicate ``localFlow``, which is equivalent to ``localFlowStep*``.

For example, you can find flow from a parameter ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

   DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow by including non-value-preserving flow steps. For example:

.. code-block:: java

     String temp = x;
     String y = temp + ", " + temp;

If ``x`` is a tainted string then ``y`` is also tainted.


To use the taint tracking library you need the following import:

.. code-block:: ql

   import semmle.code.java.dataflow.TaintTracking

Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``. You can apply the predicate recursively by using the ``+`` and ``*`` operators, or by using the predefined recursive predicate ``localTaint``, which is equivalent to ``localTaintStep*``.

For example, you can find taint propagation from a parameter ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

   TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))

Examples
~~~~~~~~

This query finds the filename passed to ``new FileReader(..)``.

.. code-block:: ql

   import java

   from Constructor fileReader, Call call
   where
     fileReader.getDeclaringType().hasQualifiedName("java.io", "FileReader") and
     call.getCallee() = fileReader
   select call.getArgument(0)

Unfortunately, this only gives the expression in the argument, not the values which could be passed to it. So we use local data flow to find all expressions that flow into the argument:

.. code-block:: ql

   import java
   import semmle.code.java.dataflow.DataFlow

   from Constructor fileReader, Call call, Expr src
   where
     fileReader.getDeclaringType().hasQualifiedName("java.io", "FileReader") and
     call.getCallee() = fileReader and
     DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))
   select src

Then we can make the source more specific, for example an access to a public parameter. This query finds where a public parameter is passed to ``new FileReader(..)``:

.. code-block:: ql

   import java
   import semmle.code.java.dataflow.DataFlow

   from Constructor fileReader, Call call, Parameter p
   where
     fileReader.getDeclaringType().hasQualifiedName("java.io", "FileReader") and
     call.getCallee() = fileReader and
     DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(call.getArgument(0)))
   select p

This query finds calls to formatting functions where the format string is not hard-coded.

.. code-block:: ql

   import java
   import semmle.code.java.dataflow.DataFlow
   import semmle.code.java.StringFormat

   from StringFormatMethod format, MethodAccess call, Expr formatString
   where
     call.getMethod() = format and
     call.getArgument(format.getFormatStringIndex()) = formatString and
     not exists(DataFlow::Node source, DataFlow::Node sink |
       DataFlow::localFlow(source, sink) and
       source.asExpr() instanceof StringLiteral and
       sink.asExpr() = formatString
     )
   select call, "Argument to String format method isn't hard-coded."

Exercises
~~~~~~~~~

Exercise 1: Write a query that finds all hard-coded strings used to create a ``java.net.URL``, using local data flow. (`Answer <#exercise-1>`__)

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

You use the global data flow library by implementing the signature ``DataFlow::ConfigSig`` and applying the module ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import semmle.code.java.dataflow.DataFlow

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = DataFlow::Global<MyFlowConfiguration>;

These predicates are defined in the configuration:

-  ``isSource``—defines where data may flow from
-  ``isSink``—defines where data may flow to
-  ``isBarrier``—optional, restricts the data flow
-  ``isAdditionalFlowStep``—optional, adds additional flow steps

The data flow analysis is performed using the predicate ``flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyFlow::flow(source, sink)
   select source, "Data flow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow as local taint tracking is to local data flow. That is, global taint tracking extends global data flow with additional non-value-preserving steps. You use the global taint tracking library by applying the module ``TaintTracking::Global<ConfigSig>`` to your configuration instead of ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import semmle.code.java.dataflow.TaintTracking

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = TaintTracking::Global<MyFlowConfiguration>;

The resulting module has an identical signature to the one obtained from ``DataFlow::Global<ConfigSig>``.

Flow sources
~~~~~~~~~~~~

The data flow library contains some predefined flow sources. The class ``RemoteFlowSource`` (defined in ``semmle.code.java.dataflow.FlowSources``) represents data flow sources that may be controlled by a remote user, which is useful for finding security problems.

Examples
~~~~~~~~

This query shows a taint-tracking configuration that uses remote user input as data sources.

.. code-block:: ql

   import java
   import semmle.code.java.dataflow.FlowSources

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source instanceof RemoteFlowSource
     }

     ...
   }

   module MyTaintFlow = TaintTracking::Global<MyFlowConfiguration>;

Exercises
~~~~~~~~~

Exercise 2: Write a query that finds all hard-coded strings used to create a ``java.net.URL``, using global data flow. (`Answer <#exercise-2>`__)

Exercise 3: Write a class that represents flow sources from ``java.lang.System.getenv(..)``. (`Answer <#exercise-3>`__)

Exercise 4: Using the answers from 2 and 3, write a query which finds all global data flows from ``getenv`` to ``java.net.URL``. (`Answer <#exercise-4>`__)

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   import semmle.code.java.dataflow.DataFlow

   from Constructor url, Call call, StringLiteral src
   where
     url.getDeclaringType().hasQualifiedName("java.net", "URL") and
     call.getCallee() = url and
     DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))
   select src

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   import semmle.code.java.dataflow.DataFlow

   module LiteralToURLConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source.asExpr() instanceof StringLiteral
     }

     predicate isSink(DataFlow::Node sink) {
       exists(Call call |
         sink.asExpr() = call.getArgument(0) and
         call.getCallee().(Constructor).getDeclaringType().hasQualifiedName("java.net", "URL")
       )
     }
   }

   module LiteralToURLFlow = DataFlow::Global<LiteralToURLConfig>;

   from DataFlow::Node src, DataFlow::Node sink
   where LiteralToURLFlow::flow(src, sink)
   select src, "This string constructs a URL $@.", sink, "here"

Exercise 3
~~~~~~~~~~

.. code-block:: ql

   import java

   class GetenvSource extends MethodAccess {
     GetenvSource() {
       exists(Method m | m = this.getMethod() |
         m.hasName("getenv") and
         m.getDeclaringType() instanceof TypeSystem
       )
     }
   }

Exercise 4
~~~~~~~~~~

.. code-block:: ql

   import semmle.code.java.dataflow.DataFlow

   class GetenvSource extends DataFlow::ExprNode {
     GetenvSource() {
       exists(Method m | m = this.asExpr().(MethodAccess).getMethod() |
         m.hasName("getenv") and
         m.getDeclaringType() instanceof TypeSystem
       )
     }
   }

   module GetenvToURLConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source instanceof GetenvSource
     }

     predicate isSink(DataFlow::Node sink) {
       exists(Call call |
         sink.asExpr() = call.getArgument(0) and
         call.getCallee().(Constructor).getDeclaringType().hasQualifiedName("java.net", "URL")
       )
     }
   }

   module GetenvToURLFlow = DataFlow::Global<GetenvToURLConfig>;

   from DataFlow::Node src, DataFlow::Node sink
   where GetenvToURLFlow::flow(src, sink)
   select src, "This environment variable constructs a URL $@.", sink, "here"

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/using-range-analsis-in-cpp.rst
.. _using-range-analsis-in-cpp:

Using range analysis for C and C++
==================================

You can use range analysis to determine the upper or lower bounds on an expression, or whether an expression could potentially over or underflow.

About the range analysis library
--------------------------------

The range analysis library (defined in ``semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis``) provides a set of predicates for determining constant upper and lower bounds on expressions, as well as recognizing integer overflows. For performance, the library performs automatic widening and therefore may not provide the tightest possible bounds.

Bounds predicates
-----------------

The ``upperBound`` and ``lowerBound`` predicates provide constant bounds on expressions. No conversions of the argument are included in the bound. In the common case that your query needs to take conversions into account, call them on the converted form, such as ``upperBound(expr.getFullyConverted())``.

Overflow predicates
-------------------

``exprMightOverflow`` and related predicates hold if the relevant expression might overflow, as determined by the range analysis library. The ``convertedExprMightOverflow`` family of predicates will take conversions into account.

Example
-------

This query uses ``upperBound`` to determine whether the result of ``snprintf`` is checked when used in a loop.

.. code-block:: ql

    from FunctionCall call, DataFlow::Node source, DataFlow::Node sink, Expr convSink
    where
      // the call is an snprintf with a string format argument
      call.getTarget().getName() = "snprintf" and
      call.getArgument(2).getValue().regexpMatch(".*%s.*") and

      // the result of the call influences its size argument in later iterations
      TaintTracking::localTaint(source, sink) and
      source.asExpr() = call and
      sink.asExpr() = call.getArgument(1) and

      // there is no fixed bound on the snprintf's size argument
      upperBound(convSink) = typeUpperBound(convSink.getType().getUnspecifiedType()) and
      convSink = call.getArgument(1).getFullyConverted()

    select call, upperBound(call.getArgument(1).getFullyConverted())

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/customizing-library-models-for-csharp.rst
.. _customizing-library-models-for-csharp:

Customizing library models for C#
=================================

You can model the methods and callables that control data flow in any framework or library. This is especially useful for custom frameworks or niche libraries, that are not supported by the standard CodeQL libraries.

.. include:: ../reusables/beta-note-customizing-library-models.rst

About this article
------------------

This article contains reference material about how to define custom models for sources, sinks, and flow summaries for C# dependencies in data extension files.

About data extensions
---------------------

You can customize analysis by defining models (summaries, sinks, and sources) of your code's C#/.NET dependencies in data extension files. Each model defines the behavior of one or more elements of your library or framework, such as methods, properties, and callables. When you run dataflow analysis, these models expand the potential sources and sinks tracked by dataflow analysis and improve the precision of results.

Most of the security queries search for paths from a source of untrusted input to a sink that represents a vulnerability. This is known as taint tracking. Each source is a starting point for dataflow analysis to track tainted data and each sink is an end point.

Taint tracking queries also need to know how data can flow through elements that are not included in the source code. These are modeled as summaries. A summary model enables queries to synthesize the flow behavior through elements in dependency code that is not stored in your repository.

Syntax used to define an element in an extension file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each model of an element is defined using a data extension where each tuple constitutes a model.
A data extension file to extend the standard C# queries included with CodeQL is a YAML file with the form:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: <name of extensible predicate>
       data:
         - <tuple1>
         - <tuple2>
         - ...

Each YAML file may contain one or more top-level extensions.

- ``addsTo`` defines the CodeQL pack name and extensible predicate that the extension is injected into.
- ``data`` defines one or more rows of tuples that are injected as values into the extensible predicate. The number of columns and their types must match the definition of the extensible predicate.

Data extensions use union semantics, which means that the tuples of all extensions for a single extensible predicate are combined, duplicates are removed, and all of the remaining tuples are queryable by referencing the extensible predicate.

Publish data extension files in a CodeQL model pack to share
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can group one or more data extension files into a CodeQL model pack and publish it to the GitHub Container Registry. This makes it easy for anyone to download the model pack and use it to extend their analysis. For more information, see `Creating a CodeQL model pack <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack>`__ and `Publishing and using CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/publishing-and-using-codeql-packs/>`__ in the CodeQL CLI documentation.

Extensible predicates used to create custom models in C#
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The CodeQL library for C# analysis exposes the following extensible predicates:

- ``sourceModel(namespace, type, subtypes, name, signature, ext, output, kind, provenance)``. This is used to model sources of potentially tainted data. The ``kind`` of the sources defined using this predicate determine which threat model they are associated with. Different threat models can be used to customize the sources used in an analysis. For more information, see ":ref:`Threat models <threat-models-csharp>`."
- ``sinkModel(namespace, type, subtypes, name, signature, ext, input, kind, provenance)``. This is used to model sinks where tainted data may be used in a way that makes the code vulnerable.
- ``summaryModel(namespace, type, subtypes, name, signature, ext, input, output, kind, provenance)``. This is used to model flow through elements.
- ``neutralModel(namespace, type, name, signature, kind, provenance)``. This is similar to a summary model but used to model the flow of values that have only a minor impact on the dataflow analysis. Manual neutral models (those with a provenance such as ``manual`` or ``ai-manual``) can be used to override generated summary models (those with a provenance such as ``df-generated``), so that the summary model will be ignored. Other than that, neutral models have no effect.

The extensible predicates are populated using the models defined in data extension files.

Examples of custom model definitions
------------------------------------

The examples in this section are taken from the standard CodeQL C# query pack published by GitHub. They demonstrate how to add tuples to extend extensible predicates that are used by the standard queries.

Example: Taint sink in the ``System.Data.SqlClient`` namespace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example shows how the C# query pack models the argument of the ``SqlCommand`` constructor as a SQL injection sink.
This is the constructor of the ``SqlCommand`` class, which is located in the ``System.Data.SqlClient`` namespace.

.. code-block:: csharp

   public static void TaintSink(SqlConnection conn, string query) {
        SqlCommand command = new SqlCommand(query, connection) // The argument to this method is a SQL injection sink.
        ...
   }

We need to add a tuple to the ``sinkModel``\(namespace, type, subtypes, name, signature, ext, input, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: sinkModel
       data:
         - ["System.Data.SqlClient", "SqlCommand", False, "SqlCommand", "(System.String,System.Data.SqlClient.SqlConnection)", "", "Argument[0]", "sql-injection", "manual"]

Since we want to add a new sink, we need to add a tuple to the ``sinkModel`` extensible predicate.
The first five values identify the callable (in this case a method) to be modeled as a sink.

- The first value ``System.Data.SqlClient`` is the namespace name.
- The second value ``SqlCommand`` is the name of the class (type) that contains the method.
- The third value ``False`` is a flag that indicates whether or not the sink also applies to all overrides of the method.
- The fourth value ``SqlCommand`` is the method name. Constructors are named after the class.
- The fifth value ``(System.String,System.Data.SqlClient.SqlConnection)`` is the method input type signature. The type names must be fully qualified.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the sink.

- The seventh value ``Argument[0]`` is the ``access path`` to the first argument passed to the method, which means that this is the location of the sink.
- The eighth value ``sql-injection`` is the kind of the sink. The sink kind is used to define the queries where the sink is in scope. In this case - the SQL injection queries.
- The ninth value ``manual`` is the provenance of the sink, which is used to identify the origin of the sink.

Example: Taint source from the ``System.Net.Sockets`` namespace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the C# query pack models the return value from the ``GetStream`` method as a ``remote`` source.
This is the ``GetStream`` method in the ``TcpClient`` class, which is located in the ``System.Net.Sockets`` namespace.

.. code-block:: csharp

   public static void Tainted(TcpClient client) {
       NetworkStream stream = client.GetStream(); // The return value of this method is a remote source of taint.
       ...
   }

We need to add a tuple to the ``sourceModel``\(namespace, type, subtypes, name, signature, ext, output, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: sourceModel
       data:
         - ["System.Net.Sockets", "TcpClient", False, "GetStream", "()", "", "ReturnValue", "remote", "manual"]


Since we are adding a new source, we need to add a tuple to the ``sourceModel`` extensible predicate.
The first five values identify the callable (in this case a method) to be modeled as a source.

- The first value ``System.Net.Sockets`` is the namespace name.
- The second value ``TcpClient`` is the name of the class (type) that contains the source.
- The third value ``False`` is a flag that indicates whether or not the source also applies to all overrides of the method.
- The fourth value ``GetStream`` is the method name.
- The fifth value ``()`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the source.

- The seventh value ``ReturnValue`` is the access path to the return of the method, which means that it is the return value that should be considered a source of tainted input.
- The eighth value ``remote`` is the kind of the source. The source kind is used to define the threat model where the source is in scope. ``remote`` applies to many of the security related queries as it means a remote source of untrusted data. As an example the SQL injection query uses ``remote`` sources. For more information, see ":ref:`Threat models <threat-models-csharp>`."
- The ninth value ``manual`` is the provenance of the source, which is used to identify the origin of the source.

Example: Add flow through the ``Concat`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the C# query pack models flow through a method for a simple case.
This pattern covers many of the cases where we need to summarize flow through a method that is stored in a library or framework outside the repository.

.. code-block:: csharp

   public static void TaintFlow(string s1, string s2) {
       string t = String.Concat(s1, s2); // There is taint flow from s1 and s2 to t.
       ...
   }

We need to add tuples to the ``summaryModel``\(namespace, type, subtypes, name, signature, ext, input, output, kind, provenance) extensible predicate by updating a data extension file:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: summaryModel
       data:
         - ["System", "String", False, "Concat", "(System.Object,System.Object)", "", "Argument[0]", "ReturnValue", "taint", "manual"]
         - ["System", "String", False, "Concat", "(System.Object,System.Object)", "", "Argument[1]", "ReturnValue", "taint", "manual"]

Since we are adding flow through a method, we need to add tuples to the ``summaryModel`` extensible predicate.
Each tuple defines flow from one argument to the return value.
The first row defines flow from the first argument (``s1`` in the example) to the return value (``t`` in the example) and the second row defines flow from the second argument (``s2`` in the example) to the return value (``t`` in the example).

The first five values identify the callable (in this case a method) to be modeled as a summary.
These are the same for both of the rows above as we are adding two summaries for the same method.

- The first value ``System`` is the namespace name.
- The second value ``String`` is the class (type) name.
- The third value ``False`` is a flag that indicates whether or not the summary also applies to all overrides of the method.
- The fourth value ``Concat`` is the method name.
- The fifth value ``(System.Object,System.Object)`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the summary.

- The seventh value is the access path to the input (where data flows from). ``Argument[0]`` is the access path to the first argument (``s1`` in the example) and ``Argument[1]`` is the access path to the second argument (``s2`` in the example).
- The eighth value ``ReturnValue`` is the access path to the output (where data flows to), in this case ``ReturnValue``, which means that the input flows to the return value.
- The ninth value ``taint`` is the kind of the flow. ``taint`` means that taint is propagated through the call.
- The tenth value ``manual`` is the provenance of the summary, which is used to identify the origin of the summary.

It would also be possible to merge the two rows into one by using a comma-separated list in the seventh value. This would be useful if the method has many arguments and the flow is the same for all of them.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: summaryModel
       data:
         - ["System", "String", False, "Concat", "(System.Object,System.Object)", "", "Argument[0,1]", "ReturnValue", "taint", "manual"]

This row defines flow from both the first and the second argument to the return value. The seventh value ``Argument[0,1]`` is shorthand for specifying an access path to both ``Argument[0]`` and ``Argument[1]``.

Example: Add flow through the ``Trim`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the C# query pack models flow through a method for a simple case.

.. code-block:: csharp

   public static void TaintFlow(string s) {
       string t = s.Trim(); // There is taint flow from s to t.
       ...
   }

We need to add a tuple to the ``summaryModel``\(namespace, type, subtypes, name, signature, ext, input, output, kind, provenance) extensible predicate by updating a data extension file:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: summaryModel
       data:
         - ["System", "String", False, "Trim", "()", "", "Argument[this]", "ReturnValue", "taint", "manual"]

Since we are adding flow through a method, we need to add tuples to the ``summaryModel`` extensible predicate.
Each tuple defines flow from one argument to the return value.
The first row defines flow from the qualifier of the method call (``s1`` in the example) to the return value (``t`` in the example).

The first five values identify the callable (in this case a method) to be modeled as a summary.
These are the same for both of the rows above as we are adding two summaries for the same method.

- The first value ``System`` is the namespace name.
- The second value ``String`` is the class (type) name.
- The third value ``False`` is a flag that indicates whether or not the summary also applies to all overrides of the method.
- The fourth value ``Trim`` is the method name.
- The fifth value ``()`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the summary.

- The seventh value is the access path to the input (where data flows from). ``Argument[this]`` is the access path to the qualifier (``s`` in the example).
- The eighth value ``ReturnValue`` is the access path to the output (where data flows to), in this case ``ReturnValue``, which means that the input flows to the return value.
- The ninth value ``taint`` is the kind of the flow. ``taint`` means that taint is propagated through the call.
- The tenth value ``manual`` is the provenance of the summary, which is used to identify the origin of the summary.

Example: Add flow through the ``Select`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the C# query pack models a more complex flow through a method.
Here we model flow through higher order methods and collection types, as well as how to handle extension methods and generics.

.. code-block:: csharp

   public static void TaintFlow(IEnumerable<string> stream) {
     IEnumerable<string> lines = stream.Select(item => item + "\n");
     ...
   }

We need to add tuples to the ``summaryModel``\(namespace, type, subtypes, name, signature, ext, input, output, kind, provenance) extensible predicate by updating a data extension file:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/csharp-all
         extensible: summaryModel
       data:
         - ["System.Linq", "Enumerable", False, "Select<TSource,TResult>", "(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,TResult>)", "", "Argument[0].Element", "Argument[1].Parameter[0]", "value", "manual"]
         - ["System.Linq", "Enumerable", False, "Select<TSource,TResult>", "(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,TResult>)", "", "Argument[1].ReturnValue", "ReturnValue.Element", "value", "manual"]


Since we are adding flow through a method, we need to add tuples to the ``summaryModel`` extensible predicate.
Each tuple defines part of the flow that comprises the total flow through the ``Select`` method.
The first five values identify the callable (in this case a method) to be modeled as a summary.
These are the same for both of the rows above as we are adding two summaries for the same method.

- The first value ``System.Linq`` is the namespace name.
- The second value ``Enumerable`` is the class (type) name.
- The third value ``False`` is a flag that indicates whether or not the summary also applies to all overrides of the method.
- The fourth value ``Select<TSource,TResult>`` is the method name, along with the type parameters for the method. The names of the generic type parameters provided in the model must match the names of the generic type parameters in the method signature in the source code.
- The fifth value ``(System.Collections.Generic.IEnumerable<TSource>,System.Func<TSource,TResult>)`` is the method input type signature. The generics in the signature must match the generics in the method signature in the source code.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the summary definition.

- The seventh value is the access path to the ``input`` (where data flows from).
- The eighth value is the access path to the ``output`` (where data flows to).

For the first row:

- The seventh value is ``Argument[0].Element``, which is the access path to the elements of the qualifier (the elements of the enumerable ``stream`` in the example).
- The eight value is ``Argument[1].Parameter[0]``, which is the access path to the first parameter of the ``System.Func<TSource,TResult>`` argument of ``Select`` (the lambda parameter ``item`` in the example).

For the second row:

- The seventh value is ``Argument[1].ReturnValue``, which is the access path to the return value of the ``System.Func<TSource,TResult>`` argument of ``Select`` (the return value of the lambda in the example).
- The eighth value is ``ReturnValue.Element``, which is the access path to the elements of the return value of ``Select`` (the elements of the enumerable ``lines`` in the example).

For the remaining values for both rows:

- The ninth value ``value`` is the kind of the flow. ``value`` means that the value is preserved.
- The tenth value ``manual`` is the provenance of the summary, which is used to identify the origin of the summary.

That is, the first row specifies that values can flow from the elements of the qualifier enumerable into the first argument of the function provided to ``Select``.  The second row specifies that values can flow from the return value of the function to the elements of the enumerable returned from ``Select``.

Example: Add a ``neutral`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how we can model a method as being neutral with respect to flow. We will also cover how to model a property by modeling the getter of the ``Now`` property of the ``DateTime`` class as neutral.
A neutral model is used to define that there is no flow through a method.

.. code-block:: csharp

   public static void TaintFlow() {
       System.DateTime t = System.DateTime.Now; // There is no flow from Now to t.
       ...
   }

We need to add a tuple to the ``neutralModel``\(namespace, type, name, signature, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
   - addsTo:
       pack: codeql/csharp-all
       extensible: neutralModel
     data:
       - ["System", "DateTime", "get_Now", "()", "summary", "manual"]


Since we are adding a neutral model, we need to add tuples to the ``neutralModel`` extensible predicate.
The first four values identify the callable (in this case the getter of the ``Now`` property) to be modeled as a neutral, the fifth value is the kind, and the sixth value is the provenance (origin) of the neutral.

- The first value ``System`` is the namespace name.
- The second value ``DateTime`` is the class (type) name.
- The third value ``get_Now`` is the method name. Getter and setter methods are named ``get_<name>`` and ``set_<name>`` respectively.
- The fourth value ``()`` is the method input type signature.
- The fifth value ``summary`` is the kind of the neutral.
- The sixth value ``manual`` is the provenance of the neutral.

.. _threat-models-csharp:

Threat models
-------------

.. include:: ../reusables/threat-model-description.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/types-in-java.rst
.. _types-in-java:

Types in Java and Kotlin
========================

You can use CodeQL to find out information about data types used in Java/Kotlin code. This allows you to write queries to identify specific type-related issues.

About working with Java types
-----------------------------

The standard CodeQL library represents Java types by means of the ``Type`` class and its various subclasses.

In particular, class ``PrimitiveType`` represents primitive types that are built into the Java language (such as ``boolean`` and ``int``), whereas ``RefType`` and its subclasses represent reference types, that is classes, interfaces, array types, and so on. This includes both types from the Java standard library (like ``java.lang.Object``) and types defined by non-library code.

Class ``RefType`` also models the class hierarchy: member predicates ``getASupertype`` and ``getASubtype`` allow you to find a reference type's immediate super types and sub types. For example, consider the following Java program:

.. code-block:: java

   class A {}

   interface I {}

   class B extends A implements I {}

Here, class ``A`` has exactly one immediate super type (``java.lang.Object``) and exactly one immediate sub type (``B``); the same is true of interface ``I``. Class ``B``, on the other hand, has two immediate super types (``A`` and ``I``), and no immediate sub types.

To determine ancestor types (including immediate super types, and also *their* super types, etc.), we can use transitive closure. For example, to find all ancestors of ``B`` in the example above, we could use the following query:

.. code-block:: ql

   import java

   from Class B
   where B.hasName("B")
   select B.getASupertype+()

If we ran this query on the example snippet above, the query would return ``A``, ``I``, and ``java.lang.Object``.

.. pull-quote::

   Tip

   If you want to see the location of ``B`` as well as ``A``, you can replace ``B.getASupertype+()`` with ``B.getASupertype*()`` and re-run the query.

Besides class hierarchy modeling, ``RefType`` also provides member predicate ``getAMember`` for accessing members (that is, fields, constructors, and methods) declared in the type, and predicate ``inherits(Method m)`` for checking whether the type either declares or inherits a method ``m``.

Example: Finding problematic array casts
----------------------------------------

As an example of how to use the class hierarchy API, we can write a query that finds downcasts on arrays, that is, cases where an expression ``e`` of some type ``A[]`` is converted to type ``B[]``, such that ``B`` is a (not necessarily immediate) subtype of ``A``.

This kind of cast is problematic, since downcasting an array results in a runtime exception, even if every individual array element could be downcast. For example, the following code throws a ``ClassCastException``:

.. code-block:: java

   Object[] o = new Object[] { "Hello", "world" };
   String[] s = (String[])o;

If the expression ``e`` happens to actually evaluate to a ``B[]`` array, on the other hand, the cast will succeed:

.. code-block:: java

   Object[] o = new String[] { "Hello", "world" };
   String[] s = (String[])o;

In this tutorial, we don't try to distinguish these two cases. Our query should simply look for cast expressions ``ce`` that cast from some type ``source`` to another type ``target``, such that:

-  Both ``source`` and ``target`` are array types.
-  The element type of ``source`` is a transitive super type of the element type of ``target``.

This recipe is not too difficult to translate into a query:

.. code-block:: ql

   import java

   from CastExpr ce, Array source, Array target
   where source = ce.getExpr().getType() and
       target = ce.getType() and
       target.getElementType().(RefType).getASupertype+() = source.getElementType()
   select ce, "Potentially problematic array downcast."

Many projects return results for this query.

Note that by casting ``target.getElementType()`` to a ``RefType``, we eliminate all cases where the element type is a primitive type, that is, ``target`` is an array of primitive type: the problem we are looking for cannot arise in that case. Unlike in Java, a cast in QL never fails: if an expression cannot be cast to the desired type, it is simply excluded from the query results, which is exactly what we want.

Improvements
~~~~~~~~~~~~

Running this query on old Java code, before version 5, often returns many false positive results arising from uses of the method ``Collection.toArray(T[])``, which converts a collection into an array of type ``T[]``.

In code that does not use generics, this method is often used in the following way:

.. code-block:: java

   List l = new ArrayList();
   // add some elements of type A to l
   A[] as = (A[])l.toArray(new A[0]);

Here, ``l`` has the raw type ``List``, so ``l.toArray`` has return type ``Object[]``, independent of the type of its argument array. Hence the cast goes from ``Object[]`` to ``A[]`` and will be flagged as problematic by our query, although at runtime this cast can never go wrong.

To identify these cases, we can create two CodeQL classes that represent, respectively, the ``Collection.toArray`` method, and calls to this method or any method that overrides it:

.. code-block:: ql

   /** class representing java.util.Collection.toArray(T[]) */
   class CollectionToArray extends Method {
       CollectionToArray() {
           this.getDeclaringType().hasQualifiedName("java.util", "Collection") and
           this.hasName("toArray") and
           this.getNumberOfParameters() = 1
       }
   }

   /** class representing calls to java.util.Collection.toArray(T[]) */
   class CollectionToArrayCall extends MethodAccess {
       CollectionToArrayCall() {
           exists(CollectionToArray m |
               this.getMethod().getSourceDeclaration().overridesOrInstantiates*(m)
           )
       }

       /** the call's actual return type, as determined from its argument */
       Array getActualReturnType() {
           result = this.getArgument(0).getType()
       }
   }

Notice the use of ``getSourceDeclaration`` and ``overridesOrInstantiates`` in the constructor of ``CollectionToArrayCall``: we want to find calls to ``Collection.toArray`` and to any method that overrides it, as well as any parameterized instances of these methods. In our example above, for instance, the call ``l.toArray`` resolves to method ``toArray`` in the raw class ``ArrayList``. Its source declaration is ``toArray`` in the generic class ``ArrayList<T>``, which overrides ``AbstractCollection<T>.toArray``, which in turn overrides ``Collection<T>.toArray``, which is an instantiation of ``Collection.toArray`` (since the type parameter ``T`` in the overridden method belongs to ``ArrayList`` and is an instantiation of the type parameter belonging to ``Collection``).

Using these new classes we can extend our query to exclude calls to ``toArray`` on an argument of type ``A[]`` which are then cast to ``A[]``:

.. code-block:: ql

   import java

   // Insert the class definitions from above

   from CastExpr ce, Array source, Array target
   where source = ce.getExpr().getType() and
       target = ce.getType() and
       target.getElementType().(RefType).getASupertype+() = source.getElementType() and
       not ce.getExpr().(CollectionToArrayCall).getActualReturnType() = target
   select ce, "Potentially problematic array downcast."

Notice that fewer results are found by this improved query.

Example: Finding mismatched contains checks
-------------------------------------------

We'll now develop a query that finds uses of ``Collection.contains`` where the type of the queried element is unrelated to the element type of the collection, which guarantees that the test will always return ``false``.

For example, `Apache Zookeeper <https://zookeeper.apache.org/>`__ used to have a snippet of code similar to the following in class ``QuorumPeerConfig``:

.. code-block:: java

   Map<Object, Object> zkProp;

   // ...

   if (zkProp.entrySet().contains("dynamicConfigFile")){
       // ...
   }

Since ``zkProp`` is a map from ``Object`` to ``Object``, ``zkProp.entrySet`` returns a collection of type ``Set<Entry<Object, Object>>``. Such a set cannot possibly contain an element of type ``String``. (The code has since been fixed to use ``zkProp.containsKey``.)

In general, we want to find calls to ``Collection.contains`` (or any of its overriding methods in any parameterized instance of ``Collection``), such that the type ``E`` of collection elements and the type ``A`` of the argument to ``contains`` are unrelated, that is, they have no common subtype.

We start by creating a class that describes ``java.util.Collection``:

.. code-block:: ql

   class JavaUtilCollection extends GenericInterface {
       JavaUtilCollection() {
           this.hasQualifiedName("java.util", "Collection")
       }
   }

To make sure we have not mistyped anything, we can run a simple test query:

.. code-block:: ql

   from JavaUtilCollection juc
   select juc

This query should return precisely one result.

Next, we can create a class that describes ``java.util.Collection.contains``:

.. code-block:: ql

   class JavaUtilCollectionContains extends Method {
       JavaUtilCollectionContains() {
           this.getDeclaringType() instanceof JavaUtilCollection and
           this.hasStringSignature("contains(Object)")
       }
   }

Notice that we use ``hasStringSignature`` to check that:

-  The method in question has name ``contains``.
-  It has exactly one argument.
-  The type of the argument is ``Object``.

Alternatively, we could have implemented these three checks more verbosely using ``hasName``, ``getNumberOfParameters``, and ``getParameter(0).getType() instanceof TypeObject``.

As before, it is a good idea to test the new class by running a simple query to select all instances of ``JavaUtilCollectionContains``; again there should only be a single result.

Now we want to identify all calls to ``Collection.contains``, including any methods that override it, and considering all parameterized instances of ``Collection`` and its subclasses. That is, we are looking for method accesses where the source declaration of the invoked method (reflexively or transitively) overrides ``Collection.contains``. We encode this in a CodeQL class ``JavaUtilCollectionContainsCall``:

.. code-block:: ql

   class JavaUtilCollectionContainsCall extends MethodAccess {
       JavaUtilCollectionContainsCall() {
           exists(JavaUtilCollectionContains jucc |
               this.getMethod().getSourceDeclaration().overrides*(jucc)
           )
       }
   }

This definition is slightly subtle, so you should run a short query to test that ``JavaUtilCollectionContainsCall`` correctly identifies calls to ``Collection.contains``.

For every call to ``contains``, we are interested in two things: the type of the argument, and the element type of the collection on which it is invoked. So we need to add two member predicates ``getArgumentType`` and ``getCollectionElementType`` to class ``JavaUtilCollectionContainsCall`` to compute this information.

The former is easy:

.. code-block:: ql

   Type getArgumentType() {
       result = this.getArgument(0).getType()
   }

For the latter, we proceed as follows:

-  Find the declaring type ``D`` of the ``contains`` method being invoked.
-  Find a (reflexive or transitive) super type ``S`` of ``D`` that is a parameterized instance of ``java.util.Collection``.
-  Return the (only) type argument of ``S``.

We encode this as follows:

.. code-block:: ql

   Type getCollectionElementType() {
       exists(RefType D, ParameterizedInterface S |
           D = this.getMethod().getDeclaringType() and
           D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and
           result = S.getTypeArgument(0)
       )
   }

Having added these two member predicates to ``JavaUtilCollectionContainsCall``, we need to write a predicate that checks whether two given reference types have a common subtype:

.. code-block:: ql

   predicate haveCommonDescendant(RefType tp1, RefType tp2) {
       exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))
   }

Now we are ready to write a first version of our query:

.. code-block:: ql

   import java

   // Insert the class definitions from above

   from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType
   where collEltType = juccc.getCollectionElementType() and argType = juccc.getArgumentType() and
       not haveCommonDescendant(collEltType, argType)
   select juccc, "Element type " + collEltType + " is incompatible with argument type " + argType

Improvements
~~~~~~~~~~~~

For many programs, this query yields a large number of false positive results due to type variables and wild cards: if the collection element type is some type variable ``E`` and the argument type is ``String``, for example, CodeQL will consider that the two have no common subtype, and our query will flag the call. An easy way to exclude such false positive results is to simply require that neither ``collEltType`` nor ``argType`` are instances of ``TypeVariable``.

Another source of false positives is autoboxing of primitive types: if, for example, the collection's element type is ``Integer`` and the argument is of type ``int``, predicate ``haveCommonDescendant`` will fail, since ``int`` is not a ``RefType``. To account for this, our query should check that ``collEltType`` is not the boxed type of ``argType``.

Finally, ``null`` is special because its type (known as ``<nulltype>`` in the CodeQL library) is compatible with every reference type, so we should exclude it from consideration.

Adding these three improvements, our final query becomes:

.. code-block:: ql

    import java

    class JavaUtilCollection extends GenericInterface {
        JavaUtilCollection() {
            this.hasQualifiedName("java.util", "Collection")
        }
    }

    class JavaUtilCollectionContains extends Method {
        JavaUtilCollectionContains() {
            this.getDeclaringType() instanceof JavaUtilCollection and
            this.hasStringSignature("contains(Object)")
        }
    }

    class JavaUtilCollectionContainsCall extends MethodAccess {
        JavaUtilCollectionContainsCall() {
            exists(JavaUtilCollectionContains jucc |
                this.getMethod().getSourceDeclaration().overrides*(jucc)
            )
        }
    Type getArgumentType() {
        result = this.getArgument(0).getType()
        }
        Type getCollectionElementType() {
        exists(RefType D, ParameterizedInterface S |
            D = this.getMethod().getDeclaringType() and
            D.hasSupertype*(S) and S.getSourceDeclaration() instanceof JavaUtilCollection and
            result = S.getTypeArgument(0)
        )
        }
    }

    predicate haveCommonDescendant(RefType tp1, RefType tp2) {
        exists(RefType commondesc | commondesc.hasSupertype*(tp1) and commondesc.hasSupertype*(tp2))
    }

    from JavaUtilCollectionContainsCall juccc, Type collEltType, Type argType
    where collEltType = juccc.getCollectionElementType() and argType = juccc.getArgumentType() and
        not haveCommonDescendant(collEltType, argType) and
        not collEltType instanceof TypeVariable and not argType instanceof TypeVariable and
        not collEltType = argType.(PrimitiveType).getBoxedType() and
        not argType.hasName("<nulltype>")
    select juccc, "Element type " + collEltType + " is incompatible with argument type " + argType

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/using-api-graphs-in-python.rst
.. _using-api-graphs-in-python:

Using API graphs in Python
==========================

API graphs are a uniform interface for referring to functions, classes, and methods defined in
external libraries.

About this article
------------------

This article describes how to use API graphs to reference classes and functions defined in library
code. You can use API graphs to conveniently refer to external library functions when defining things like
remote flow sources.


Module imports
--------------

The most common entry point into the API graph will be the point where an external module or package is
imported. For example, you can access the API graph node corresponding to the ``re`` library
by using the ``API::moduleImport`` method defined in the ``semmle.python.ApiGraphs`` module, as the
following snippet demonstrates.

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    select API::moduleImport("re")

This query selects the API graph node corresponding to the ``re`` module. This node represents the fact that the ``re`` module has been imported rather than a specific location in the program where the import happens. Therefore, there will be at most one result per project, and it will not have a useful location, so you'll have to click `Show 1 non-source result` in order to see it.

To find where the ``re`` module is referenced in the program, you can use the ``getAValueReachableFromSource`` method. The following query selects all references to the ``re`` module in the current database.

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    select API::moduleImport("re").getAValueReachableFromSource()

Note that the ``getAValueReachableFromSource`` method accounts for local flow, so that ``my_re_compile``
in the following snippet is
correctly recognized as a reference to the ``re.compile`` function.

.. code-block:: python

    from re import compile as re_compile

    my_re_compile = re_compile

    r = my_re_compile(".*")

If you only require immediate uses, without taking local flow into account, then you can use
the ``asSource`` method instead.

Note that the given module name *must not* contain any dots. Thus, something like
``API::moduleImport("flask.views")`` will not do what you expect. Instead, this should be decomposed
into an access of the ``views`` member of the API graph node for ``flask``, as described in the next
section.

Accessing attributes
--------------------

Given a node in the API graph, you can access its attributes by using the ``getMember`` method. Using
the above ``re.compile`` example, you can now find references to ``re.compile``.

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    select API::moduleImport("re").getMember("compile").getAValueReachableFromSource()

In addition to ``getMember``, you can use the ``getUnknownMember`` method to find references to API
components where the name is not known statically. You can use the ``getAMember`` method to
access all members, both known and unknown.

Calls and class instantiations
------------------------------

To track instances of classes defined in external libraries, or the results of calling externally
defined functions, you can use the ``getReturn`` method. The following snippet finds all places
where the return value of ``re.compile`` is used:

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    select API::moduleImport("re").getMember("compile").getReturn().getAValueReachableFromSource()

Note that this includes all uses of the result of ``re.compile``, including those reachable via
local flow. To get just the *calls* to ``re.compile``, you can use ``asSource`` instead of
``getAValueReachableFromSource``. As this is a common occurrence, you can, instead of
``getReturn`` followed by ``asSource``, simply use ``getACall``. This will result in an
``API::CallNode``, which deserves a small description of its own.

``API::CallNode``s are not ``API::Node``s. Instead they are ``DataFlow::Node``s with some convenience
predicates that allows you to recover ``API::Node``s for the return value as well as for arguments
to the call. This enables you to constrain the call in various ways using the API graph. The following
snippet finds all calls to ``re.compile`` where the ``pattern`` argument comes from parsing a command
line argument using the ``argparse`` library.

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    from API::CallNode call
    where
        call = API::moduleImport("re").getMember("compile").getACall() and
        call.getParameter(0, "pattern") =
            API::moduleImport("argparse")
                .getMember("ArgumentParser")
                .getReturn()
                .getMember("parse_args")
                .getMember(_)
    select call


Note that the API graph does not distinguish between class instantiations and function calls. As far
as it's concerned, both are simply places where an API graph node is called.

Subclasses
----------

For many libraries, the main mode of usage is to extend one or more library classes. To track this
in the API graph, you can use the ``getASubclass`` method to get the API graph node corresponding to
all the immediate subclasses of this node. To find *all* subclasses, use ``*`` or ``+`` to apply the
method repeatedly, as in ``getASubclass*``.

Note that ``getASubclass`` does not account for any subclassing that takes place in library code
that has not been extracted. Thus, it may be necessary to account for this in the models you write.
For example, the ``flask.views.View`` class has a predefined subclass ``MethodView``. To find
all subclasses of ``View``, you must explicitly include the subclasses of ``MethodView`` as well.

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    API::Node viewClass() {
      result =
        API::moduleImport("flask").getMember("views").getMember(["View", "MethodView"]).getASubclass*()
    }

    select viewClass().getAValueReachableFromSource()

Note the use of the set literal ``["View", "MethodView"]`` to match both classes simultaneously.

Built-in functions and classes
------------------------------

You can access built-in functions and classes using the ``API::builtin`` method, giving the name of
the built-in as an argument.

For example, to find all calls to the built-in ``open`` function, you can use the following snippet.

.. code-block:: ql

    import python
    import semmle.python.ApiGraphs

    select API::builtin("open").getACall()




Further reading
---------------


.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/hash-consing-and-value-numbering.rst
.. _hash-consing-and-value-numbering:

Hash consing and value numbering
================================

You can use specialized CodeQL libraries to recognize expressions that are syntactically identical or compute the same value at runtime in C and C++ codebases.

About the hash consing and value numbering libraries
----------------------------------------------------

In C and C++ databases, each node in the abstract syntax tree is represented by a separate object. This allows both analysis and results display to refer to specific appearances of a piece of syntax. However, it is frequently useful to determine whether two expressions are equivalent, either syntactically or semantically.

The hash consing library (defined in ``semmle.code.cpp.valuenumbering.HashCons``) provides a mechanism for identifying expressions that have the same syntactic structure. The global value numbering library (defined in ``semmle.code.cpp.valuenumbering.GlobalValueNumbering``) provides a mechanism for identifying expressions that compute the same value at runtime. Both libraries partition the expressions in each function into equivalence classes represented by objects. Each ``HashCons`` object represents a set of expressions with identical parse trees, while ``GVN`` objects represent sets of expressions that will always compute the same value. For more information, see `Hash consing <https://en.wikipedia.org/wiki/Hash_consing>`__ and `Value numbering <https://en.wikipedia.org/wiki/Value_numbering>`__ on Wikipedia.

Example C code
--------------

In the following C program, ``x + y`` and ``x + z`` will be assigned the same value number but different hash conses.

.. code-block:: c

    int x = 1;
    int y = 2;
    int z = y;
    if(x + y == x + z) {
      ...
    }

However, in the next example, the uses of ``x + y`` will have different value numbers but the same hash cons.

.. code-block:: c

    int x = 1;
    int y = 2;
    if(x + y) {
      ...
    }

    x = 2;

    if(x + y) {
      ...
    }

Value numbering
---------------

The value numbering library (defined in ``semmle.code.cpp.valuenumbering.GlobalValueNumbering``) provides a mechanism for identifying expressions that compute the same value at runtime. Value numbering is useful when your primary concern is with the values being produced or the eventual machine code being run. For instance, value numbering might be used to determine whether a check is being done against the same value as the operation it is guarding.

The value numbering API
~~~~~~~~~~~~~~~~~~~~~~~

The value numbering library exposes its interface primarily through the ``GVN`` class. Each instance of ``GVN`` represents a set of expressions that will always evaluate to the same value. To get an expression in the set represented by a particular ``GVN``, use the ``getAnExpr()`` member predicate.

To get the ``GVN`` of an ``Expr``, use the ``globalValueNumber`` predicate.

.. pull-quote:: Note

    While the ``GVN`` class has ``toString`` and ``getLocation`` methods, these are only provided as debugging aids. They give the ``toString`` and ``getLocation`` of an arbitrary ``Expr`` within the set.

Why not a predicate?
~~~~~~~~~~~~~~~~~~~~

The obvious interface for this library would be a predicate ``equivalent(Expr e1, Expr e2)``. However, this predicate would be very large, with a quadratic number of rows for each set of equivalent expressions. By using a class as an intermediate step, the number of rows can be kept linear, and therefore can be cached.

Example query
~~~~~~~~~~~~~

This query uses the ``GVN`` class to identify calls to ``strncpy`` where the size argument is derived from the source rather than the destination

.. code-block:: ql

    from FunctionCall strncpy, FunctionCall strlen
    where
      strncpy.getTarget().hasGlobalName("strncpy") and
      strlen.getTarget().hasGlobalName("strlen") and
      globalValueNumber(strncpy.getArgument(1)) = globalValueNumber(strlen.getArgument(0)) and
      strlen = strncpy.getArgument(2)
    select ci, "This call to strncpy is bounded by the size of the source rather than the destination"

.. TODO: a second example

Hash consing
------------

The hash consing library (defined in ``semmle.code.cpp.valuenumbering.HashCons``) provides a mechanism for identifying expressions that have the same syntactic structure. Hash consing is useful when your primary concern is with the text of the code. For instance, hash consing might be used to detect duplicate code within a function.

The hash consing API
~~~~~~~~~~~~~~~~~~~~

The hash consing library exposes its interface primarily through the ``HashCons`` class. Each instance of ``HashCons`` represents a set of expressions within one function that have the same syntax (including referring to the same variables). To get an expression in the set represented by a particular ``HashCons``, use the ``getAnExpr()`` member predicate.

.. pull-quote:: Note

    While the ``HashCons`` class has ``toString`` and ``getLocation`` methods, these are only provided as debugging aids. They give the ``toString`` and ``getLocation`` of an arbitrary ``Expr`` within the set.

To get the ``HashCons`` of an ``Expr``, use the ``hashCons`` predicate.

Example query
~~~~~~~~~~~~~

.. TODO: prose explanations

.. code-block:: ql

    import cpp
    import semmle.code.cpp.valuenumbering.HashCons

    from IfStmt outer, IfStmt inner
    where
      outer.getElse+() = inner and
      hashCons(outer.getCondition()) = hashCons(inner.getCondition())
    select inner.getCondition(), "The condition of this if statement duplicates the condition of $@",
      outer.getCondition(), "an enclosing if statement"

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/data-flow-cheat-sheet-for-javascript.rst
.. _data-flow-cheat-sheet-for-javascript:

Data flow cheat sheet for JavaScript
====================================

This article describes parts of the JavaScript libraries commonly used for variant analysis and in data flow queries.

Taint tracking path queries
---------------------------

Use the following template to create a taint tracking path query:

.. code-block:: ql

    /**
     * @kind path-problem
     */
    import javascript
    import DataFlow
    import DataFlow::PathGraph

    class MyConfig extends TaintTracking::Configuration {
      MyConfig() { this = "MyConfig" }
      override predicate isSource(Node node) { ... }
      override predicate isSink(Node node) { ... }
      override predicate isAdditionalTaintStep(Node pred, Node succ) { ... }
    }

    from MyConfig cfg, PathNode source, PathNode sink
    where cfg.hasFlowPath(source, sink)
    select sink.getNode(), source, sink, "taint from $@.", source.getNode(), "here"

This query reports flow paths which:

- Begin at a node matched by `isSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Configuration.qll/predicate.Configuration$Configuration$isSource.1.html>`__.
- Step through variables, function calls, properties, strings, arrays, promises, exceptions, and steps added by `isAdditionalTaintStep <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/TaintTracking.qll/predicate.TaintTracking$TaintTracking$Configuration$isAdditionalTaintStep.2.html>`__.
- End at a node matched by `isSink <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Configuration.qll/predicate.Configuration$Configuration$isSink.1.html>`__.

See also: "`Global data flow <https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-javascript-and-typescript/#global-data-flow>`__" and ":ref:`Creating path queries <creating-path-queries>`."

DataFlow module
---------------

Use data flow nodes to match program elements independently of syntax. See also: ":doc:`Analyzing data flow in JavaScript and TypeScript <analyzing-data-flow-in-javascript-and-typescript>`."

Predicates in the ``DataFlow::`` module:

- `moduleImport <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$moduleImport.1.html>`__ -- finds uses of a module
- `moduleMember <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$moduleMember.2.html>`__ -- finds uses of a module member
- `globalVarRef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$globalVarRef.1.html>`__ -- finds uses of a global variable

Classes and member predicates in the ``DataFlow::`` module:

- `Node <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$Node.html>`__ -- something that can have a value, such as an expression, declaration, or SSA variable
    - `getALocalSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$getALocalSource.0.html>`__ -- find the node that this came from
    - `getTopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$getTopLevel.0.html>`__ -- top-level scope enclosing this node
    - `getFile <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$getFile.0.html>`__ -- file containing this node
    - `getIntValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$getIntValue.0.html>`__ -- value of this node if it's is an integer constant
    - `getStringValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$getStringValue.0.html>`__ -- value of this node if it's is a string constant
    - `mayHaveBooleanValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$mayHaveBooleanValue.1.html>`__ -- check if the value is ``true`` or ``false``
- `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ extends `Node <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$Node.html>`__ -- function call, parameter, object creation, or reference to a property or global variable
    - `getALocalUse <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getALocalUse.0.html>`__ -- find nodes whose value came from this node
    - `getACall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getACall.0.html>`__ -- find calls with this as the callee
    - `getAnInstantiation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAnInstantiation.0.html>`__ -- find ``new``-calls with this as the callee
    - `getAnInvocation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAnInvocation.0.html>`__ -- find calls or ``new``-calls with this as the callee
    - `getAMethodCall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAMethodCall.1.html>`__ -- find method calls with this as the receiver
    - `getAMemberCall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAMemberCall.1.html>`__ -- find calls with a member of this as the callee
    - `getAPropertyRead <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAPropertyRead.1.html>`__ -- find property reads with this as the base
    - `getAPropertyWrite <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAPropertyWrite.1.html>`__ -- find property writes with this as the base
    - `getAPropertySource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAPropertySource.1.html>`__ -- find nodes flowing into a property of this node
- `InvokeNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$InvokeNode.html>`__, `NewNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$NewNode.html>`__, `CallNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$CallNode.html>`__, `MethodCallNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$MethodCallNode.html>`__ extends `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ -- call to a function or constructor
    - `getArgument <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getArgument.1.html>`__ -- an argument to the call
    - `getCalleeNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getCalleeNode.0.html>`__ -- node being invoked as a function
    - `getCalleeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getCalleeName.0.html>`__ -- name of the variable or property being called
    - `getOptionArgument <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getOptionArgument.2.html>`__ -- a "named argument" passed in through an object literal
    - `getCallback <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getCallback.1.html>`__ -- a function passed as a callback
    - `getACallee <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getACallee.0.html>`__ - a function being called here
    - (MethodCallNode).\ `getMethodName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$MethodCallNode$getMethodName.0.html>`__ -- name of the method being invoked
    - (MethodCallNode).\ `getReceiver <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$CallNode$getReceiver.0.html>`__ -- receiver of the method call
- `FunctionNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$FunctionNode.html>`__ extends `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ -- definition of a function, including closures, methods, and class constructors
    - `getName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$FunctionNode$getName.0.html>`__ -- name of the function, derived from a variable or property name
    - `getParameter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$FunctionNode$getParameter.1.html>`__ -- a parameter of the function
    - `getReceiver <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$FunctionNode$getReceiver.0.html>`__ -- the node representing the value of ``this``
    - `getAReturn <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$FunctionNode$getAReturn.0.html>`__ -- get a returned expression
- `ParameterNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$ParameterNode.html>`__ extends `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ -- parameter of a function
    - `getName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ParameterNode$getName.0.html>`__ -- the parameter name, if it has one
- `ClassNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$ClassNode.html>`__ extends `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ -- class declaration or function that acts as a class
    - `getName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ClassNode$getName.0.html>`__ -- name of the class, derived from a variable or property name
    - `getConstructor <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ClassNode$getConstructor.0.html>`__ -- the constructor function
    - `getInstanceMethod <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ClassNode$getInstanceMethod.1.html>`__ -- get an instance method by name
    - `getStaticMethod <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ClassNode$getStaticMethod.1.html>`__ -- get a static method by name
    - `getAnInstanceReference <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ClassNode$getAnInstanceReference.0.html>`__ -- find references to an instance of the class
    - `getAClassReference <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ClassNode$getAClassReference.0.html>`__ -- find references to the class itself
- `ObjectLiteralNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$ObjectLiteralNode.html>`__ extends `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ -- object literal
    - `getAPropertyWrite <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAPropertyWrite.1.html>`__ -- a property in the object literal
    - `getAPropertySource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getAPropertySource.1.html>`__ -- value flowing into a property
- `ArrayCreationNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$ArrayCreationNode.html>`__ extends `SourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__ -- array literal or call to ``Array`` constructor
    - `getElement <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$ArrayCreationNode$getElement.1.html>`__ -- an element of the array
- `PropRef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$PropRef.html>`__, `PropRead <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$PropRead.html>`__, `PropWrite <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$PropWrite.html>`__ -- read or write of a property
    - `getPropertyName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$PropRef$getPropertyName.0.html>`__ -- name of the property, if it is constant
    - `getPropertyNameExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$PropRef$getPropertyNameExpr.0.html>`__ -- expression holding the name of the property
    - `getBase <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$PropRef$getBase.0.html>`__ -- object whose property is accessed
    - (PropWrite).\ `getRhs <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$PropWrite$getRhs.0.html>`__ -- right-hand side of the property assignment


StringOps module
----------------

- StringOps::`Concatenation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/StringOps.qll/type.StringOps$StringOps$Concatenation.html>`__ -- string concatenation, using a plus operator, template literal, or array join call
- StringOps::`StartsWith <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/StringOps.qll/type.StringOps$StringOps$StartsWith.html>`__ -- check if a string starts with something
- StringOps::`EndsWith <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/StringOps.qll/type.StringOps$StringOps$EndsWith.html>`__ -- check if a string ends with something
- StringOps::`Includes <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/StringOps.qll/type.StringOps$StringOps$Includes.html>`__ -- check if a string contains something
- StringOps::`RegExpTest <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/StringOps.qll/type.StringOps$StringOps$RegExpTest.html>`__ -- check if a string matches a RegExp

Utility
--------

- `ExtendCall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Extend.qll/type.Extend$ExtendCall.html>`__ -- call that copies properties from one object to another
- `JsonParserCall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JsonParsers.qll/type.JsonParsers$JsonParserCall.html>`__ -- call that deserializes a JSON string
- `JsonStringifyCall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JsonStringifiers.qll/type.JsonStringifiers$JsonStringifyCall.html>`__ -- call that serializes a JSON string
- `PropertyProjection <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/PropertyProjection.qll/type.PropertyProjection$PropertyProjection.html>`__ -- call that extracts nested properties by name

System and Network
------------------

- `ClientRequest <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/ClientRequests.qll/type.ClientRequests$ClientRequest.html>`__ -- outgoing network request
- `DatabaseAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$DatabaseAccess.html>`__ -- query being submitted to a database
- `FileNameSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$FileNameSource.html>`__ -- reference to a filename
- `FileSystemAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$FileSystemAccess.html>`__ -- file system operation
    - `FileSystemReadAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$FileSystemReadAccess.html>`__ -- reading the contents of a file
    - `FileSystemWriteAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$FileSystemWriteAccess.html>`__ -- writing to the contents of a file
- `PersistentReadAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$PersistentReadAccess.html>`__ -- reading from persistent storage, like cookies
- `PersistentWriteAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$PersistentWriteAccess.html>`__ -- writing to persistent storage
- `SystemCommandExecution <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Concepts.qll/type.Concepts$SystemCommandExecution.html>`__ -- execution of a system command

.. _data-flow-cheat-sheet-for-javascript--untrusted-data:

Untrusted data
--------------

- `RemoteFlowSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/type.RemoteFlowSources$Cached$RemoteFlowSource.html>`__ -- source of untrusted user input
    - `isUserControlledObject <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/predicate.RemoteFlowSources$Cached$RemoteFlowSource$isUserControlledObject.0.html>`__ -- is the input deserialized to a JSON-like object? (as opposed to just being a string)
- `ClientSideRemoteFlowSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/type.RemoteFlowSources$Cached$ClientSideRemoteFlowSource.html>`__ extends `RemoteFlowSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/type.RemoteFlowSources$Cached$RemoteFlowSource.html>`__ -- input specific to the browser environment
    - `getKind <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/predicate.RemoteFlowSources$Cached$ClientSideRemoteFlowSource$getKind.0.html>`__ -- is this derived from the ``path``, ``fragment``, ``query``, ``url``, or ``name``?
- HTTP::`RequestInputAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/HTTP.qll/type.HTTP$HTTP$RequestInputAccess.html>`__ extends `RemoteFlowSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/type.RemoteFlowSources$Cached$RemoteFlowSource.html>`__ -- input from an incoming HTTP request
    - `getKind <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/HTTP.qll/predicate.HTTP$HTTP$RequestInputAccess$getKind.0.html>`__ -- is this derived from a ``parameter``, ``header``, ``body``, ``url``, or ``cookie``?
- HTTP::`RequestHeaderAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/HTTP.qll/type.HTTP$HTTP$RequestHeaderAccess.html>`__ extends `RequestInputAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/HTTP.qll/type.HTTP$HTTP$RequestInputAccess.html>`__ -- access to a specific header
    - `getAHeaderName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/HTTP.qll/predicate.HTTP$HTTP$RequestHeaderAccess$getAHeaderName.0.html>`__ -- the name of a header being accessed

Note: some `RemoteFlowSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/type.RemoteFlowSources$Cached$RemoteFlowSource.html>`__ instances, such as input from a web socket,
belong to none of the specific subcategories above.

Files
-----

-  `File <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$File.html>`__,
   `Folder <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Folder.html>`__ extends
   `Container <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Container.html>`__ -- file or folder in the database

   -  `getBaseName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/predicate.Files$Container$getBaseName.0.html>`__ -- the name of the file or folder
   -  `getRelativePath <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/predicate.Files$Container$getRelativePath.0.html>`__ -- path relative to the database root

AST nodes
---------

See also: ":doc:`Abstract syntax tree classes for working with JavaScript and TypeScript programs <abstract-syntax-tree-classes-for-working-with-javascript-and-typescript-programs>`."

Conversion between DataFlow and AST nodes:

- `Node.asExpr() <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$asExpr.0.html>`__ -- convert node to an expression, if possible
- `Expr.flow() <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/predicate.AST$AST$ValueNode$flow.0.html>`__ -- convert expression to a node (always possible)
- `DataFlow::valueNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$valueNode.1.html>`__ -- convert expression or declaration to a node
- `DataFlow::parameterNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$parameterNode.1.html>`__ -- convert a parameter to a node
- `DataFlow::thisNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$thisNode.1.html>`__ -- get the receiver node of a function

String matching
---------------

-  x.\ `matches <https://codeql.github.com/codeql-standard-libraries/javascript/predicate.string$matches.1.html>`__\ ("escape%") -- holds if x starts with "escape"
-  x.\ `regexpMatch <https://codeql.github.com/codeql-standard-libraries/javascript/predicate.string$regexpMatch.1.html>`__\ ("escape.*") -- holds if x starts with "escape"
-  x.\ `regexpMatch <https://codeql.github.com/codeql-standard-libraries/javascript/predicate.string$regexpMatch.1.html>`__\ ("(?i).*escape.*") -- holds if x contains
   "escape" (case insensitive)

Access paths
------------

When multiple property accesses are chained together they form what's called an "access path".

To identify nodes based on access paths, use the following predicates in `AccessPath <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/GlobalAccessPaths.qll/module.GlobalAccessPaths$AccessPath.html>`__ module:

- AccessPath::`getAReferenceTo <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/GlobalAccessPaths.qll/predicate.GlobalAccessPaths$AccessPath$getAReferenceTo.2.html>`__ -- find nodes that refer to the given access path
- AccessPath::`getAnAssignmentTo <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/GlobalAccessPaths.qll/predicate.GlobalAccessPaths$AccessPath$getAnAssignmentTo.2.html>`__ -- finds nodes that are assigned to the given access path
- AccessPath::`getAnAliasedSourceNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/GlobalAccessPaths.qll/predicate.GlobalAccessPaths$AccessPath$getAnAliasedSourceNode.1.html>`__ -- finds nodes that refer to the same access path

``getAReferenceTo`` and ``getAnAssignmentTo`` have a 1-argument version for global access paths, and a 2-argument version for access paths starting at a given node.

Type tracking
-------------

See also: ":doc:`Using type tracking for API modeling <using-type-tracking-for-api-modeling>`."

Use the following template to define forward type tracking predicates:

.. code-block:: ql

  import DataFlow

  SourceNode myType(TypeTracker t) {
    t.start() and
    result = /* SourceNode to track */
    or
    exists(TypeTracker t2 |
      result = myType(t2).track(t2, t)
    )
  }

  SourceNode myType() {
    result = myType(TypeTracker::end())
  }

Use the following template to define backward type tracking predicates:

.. code-block:: ql

  import DataFlow

  SourceNode myType(TypeBackTracker t) {
    t.start() and
    result = (/* argument to track */).getALocalSource()
    or
    exists(TypeBackTracker t2 |
      result = myType(t2).backtrack(t2, t)
    )
  }

  SourceNode myType() {
    result = myType(TypeBackTracker::end())
  }

Troubleshooting
---------------

-  Using a call node as as sink? Try using `getArgument <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$InvokeNode$getArgument.1.html>`__
   to get an *argument* of the call node instead.
-  Trying to use `moduleImport <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$moduleImport.1.html>`__
   or `moduleMember <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/predicate.Nodes$moduleMember.2.html>`__
   as a call node?
   Try using `getACall <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$getACall.0.html>`__
   to get a *call* to the imported function, instead of the function itself.
-  Compilation fails due to incompatible types? Make sure AST nodes and
   DataFlow nodes are not mixed up. Use `asExpr() <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/predicate.DataFlow$DataFlow$Node$asExpr.0.html>`__ or
   `flow() <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/predicate.AST$AST$ValueNode$flow.0.html>`__ to convert.

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/using-api-graphs-in-ruby.rst
.. _using-api-graphs-in-ruby:

Using API graphs in Ruby
==========================

API graphs are a uniform interface for referring to functions, classes, and methods defined in
external libraries.

About this article
------------------

This article describes how you can use API graphs to reference classes and functions defined in library
code. API graphs are particularly useful when you want to model the remote flow sources available from external library functions.


Module and class references
---------------------------

The most common entry point into the API graph is when a top-level module or class is accessed. 
For example, you can access the API graph node corresponding to the ``::Regexp`` class
by using the ``API::getTopLevelMember`` method defined in the ``codeql.ruby.ApiGraphs`` module, as the
following snippet demonstrates.

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("Regexp")

The example above finds references to a top-level class. For nested
modules and classes, you can use the ``getMember`` method. For example the following query selects
references to the ``Net::HTTP`` class.

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("Net").getMember("HTTP")

Note that you should specify module names without ``::`` symbols. If you write ``API::getTopLevelMember("Net::HTTP")``, it will not do what you expect. Instead, you need to decompose this name
into an access of the ``HTTP`` member of the API graph node for ``Net``, as shown in the example above.

Calls and class instantiations
------------------------------

To track the calls of externally defined functions, you can use the ``getMethod`` method. The
following snippet finds all calls of ``Regexp.compile``:

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("Regexp").getMethod("compile")

The example above is for a call to a class method. Tracking calls to instance methods, is a two-step
process, first you need to find instances of the class before you can find the calls
to methods on those instances. The following snippet finds instantiations of the ``Regexp`` class:

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("Regexp").getInstance()

Note that the ``getInstance`` method also includes subclasses. For example if there is a 
``class SpecialRegexp < Regexp`` then ``getInstance`` also finds ``SpecialRegexp.new``.

The following snippet builds on the above to find calls of the ``Regexp#match?`` instance method:

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("Regexp").getInstance().getMethod("match?")

Subclasses
----------

Many libraries are used by extending one or more library classes. To track this
in the API graph, you can use the ``getASubclass`` method to get the API graph node corresponding to
the immediate subclasses of a node. To find *all* subclasses, use ``*`` or ``+`` to apply the
method repeatedly. You can see an example where all subclasses are identified using ``getASubclass*`` below.

Note that ``getASubclass`` can only return subclasses that are extracted as part of the CodeQL database 
that you are analyzing. When libraries have predefined subclasses, you will need to explicitly include them in your model.
For example, the ``ActionController::Base`` class has a predefined subclass ``Rails::ApplicationController``. To find
all subclasses of ``ActionController::Base``, you must explicitly include the subclasses of ``Rails::ApplicationController`` as well.

.. code-block:: ql

    import codeql.ruby.ApiGraphs


    API::Node actionController() {
      result =
        [
          API::getTopLevelMember("ActionController").getMember("Base"),
          API::getTopLevelMember("Rails").getMember("ApplicationController")
        ].getASubclass*()
    }

    select actionController()


Using the API graph in dataflow queries
---------------------------------------

Dataflow queries often search for points where data from external sources enters the code base
as well as places where data leaves the code base. API graphs provide a convenient way to refer 
to external API components such as library functions and their inputs and outputs. 
However, you do not use API graph nodes directly in dataflow queries. 

- API graph nodes model entities that are defined outside your code base.
- Dataflow nodes model entities defined within the current code base. 

You bridge the gap between the entities outside and inside your code base using 
the API node class methods: ``asSource()`` and ``asSink()``.

The ``asSource()`` method is used to select dataflow nodes where a value from an external source
enters the current code base. A typical example is the return value of a library function such as
``File.read(path)``:

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("File").getMethod("read").getReturn().asSource()


The ``asSink()`` method is used to select dataflow nodes where a value leaves the
current code base and flows into an external library. For example the second parameter
of the ``File.write(path, value)`` method.

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("File").getMethod("write").getParameter(1).asSink()

A more complex example is a call to ``File.open`` with a block argument. This function creates a ``File`` instance
and passes it to the supplied block. In this case, we are interested in the first parameter of the block because this is where an
externally created value enters the code base, that is, the ``|file|`` in the Ruby example below:

.. code-block:: ruby

    File.open("/my/file.txt", "w") { |file| file << "Hello world" }

The following snippet of CodeQL finds parameters of blocks of ``File.open`` method calls:

.. code-block:: ql

    import codeql.ruby.ApiGraphs

    select API::getTopLevelMember("File").getMethod("open").getBlock().getParameter(0).asSource()

The following example is a dataflow query that that uses API graphs to find cases where data that 
is read flows into a call to ``File.write``.

.. code-block:: ql

    import codeql.ruby.DataFlow
    import codeql.ruby.ApiGraphs

    module Configuration implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node source) {
        source = API::getTopLevelMember("File").getMethod("read").getReturn().asSource()
      }

      predicate isSink(DataFlow::Node sink) {
        sink = API::getTopLevelMember("File").getMethod("write").getParameter(1).asSink()
      }
    }

    module Flow = DataFlow::Global<Configuration>;

    from DataFlow::Node src, DataFlow::Node sink
    where Flow::flow(src, sink)
    select src, "The data read here flows into a $@ call.", sink, "File.write"

Further reading
---------------


.. include:: ../reusables/ruby-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-javascript.rst
.. _codeql-library-for-javascript:

CodeQL library for JavaScript
=============================

When you're analyzing a JavaScript program, you can make use of the large collection of classes in the CodeQL library for JavaScript.

Overview
--------

There is an extensive CodeQL library for analyzing JavaScript code. The classes in this library present the data from a CodeQL database in an object-oriented form and provide abstractions and predicates to help you with common analysis tasks.

The library is implemented as a set of QL modules, that is, files with the extension ``.qll``. The module ``javascript.qll`` imports most other standard library modules, so you can include the complete library by beginning your query with:

.. code-block:: ql

   import javascript

The rest of this tutorial briefly summarizes the most important classes and predicates provided by this library, including references to the `detailed API documentation <https://codeql.github.com/codeql-standard-libraries/javascript/>`__ where applicable.

Introducing the library
-----------------------

The CodeQL library for JavaScript presents information about JavaScript source code at different levels:

-  **Textual** — classes that represent source code as unstructured text files
-  **Lexical** — classes that represent source code as a series of tokens and comments
-  **Syntactic** — classes that represent source code as an abstract syntax tree
-  **Name binding** — classes that represent scopes and variables
-  **Control flow** — classes that represent the flow of control during execution
-  **Data flow** — classes that you can use to reason about data flow in JavaScript source code
-  **Type inference** — classes that you can use to approximate types for JavaScript expressions and variables
-  **Call graph** — classes that represent the caller-callee relationship between functions
-  **Inter-procedural data flow** — classes that you can use to define inter-procedural data flow and taint tracking analyses
-  **Frameworks** — classes that represent source code entities that have a special meaning to JavaScript tools and frameworks

Note that representations above the textual level (for example the lexical representation or the flow graphs) are only available for JavaScript code that does not contain fatal syntax errors. For code with such errors, the only information available is at the textual level, as well as information about the errors themselves.

Additionally, there is library support for working with HTML documents, JSON, and YAML data, JSDoc comments, and regular expressions.

Textual level
~~~~~~~~~~~~~

At its most basic level, a JavaScript code base can simply be viewed as a collection of files organized into folders, where each file is composed of zero or more lines of text.

Note that the textual content of a program is not included in the CodeQL database unless you specifically request it during extraction.

Files and folders
^^^^^^^^^^^^^^^^^

In the CodeQL libraries, files are represented as entities of class `File <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$File.html>`__, and folders as entities of class `Folder <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Folder.html>`__, both of which are subclasses of class `Container <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Container.html>`__.

Class `Container <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Container.html>`__ provides the following member predicates:

-  ``Container.getParentContainer()`` returns the parent folder of the file or folder.
-  ``Container.getAFile()`` returns a file within the folder.
-  ``Container.getAFolder()`` returns a folder nested within the folder.

Note that while ``getAFile`` and ``getAFolder`` are declared on class `Container <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Container.html>`__, they currently only have results for `Folder <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Folder.html>`__\ s.

Both files and folders have paths, which can be accessed by the predicate ``Container.getAbsolutePath()``. For example, if ``f`` represents a file with the path ``/home/user/project/src/index.js``, then ``f.getAbsolutePath()`` evaluates to the string ``"/home/user/project/src/index.js"``, while ``f.getParentContainer().getAbsolutePath()`` returns ``"/home/user/project/src"``.

These paths are absolute file system paths. If you want to obtain the path of a file relative to the source location in the CodeQL database, use ``Container.getRelativePath()`` instead. Note, however, that a database may contain files that are not located underneath the source location; for such files, ``getRelativePath()`` will not return anything.

The following member predicates of class `Container <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Container.html>`__ provide more information about the name of a file or folder:

-  ``Container.getBaseName()`` returns the base name of a file or folder, not including its parent folder, but including its extension. In the above example, ``f.getBaseName()`` would return the string ``"index.js"``.
-  ``Container.getStem()`` is similar to ``Container.getBaseName()``, but it does *not* include the file extension; so ``f.getStem()`` returns ``"index"``.
-  ``Container.getExtension()`` returns the file extension, not including the dot; so ``f.getExtension()`` returns ``"js"``.

For example, the following query computes, for each folder, the number of JavaScript files (that is, files with extension ``js``) contained in the folder:

.. code-block:: ql

   import javascript

   from Folder d
   select d.getRelativePath(), count(File f | f = d.getAFile() and f.getExtension() = "js")

When you run the query on most projects, the results include folders that contain files with a ``js`` extension and folders that don't.

Locations
^^^^^^^^^

Most entities in a CodeQL database have an associated source location. Locations are identified by five pieces of information: a file, a start line, a start column, an end line, and an end column. Line and column counts are 1-based (so the first character of a file is at line 1, column 1), and the end position is inclusive.

All entities associated with a source location belong to the class `Locatable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Locations.qll/type.Locations$Locatable.html>`__. The location itself is modeled by the class `Location <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Locations.qll/type.Locations$Location.html>`__ and can be accessed through the member predicate ``Locatable.getLocation()``. The `Location <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Locations.qll/type.Locations$Location.html>`__ class provides the following member predicates:

-  ``Location.getFile()``, ``Location.getStartLine()``, ``Location.getStartColumn()``, ``Location.getEndLine()``, ``Location.getEndColumn()`` return detailed information about the location.
-  ``Location.getNumLines()`` returns the number of (whole or partial) lines covered by the location.
-  ``Location.startsBefore(Location)`` and ``Location.endsAfter(Location)`` determine whether one location starts before or ends after another location.
-  ``Location.contains(Location)`` indicates whether one location completely contains another location; ``l1.contains(l2)`` holds if, and only if, ``l1.startsBefore(l2)`` and ``l1.endsAfter(l2)``.

Lines
^^^^^

Lines of text in files are represented by the class `Line <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Lines.qll/type.Lines$Line.html>`__. This class offers the following member predicates:

-  ``Line.getText()`` returns the text of the line, excluding any terminating newline characters.
-  ``Line.getTerminator()`` returns the terminator character(s) of the line. The last line in a file may not have any terminator characters, in which case this predicate does not return anything; otherwise it returns either the two-character string ``"\r\n"`` (carriage-return followed by newline), or one of the one-character strings ``"\n"`` (newline), ``"\r"`` (carriage-return), ``"\u2028"`` (Unicode character LINE SEPARATOR), ``"\u2029"`` (Unicode character PARAGRAPH SEPARATOR).

Note that, as mentioned above, the textual representation of the program is not included in the CodeQL database by default.

Lexical level
~~~~~~~~~~~~~

A slightly more structured view of a JavaScript program is provided by the classes `Token <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$Token.html>`__ and `Comment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$Comment.html>`__, which represent tokens and comments, respectively.

Tokens
^^^^^^

The most important member predicates of class `Token <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$Token.html>`__ are as follows:

-  ``Token.getValue()`` returns the source text of the token.
-  ``Token.getIndex()`` returns the index of the token within its enclosing script.
-  ``Token.getNextToken()`` and ``Token.getPreviousToken()`` navigate between tokens.

The `Token <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$Token.html>`__ class has nine subclasses, each representing a particular kind of token:

-  `EOFToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$EOFToken.html>`__: a marker token representing the end of a script
-  `NullLiteralToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$NullLiteralToken.html>`__, `BooleanLiteralToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$BooleanLiteralToken.html>`__, `NumericLiteralToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$NumericLiteralToken.html>`__, `StringLiteralToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$StringLiteralToken.html>`__ and `RegularExpressionToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$RegularExpressionToken.html>`__: different kinds of literals
-  `IdentifierToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$IdentifierToken.html>`__ and `KeywordToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$KeywordToken.html>`__: identifiers and keywords (including reserved words) respectively
-  `PunctuatorToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$PunctuatorToken.html>`__: operators and other punctuation symbols

As an example of a query operating entirely on the lexical level, consider the following query, which finds consecutive comma tokens arising from an omitted element in an array expression:

.. code-block:: ql

   import javascript

   class CommaToken extends PunctuatorToken {
       CommaToken() {
           getValue() = ","
       }
   }

   from CommaToken comma
   where comma.getNextToken() instanceof CommaToken
   select comma, "Omitted array elements are bad style."

If the query returns no results, this pattern isn't used in the projects that you analyzed.

You can use predicate ``Locatable.getFirstToken()`` and ``Locatable.getLastToken()`` to access the first and last token (if any) belonging to an element with a source location.

Comments
^^^^^^^^

The class `Comment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$Comment.html>`__ and its subclasses represent the different kinds of comments that can occur in JavaScript programs:

-  `Comment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$Comment.html>`__: any comment

   -  `LineComment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$LineComment.html>`__: a single-line comment terminated by an end-of-line character

      -  `SlashSlashComment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$SlashSlashComment.html>`__: a plain JavaScript single-line comment starting with ``//``
      -  `HtmlLineComment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$HtmlLineComment.html>`__: a (non-standard) HTML comment

         -  `HtmlCommentStart <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$HtmlCommentStart.html>`__: an HTML comment starting with ``<!--``

         -  `HtmlCommentEnd <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$HtmlCommentEnd.html>`__: an HTML comment ending with ``-->``

   -  `BlockComment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$BlockComment.html>`__: a block comment potentially spanning multiple lines

      -  `SlashStarComment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$SlashStarComment.html>`__: a plain JavaScript block comment surrounded with ``/*...*/``
      -  `DocComment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$DocComment.html>`__: a documentation block comment surrounded with ``/**...*/``

The most important member predicates are as follows:

-  ``Comment.getText()`` returns the source text of the comment, not including delimiters.
-  ``Comment.getLine(i)`` returns the ``i``\ th line of text within the comment (0-based).
-  ``Comment.getNumLines()`` returns the number of lines in the comment.
-  ``Comment.getNextToken()`` returns the token immediately following a comment. Note that such a token always exists: if a comment appears at the end of a file, its following token is an `EOFToken <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Tokens.qll/type.Tokens$EOFToken.html>`__.

As an example of a query using only lexical information, consider the following query for finding HTML comments, which are not a standard ECMAScript feature and should be avoided:

.. code-block:: ql

   import javascript

   from HtmlLineComment c
   select c, "Do not use HTML comments."

Syntactic level
~~~~~~~~~~~~~~~

The majority of classes in the JavaScript library is concerned with representing a JavaScript program as a collection of `abstract syntax trees <https://en.wikipedia.org/wiki/Abstract_syntax_tree>`__ (ASTs).

The class `ASTNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$ASTNode.html>`__ contains all entities representing nodes in the abstract syntax trees and defines generic tree traversal predicates:

-  ``ASTNode.getChild(i)``: returns the ``i``\ th child of this AST node.
-  ``ASTNode.getAChild()``: returns any child of this AST node.
-  ``ASTNode.getParent()``: returns the parent node of this AST node, if any.

.. pull-quote::

   Note

   These predicates should only be used to perform generic AST traversal. To access children of specific AST node types, the specialized predicates introduced below should be used instead. In particular, queries should not rely on the numeric indices of child nodes relative to their parent nodes: these are considered an implementation detail that may change between versions of the library.

Top-levels
^^^^^^^^^^

From a syntactic point of view, each JavaScript program is composed of one or more top-level code blocks (or *top-levels* for short), which are blocks of JavaScript code that do not belong to a larger code block. Top-levels are represented by the class `TopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$TopLevel.html>`__ and its subclasses:

-  `TopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$TopLevel.html>`__

   -  `Script <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$Script.html>`__: a stand-alone file or HTML ``<script>`` element

      -  `ExternalScript <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$ExternalScript.html>`__: a stand-alone JavaScript file
      -  `InlineScript <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$InlineScript.html>`__: code embedded inline in an HTML ``<script>`` tag

   -  `CodeInAttribute <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$CodeInAttribute.html>`__: a code block originating from an HTML attribute value

      -  `EventHandlerCode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$EventHandlerCode.html>`__: code from an event handler attribute such as ``onload``
      -  `JavaScriptURL <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$JavaScriptURL.html>`__: code from a URL with the ``javascript:`` scheme

   -  `Externs <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$Externs.html>`__: a JavaScript file containing `externs <https://developers.google.com/closure/compiler/docs/externs-and-exports>`__ definitions

Every `TopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$TopLevel.html>`__ class is contained in a `File <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$File.html>`__ class, but a single `File <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$File.html>`__ may contain more than one `TopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$TopLevel.html>`__. To go from a ``TopLevel tl`` to its `File <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$File.html>`__, use ``tl.getFile()``; conversely, for a ``File f``, predicate ``f.getATopLevel()`` returns a top-level contained in ``f``. For every AST node, predicate ``ASTNode.getTopLevel()`` can be used to find the top-level it belongs to.

The `TopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$TopLevel.html>`__ class additionally provides the following member predicates:

-  ``TopLevel.getNumberOfLines()`` returns the total number of lines (including code, comments and whitespace) in the top-level.
-  ``TopLevel.getNumberOfLinesOfCode()`` returns the number of lines of code, that is, lines that contain at least one token.
-  ``TopLevel.getNumberOfLinesOfComments()`` returns the number of lines containing or belonging to a comment.
-  ``TopLevel.isMinified()`` determines whether the top-level contains minified code, using a heuristic based on the average number of statements per line.

.. pull-quote::

   Note

   By default, GitHub code scanning filters out alerts in minified top-levels, since they are often hard to interpret. When you write your own queries in Visual Studio Code, this filtering is *not* done automatically, so you may want to explicitly add a condition of the form ``and not e.getTopLevel().isMinified()`` or similar to your query to exclude results in minified code.

Statements and expressions
^^^^^^^^^^^^^^^^^^^^^^^^^^

The most important subclasses of `ASTNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$ASTNode.html>`__ besides `TopLevel <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$TopLevel.html>`__ are `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__ and `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__, which, together with their subclasses, represent statements and expressions, respectively. This section briefly discusses some of the more important classes and predicates. For a full reference of all the subclasses of `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__ and `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__ and their API, see
`Stmt.qll <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/module.Stmt.html>`__ and `Expr.qll <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/module.Expr.html>`__.

-  `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__: use ``Stmt.getContainer()`` to access the innermost function or top-level in which the statement is contained.

   -  `ControlStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ControlStmt.html>`__: a statement that controls the execution of other statements, that is, a conditional, loop, ``try`` or ``with`` statement; use ``ControlStmt.getAControlledStmt()`` to access the statements that it controls.

      -  `IfStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$IfStmt.html>`__: an ``if`` statement; use ``IfStmt.getCondition()``, ``IfStmt.getThen()`` and ``IfStmt.getElse()`` to access its condition expression, "then" branch and "else" branch, respectively.
      -  `LoopStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$LoopStmt.html>`__: a loop; use ``Loop.getBody()`` and ``Loop.getTest()`` to access its body and its test expression, respectively.

         -  `WhileStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$WhileStmt.html>`__, `DoWhileStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$DoWhileStmt.html>`__: a "while" or "do-while" loop, respectively.
         -  `ForStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ForStmt.html>`__: a "for" statement; use ``ForStmt.getInit()`` and ``ForStmt.getUpdate()`` to access the init and update expressions, respectively.
         -  `EnhancedForLoop <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$EnhancedForLoop.html>`__: a "for-in" or "for-of" loop; use ``EnhancedForLoop.getIterator()`` to access the loop iterator (which may be a expression or variable declaration), and ``EnhancedForLoop.getIterationDomain()`` to access the expression being iterated over.

            -  `ForInStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ForInStmt.html>`__, `ForOfStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ForOfStmt.html>`__: a "for-in" or "for-of" loop, respectively.

      -  `WithStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$WithStmt.html>`__: a "with" statement; use ``WithStmt.getExpr()`` and ``WithStmt.getBody()`` to access the controlling expression and the body of the with statement, respectively.
      -  `SwitchStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$SwitchStmt.html>`__: a switch statement; use ``SwitchStmt.getExpr()`` to access the expression on which the statement switches; use ``SwitchStmt.getCase(int)`` and ``SwitchStmt.getACase()`` to access individual switch cases; each case is modeled by an entity of class `Case <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Case.html>`__, whose member predicates ``Case.getExpr()`` and ``Case.getBodyStmt(int)`` provide access to the expression checked by the switch case (which is undefined for ``default``), and its body.
      -  `TryStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$TryStmt.html>`__: a "try" statement; use ``TryStmt.getBody()``, ``TryStmt.getCatchClause()`` and ``TryStmt.getFinally`` to access its body, "catch" clause and "finally" block, respectively.

   -  `BlockStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$BlockStmt.html>`__: a block of statements; use ``BlockStmt.getStmt(int)`` to access the individual statements in the block.
   -  `ExprStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ExprStmt.html>`__: an expression statement; use ``ExprStmt.getExpr()`` to access the expression itself.
   -  `JumpStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$JumpStmt.html>`__: a statement that disrupts structured control flow, that is, one of ``break``, ``continue``, ``return`` and ``throw``; use predicate ``JumpStmt.getTarget()`` to determine the target of the jump, which is either a statement or (for ``return`` and uncaught ``throw`` statements) the enclosing function.

      -  `BreakStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$BreakStmt.html>`__: a "break" statement; use ``BreakStmt.getLabel()`` to access its (optional) target label.
      -  `ContinueStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ContinueStmt.html>`__: a "continue" statement; use ``ContinueStmt.getLabel()`` to access its (optional) target label.
      -  `ReturnStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ReturnStmt.html>`__: a "return" statement; use ``ReturnStmt.getExpr()`` to access its (optional) result expression.
      -  `ThrowStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ThrowStmt.html>`__: a "throw" statement; use ``ThrowStmt.getExpr()`` to access its thrown expression.

   -  `FunctionDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$FunctionDeclStmt.html>`__: a function declaration statement; see below for available member predicates.
   -  `ClassDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassDeclStmt.html>`__: a class declaration statement; see below for available member predicates.
   -  `DeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$DeclStmt.html>`__: a declaration statement containing one or more declarators which can be accessed by predicate ``DeclStmt.getDeclarator(int)``.

      -  `VarDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$VarDeclStmt.html>`__, `ConstDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ConstDeclStmt.html>`__, `LetStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$LetStmt.html>`__: a ``var``, ``const`` or ``let`` declaration statement.

-  `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__: use ``Expr.getEnclosingStmt()`` to obtain the innermost statement to which this expression belongs; ``Expr.isPure()`` determines whether the expression is side-effect-free.

   -  `Identifier <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Identifier.html>`__: an identifier; use ``Identifier.getName()`` to obtain its name.
   -  `Literal <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Literal.html>`__: a literal value; use ``Literal.getValue()`` to obtain a string representation of its value, and ``Literal.getRawValue()`` to obtain its raw source text (including surrounding quotes for string literals).

      -  `NullLiteral <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NullLiteral.html>`__, `BooleanLiteral <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BooleanLiteral.html>`__, `NumberLiteral <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NumberLiteral.html>`__, `StringLiteral <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$StringLiteral.html>`__, `RegExpLiteral <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$RegExpLiteral.html>`__: different kinds of literals.

   -  `ThisExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ThisExpr.html>`__: a "this" expression.
   -  `SuperExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$SuperExpr.html>`__: a "super" expression.
   -  `ArrayExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ArrayExpr.html>`__: an array expression; use ``ArrayExpr.getElement(i)`` to obtain the ``i``\ th element expression, and ``ArrayExpr.elementIsOmitted(i)`` to check whether the ``i``\ th element is omitted.
   -  `ObjectExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ObjectExpr.html>`__: an object expression; use ``ObjectExpr.getProperty(i)`` to obtain the ``i``\ th property in the object expression; properties are modeled by class `Property <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Property.html>`__, which is described in more detail below.
   -  `FunctionExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$FunctionExpr.html>`__: a function expression; see below for available member predicates.
   -  `ArrowFunctionExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ArrowFunctionExpr.html>`__: an ECMAScript 2015-style arrow function expression; see below for available member predicates.
   -  `ClassExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassExpr.html>`__: a class expression; see below for available member predicates.
   -  `ParExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ParExpr.html>`__: a parenthesized expression; use ``ParExpr.getExpression()`` to obtain the operand expression; for any expression, ``Expr.stripParens()`` can be used to recursively strip off any parentheses
   -  `SeqExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$SeqExpr.html>`__: a sequence of two or more expressions connected by the comma operator; use ``SeqExpr.getOperand(i)`` to obtain the ``i``\ th sub-expression.
   -  `ConditionalExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ConditionalExpr.html>`__: a ternary conditional expression; member predicates ``ConditionalExpr.getCondition()``, ``ConditionalExpr.getConsequent()`` and ``ConditionalExpr.getAlternate()`` provide access to the condition expression, the "then" expression and the "else" expression, respectively.
   -  `InvokeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$InvokeExpr.html>`__: a function call or a "new" expression; use ``InvokeExpr.getCallee()`` to obtain the expression specifying the function to be called, and ``InvokeExpr.getArgument(i)`` to obtain the ``i``\ th argument expression.

      -  `CallExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$CallExpr.html>`__: a function call.
      -  `NewExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NewExpr.html>`__: a "new" expression.
      -  `MethodCallExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$MethodCallExpr.html>`__: a function call whose callee expression is a property access; use ``MethodCallExpr.getReceiver`` to access the receiver expression of the method call, and ``MethodCallExpr.getMethodName()`` to get the method name (if it can be determined statically).

   -  `PropAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropAccess.html>`__: a property access, that is, either a "dot" expression of the form ``e.f`` or an index expression of the form ``e[p]``; use ``PropAccess.getBase()`` to obtain the base expression on which the property is accessed (``e`` in the example), and ``PropAccess.getPropertyName()`` to determine the name of the accessed property; if the name cannot be statically determined, ``getPropertyName()`` does not return any value.

      -  `DotExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$DotExpr.html>`__: a "dot" expression.
      -  `IndexExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$IndexExpr.html>`__: an index expression (also known as computed property access).

   -  `UnaryExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$UnaryExpr.html>`__: a unary expression; use ``UnaryExpr.getOperand()`` to obtain the operand expression.

      -  `NegExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NegExpr.html>`__ ("-"), `PlusExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PlusExpr.html>`__ ("+"), `LogNotExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LogNotExpr.html>`__ ("!"), `BitNotExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BitNotExpr.html>`__ ("~"), `TypeofExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$TypeofExpr.html>`__, `VoidExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$VoidExpr.html>`__, `DeleteExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$DeleteExpr.html>`__, `SpreadElement <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$SpreadElement.html>`__ ("..."): various types of unary expressions.

   -  `BinaryExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BinaryExpr.html>`__: a binary expression; use ``BinaryExpr.getLeftOperand()`` and ``BinaryExpr.getRightOperand()`` to access the operand expressions.

      -  `Comparison <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Comparison.html>`__: any comparison expression.

         -  `EqualityTest <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$EqualityTest.html>`__: any equality or inequality test.

            -  `EqExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$EqExpr.html>`__ ("=="), `NEqExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$NEqExpr.html>`__ ("!="): non-strict equality and inequality tests.
            -  `StrictEqExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$StrictEqExpr.html>`__ ("==="), `StrictNEqExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$StrictNEqExpr.html>`__ ("!=="): strict equality and inequality tests.

         -  `LTExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LTExpr.html>`__ ("<"), `LEExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LEExpr.html>`__ ("<="), `GTExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$GTExpr.html>`__ (">"), `GEExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$GEExpr.html>`__ (">="): numeric comparisons.

      -  `LShiftExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LShiftExpr.html>`__ ("<<"), `RShiftExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$RShiftExpr.html>`__ (">>"), `URShiftExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$URShiftExpr.html>`__ (">>>"): shift operators.
      -  `AddExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AddExpr.html>`__ ("+"), `SubExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$SubExpr.html>`__ ("-"), `MulExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$MulExpr.html>`__ ("*"), `DivExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$DivExpr.html>`__ ("/"), `ModExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ModExpr.html>`__ ("%"), `ExpExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ExpExpr.html>`__ ("**"): arithmetic operators.
      -  `BitOrExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BitOrExpr.html>`__ ("|"), `XOrExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$XOrExpr.html>`__ ("^"), `BitAndExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$BitAndExpr.html>`__ ("&"): bitwise operators.
      -  `InExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$InExpr.html>`__: an ``in`` test.
      -  `InstanceofExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$InstanceofExpr.html>`__: an ``instanceof`` test.
      -  `LogAndExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LogAndExpr.html>`__ ("&&"), `LogOrExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$LogOrExpr.html>`__ ("||"): short-circuiting logical operators.

   -  `Assignment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Assignment.html>`__: assignment expressions, either simple or compound; use ``Assignment.getLhs()`` and ``Assignment.getRhs()`` to access the left- and right-hand side, respectively.

      -  `AssignExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignExpr.html>`__: a simple assignment expression.
      -  `CompoundAssignExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$CompoundAssignExpr.html>`__: a compound assignment expression.

         -  `AssignAddExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignAddExpr.html>`__, `AssignSubExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignSubExpr.html>`__, `AssignMulExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignMulExpr.html>`__, `AssignDivExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignDivExpr.html>`__, `AssignModExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignModExpr.html>`__, `AssignLShiftExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignLShiftExpr.html>`__, `AssignRShiftExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignRShiftExpr.html>`__,
            `AssignURShiftExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignURShiftExpr.html>`__, `AssignOrExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignOrExpr.html>`__, `AssignXOrExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignXOrExpr.html>`__, `AssignAndExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignAndExpr.html>`__, `AssignExpExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AssignExpExpr.html>`__: different kinds of compound assignment expressions.

   -  `UpdateExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$UpdateExpr.html>`__: an increment or decrement expression; use ``UpdateExpr.getOperand()`` to obtain the operand expression.

      -  `PreIncExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PreIncExpr.html>`__, `PostIncExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PostIncExpr.html>`__: an increment expression.
      -  `PreDecExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PreDecExpr.html>`__, `PostDecExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PostDecExpr.html>`__: a decrement expression.

   -  `YieldExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$YieldExpr.html>`__: a "yield" expression; use ``YieldExpr.getOperand()`` to access the (optional) operand expression; use ``YieldExpr.isDelegating()`` to check whether this is a delegating ``yield*``.
   -  `TemplateLiteral <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Templates.qll/type.Templates$TemplateLiteral.html>`__: an ECMAScript 2015 template literal; ``TemplateLiteral.getElement(i)`` returns the ``i``\ th element of the template, which may either be an interpolated expression or a constant template element.
   -  `TaggedTemplateExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Templates.qll/type.Templates$TaggedTemplateExpr.html>`__: an ECMAScript 2015 tagged template literal; use ``TaggedTemplateExpr.getTag()`` to access the tagging expression, and ``TaggedTemplateExpr.getTemplate()`` to access the template literal being tagged.
   -  `TemplateElement <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Templates.qll/type.Templates$TemplateElement.html>`__: a constant template element; as for literals, use ``TemplateElement.getValue()`` to obtain the value of the element, and ``TemplateElement.getRawValue()`` for its raw value
   -  `AwaitExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AwaitExpr.html>`__: an "await" expression; use ``AwaitExpr.getOperand()`` to access the operand expression.

`Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__ and `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__ share a common superclass `ExprOrStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$ExprOrStmt.html>`__ which is useful for queries that should operate either on statements or on expressions, but not on any other AST nodes.

As an example of how to use expression AST nodes, here is a query that finds expressions of the form ``e + f >> g``; such expressions should be rewritten as ``(e + f) >> g`` to clarify operator precedence:

.. code-block:: ql

   import javascript

   from ShiftExpr shift, AddExpr add
   where add = shift.getAnOperand()
   select add, "This expression should be bracketed to clarify precedence rules."

Functions
^^^^^^^^^

JavaScript provides several ways of defining functions: in ECMAScript 5, there are function declaration statements and function expressions, and ECMAScript 2015 adds arrow function expressions. These different syntactic forms are represented by the classes `FunctionDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$FunctionDeclStmt.html>`__ (a subclass of `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__), `FunctionExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$FunctionExpr.html>`__ (a subclass of `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__) and `ArrowFunctionExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ArrowFunctionExpr.html>`__ (also a subclass of
`Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__), respectively. All three are subclasses of `Function <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Functions.qll/type.Functions$Function.html>`__, which provides common member predicates for accessing function parameters or the function body:

-  ``Function.getId()`` returns the `Identifier <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Identifier.html>`__ naming the function, which may not be defined for function expressions.
-  ``Function.getParameter(i)`` and ``Function.getAParameter()`` access the ``i``\ th parameter or any parameter, respectively; parameters are modeled by the class `Parameter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Parameter.html>`__, which is a subclass of `BindingPattern <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$BindingPattern.html>`__ (see below).
-  ``Function.getBody()`` returns the body of the function, which is usually a `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__, but may be an `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__ for arrow function expressions and legacy `expression closures <https://developer.mozilla.org/en-US/docs/Archive/Web/JavaScript/Expression_closures>`__.

As an example, here is a query that finds all expression closures:

.. code-block:: ql

   import javascript

   from FunctionExpr fe
   where fe.getBody() instanceof Expr
   select fe, "Use arrow expressions instead of expression closures."

As another example, this query finds functions that have two parameters that bind the same variable:

.. code-block:: ql

   import javascript

   from Function fun, Parameter p, Parameter q, int i, int j
   where p = fun.getParameter(i) and
       q = fun.getParameter(j) and
       i < j and
       p.getAVariable() = q.getAVariable()
   select fun, "This function has two parameters that bind the same variable."

Classes
^^^^^^^

Classes can be defined either by class declaration statements, represented by the CodeQL class `ClassDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassDeclStmt.html>`__ (which is a subclass of `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__), or by class expressions, represented by the CodeQL class `ClassExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassExpr.html>`__ (which is a subclass of `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__). Both of these classes are also subclasses of `ClassDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassDefinition.html>`__, which provides common member predicates for accessing the name of a class, its superclass, and its body:

-  ``ClassDefinition.getIdentifier()`` returns the `Identifier <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Identifier.html>`__ naming the function, which may not be defined for class expressions.
-  ``ClassDefinition.getSuperClass()`` returns the `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__ specifying the superclass, which may not be defined.
-  ``ClassDefinition.getMember(n)`` returns the definition of member ``n`` of this class.
-  ``ClassDefinition.getMethod(n)`` restricts ``ClassDefinition.getMember(n)`` to methods (as opposed to fields).
-  ``ClassDefinition.getField(n)`` restricts ``ClassDefinition.getMember(n)`` to fields (as opposed to methods).
-  ``ClassDefinition.getConstructor()`` gets the constructor of this class, possibly a synthetic default constructor.

Note that class fields are not a standard language feature yet, so details of their representation may change.

Method definitions are represented by the class `MethodDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$MethodDefinition.html>`__, which (like its counterpart `FieldDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$FieldDefinition.html>`__ for fields) is a subclass of `MemberDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$MemberDefinition.html>`__. That class provides the following important member predicates:

-  ``MemberDefinition.isStatic()``: holds if this is a static member.
-  ``MemberDefinition.isComputed()``: holds if the name of this member is computed at runtime.
-  ``MemberDefinition.getName()``: gets the name of this member if it can be determined statically.
-  ``MemberDefinition.getInit()``: gets the initializer of this field; for methods, the initializer is a function expressions, for fields it may be an arbitrary expression, and may be undefined.

There are three classes for modeling special methods: `ConstructorDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ConstructorDefinition.html>`__ models constructors, while `GetterMethodDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$GetterMethodDefinition.html>`__ and `SetterMethodDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$SetterMethodDefinition.html>`__ model getter and setter methods, respectively.

Declarations and binding patterns
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Variables are declared by declaration statements (class `DeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$DeclStmt.html>`__), which come in three flavors: ``var`` statements (represented by class `VarDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$VarDeclStmt.html>`__), ``const`` statements (represented by class `ConstDeclStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$ConstDeclStmt.html>`__), and ``let`` statements (represented by class `LetStmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$LetStmt.html>`__). Every declaration statement has one or more declarators, represented by class `VariableDeclarator <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VariableDeclarator.html>`__.

Each declarator consists of a binding pattern, returned by predicate ``VariableDeclarator.getBindingPattern()``, and an optional initializing expression, returned by ``VariableDeclarator.getInit()``.

Often, the binding pattern is a simple identifier, as in ``var x = 42``. In ECMAScript 2015 and later, however, it can also be a more complex destructuring pattern, as in ``var [x, y] = arr``.

The various kinds of binding patterns are represented by class `BindingPattern <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$BindingPattern.html>`__ and its subclasses:

-  `VarRef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarRef.html>`__: a simple identifier in an l-value position, for example the ``x`` in ``var x`` or in ``x = 42``
-  `Parameter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Parameter.html>`__: a function or catch clause parameter
-  `ArrayPattern <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$ArrayPattern.html>`__: an array pattern, for example, the left-hand side of ``[x, y] = arr``
-  `ObjectPattern <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$ObjectPattern.html>`__: an object pattern, for example, the left-hand side of ``{x, y: z} = o``

Here is an example of a query to find declaration statements that declare the same variable more than once, excluding results in minified code:

.. code-block:: ql

   import javascript

   from DeclStmt ds, VariableDeclarator d1, VariableDeclarator d2, Variable v, int i, int j
   where d1 = ds.getDecl(i) and
       d2 = ds.getDecl(j) and
       i < j and
       v = d1.getBindingPattern().getAVariable() and
       v = d2.getBindingPattern().getAVariable() and
       not ds.getTopLevel().isMinified()
   select ds, "Variable " + v.getName() + " is declared both $@ and $@.", d1, "here", d2, "here"

This is not a common problem, so you may not find any results in your own projects.

   Notice the use of ``not ... isMinified()`` here and in the next few queries. This excludes any results found in minified code. If you delete ``and not ds.getTopLevel().isMinified()`` and re-run the query, two results in minified code in the *meteor/meteor* project are reported.

Properties
^^^^^^^^^^

Properties in object literals are represented by class `Property <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Property.html>`__, which is also a subclass of `ASTNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$ASTNode.html>`__, but neither of `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__ nor of `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__.

Class `Property <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Property.html>`__ has two subclasses `ValueProperty <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$ValueProperty.html>`__ and `PropertyAccessor <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertyAccessor.html>`__, which represent, respectively, normal value properties and getter/setter properties. Class `PropertyAccessor <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertyAccessor.html>`__, in turn, has two subclasses `PropertyGetter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertyGetter.html>`__ and `PropertySetter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertySetter.html>`__ representing getters and setters, respectively.

The predicates ``Property.getName()`` and ``Property.getInit()`` provide access to the defined property's name and its initial value. For `PropertyAccessor <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$PropertyAccessor.html>`__ and its subclasses, ``getInit()`` is overloaded to return the getter/setter function.

As an example of a query involving properties, consider the following query that flags object expressions containing two identically named properties, excluding results in minified code:

.. code-block:: ql

   import javascript

   from ObjectExpr oe, Property p1, Property p2, int i, int j
   where p1 = oe.getProperty(i) and
       p2 = oe.getProperty(j) and
       i < j and
       p1.getName() = p2.getName() and
       not oe.getTopLevel().isMinified()
   select oe, "Property " + p1.getName() + " is defined both $@ and $@.", p1, "here", p2, "here"

Modules
^^^^^^^

The JavaScript library has support for working with ECMAScript 2015 modules, as well as legacy CommonJS modules (still commonly employed by Node.js code bases) and AMD-style modules. The classes `ES2015Module <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/ES2015Modules.qll/type.ES2015Modules$ES2015Module.html>`__, `NodeModule <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NodeJS.qll/type.NodeJS$NodeModule.html>`__, and `AMDModule <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AMD.qll/type.AMD$AmdModule.html>`__ represent these three types of modules, and all three extend the common superclass `Module <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Modules.qll/type.Modules$Module.html>`__.

The most important member predicates defined by `Module <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Modules.qll/type.Modules$Module.html>`__ are:

-  ``Module.getName()``: gets the name of the module, which is just the stem (that is, the basename without extension) of the enclosing file.
-  ``Module.getAnImportedModule()``: gets another module that is imported (through ``import`` or ``require``) by this module.
-  ``Module.getAnExportedSymbol()``: gets the name of a symbol that this module exports.

Moreover, there is a class `Import <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Modules.qll/type.Modules$Import.html>`__ that models both ECMAScript 2015-style ``import`` declarations and CommonJS/AMD-style ``require`` calls; its member predicate ``Import.getImportedModule`` provides access to the module the import refers to, if it can be determined statically.

Name binding
~~~~~~~~~~~~

Name binding is modeled in the JavaScript libraries using four concepts: *scopes*, *variables*, *variable declarations*, and *variable accesses*, represented by the classes `Scope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Scope.html>`__, `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__, `VarDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarDecl.html>`__ and `VarAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarAccess.html>`__, respectively.

Scopes
^^^^^^

In ECMAScript 5, there are three kinds of scopes: the global scope (one per program), function scopes (one per function), and catch clause scopes (one per ``catch`` clause). These three kinds of scopes are represented by the classes `GlobalScope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$GlobalScope.html>`__, `FunctionScope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$FunctionScope.html>`__ and `CatchScope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$CatchScope.html>`__. ECMAScript 2015 adds block scopes for ``let``-bound variables, which are also represented by class `Scope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Scope.html>`__, class expression scopes (`ClassExprScope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassExprScope.html>`__),
and module scopes (`ModuleScope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$ModuleScope.html>`__).

Class `Scope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Scope.html>`__ provides the following API:

-  ``Scope.getScopeElement()`` returns the AST node inducing this scope; undefined for `GlobalScope <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$GlobalScope.html>`__.
-  ``Scope.getOuterScope()`` returns the lexically enclosing scope of this scope.
-  ``Scope.getAnInnerScope()`` returns a scope lexically nested inside this scope.
-  ``Scope.getVariable(name)``, ``Scope.getAVariable()`` return a variable declared (implicitly or explicitly) in this scope.

Variables
^^^^^^^^^

The `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__ class models all variables in a JavaScript program, including global variables, local variables, and parameters (both of functions and ``catch`` clauses), whether explicitly declared or not.

It is important not to confuse variables and their declarations: local variables may have more than one declaration, while global variables and the implicitly declared local ``arguments`` variable need not have a declaration at all.

Variable declarations and accesses
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Variables may be declared by variable declarators, by function declaration statements and expressions, by class declaration statements or expressions, or by parameters of functions and ``catch`` clauses. While these declarations differ in their syntactic form, in each case there is an identifier naming the declared variable. We consider that identifier to be the declaration proper, and assign it the class `VarDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarDecl.html>`__. Identifiers that reference a variable, on the other hand, are given the class `VarAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarAccess.html>`__.

The most important predicates involving variables, their declarations, and their accesses are as follows:

-  ``Variable.getName()``, ``VarDecl.getName()``, ``VarAccess.getName()`` return the name of the variable.
-  ``Variable.getScope()`` returns the scope to which the variable belongs.
-  ``Variable.isGlobal()``, ``Variable.isLocal()``, ``Variable.isParameter()`` determine whether the variable is a global variable, a local variable, or a parameter variable, respectively.
-  ``Variable.getAnAccess()`` maps a `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__ to all `VarAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarAccess.html>`__\ es that refer to it.
-  ``Variable.getADeclaration()`` maps a `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__ to all `VarDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarDecl.html>`__\ s that declare it (of which there may be none, one, or more than one).
-  ``Variable.isCaptured()`` determines whether the variable is ever accessed in a scope that is lexically nested within the scope where it is declared.

As an example, consider the following query which finds distinct function declarations that declare the same variable, that is, two conflicting function declarations within the same scope (again excluding minified code):

.. code-block:: ql

   import javascript

   from FunctionDeclStmt f, FunctionDeclStmt g
   where f != g and f.getVariable() = g.getVariable() and
       not f.getTopLevel().isMinified() and
       not g.getTopLevel().isMinified()
   select f, g

Some projects declare conflicting functions of the same name and rely on platform-specific behavior to disambiguate the two declarations.

Control flow
~~~~~~~~~~~~

A different program representation in terms of intraprocedural control flow graphs (CFGs) is provided by the classes in library `CFG.qll <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/module.CFG.html>`__.

Class `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowNode.html>`__ represents a single node in the control flow graph, which is either an expression, a statement, or a synthetic control flow node. Note that `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__ and `Stmt <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Stmt.qll/type.Stmt$Stmt.html>`__ do not inherit from `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowNode.html>`__ at the CodeQL level, although their entity types are compatible, so you can explicitly cast from one to the other if you need to map between the AST-based and the CFG-based program representations.

There are two kinds of synthetic control flow nodes: entry nodes (class `ControlFlowEntryNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowEntryNode.html>`__), which represent the beginning of a top-level or function, and exit nodes (class `ControlFlowExitNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowExitNode.html>`__), which represent their end. They do not correspond to any AST nodes, but simply serve as the unique entry point and exit point of a control flow graph. Entry and exit nodes can be accessed through the predicates ``StmtContainer.getEntry()`` and ``StmtContainer.getExit()``.

Most, but not all, top-levels and functions have another distinguished CFG node, the *start node*. This is the CFG node at which execution begins. Unlike the entry node, which is a synthetic construct, the start node corresponds to an actual program element: for top-levels, it is the first CFG node of the first statement; for functions, it is the CFG node corresponding to their first parameter or, if there are no parameters, the first CFG node of the body. Empty top-levels do not have a start node.

For most purposes, using start nodes is preferable to using entry nodes.

The structure of the control flow graph is reflected in the member predicates of `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowNode.html>`__:

-  ``ControlFlowNode.getASuccessor()`` returns a `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowNode.html>`__ that is a successor of this `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowNode.html>`__ in the control flow graph.
-  ``ControlFlowNode.getAPredecessor()`` is the inverse of ``getASuccessor()``.
-  ``ControlFlowNode.isBranch()`` determines whether this node has more than one successor.
-  ``ControlFlowNode.isJoin()`` determines whether this node has more than one predecessor.
-  ``ControlFlowNode.isStart()`` determines whether this node is a start node.

Many control-flow-based analyses are phrased in terms of `basic blocks <https://en.wikipedia.org/wiki/Basic_block>`__ rather than single control flow nodes, where a basic block is a maximal sequence of control flow nodes without branches or joins. The class `BasicBlock <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/BasicBlocks.qll/type.BasicBlocks$BasicBlock.html>`__ from `BasicBlocks.qll <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/BasicBlocks.qll/module.BasicBlocks.html>`__ represents all such basic blocks. Similar to `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CFG.qll/type.CFG$ControlFlowNode.html>`__, it provides member predicates ``getASuccessor()`` and ``getAPredecessor()`` to navigate the control flow graph at the level of basic blocks, and member predicates ``getANode()``, ``getNode(int)``, ``getFirstNode()`` and ``getLastNode()`` to access individual control flow nodes within a basic block. The predicate
``Function.getEntryBB()`` returns the entry basic block in a function, that is, the basic block containing the function's entry node. Similarly, ``Function.getStartBB()`` provides access to the start basic block, which contains the function's start node. As for CFG nodes, ``getStartBB()`` should normally be preferred over ``getEntryBB()``.

As an example of an analysis using basic blocks, ``BasicBlock.isLiveAtEntry(v, u)`` determines whether variable ``v`` is `live <https://en.wikipedia.org/wiki/Live_variable_analysis>`__ at the entry of the given basic block, and if so binds ``u`` to a use of ``v`` that refers to its value at the entry. We can use it to find global variables that are used in a function where they are not live (that is, every read of the variable is preceded by a write), suggesting that the variable was meant to be declared as a local variable instead:

.. code-block:: ql

   import javascript

   from Function f, GlobalVariable gv
   where gv.getAnAccess().getEnclosingFunction() = f and
       not f.getStartBB().isLiveAtEntry(gv, _)
   select f, "This function uses " + gv + " like a local variable."

Many projects have some variables which look as if they were intended to be local.

Data flow
~~~~~~~~~

Definitions and uses
^^^^^^^^^^^^^^^^^^^^

Library `DefUse.qll <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DefUse.qll/module.DefUse.html>`__ provides classes and predicates to determine `def-use <https://en.wikipedia.org/wiki/Use-define_chain>`__ relationships between definitions and uses of variables.

Classes `VarDef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DefUse.qll/type.DefUse$VarDef.html>`__ and `VarUse <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DefUse.qll/type.DefUse$VarUse.html>`__ contain all expressions that define and use a variable, respectively. For the former, you can use predicate ``VarDef.getAVariable()`` to find out which variables are defined by a given variable definition (recall that destructuring assignments in ECMAScript 2015 define several variables at the same time). Similarly, predicate ``VarUse.getVariable()`` returns the (single) variable being accessed by a variable use.

The def-use information itself is provided by predicate ``VarUse.getADef()``, that connects a use of a variable to a definition of the same variable, where the definition may reach the use.

As an example, the following query finds definitions of local variables that are not used anywhere; that is, the variable is either not referenced at all after the definition, or its value is overwritten:

.. code-block:: ql

   import javascript

   from VarDef def, LocalVariable v
   where v = def.getAVariable() and
       not exists (VarUse use | def = use.getADef())
   select def, "Dead store of local variable."

SSA
^^^

A more fine-grained representation of a program's data flow based on `Static Simple Assignment Form (SSA) <https://en.wikipedia.org/wiki/Static_single_assignment_form>`__ is provided by the library ``semmle.javascript.SSA``.

In SSA form, each use of a local variable has exactly one (SSA) definition that reaches it. SSA definitions are represented by class `SsaDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/SSA.qll/type.SSA$SsaDefinition.html>`__. They are not AST nodes, since not every SSA definition corresponds to an explicit element in the source code.

Altogether, there are five kinds of SSA definitions:

#. Explicit definitions (`SsaExplicitDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/SSA.qll/type.SSA$SsaExplicitDefinition.html>`__): these simply wrap a `VarDef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DefUse.qll/type.DefUse$VarDef.html>`__, that is, a definition like ``x = 1`` appearing explicitly in the source code.
#. Implicit initializations (`SsaImplicitInit <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/SSA.qll/type.SSA$SsaImplicitInit.html>`__): these represent the implicit initialization of local variables with ``undefined`` at the beginning of their scope.
#. Phi nodes (`SsaPhiNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/SSA.qll/type.SSA$SsaPhiNode.html>`__): these are pseudo-definitions that merge two or more SSA definitions where necessary; see the Wikipedia page linked to above for an explanation.
#. Variable captures (`SsaVariableCapture <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/SSA.qll/type.SSA$SsaVariableCapture.html>`__): these are pseudo-definitions appearing at places in the code where the value of a captured variable may change without there being an explicit assignment, for example due to a function call.
#. Refinement nodes (`SsaRefinementNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/SSA.qll/type.SSA$SsaRefinementNode.html>`__): these are pseudo-definitions appearing at places in the code where something becomes known about a variable; for example, a conditional ``if (x === null)`` induces a refinement node at the beginning of its "then" branch recording the fact that ``x`` is known to be ``null`` there. (In the literature, these are sometimes known as "pi nodes.")

Data flow nodes
^^^^^^^^^^^^^^^

Moving beyond just variable definitions and uses, library ``semmle.javascript.dataflow.DataFlow`` provides a representation of the program as a data flow graph. Its nodes are values of class `DataFlow::Node <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$Node.html>`__, which has two subclasses ``ValueNode`` and ``SsaDefinitionNode``. Nodes of the former kind wrap an expression or a statement that is considered to produce a value (specifically, a function or class declaration statement, or a TypeScript namespace or enum declaration). Nodes of the latter kind wrap SSA definitions.

You can use the predicate ``DataFlow::valueNode`` to convert an expression, function or class into its corresponding ``ValueNode``, and similarly ``DataFlow::ssaDefinitionNode`` to map an SSA definition to its corresponding ``SsaDefinitionNode``.

There is also an auxiliary predicate ``DataFlow::parameterNode`` that maps a parameter to its corresponding data flow node. (This is really just a convenience wrapper around ``DataFlow::ssaDefinitionNode``, since parameters are also considered to be SSA definitions.)

Going in the other direction, there is a predicate ``ValueNode.getAstNode()`` for mapping from ``ValueNode``\ s to ``ASTNode``\ s, and ``SsaDefinitionNode.getSsaVariable()`` for mapping from ``SsaDefinitionNode``\ s to ``SsaVariable``\ s. There is also a utility predicate ``Node.asExpr()`` that gets the underlying expression for a ``ValueNode``, and is undefined for all nodes that do not correspond to an expression. (Note in particular that this predicate is not defined for ``ValueNode``\ s wrapping function or class declaration statements!)

You can use the predicate ``DataFlow::Node.getAPredecessor()`` to find other data flow nodes from which values may flow into this node, and ``getASuccessor`` for the other direction.

For example, here is a query that finds all invocations of a method called ``send`` on a value that comes from a parameter named ``res``, indicating that it is perhaps sending an HTTP response:

.. code-block:: ql

   import javascript

   from SimpleParameter res, DataFlow::Node resNode, MethodCallExpr send
   where res.getName() = "res" and
         resNode = DataFlow::parameterNode(res) and
         resNode.getASuccessor+() = DataFlow::valueNode(send.getReceiver()) and
         send.getMethodName() = "send"
   select send

Note that the data flow modeling in this library is intraprocedural, that is, flow across function calls and returns is *not* modeled. Likewise, flow through object properties and global variables is not modeled.

Type inference
~~~~~~~~~~~~~~

The library ``semmle.javascript.dataflow.TypeInference`` implements a simple type inference for JavaScript based on intraprocedural, heap-insensitive flow analysis. Basically, the inference algorithm approximates the possible concrete runtime values of variables and expressions as sets of abstract values (represented by the class `AbstractValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/AbstractValues.qll/type.AbstractValues$AbstractValue.html>`__), each of which stands for a set of concrete values.

For example, there is an abstract value representing all non-zero numbers, and another representing all non-empty strings except for those that can be converted to a number. Both of these abstract values are fairly coarse approximations that represent very large sets of concrete values.

Other abstract values are more precise, to the point where they represent single concrete values: for example, there is an abstract value representing the concrete ``null`` value, and another representing the number zero.

There is a special group of abstract values called *indefinite* abstract values that represent all concrete values. The analysis uses these to handle expressions for which it cannot infer a more precise value, such as function parameters (as mentioned above, the analysis is intraprocedural and hence does not model argument passing) or property reads (the analysis does not model property values either).

Each indefinite abstract value is associated with a string value describing the cause of imprecision. In the above examples, the indefinite value for the parameter would have cause ``"call"``, while the indefinite value for the property would have cause ``"heap"``.

To check whether an abstract value is indefinite, you can use the ``isIndefinite`` member predicate. Its single argument describes the cause of imprecision.

Each abstract value has one or more associated types (CodeQL class `InferredType <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/InferredTypes.qll/type.InferredTypes$InferredType.html>`__ corresponding roughly to the type tags computed by the ``typeof`` operator. The types are ``null``, ``undefined``, ``boolean``, ``number``, ``string``, ``function``, ``class``, ``date`` and ``object``.

To access the results of the type inference, use class `DataFlow::AnalyzedNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/TypeInference.qll/type.TypeInference$AnalyzedNode.html>`__: any `DataFlow::Node <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/DataFlow.qll/type.DataFlow$DataFlow$Node.html>`__ can be cast to this class, and additionally there is a convenience predicate ``Expr::analyze`` that maps expressions directly to their corresponding ``AnalyzedNode``\ s.

Once you have an ``AnalyzedNode``, you can use predicate ``AnalyzedNode.getAValue()`` to access the abstract values inferred for it, and ``getAType()`` to get the inferred types.

For example, here is a query that looks for ``null`` checks on expressions that cannot, in fact, be null:

.. code-block:: ql

   import javascript

   from StrictEqualityTest eq, DataFlow::AnalyzedNode nd, NullLiteral null
   where eq.hasOperands(nd.asExpr(), null) and
         not nd.getAValue().isIndefinite(_) and
         not nd.getAValue() instanceof AbstractNull
   select eq, "Spurious null check."

To paraphrase, the query looks for equality tests ``eq`` where one operand is a ``null`` literal and the other some expression that we convert to an ``AnalyzedNode``. If the type inference results for that node are precise (that is, none of the inferred values is indefinite) and (the abstract representation of) ``null`` is not among them, we flag ``eq``.

You can add custom type inference rules by defining new subclasses of ``DataFlow::AnalyzedNode`` and overriding ``getAValue``. You can also introduce new abstract values by extending the abstract class ``CustomAbstractValueTag``, which is a subclass of ``string``: each string belonging to that class induces a corresponding abstract value of type ``CustomAbstractValue``. You can use the predicate ``CustomAbstractValue.getTag()`` to map from the abstract value to its tag. By implementing the abstract predicates of class ``CustomAbstractValueTag`` you can define the semantics of your custom abstract values, such as what primitive value they coerce to and what type they have.

Call graph
~~~~~~~~~~

The JavaScript library implements a simple `call graph <https://en.wikipedia.org/wiki/Call_graph>`__ construction algorithm to statically approximate the possible call targets of function calls and ``new`` expressions. Due to the dynamically typed nature of JavaScript and its support for higher-order functions and reflective language features, building static call graphs is quite difficult. Simple call graph algorithms tend to be incomplete, that is, they often fail to resolve all possible call targets. More sophisticated algorithms can suffer from the opposite problem of imprecision, that is, they may infer many spurious call targets.

The call graph is represented by the member predicate ``getACallee()`` of class `DataFlow::InvokeNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Nodes.qll/type.Nodes$InvokeNode.html>`__, which computes possible callees of the given invocation, that is, functions that may at runtime be invoked by this expression.

Furthermore, there are three member predicates that indicate the quality of the callee information for this invocation:

-  ``DataFlow::InvokeNode.isImprecise()``: holds for invocations where the call graph builder might infer spurious call targets.
-  ``DataFlow::InvokeNode.isIncomplete()``: holds for invocations where the call graph builder might fail to infer possible call targets.
-  ``DataFlow::InvokeNode.isUncertain()``: holds if either ``isImprecise()`` or ``isIncomplete()`` holds.

As an example of a call-graph-based query, here is a query to find invocations for which the call graph builder could not find any callees, despite the analysis being complete for this invocation:

.. code-block:: ql

   import javascript

   from DataFlow::InvokeNode invk
   where not invk.isIncomplete() and
         not exists(invk.getACallee())
   select invk, "Unable to find a callee for this invocation."

Inter-procedural data flow
~~~~~~~~~~~~~~~~~~~~~~~~~~

The data flow graph-based analyses described so far are all intraprocedural: they do not take flow from function arguments to parameters or from a ``return`` to the function's caller into account. The data flow library also provides a framework for constructing custom inter-procedural analyses.

We distinguish here between data flow proper, and *taint tracking*: the latter not only considers value-preserving flow (such as from variable definitions to uses), but also cases where one value influences ("taints") another without determining it entirely. For example, in the assignment ``s2 = s1.substring(i)``, the value of ``s1`` influences the value of ``s2``, because ``s2`` is assigned a substring of ``s1``. In general, ``s2`` will not be assigned ``s1`` itself, so there is no data flow from ``s1`` to ``s2``, but ``s1`` still taints ``s2``.

It is a common pattern that we wish to specify data flow or taint analysis in terms of its *sources* (where flow starts), *sinks* (where it should be tracked), and *barriers* or *sanitizers* (where flow is interrupted). Sanitizers they are very common in security analyses: for example, an analysis that tracks the flow of untrusted user input into, say, a SQL query has to keep track of code that validates the input, thereby making it safe to use. Such a validation step is an example of a sanitizer.

The classes ``DataFlow::Configuration`` and ``TaintTracking::Configuration`` allow specifying a data flow or taint analysis, respectively, by overriding the following predicates:

-  ``isSource(DataFlow::Node nd)`` selects all nodes ``nd`` from where flow tracking starts.
-  ``isSink(DataFlow::Node nd)`` selects all nodes ``nd`` to which the flow is tracked.
-  ``isBarrier(DataFlow::Node nd)`` selects all nodes ``nd`` that act as a barrier for data flow; ``isSanitizer`` is the corresponding predicate for taint tracking configurations.
-  ``isBarrierEdge(DataFlow::Node src, DataFlow::Node trg)`` is a variant of ``isBarrier(nd)`` that allows specifying barrier *edges* in addition to barrier nodes; again, ``isSanitizerEdge`` is the corresponding predicate for taint tracking;
-  ``isAdditionalFlowStep(DataFlow::Node src, DataFlow::Node trg)`` allows specifying custom additional flow steps for this analysis; ``isAdditionalTaintStep`` is the corresponding predicate for taint tracking configurations.

Since for technical reasons both ``Configuration`` classes are subtypes of ``string``, you have to choose a unique name for each flow configuration and equate ``this`` with it in the characteristic predicate (as in the example below).

The predicate ``Configuration.hasFlow`` performs the actual flow tracking, starting at a source and looking for flow to a sink that does not pass through a barrier node or edge.

For example, suppose that we are developing an analysis to find hard-coded passwords. We might write a simple query that looks for string constants flowing into variables named ``"password"``.

.. code-block:: ql

   import javascript

   class PasswordTracker extends DataFlow::Configuration {
       PasswordTracker() {
           // unique identifier for this configuration
           this = "PasswordTracker"
       }

       override predicate isSource(DataFlow::Node nd) {
           nd.asExpr() instanceof StringLiteral
       }

       override predicate isSink(DataFlow::Node nd) {
           passwordVarAssign(_, nd)
       }

       predicate passwordVarAssign(Variable v, DataFlow::Node nd) {
          v.getAnAssignedExpr() = nd.asExpr() and
          v.getName().toLowerCase() = "password"
       }
   }

Now we can rephrase our query to use ``Configuration.hasFlow``:

.. code-block:: ql

   from PasswordTracker pt, DataFlow::Node source, DataFlow::Node sink, Variable v
   where pt.hasFlow(source, sink) and pt.passwordVarAssign(v, sink)
   select sink, "Password variable " + v + " is assigned a constant string."


Syntax errors
~~~~~~~~~~~~~

JavaScript code that contains syntax errors cannot usually be analyzed. For such code, the lexical and syntactic representations are not available, and hence no name binding information, call graph or control and data flow. All that is available in this case is a value of class `JSParseError <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Errors.qll/type.Errors$JSParseError.html>`__ representing the syntax error. It provides information about the syntax error location (`JSParseError <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Errors.qll/type.Errors$JSParseError.html>`__ is a subclass of `Locatable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Locations.qll/type.Locations$Locatable.html>`__) and the error message through predicate ``JSParseError.getMessage``.

Note that for some very simple syntax errors the parser can recover and continue parsing. If this happens, lexical and syntactic information is available in addition to the `JSParseError <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Errors.qll/type.Errors$JSParseError.html>`__ values representing the (recoverable) syntax errors encountered during parsing.

Frameworks
~~~~~~~~~~

AngularJS
^^^^^^^^^

The ``semmle.javascript.frameworks.AngularJS`` library provides support for working with `AngularJS (Angular 1.x) <https://angularjs.org/>`__ code. Its most important classes are:

-  `AngularJS::AngularModule <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/AngularJS/AngularJSCore.qll/type.AngularJSCore$AngularModule.html>`__: an Angular module
-  `AngularJS::DirectiveDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/AngularJS/ServiceDefinitions.qll/type.ServiceDefinitions$DirectiveDefinition.html>`__, `AngularJS::FactoryRecipeDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/AngularJS/ServiceDefinitions.qll/type.ServiceDefinitions$FactoryRecipeDefinition.html>`__, `AngularJS::FilterDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/AngularJS/ServiceDefinitions.qll/type.ServiceDefinitions$FilterDefinition.html>`__, `AngularJS::ControllerDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/AngularJS/ServiceDefinitions.qll/type.ServiceDefinitions$ControllerDefinition.html>`__: a definition of a directive, service, filter or controller, respectively
-  `AngularJS::InjectableFunction <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/AngularJS/DependencyInjections.qll/type.DependencyInjections$InjectableFunction.html>`__: a function that is subject to dependency injection

HTTP framework libraries
^^^^^^^^^^^^^^^^^^^^^^^^

The library ``semmle.javacript.frameworks.HTTP`` provides classes modeling common concepts from various HTTP frameworks.

Currently supported frameworks are `Express <https://expressjs.com/>`__, the standard Node.js ``http`` and ``https`` modules, `Connect <https://github.com/senchalabs/connect>`__, `Koa <https://koajs.com>`__, `Hapi <https://hapi.dev/>`__ and `Restify <http://restify.com/>`__.

The most important classes include (all in module ``HTTP``):

-  ``ServerDefinition``: an expression that creates a new HTTP server.
-  ``RouteHandler``: a callback for handling an HTTP request.
-  ``RequestExpr``: an expression that may contain an HTTP request object.
-  ``ResponseExpr``: an expression that may contain an HTTP response object.
-  ``HeaderDefinition``: an expression that sets one or more HTTP response headers.
-  ``CookieDefinition``: an expression that sets a cookie in an HTTP response.
-  ``RequestInputAccess``: an expression that accesses user-controlled request data.

For each framework library, there is a corresponding CodeQL library (for example ``semmle.javacript.frameworks.Express``) that instantiates the above classes for that framework and adds framework-specific classes.

Node.js
^^^^^^^

The ``semmle.javascript.NodeJS`` library provides support for working with `Node.js <http://nodejs.org/>`__ modules through the following classes:

-  `NodeModule <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NodeJS.qll/type.NodeJS$NodeModule.html>`__: a top-level that defines a Node.js module; see the section on `Modules <#modules>`__ for more information.
-  `Require <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NodeJS.qll/type.NodeJS$Require.html>`__: a call to the special ``require`` function that imports a module.

As an example of the use of these classes, here is a query that counts for every module how many other modules it imports:

.. code-block:: ql

   import javascript

   from NodeModule m
   select m, count(m.getAnImportedModule())

When you analyze a project, for each module you can see how many other modules it imports.

NPM
^^^

The ``semmle.javascript.NPM`` library provides support for working with `NPM <https://www.npmjs.com/>`__ packages through the following classes:

-  `PackageJSON <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/type.NPM$PackageJSON.html>`__: a ``package.json`` file describing an NPM package; various getter predicates are available for accessing detailed information about the package, which are described in the `online API documentation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/module.NPM.html>`__.
-  `BugTrackerInfo <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/type.NPM$BugTrackerInfo.html>`__, `ContributorInfo <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/type.NPM$ContributorInfo.html>`__, `RepositoryInfo <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/type.NPM$RepositoryInfo.html>`__: these classes model parts of the ``package.json`` file providing information on bug tracking systems, contributors and repositories.
-  `PackageDependencies <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/type.NPM$PackageDependencies.html>`__: models the dependencies of an NPM package; the predicate ``PackageDependencies.getADependency(pkg, v)`` binds ``pkg`` to the name and ``v`` to the version of a package required by a ``package.json`` file.
-  `NPMPackage <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/NPM.qll/type.NPM$NPMPackage.html>`__: a subclass of `Folder <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Files.qll/type.Files$Folder.html>`__ that models an NPM package; important member predicates include:

   -  ``NPMPackage.getPackageName()`` returns the name of this package.
   -  ``NPMPackage.getPackageJSON()`` returns the ``package.json`` file for this package.
   -  ``NPMPackage.getNodeModulesFolder()`` returns the ``node_modules`` folder for this package.
   -  ``NPMPackage.getAModule()`` returns a Node.js module belonging to this package (not including modules in the ``node_modules`` folder).

As an example of the use of these classes, here is a query that identifies unused dependencies, that is, module dependencies that are listed in the ``package.json`` file, but which are not imported by any ``require`` call:

.. code-block:: ql

   import javascript

   from NPMPackage pkg, PackageDependencies deps, string name
   where deps = pkg.getPackageJSON().getDependencies() and
   deps.getADependency(name, _) and
   not exists (Require req | req.getTopLevel() = pkg.getAModule() | name = req.getImportedPath().getValue())
   select deps, "Unused dependency '" + name + "'."

React
^^^^^

The ``semmle.javascript.frameworks.React`` library provides support for working with `React <https://reactjs.org/>`__ code through the `ReactComponent <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/React.qll/type.React$ReactComponent.html>`__ class, which models a React component defined either in the functional style or the class-based style (both ECMAScript 2015 classes and old-style ``React.createClass`` classes are supported).

Databases
^^^^^^^^^

The class ``SQL::SqlString`` represents an expression that is interpreted as a SQL command. Currently, we model SQL commands issued through the following npm packages:
`mysql <https://www.npmjs.com/package/mysql>`__, `pg <https://www.npmjs.com/package/pg>`__, `pg-pool <https://www.npmjs.com/package/pg-pool>`__, `sqlite3 <https://www.npmjs.com/package/sqlite3>`__, `mssql <https://www.npmjs.com/package/mssql>`__ and `sequelize <https://www.npmjs.com/package/sequelize>`__.

Similarly, the class ``NoSQL::Query`` represents an expression that is interpreted as a NoSQL query by the ``mongodb`` or ``mongoose`` package.

Finally, the class ``DatabaseAccess`` contains all data flow nodes that perform a database access using any of the packages above.

For example, here is a query to find SQL queries that use string concatenation (instead of a templating-based solution, which is usually safer):

.. code-block:: ql

   import javascript

   from SQL::SqlString ss
   where ss instanceof AddExpr
   select ss, "Use templating instead of string concatenation."

Miscellaneous
~~~~~~~~~~~~~

Externs
^^^^^^^

The ``semmle.javascript.Externs`` library provides support for working with `externs <https://developers.google.com/closure/compiler/docs/api-tutorial3>`__ through the following classes:

-  `ExternalDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalDecl.html>`__: common superclass modeling all different kinds of externs declarations; it defines two member predicates:

   -  ``ExternalDecl.getQualifiedName()`` returns the fully qualified name of the declared entity.
   -  ``ExternalDecl.getName()`` returns the unqualified name of the declared entity.

-  `ExternalTypedef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalTypedef.html>`__: a subclass of `ExternalDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalDecl.html>`__ representing type declarations; unlike other externs declarations, such declarations do not declare a function or object that is present at runtime, but simply introduce an alias for a type.
-  `ExternalVarDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalVarDecl.html>`__: a subclass of `ExternalDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalDecl.html>`__ representing a variable or function declaration; it defines two member predicates:

   -  ``ExternalVarDecl.getInit()`` returns the initializer associated with this declaration, if any; this can either be a `Function <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Functions.qll/type.Functions$Function.html>`__ or an `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__.
   -  ``ExternalVarDecl.getDocumentation()`` returns the JSDoc comment associated with this declaration.

Variables and functions declared in an externs file are either globals (represented by class `ExternalGlobalDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalGlobalDecl.html>`__), or members (represented by class `ExternalMemberDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalMemberDecl.html>`__).

Members are further subdivided into static members (class `ExternalStaticMemberDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalStaticMemberDecl.html>`__) and instance members (class `ExternalInstanceMemberDecl <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/type.Externs$ExternalInstanceMemberDecl.html>`__).

For more details on these and other classes representing externs, see `the API documentation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Externs.qll/module.Externs.html>`__.

HTML
^^^^

The ``semmle.javascript.HTML`` library provides support for working with HTML documents. They are represented as a tree of ``HTML::Element`` nodes, each of which may have zero or more attributes represented by class ``HTML::Attribute``.

Similar to the abstract syntax tree representation, ``HTML::Element`` has member predicates ``getChild(i)`` and ``getParent()`` to navigate from an element to its ``i``\ th child element and its parent element, respectively. Use predicate ``HTML::Element.getAttribute(i)`` to get the ``i``\ th attribute of the element, and ``HTML::Element.getAttributeByName(n)`` to get the attribute with name ``n``.

For ``HTML::Attribute``, predicates ``getName()`` and ``getValue()`` provide access to the attribute's name and value, respectively.

Both ``HTML::Element`` and ``HTML::Attribute`` have a predicate ``getRoot()`` that gets the root ``HTML::Element`` of the document to which they belong.

JSDoc
^^^^^

The ``semmle.javascript.JSDoc`` library provides support for working with `JSDoc comments <https://jsdoc.app/>`__. Documentation comments are parsed into an abstract syntax tree representation closely following the format employed by the `Doctrine <https://github.com/eslint/doctrine>`__ JSDoc parser.

A JSDoc comment as a whole is represented by an entity of class `JSDoc <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/type.JSDoc$JSDoc.html>`__, while individual tags are represented by class `JSDocTag <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/type.JSDoc$JSDocTag.html>`__. Important member predicates of these two classes include:

-  ``JSDoc.getDescription()`` returns the descriptive header of the JSDoc comment, if any.
-  ``JSDoc.getComment()`` maps the `JSDoc <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/type.JSDoc$JSDoc.html>`__ entity to its underlying `Comment <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Comments.qll/type.Comments$Comment.html>`__ entity.
-  ``JSDocTag.getATag()`` returns a tag in this JSDoc comment.
-  ``JSDocTag.getTitle()`` returns the title of his tag; for instance, an ``@param`` tag has title ``"param"``.
-  ``JSDocTag.getName()`` returns the name of the parameter or variable documented by this tag.
-  ``JSDocTag.getType()`` returns the type of the parameter or variable documented by this tag.
-  ``JSDocTag.getDescription()`` returns the description associated with this tag.

Types in JSDoc comments are represented by the class `JSDocTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/type.JSDoc$JSDocTypeExpr.html>`__ and its subclasses, which again represent type expressions as abstract syntax trees. Examples of type expressions are `JSDocAnyTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/type.JSDoc$JSDocAnyTypeExpr.html>`__, representing the "any" type ``*``, or `JSDocNullTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/type.JSDoc$JSDocNullTypeExpr.html>`__, representing the null type.

As an example, here is a query that finds ``@param`` tags that do not specify the name of the documented parameter:

.. code-block:: ql

   import javascript

   from JSDocTag t
   where t.getTitle() = "param" and
   not exists(t.getName())
   select t, "@param tag is missing name."

For full details on these and other classes representing JSDoc comments and type expressions, see `the API documentation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSDoc.qll/module.JSDoc.html>`__.

JSX
^^^

The ``semmle.javascript.JSX`` library provides support for working with `JSX code <https://reactjs.org/docs/jsx-in-depth.html>`__.

Similar to the representation of HTML documents, JSX fragments are modeled as a tree of `JSXElement <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSX.qll/type.JSX$JSXElement.html>`__\ s, each of which may have zero or more `JSXAttribute <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSX.qll/type.JSX$JSXAttribute.html>`__\ s.

However, unlike HTML, JSX is interleaved with JavaScript, hence `JSXElement <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSX.qll/type.JSX$JSXElement.html>`__ is a subclass of `Expr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$Expr.html>`__. Like ``HTML::Element``, it has predicates ``getAttribute(i)`` and ``getAttributeByName(n)`` to look up attributes of a JSX element. Its body elements can be accessed by predicate ``getABodyElement()``; note that the results of this predicate are arbitrary expressions, which may either be further `JSXElement <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSX.qll/type.JSX$JSXElement.html>`__\ s, or other expressions that are interpolated into the body of the outer element.

`JSXAttribute <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSX.qll/type.JSX$JSXAttribute.html>`__, again not unlike ``HTML::Attribute``, has predicates ``getName()`` and ``getValue()`` to access the attribute name and value.

JSON
^^^^

The ``semmle.javascript.JSON`` library provides support for working with `JSON <http://json.org/>`__ files that were processed by the JavaScript extractor when building the CodeQL database.

JSON files are modeled as trees of JSON values. Each JSON value is represented by an entity of class `JSONValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONValue.html>`__, which provides the following member predicates:

-  ``JSONValue.getParent()`` returns the JSON object or array in which this value occurs.
-  ``JSONValue.getChild(i)`` returns the ``i``\ th child of this JSON object or array.

Note that `JSONValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONValue.html>`__ is a subclass of `Locatable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Locations.qll/type.Locations$Locatable.html>`__, so the usual member predicates of `Locatable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Locations.qll/type.Locations$Locatable.html>`__ can be used to determine the file in which a JSON value appears, and its location within that file.

Class `JSONValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONValue.html>`__ has the following subclasses:

-  `JSONPrimitiveValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONPrimitiveValue.html>`__: a JSON-encoded primitive value; use ``JSONPrimitiveValue.getValue()`` to obtain a string representation of the value.

   -  `JSONNull <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONNull.html>`__, `JSONBoolean <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONBoolean.html>`__, `JSONNumber <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONNumber.html>`__, `JSONString <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONString.html>`__: subclasses of `JSONPrimitiveValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONPrimitiveValue.html>`__ representing the various kinds of primitive values.

-  `JSONArray <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONArray.html>`__: a JSON-encoded array; use ``JSONArray.getElementValue(i)`` to access the ``i``\ th element of the array.
-  `JSONObject <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/JSON.qll/type.JSON$JSONObject.html>`__: a JSON-encoded object; use ``JSONObject.getValue(n)`` to access the value of property ``n`` of the object.

Regular expressions
^^^^^^^^^^^^^^^^^^^

The ``semmle.javascript.Regexp`` library provides support for working with regular expression literals. The syntactic structure of regular expression literals is represented as an abstract syntax tree of regular expression terms, modeled by the class `RegExpTerm <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Regexp.qll/type.Regexp$RegExpTerm.html>`__. Similar to `ASTNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$ASTNode.html>`__, class `RegExpTerm <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Regexp.qll/type.Regexp$RegExpTerm.html>`__ provides member predicates ``getParent()`` and ``getChild(i)`` to navigate the structure of the syntax tree.

Various subclasses of `RegExpTerm <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Regexp.qll/type.Regexp$RegExpTerm.html>`__ model different kinds of regular expression constructs and operators; see `the API documentation <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Regexp.qll/module.Regexp.html>`__ for details.

YAML
^^^^

The ``semmle.javascript.YAML`` library provides support for working with `YAML <https://yaml.org/>`__ files that were processed by the JavaScript extractor when building the CodeQL database.

YAML files are modeled as trees of YAML nodes. Each YAML node is represented by an entity of class `YAMLNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLNode.html>`__, which provides, among others, the following member predicates:

-  ``YAMLNode.getParentNode()`` returns the YAML collection in which this node is syntactically nested.
-  ``YAMLNode.getChildNode(i)`` returns the ``i``\ th child node of this node, ``YAMLNode.getAChildNode()`` returns any child node of this node.
-  ``YAMLNode.getTag()`` returns the tag of this YAML node.
-  ``YAMLNode.getAnchor()`` returns the anchor associated with this YAML node, if any.
-  ``YAMLNode.eval()`` returns the `YAMLValue <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLValue.html>`__ this YAML node evaluates to after resolving aliases and includes.

The various kinds of scalar values available in YAML are represented by classes `YAMLInteger <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLInteger.html>`__, `YAMLFloat <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLFloat.html>`__, `YAMLTimestamp <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLTimestamp.html>`__, `YAMLBool <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLBool.html>`__, `YAMLNull <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLNull.html>`__ and `YAMLString <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLString.html>`__. Their common superclass is `YAMLScalar <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLScalar.html>`__, which has a member predicate ``getValue()`` to obtain the value of a scalar as a
string.

`YAMLMapping <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLMapping.html>`__ and `YAMLSequence <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLSequence.html>`__ represent mappings and sequences, respectively, and are subclasses of `YAMLCollection <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLCollection.html>`__.

Alias nodes are represented by class `YAMLAliasNode <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLAliasNode.html>`__, while `YAMLMergeKey <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLMergeKey.html>`__ and `YAMLInclude <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/YAML.qll/type.YAML$YAMLInclude.html>`__ represent merge keys and ``!include`` directives, respectively.

Predicate ``YAMLMapping.maps(key, value)`` models the key-value relation represented by a mapping, taking merge keys into account.

Further reading
---------------

.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-ruby.rst
.. _codeql-library-for-ruby:

CodeQL library for Ruby
=======================

When you're analyzing a Ruby program, you can make use of the large collection of classes in the CodeQL library for Ruby.

Overview
--------

CodeQL ships with an extensive library for analyzing Ruby code.  The classes in this library present
the data from a CodeQL database in an object-oriented form and provide abstractions and predicates
to help you with common analysis tasks.

The library is implemented as a set of CodeQL modules, that is, files with the extension ``.qll``. The
module `ruby.qll <https://github.com/github/codeql/blob/main/ruby/ql/lib/ruby.qll>`__ imports most other standard library modules, so you can include the complete
library by beginning your query with:

.. code-block:: ql

   import codeql.ruby.AST

The CodeQL libraries model various aspects of Ruby code, depending on the type of query you want to write.
For example the abstract syntax tree (AST) library is used for locating program elements, to match syntactic
elements in the source code. This can be used to find values, patterns and structures.

The control flow graph (CFG) is imported using

.. code-block:: ql

   import codeql.ruby.CFG

The CFG models the control flow between statements and expressions, for example whether one expression can
flow to another expression, or whether an expression "dominates" another one, meaning that all paths to an
expression must flow through another expression first.

The data flow library is imported using 

.. code-block:: ql

   import codeql.ruby.DataFlow

Data flow tracks the flow of data through the program, including through function calls (interprocedural data flow).
Data flow is particularly useful for security queries, where untrusted data flows to vulnerable parts of the program
to exploit it. Related to data flow, is the taint-tracking library, which finds how data can *influence* other values
in a program, even when it is not copied exactly.

The API graphs library is used to locate methods in libraries. This is particuarly useful when locating
particular functions or parameters that could be used as a source or sink of data in a security query.

To summarize, the main Ruby modules are:

.. list-table:: Main Ruby modules
   :header-rows: 1

   * - Import
     - Description
   * - ``ruby``
     - The standard Ruby library
   * - ``codeql.ruby.AST``
     - The abstract syntax tree library (also imported by `ruby.qll`)
   * - ``codeql.ruby.ApiGraphs``
     - The API graphs library
   * - ``codeql.ruby.CFG``
     - The control flow graph library
   * - ``codeql.ruby.DataFlow``
     - The data flow library
   * - ``codeql.ruby.TaintTracking``
     - The taint tracking library

The CodeQL examples in this article are only excerpts and are not meant to represent complete queries.

Abstract syntax
---------------

The abstract syntax tree (AST) represents the elements of the source code organized into a tree. The `AST viewer <https://docs.github.com/en/code-security/codeql-for-vs-code/using-the-advanced-functionality-of-the-codeql-for-vs-code-extension/exploring-the-structure-of-your-source-code/>`__
in Visual Studio Code shows the AST nodes, including the relevant CodeQL classes and predicates.

All CodeQL AST classes inherit from the `AstNode` class, which provides the following member predicates
to all AST classes:

.. list-table:: Main predicates in ``AstNode``
   :header-rows: 1

   * - Predicate
     - Description
   * - ``getEnclosingModule()``
     - Gets the enclosing module, if any.
   * - ``getEnclosingMethod()``
     - Gets the enclosing method, if any.
   * - ``getLocation()``
     - Gets the location of this node.
   * - ``getAChild()``
     - Gets a child node of this node.
   * - ``getParent()``
     - Gets the parent of this `AstNode`, if this node is not a root node.
   * - ``getDesugared``
     - Gets the desugared version of this AST node, if any.
   * - ``isSynthesized()``
     - Holds if this node was synthesized to represent an implicit AST node not
       present in the source code.

Modules
~~~~~~~

Modules represent the main structural elements of Ruby programs, and include modules (``Module``), 
namespaces  (``Namespace``) and classes (``ClassDeclaration``).

.. list-table:: Callable classes
   :header-rows: 1

   * - CodeQL class
     - Description and selected predicates
   * - ``Module``
     -  A representation of a runtime `module` or `class` value.

        - `getADeclaration()` - Gets a declaration
        - `getSuperClass()` - Gets the super class of this module, if any.
        - `getAPrependedModule()` - Gets a prepended module.
        - `getAnIncludedModule()` - Gets an included module.
   * - ``Namespace``
     - A class or module definition.
     
       - `getName()` - Gets the name of the module/class.
       - `getAMethod()`, `getMethod(name)` - Gets a method in this namespace.
       - `getAClass()`, `getClass(name)` - Gets a class in this namespace.
       - `getAModule()`, `getModule(name)` - Gets a module in this namespace.
   * - ``ClassDeclaration``
     - A class definition.
   * - ``SingletonClass``
     - A definition of a singleton class on an object.
   * - ``ModuleDeclaration``
     - A module definition.
   * - ``Toplevel``
     - The node representing the entire Ruby source file.

The following example lists all methods in the class `ApiController`:

.. code-block:: ql

   import codeql.ruby.AST

   from ClassDeclaration m
   where m.getName() = "ApiController"
   select m, m.getAMethod()

Callables
~~~~~~~~~

`Callables` are elements that can be called, including methods and blocks.

.. list-table:: Callable classes
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``Callable``
     - A callable.

       - `getAParameter()` - gets a parameter of this callable.
       - `getParameter(n)` - gets the nth parameter of this callable.
   * - ``Private``
     - A call to ``private``.
   * - ``Method``
     - A method.
  
       - `getName()` - gets the name of this method
   * - ``SingletonMethod``
     - A singleton method.
   * - ``Lambda``
     - A lambda (anonymous method).
   * - ``Block``
     - A block.
   * - ``DoBlock``
     - A block enclosed within `do` and `end`.
   * - ``BraceBlock``
     - A block defined using curly braces.

*Parameters* are the values that are passed into callables. Unlike other CodeQL language models,
parameters in Ruby are not variables themselves, but can introduce variables into the
callable. The variables of a parameter are given by the `getAVariable()` predicate.

.. list-table:: Parameter classes
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``Parameter``
     - A parameter.
  
       - `getCallable()` - Gets the callable that this parameter belongs to.
       - `getPosition()` - Gets the zero-based position of this parameter.
       - `getAVariable()`, `getVariable(name)` - Gets a variable introduced by this parameter.
   * - ``PatternParameter``
     - A parameter defined using a pattern.
   * - ``TuplePatternParameter``
     - A parameter defined using a tuple pattern.
   * - ``NamedParameter``
     - A named parameter.

       - `getName()`, `hasName(name)` - Gets the name of this parameter.
       - `getAnAccess()` - Gets an access to this parameter.
       - `getDefiningAccess()` - Gets the access that defines the underlying local variable.
   * - ``SimpleParameter``
     - A simple (normal) parameter.
   * - ``BlockParameter``
     - A parameter that is a block.
   * - ``HashSplatParameter``
     - A hash-splat (or double-splat) parameter.
   * - ``KeywordParameter``
     - A keyword parameter, including a default value if the parameter is optional.

       - `getDefaultValue()` - Gets the default value, i.e. the value assigned to the parameter when one is not provided by the caller.
   * - ``OptionalParameter``
     - An optional parameter.

       - `getDefaultValue()` - Gets the default value, i.e. the value assigned to the parameter when one is not provided by the caller.
   * - ``SplatParameter``
     - A splat parameter.


Example

.. code-block:: ql

   import codeql.ruby.AST

   from Method m
   where m.getName() = "show"
   select m.getParameter(0)

Statements
~~~~~~~~~~

Statements are the elements of code blocks. Statements that produce a value are called *expressions*
and have CodeQL class `Expr`. The remaining statement types (that do not produce values) are listed below.

.. list-table:: Statement classes
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * -  ``Stmt``
     - The base class for all statements.

       - `getAControlFlowNode()` - Gets a control-flow node for this statement, if any.
       - `getEnclosingCallable()` - Gets the enclosing callable, if any.
   * - ``EmptyStmt``
     - An empty statement.
   * - ``BeginExpr``
     - A `begin` statement.
   * - ``BeginBlock``
     - A `BEGIN` block.
   * - ``EndBlock``
     - An `END` block.
   * - ``UndefStmt``
     - An `undef` statement.
   * - ``AliasStmt``
     - An `alias` statement.
   * - ``ReturningStmt``
     - A statement that may return a value: `return`, `break` and `next`.
   * - ``ReturnStmt``
     - A `return` statement.
   * - ``BreakStmt``
     - A `break` statement.
   * - ``NextStmt``
     - A `next` statement.
   * - ``RedoStmt``
     - A `redo` statement.
   * - ``RetryStmt``
     - A `retry` statement.

The following example finds all literals that are returned by a `return` statement.

.. code-block:: ql

   import codeql.ruby.AST

   from ReturnStmt return, Literal lit
   where lit.getParent() = return 
   select lit, "Returning a literal " + lit.getValueText()

Expressions
~~~~~~~~~~~

Expressions are types of statement that evaluate to a value. The CodeQL class `Expr` is the base class of all expression types.

.. list-table:: Expressions
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``Expr``
     - An expression.
 
       This is the root class for all expressions.

       - `getValueText()` - Gets the textual (constant) value of this expression, if any.
   * - ``Self``
     - A reference to the current object.
   * - ``Pair``
     - A pair expression.
   * - ``RescueClause``
     - A `rescue` clause.
   * - ``RescueModifierExpr``
     - An expression with a `rescue` modifier.
   * - ``StringConcatenation``
     - A concatenation of string literals.

       - `getConcatenatedValueText()` - Gets the result of concatenating all the string literals, if and only if they do not contain any interpolations.

.. list-table:: Statement sequences
   :header-rows: 1

   * - CodeQL class
     - Description
   * - ``StmtSequence``
     - A sequence of expressions.

       - `getAStmt()`, `getStmt(n)` - Gets a statement in this sequence.
       - `isEmpty()` - Holds if this sequence has no statements.
       - `getNumberOfStatements()` - Gets the number of statements in this sequence.
   * - ``BodyStmt``
     - A sequence of statements representing the body of a method, class, module, or do-block.

       - `getARescue()`, `getRescue(n)` - Gets a rescue clause in this block.
       - `getElse()` - Gets the `else` clause in this block, if any.
       - `getEnsure()` - Gets the `ensure` clause in this block, if any.
   * - ``ParenthesizedExpr``
     - A parenthesized expression sequence, typically containing a single expression.


Literals are expressions that evaluate directly to the given value. The CodeQL Ruby library models all types of
Ruby literal.

.. list-table:: Literals
   :header-rows: 1

   * - CodeQL class
     - Description
   * - ``Literal``
     - A literal. This is the base class for all literals.

       - `getValueText()` - Gets the source text for this literal, if this is a simple literal.
   * - ``NumericLiteral``
     - A numerical literal. The literal types are ``IntegerLiteral``, ``FloatLiteral``, ``RationalLiteral``, and ``ComplexLiteral``.
   * - ``NilLiteral``
     - A `nil` literal.
   * - ``BooleanLiteral``
     - A Boolean value. The classes ``TrueLiteral`` and ``FalseLiteral`` match `true` and `false` respectively.
   * - ``StringComponent``
     - A component of a string. Either a ``StringTextComponent``, ``StringEscapeSequenceComponent``, or ``StringInterpolationComponent``.
   * - ``RegExpLiteral``
     - A regular expression literal.
   * - ``SymbolLiteral``
     - A symbol literal.
   * - ``SubshellLiteral``
     - A subshell literal.
   * - ``CharacterLiteral``
     - A character literal.
   * - ``ArrayLiteral``
     - An array literal.
   * - ``HashLiteral``
     - A hash literal.
   * - ``RangeLiteral``
     - A range literal.
   * - ``MethodName``
     - A method name literal.

The following example defines a string literal class containing the text "username":

.. code-block:: ql

   class UsernameLiteral extends Literal
   {
     UsernameLiteral() { this.getValueText().toLowerCase().matches("%username%") }
   }


*Operations* are types of expression that typically perform some sort of calculation. Most operations are ``MethodCalls`` because often
there is an underlying call to the operation.

.. list-table:: Operations
   :header-rows: 1

   * - CodeQL class
     - Description
   * - ``Operation``
     - An operation.
   * - ``UnaryOperation``
     - A unary operation.

       Types of unary operation include ``UnaryLogicalOperation``, ``NotExpr``, ``UnaryPlusExpr``, ``UnaryMinusExpr``, ``SplatExpr``, 
       ``HashSplatExpr``, ``UnaryBitwiseOperation``, and ``ComplementExpr``.
   * - ``DefinedExpr``
     - A call to the special `defined?` operator
   * - ``BinaryOperation``
     - A binary operation, that includes many other operation categories such as ``BinaryArithmeticOperation``, ``BinaryBitwiseOperation``, ``ComparisonOperation``, ``SpaceshipExpr``, and ``Assignment``.
   * - ``BinaryArithmeticOperation``
     - A binary arithmetic operation. Includes: ``AddExpr``, ``SubExpr``, ``MulExpr``, ``DivExpr``, ``ModuloExpr``, and ``ExponentExpr``.
   * - ``BinaryLogicalOperation``
     - A binary logical operation. Includes: ``LogicalAndExpr`` and ``LogicalOrExpr``.
   * - ``BinaryBitwiseOperation``
     - A binary bitwise operation. Includes: ``LShiftExpr``, ``RShiftExpr``, ``BitwiseAndExpr``, ``BitwiseOrExpr``, and ``BitwiseXorExpr``.
   * - ``ComparisonOperation``
     - A comparison operation, including the classes ``EqualityOperation``, ``EqExpr``, ``NEExpr``, ``CaseEqExpr``, ``RelationalOperation``, ``GTExpr``, ``GEExpr``, ``LTExpr``, and ``LEExpr``.
   * - ``RegExpMatchExpr``
     - A regexp match expression.
   * - ``NoRegExpMatchExpr``
     - A regexp-doesn't-match expression.
   * - ``Assignment``
     - An assignment. Assignments are simple assignments (``AssignExpr``), or assignment operations (``AssignOperation``).

       The assignment arithmetic operations (``AssignArithmeticOperation``) are ``AssignAddExpr``, ``AssignSubExpr``, ``AssignMulExpr``, ``AssignDivExpr``, ``AssignModuloExpr``, and ``AssignExponentExpr``.
       
       The assignment logical operations (``AssignLogicalOperation``) are ``AssignLogicalAndExpr`` and ``AssignLogicalOrExpr``.

       The assignment bitwise operations (``AssignBitwiseOperation``) are ``AssignLShiftExpr``, ``AssignRShiftExpr``, ``AssignBitwiseAndExpr``, ``AssignBitwiseOrExpr``, and ``AssignBitwiseXorExpr``.

The following example finds "chained assignments" (of the form ``A=B=C``):

.. code-block:: ql

   import codeql.ruby.AST
   
   from Assignment op
   where op.getRightOperand() instanceof Assignment
   select op, "This is a chained assignment."

Calls pass control to another function, include explicit method calls (``MethodCall``), but also include other types of call such as `super` calls or `yield` calls.

.. list-table:: Calls
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``Call``
     - A call.
        
       - `getArgument(n)`, `getAnArgument()`, `getKeywordArgument(keyword)` - Gets an argument of this call.
       - `getATarget()` - Gets a potential target of this call, if any.
   * - ``MethodCall``
     - A method call.

       - `getReceiver()` - Gets the receiver of this call, if any. This is the object being invoked.
       - `getMethodName()` - Gets the name of the method being called.
       - `getBlock()` - Gets the block of this method call, if any.
   * - ``SetterMethodCall``
     - A call to a setter method.
   * - ``ElementReference``
     - An element reference; a call to the `[]` method.
   * - ``YieldCall``
     - A call to `yield`.
   * - ``SuperCall``
     - A call to `super`.
   * - ``BlockArgument``
     - A block argument in a method call.

The following example finds all method calls to a method called `delete`.

.. code-block:: ql

   import codeql.ruby.AST

   from MethodCall call
   where call.getMethodName() = "delete"
   select call, "Call to 'delete'."

Control expressions are expressions used for control flow.  They are classed as expressions because they can produce a value.

.. list-table:: Control expressions
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``ControlExpr``
     - A control expression, such as a `case`, `if`, `unless`, ternary-if (`?:`), `while`, `until` (including expression-modifier variants), and `for`.
   * - ``ConditionalExpr``
     - A conditional expression.

       - `getCondition()` - Gets the condition expression.
   * - ``IfExpr``
     - An `if` or `elsif` expression.

       - `getThen()` - Gets the `then` branch.
       - `getElse()` - Gets the `elseif` or `else` branch.
   * - ``UnlessExpr``
     - An `unless` expression.
   * - ``IfModifierExpr``
     - An expression modified using `if`.
   * - ``UnlessModifierExpr``
     - An expression modified using `unless`.
   * - ``TernaryIfExpr``
     - A conditional expression using the ternary (`?:`) operator.
   * - ``CaseExpr``
     - A `case` expression.
   * - ``WhenExpr``
     - A `when` branch of a `case` expression.
   * - ``Loop``
     - A loop. That is, a `for` loop, a `while` or `until` loop, or their expression-modifier variants.
   * - ``ConditionalLoop``
     - A loop using a condition expression. That is, a `while` or `until` loop, or their expression-modifier variants.

       - `getCondition()` - Gets the condition expression of this loop.
   * - ``WhileExpr``
     - A `while` loop.
   * - ``UntilExpr``
     - An `until` loop.
   * - ``WhileModifierExpr``
     - An expression looped using the `while` modifier.
   * - ``UntilModifierExpr``
     - An expression looped using the `until` modifier.
   * - ``ForExpr``
     - A `for` loop.

The following example finds `if`-expressions that are missing a `then` branch.

.. code-block:: ql
   
   import codeql.ruby.AST

   from IfExpr expr
   where not exists(expr.getThen())
   select expr, "This if-expression is redundant."

Variables
~~~~~~~~~

*Variables* are names that hold values in a Ruby program. If you want to query *any* type 
of variable, then use the ``Variable`` class, otherwise use one of the subclasses
``LocalVariable``, ``InstanceVariable``, ``ClassVariable`` or ``GlobalVariable``.

Local variables have the scope of a single function or block, instance variables have the
scope of an object (like member variables), *class* variables have the scope of a class and are
shared between all instances of that class (like static variables), and *global* variables
have the scope of the entire program.

.. list-table:: Variable classes
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``Variable``
     - A variable declared in a scope.

       - `getName()`, `hasName(name)` - Gets the name of this variable.
       - `getDeclaringScope()` - Gets the scope this variable is declared in.
       - `getAnAccess()` - Gets an access to this variable.
   * - ``LocalVariable``
     - A local variable.
   * - ``InstanceVariable``
     - An instance variable.
   * - ``ClassVariable``
     - A class variable.
   * - ``GlobalVariable``
     - A global variable.

The following example finds all class variables in the class `StaticController`:

.. code-block:: ql

   import codeql.ruby.AST

   from ClassDeclaration cd, ClassVariable v
   where
     v.getDeclaringScope() = cd and
     cd.getName() = "StaticController"
   select v, "This is a static variable in 'StaticController'."

Variable accesses are the uses of a variable in the source code. Note that variables, and *uses* of variables are different concepts.
Variables are modelled using the ``Variable`` class, whereas uses of the variable are modelled using the ``VariableAccess`` class.
``Variable.getAnAccess()`` gets the accesses of a variable.

Variable accesses come in two types: *reads* of the variable (a ``ReadAccess``), and *writes* to the variable (a ``WriteAccess``). 
Accesses are a type of expression, so extend the ``Expr`` class. 

.. list-table:: Variable access classes
   :header-rows: 1

   * - CodeQL class
     - Description and main predicates
   * - ``VariableAccess``
     - An access to a variable.

       - `getVariable()` - Gets the variable that is accessed.
   * - ``VariableReadAccess``
     - An access to a variable where the value is read.
   * - ``VariableWriteAccess``
     - An access to a variable where the value is updated.
   * - ``LocalVariableAccess``
     - An access to a local variable.
   * - ``LocalVariableWriteAccess``
     - An access to a local variable where the value is updated.
   * - ``LocalVariableReadAccess``
     - An access to a local variable where the value is read.
   * - ``GlobalVariableAccess``
     - An access to a global variable where the value is updated.
   * - ``InstanceVariableAccess``
     - An access to a global variable where the value is read.
   * - ``InstanceVariableReadAccess``
     - An access to an instance variable.
   * - ``InstanceVariableWriteAccess``
     - An access to an instance variable where the value is updated.
   * - ``ClassVariableAccess``
     - An access to a class variable.
   * - ``ClassVariableWriteAccess``
     - An access to a class variable where the value is updated.
   * - ``ClassVariableReadAccess``
     - An access to a class variable where the value is read.

The following example finds writes to class variables in the class `StaticController`:

.. code-block:: ql

   import codeql.ruby.AST

   from ClassVariableWriteAccess write, ClassDeclaration cd, ClassVariable v
   where
     v.getDeclaringScope() = cd and
     cd.getName() = "StaticController" and
     write.getVariable() = v
   select write, "'StaticController' class variable is written here."


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-swift-code.rst
.. _basic-query-for-swift-code:

Basic query for Swift code
==========================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run performs a basic search of the code for ``if`` expressions that are redundant, in the sense that they have an empty ``then`` branch. For example, code such as:

.. code-block:: swift

   if error {
     // we should handle the error
   }

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete the content and paste in the following query.

   .. code-block:: ql

      import swift

      from IfStmt ifStmt
      where ifStmt.getThen().(BraceStmt).getNumberOfElements() = 0
      select ifStmt, "This 'if' statement is redundant."

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-swift-query-results-1.png
   :align: center

If any matching code is found, click a link in the ``ifStmt`` column to open the file and highlight the matching ``if`` statement.

.. image:: ../images/codeql-for-visual-studio-code/basic-swift-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+
| Query part                                                       | Purpose                                                                                                           | Details                                                                                         |
+==================================================================+===================================================================================================================+=================================================================================================+
| ``import swift``                                                 | Imports the standard CodeQL AST libraries for Swift.                                                              | Every query begins with one or more ``import`` statements.                                      |
+------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+
| ``from IfStmt ifStmt``                                           | Defines the variables for the query.                                                                              | We use: an ``IfStmt`` variable for ``if`` statements.                                           |
|                                                                  | Declarations are of the form:                                                                                     |                                                                                                 |
|                                                                  | ``<type> <variable name>``                                                                                        |                                                                                                 |
+------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+
| ``where ifStmt.getThen().(BraceStmt).getNumberOfElements() = 0`` | Defines a condition on the variables.                                                                             | ``ifStmt.getThen()``: gets the ``then`` branch of the ``if`` expression.                        |
|                                                                  |                                                                                                                   | ``.(BraceStmt)``: requires that the ``then`` branch is a brace statement (``{ }``).             |
|                                                                  |                                                                                                                   | ``.getNumberOfElements() = 0``: requires that the brace statement contains no child statements. |
+------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+
| ``select ifStmt, "This 'if' statement is redundant."``           | Defines what to report for each match.                                                                            | Reports the resulting ``if`` statement with a string that explains the problem.                 |
|                                                                  |                                                                                                                   |                                                                                                 |
|                                                                  | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                 |
|                                                                  | ``select <program element>, "<alert message>"``                                                                   |                                                                                                 |
+------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find examples of ``if`` statements with an ``else`` branch, where an empty ``then`` branch does serve a purpose. For example:

.. code-block:: swift

   if (option == "-verbose") {
     // nothing to do - handled earlier
   } else {
     handleError("unrecognized option")
   }

In this case, identifying the ``if`` statement with the empty ``then`` branch as redundant is a false positive. One solution to this is to modify the query to select ``if`` statements where both the ``then`` and ``else`` branches are missing.

To exclude ``if`` statements that have an ``else`` branch:

#. Add the following to the where clause:

   .. code-block:: ql

      and not exists(ifStmt.getElse())

   The ``where`` clause is now:

   .. code-block:: ql

      where
        ifStmt.getThen().(BraceStmt).getNumberOfElements() = 0 and
        not exists(ifStmt.getElse())

#. Re-run the query.

   There are now fewer results because ``if`` expressions with an ``else`` branch are no longer included.

Further reading
---------------

.. include:: ../reusables/swift-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: Swift

.. |language-code| replace:: ``swift``

.. |example-url| replace:: https://github.com/alamofire/alamofire

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-swift.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``ifStmt`` and is linked to the location in the source code of the project where ``ifStmt`` occurs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-java.rst
.. _codeql-for-java:

CodeQL for Java and Kotlin
==========================

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from Java and Kotlin codebases.

.. pull-quote:: Enabling Kotlin support

   CodeQL treats Java and Kotlin as parts of the same language, so to enable Kotlin support you should enable ``java-kotlin`` as a language.

.. toctree::
   :hidden:

   basic-query-for-java-code
   codeql-library-for-java
   analyzing-data-flow-in-java
   types-in-java
   overflow-prone-comparisons-in-java
   navigating-the-call-graph
   annotations-in-java
   javadoc
   working-with-source-locations
   abstract-syntax-tree-classes-for-working-with-java-programs
   customizing-library-models-for-java-and-kotlin

-  :doc:`Basic query for Java and Kotlin code <basic-query-for-java-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for Java and Kotlin <codeql-library-for-java>`: When analyzing Java/Kotlin code, you can use the large collection of classes in the CodeQL library for Java/Kotlin.

-  :doc:`Analyzing data flow in Java and Kotlin <analyzing-data-flow-in-java>`: You can use CodeQL to track the flow of data through a Java/Kotlin program to its use. 

-  :doc:`Java and Kotlin types <types-in-java>`: You can use CodeQL to find out information about data types used in Java/Kotlin code. This allows you to write queries to identify specific type-related issues.

-  :doc:`Overflow-prone comparisons in Java and Kotlin <overflow-prone-comparisons-in-java>`: You can use CodeQL to check for comparisons in Java/Kotlin code where one side of the comparison is prone to overflow.

-  :doc:`Navigating the call graph <navigating-the-call-graph>`: CodeQL has classes for identifying code that calls other code, and code that can be called from elsewhere. This allows you to find, for example, methods that are never used.

-  :doc:`Annotations in Java and Kotlin <annotations-in-java>`: CodeQL databases of Java/Kotlin projects contain information about all annotations attached to program elements.

-  :doc:`Javadoc <javadoc>`: You can use CodeQL to find errors in Javadoc comments in Java code.

-  :doc:`Working with source locations <working-with-source-locations>`: You can use the location of entities within Java/Kotlin code to look for potential errors. Locations allow you to deduce the presence, or absence, of white space which, in some cases, may indicate a problem.

-  :doc:`Abstract syntax tree classes for working with Java and Kotlin programs <abstract-syntax-tree-classes-for-working-with-java-programs>`: CodeQL has a large selection of classes for representing the abstract syntax tree of Java/Kotlin programs.

-  :doc:`Customizing library models for Java and Kotlin <customizing-library-models-for-java-and-kotlin>`: You can model frameworks and libraries that your code base depends on using data extensions and publish them as CodeQL model packs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/navigating-the-call-graph.rst
.. _navigating-the-call-graph:

Navigating the call graph
=========================

CodeQL has classes for identifying code that calls other code, and code that can be called from elsewhere. This allows you to find, for example, methods that are never used.

Call graph classes
------------------

The CodeQL library for Java/Kotlin provides two abstract classes for representing a program's call graph: ``Callable`` and ``Call``. The former is simply the common superclass of ``Method`` and ``Constructor``, the latter is a common superclass of ``MethodAccess``, ``ClassInstanceExpression``, ``ThisConstructorInvocationStmt`` and ``SuperConstructorInvocationStmt``. Simply put, a ``Callable`` is something that can be invoked, and a ``Call`` is something that invokes a ``Callable``.

For example, in the following program all callables and calls have been annotated with comments:

.. code-block:: java

   class Super {
       int x;

       // callable
       public Super() {
           this(23);       // call
       }

       // callable
       public Super(int x) {
           this.x = x;
       }

       // callable
       public int getX() {
           return x;
       }
   }

       class Sub extends Super {
       // callable
       public Sub(int x) {
           super(x+19);    // call
       }

       // callable
       public int getX() {
           return x-19;
       }
   }

   class Client {
       // callable
       public static void main(String[] args) {
           Super s = new Sub(42);  // call
           s.getX();               // call
       }
   }

Class ``Call`` provides two call graph navigation predicates:

-  ``getCallee`` returns the ``Callable`` that this call (statically) resolves to; note that for a call to an instance (that is, non-static) method, the actual method invoked at runtime may be some other method that overrides this method.
-  ``getCaller`` returns the ``Callable`` of which this call is syntactically part.

For instance, in our example ``getCallee`` of the second call in ``Client.main`` would return ``Super.getX``. At runtime, though, this call would actually invoke ``Sub.getX``.

Class ``Callable`` defines a large number of member predicates; for our purposes, the two most important ones are:

-  ``calls(Callable target)`` succeeds if this callable contains a call whose callee is ``target``.
-  ``polyCalls(Callable target)`` succeeds if this callable may call ``target`` at runtime; this is the case if it contains a call whose callee is either ``target`` or a method that ``target`` overrides.

In our example, ``Client.main`` calls the constructor ``Sub(int)`` and the method ``Super.getX``; additionally, it ``polyCalls`` method ``Sub.getX``.

Example: Finding unused methods
-------------------------------

We can use the ``Callable`` class to write a query that finds methods that are not called by any other method:

.. code-block:: ql

   import java

   from Callable callee
   where not exists(Callable caller | caller.polyCalls(callee))
   select callee

This simple query typically returns a large number of results.

.. pull-quote::

   Note

   We have to use ``polyCalls`` instead of ``calls`` here: we want to be reasonably sure that ``callee`` is not called, either directly or via overriding.

Running this query on a typical Java/Kotlin project results in lots of hits in the Java/Kotlin standard library. This makes sense, since no single client program uses every method of the standard library. More generally, we may want to exclude methods and constructors from compiled libraries. We can use the predicate ``fromSource`` to check whether a compilation unit is a source file, and refine our query:

.. code-block:: ql

   import java

   from Callable callee
   where not exists(Callable caller | caller.polyCalls(callee)) and
       callee.getCompilationUnit().fromSource()
   select callee, "Not called."

This change reduces the number of results returned for most codebases.

We might also notice several unused methods with the somewhat strange name ``<clinit>``: these are class initializers; while they are not explicitly called anywhere in the code, they are called implicitly whenever the surrounding class is loaded. Hence it makes sense to exclude them from our query. While we are at it, we can also exclude finalizers, which are similarly invoked implicitly:

.. code-block:: ql

   import java

   from Callable callee
   where not exists(Callable caller | caller.polyCalls(callee)) and
       callee.getCompilationUnit().fromSource() and
       not callee.hasName("<clinit>") and not callee.hasName("finalize")
   select callee, "Not called."

This also reduces the number of results returned by most codebases.

We may also want to exclude public methods from our query, since they may be external API entry points:

.. code-block:: ql

   import java

   from Callable callee
   where not exists(Callable caller | caller.polyCalls(callee)) and
       callee.getCompilationUnit().fromSource() and
       not callee.hasName("<clinit>") and not callee.hasName("finalize") and
       not callee.isPublic()
   select callee, "Not called."

This should have a more noticeable effect on the number of results returned.

A further special case is non-public default constructors: in the singleton pattern, for example, a class is provided with private empty default constructor to prevent it from being instantiated. Since the very purpose of such constructors is their not being called, they should not be flagged up:

.. code-block:: ql

   import java

   from Callable callee
   where not exists(Callable caller | caller.polyCalls(callee)) and
       callee.getCompilationUnit().fromSource() and
       not callee.hasName("<clinit>") and not callee.hasName("finalize") and
       not callee.isPublic() and
       not callee.(Constructor).getNumberOfParameters() = 0
   select callee, "Not called."

This change has a large effect on the results for some projects but little effect on the results for others. Use of this pattern varies widely between different projects.

Finally, on many Java projects there are methods that are invoked indirectly by reflection. So, while there are no calls invoking these methods, they are, in fact, used. It is in general very hard to identify such methods. A very common special case, however, is JUnit test methods, which are reflectively invoked by a test runner. The CodeQL library for Java has support for recognizing test classes of JUnit and other testing frameworks, which we can employ to filter out methods defined in such classes:

.. code-block:: ql

   import java

   from Callable callee
   where not exists(Callable caller | caller.polyCalls(callee)) and
       callee.getCompilationUnit().fromSource() and
       not callee.hasName("<clinit>") and not callee.hasName("finalize") and
       not callee.isPublic() and
       not callee.(Constructor).getNumberOfParameters() = 0 and
       not callee.getDeclaringType() instanceof TestClass
   select callee, "Not called."

This should give a further reduction in the number of results returned.

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-cpp.rst
.. _codeql-for-cpp:

CodeQL for C and C++
====================

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from C and C++ codebases.

.. toctree::
   :hidden:

   basic-query-for-cpp-code
   codeql-library-for-cpp
   functions-in-cpp
   expressions-types-and-statements-in-cpp
   conversions-and-classes-in-cpp
   analyzing-data-flow-in-cpp
   analyzing-data-flow-in-cpp-new
   refining-a-query-to-account-for-edge-cases
   detecting-a-potential-buffer-overflow
   using-the-guards-library-in-cpp
   using-range-analsis-in-cpp
   hash-consing-and-value-numbering
   advanced-dataflow-scenarios-cpp
   customizing-library-models-for-cpp
   


-  :doc:`Basic query for C and C++ code <basic-query-for-cpp-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for C and C++ <codeql-library-for-cpp>`: When analyzing C or C++ code, you can use the large collection of classes in the CodeQL library for C and C++.

-  :doc:`Functions in C and C++ <functions-in-cpp>`: You can use CodeQL to explore functions in C and C++ code.

-  :doc:`Expressions, types, and statements in C and C++ <expressions-types-and-statements-in-cpp>`: You can use CodeQL to explore expressions, types, and statements in C and C++ code to find, for example, incorrect assignments.

-  :doc:`Conversions and classes in C and C++ <conversions-and-classes-in-cpp>`: You can use the standard CodeQL libraries for C and C++ to detect when the type of an expression is changed.

-  :doc:`Analyzing data flow in C and C++ (new) <analyzing-data-flow-in-cpp-new>`: You can use data flow analysis to track the flow of potentially malicious or insecure data that can cause vulnerabilities in your codebase. For information about data flow analysis in versions up to CodeQL 2.12.4, see :doc:`Analyzing data flow in C and C++ <analyzing-data-flow-in-cpp>`.

-  :doc:`Refining a query to account for edge cases <refining-a-query-to-account-for-edge-cases>`: You can improve the results generated by a CodeQL query by adding conditions to remove false positive results caused by common edge cases.

-  :doc:`Detecting a potential buffer overflow <detecting-a-potential-buffer-overflow>`: You can use CodeQL to detect potential buffer overflows by checking for allocations equal to ``strlen`` in C and C++.

-  :doc:`Using the guards library in C and C++ <using-the-guards-library-in-cpp>`: You can use the CodeQL guards library to identify conditional expressions that control the execution of other parts of a program in C and C++ codebases. 

-  :doc:`Using range analysis for C and C++ <using-range-analsis-in-cpp>`: You can use range analysis to determine the upper or lower bounds on an expression, or whether an expression could potentially over or underflow.

-  :doc:`Hash consing and value numbering <hash-consing-and-value-numbering>`: You can use specialized CodeQL libraries to recognize expressions that are syntactically identical or compute the same value at runtime in C and C++ codebases.

-  :doc:`Advanced C/C++ dataflow scenarios <advanced-dataflow-scenarios-cpp>`: You can track precise data flow in C and C++ codebases by distinguishing between a pointer and its indirection(s).

-  :doc:`Customizing library models for C and C++ <customizing-library-models-for-cpp>`: You can model frameworks and libraries that your codebase depends on using data extensions and publish them as CodeQL model packs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/specifying-additional-remote-flow-sources-for-javascript.rst
.. _specifying-additional-remote-flow-sources-for-javascript:

Specifying additional remote flow sources for JavaScript
========================================================

.. pull-quote::

   Deprecation Notice

   Specifying remote flow sources with the JSON format described here is soon to be deprecated
   and will be removed in the future.

You can model potential sources of untrusted user input in your code without making changes to the CodeQL standard library by specifying extra remote flow sources in an external file.

As mentioned in the :ref:`Data flow cheat sheet for JavaScript <data-flow-cheat-sheet-for-javascript--untrusted-data>`, the CodeQL libraries for JavaScript
provide a class `RemoteFlowSource <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/security/dataflow/RemoteFlowSources.qll/type.RemoteFlowSources$Cached$RemoteFlowSource.html>`__ to represent sources of untrusted user input, sometimes also referred to as remote flow
sources.

To model a new source of untrusted input, such as a previously unmodelled library API, you can
define a subclass of ``RemoteFlowSource`` that covers all uses of that API. All standard analyses
will then automatically pick up this new source of remote flow.

However, this approach requires writing QL code and adding it to the standard library, which is not
always easy to do. Instead, you can also add a JSON file describing custom sources of untrusted
input to your code base and have it picked up without needing to modify the standard library. This
JSON file can be hand-written or generated by another tool. The custom remote flow sources are only available to the code base containing the JSON file. This means that you need to copy the JSON file into each code base that requires the customizations.

Specification format
--------------------

The JSON file must be called ``codeql-javascript-remote-flow-sources.json`` and
can be located anywhere in your code base. It should consist of a single JSON object. The property
names of this object are interpreted as `source types`. The values they map to should be arrays of
strings. Each string should be of the form ``window.props``, where ``props`` is a sequence of one
or more property names separated by dots. This notation specifies that any value reachable from the global window
object by this sequence of property names should be considered as untrusted user input of the
associated source type.

Example
-------

Consider the following specification:

.. code-block:: json

  {
    "user input": [ "window.user.name", "window.user.address", "window.dob" ]
  }

It declares that the contents of global variable ``dob``, as well as the contents of properties
``name`` and ``address`` of global variable ``user``, should be considered as remote flow sources,
with source type "user input".



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/advanced-dataflow-scenarios-cpp.rst
.. _advanced-dataflow-scenarios-cpp:

.. include:: ../reusables/cpp-new-dataflow-api-note.rst

Advanced dataflow scenarios for C/C++
======================================

Data flow for C and C++ distinguishes between the value of a pointer and the value of what the pointer points to. We call this the "indirection" of the pointer. Tracking the pointer and its indirection as separate entities is important for precise dataflow. However, it also means that you need to specify which data flow node to model. If you select the wrong data flow node, then analysis will be flawed. This article discusses several scenarios where it is important to consider whether data flow should be computed on the value of the pointer or its indirection.

Overview
---------

For almost all situations we only need to instantiate a dataflow configuration and specify our sources and sinks, and the dataflow library will handle everything for us.

However, when a write to a field is not visible to CodeQL (for example, because it happens in a function whose definition is not in the database) we need to track the qualifier, and tell the dataflow library that it should transfer flow from the qualifier to the field access. This is done by adding an ``isAdditionalFlowStep`` predicate to the dataflow module.

When you write additional flow steps to track pointers, you must decide whether the dataflow step should flow from the pointer or its indirection. Similarly, you must decide whether the additional step should target a pointer or its indirection.

In contrast, if the read of a field is not visible to CodeQL, you can add an ``allowImplicitRead`` predicate to model the data flow.

Regular dataflow analysis
-------------------------

Consider the following scenario: We have data coming out of ``user_input()`` and we want to figure out if that data can ever reach an argument of ``sink``.

.. code-block:: cpp

  void sink(int);
  int user_input();

A regular dataflow query such as the following query:

.. code-block:: ql

  /**
  * @kind path-problem
  */

  import semmle.code.cpp.dataflow.new.DataFlow
  import Flow::PathGraph

  module Config implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      source.asExpr().(Call).getTarget().hasName("user_input")
    }

    predicate isSink(DataFlow::Node sink) {
      exists(Call call |
        call.getTarget().hasName("sink") and
        sink.asExpr() = call.getAnArgument()
      )
    }
  }

  module Flow = DataFlow::Global<Config>;

  from Flow::PathNode source, Flow::PathNode sink
  where Flow::flowPath(source, sink)
  select sink.getNode(), source, sink, "Flow from user input to sink!"

will catch most things such as:

.. code-block:: cpp
  :caption: Example 1
  :linenos:

  struct A {
    const int *p;
    int x;
  };

  struct B {
    A *a;
    int y;
  };

  void fill_structure(B* b, const int* pu) {
    // ...
    b->a->p = pu;
  }

  void process_structure(const B* b) {
    sink(*b->a->p);
  }

  void get_and_process() {
    int u = user_input();
    B* b = (B*)malloc(sizeof(B));
    // ...
    fill_structure(b, &u);
    // ...
    process_structure(b);
    free(b);
  }

This data flow is simple to match because the CodeQL database contains the information to see:
  1. User input starts at ``user_input()`` and flows into ``fill_structure``.
  2. The data is written to the object ``b`` with access path ``[a, p]``.
  3. The object ``b`` flows out of ``fill_structure`` and into ``process_structure``.
  4. The access path ``[a, p]`` is read in ``process_structure`` and the value ends up in the sink.

Flow from a qualifier to a field access
---------------------------------------

Sometimes field accesses are not visible to CodeQL (for example, because the implementation of the function isn't included in the database), and so dataflow cannot match up all stores with reads. This leads to missing (false negative) results. 

For example, consider an alternative setup where our source of data starts as the outgoing argument of a function ``write_user_input_to``. We can model this setup in the dataflow library using the following ``isSource``:

.. code-block:: ql

  predicate isSource(DataFlow::Node source) {
    exists(Call call |
      call.getTarget().hasName("write_user_input_to") and
      source.asDefiningArgument() = call.getArgument(0)
    )
  }

This would match the call to ``write_user_input_to`` in the following example:

.. code-block:: cpp
  :caption: Example 2
  :linenos:

  void write_user_input_to(void*);
  void use_value(int);
  void* malloc(unsigned long);

  struct U {
    const int* p;
    int x;
  };

  void process_user_data(const int* p) {
    // ...
    use_value(*p);
  }

  void get_and_process_user_input_v2() {
    U* u = (U*)malloc(sizeof(U));
    write_user_input_to(u);
    process_user_data(u->p);
    free(u);
  }

With this definition of ``isSource`` the dataflow library tracks flow along the following path:

  1. The flow now starts at the outgoing argument of ``write_user_input_to(...)``.
  2. The flow proceeds to ``u->p`` on the next line.

However, because CodeQL has not observed a write to ``p`` before the read ``u->p``, dataflow will stop at ``u``. We can correct this gap in the information available to dataflow by adding an additional flow step through field reads:

.. code-block:: ql

  /**
  * @kind path-problem
  */

  import semmle.code.cpp.dataflow.new.DataFlow
  import Flow::PathGraph

  module Config implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      exists(Call call |
        call.getTarget().hasName("write_user_input_to") and
        source.asDefiningArgument() = call.getArgument(0)
      )
    }

    predicate isSink(DataFlow::Node sink) {
      exists(Call call |
        call.getTarget().hasName("use_value") and
        sink.asExpr() = call.getAnArgument()
      )
    }

    predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
      exists(FieldAccess fa |
        n1.asIndirectExpr() = fa.getQualifier() and
        n2.asIndirectExpr() = fa
      )
    }
  }

  module Flow = DataFlow::Global<Config>;

  from Flow::PathNode source, Flow::PathNode sink
  where Flow::flowPath(source, sink)
  select sink.getNode(), source, sink, "Flow from user input to sink!"

Notice how the ``isSource`` and ``isSink`` are as expected: we're looking for flow that starts at the outgoing parameter of ``write_user_input_to(...)``, and ends up as an argument to ``isSink``. The interesting part is the addition of ``isAdditionalFlow`` which specifies an additional flow step from the qualifier of a ``FieldAccess`` to the result of the access.

In a real query the ``isAdditionalFlowStep`` step would be restricted in various ways to make sure that it doesn't add too much flow (since flow from a field qualifier to the field access in general will generate a lot of spurious flow). For example, one could restrict ``fa`` to be a field access that targets a particular field, or a field access of a field that's defined in a certain ``struct`` type.

We have an important choice here: Should ``n2`` be the node corresponding to the pointer value of ``fa`` or the indirection of ``fa`` (that is, what ``fa`` points to)?

.. _using-asIndirectExpr:

Using asIndirectExpr
~~~~~~~~~~~~~~~~~~~~

If we use ``n2.asIndirectExpr() = fa`` we specify that flow in example 2 moves to what ``fa`` points to. This allows data to flow through a later dereference, which is exactly what we need to track data flow from ``p`` to ``*p`` in ``process_user_data``.

Thus we get the required flow path.

Consider a slightly different sink:

.. code-block:: cpp
  :caption: Example 3
  :linenos:

  void write_user_input_to(void*);
  void use_pointer(int*);
  void* malloc(unsigned long);

  struct U {
    const int* p;
    int x;
  };

  void process_user_data(const int* p) {
    // ...
    use_pointer(p);
  }

  void get_and_process_user_input_v2() {
    U* u = (U*)malloc(sizeof(U));
    write_user_input_to(u);
    process_user_data(u->p);
    free(u);
  }

The only difference between the previous example and this one is that our data ends up in a call to ``use_pointer`` which takes an ``int*`` instead of an ``int`` as an argument. Since our ``isAdditionalFlowStep`` implementation already steps to the indirection of the ``FieldAccess`` we're already tracking what the field points to. So we can find this flow by using ``sink.asIndirectExpr()`` to specify that the data we're interested in tracking is the value that ends up being pointed to by an argument that is passed to ``use_pointer``:

.. code-block:: ql

  predicate isSink(DataFlow::Node sink) {
    exists(Call call |
      call.getTarget().hasName("use_pointer") and
      sink.asIndirectExpr() = call.getAnArgument()
    )
  }

.. _using-asExpr:

Using asExpr
~~~~~~~~~~~~

Alternatively, the flow in example 2 could also be tracked by:
  1. Changing ``isAdditionalFlowStep`` so that it targets the dataflow node that represents the value of the ``FieldAccess`` instead of the value it points to, and
  2. Changing ``isSink`` to specify that we're interested in tracking the value the argument passed to ``use_pointer`` (instead of the value of what the argument points to).

With those changes our query becomes:

.. code-block:: ql

  /**
  * @kind path-problem
  */

  import semmle.code.cpp.dataflow.new.DataFlow
  import Flow::PathGraph

  module Config implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      exists(Call call |
        call.getTarget().hasName("write_user_input_to") and
        source.asDefiningArgument() = call.getArgument(0)
      )
    }

    predicate isSink(DataFlow::Node sink) {
      exists(Call call |
        call.getTarget().hasName("use_pointer") and
        sink.asExpr() = call.getAnArgument()
      )
    }

    predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
      exists(FieldAccess fa |
        n1.asIndirectExpr() = fa.getQualifier() and
        n2.asExpr() = fa
      )
    }
  }

  module Flow = DataFlow::Global<Config>;

  from Flow::PathNode source, Flow::PathNode sink
  where Flow::flowPath(source, sink)
  select sink.getNode(), source, sink, "Flow from user input to sink!"

When we get to ``u->p`` the additional step transfers flow from what the qualifier points to, to the result of the ``FieldAccess``. After this, dataflow proceeds to ``p`` in ``use_pointer(p)`` and since we specified in our ``isSink`` that we're interested in the value of the argument, our dataflow analysis finds a result.

Passing the address of a variable to ``use_pointer``
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider an alternative scenario where ``U`` contains a single ``int`` data, and we pass the address of data to ``use_pointer`` as seen below.

.. code-block:: cpp
  :caption: Example 4
  :linenos:

  void write_user_input_to(void*);
  void use_pointer(int*);
  void* malloc(unsigned long);

  struct U {
    int data;
    int x;
  };

  void process_user_data(int data) {
    // ...
    use_pointer(&data);
  }


  void get_and_process_user_input_v2() {
    U* u = (U*)malloc(sizeof(U));
    write_user_input_to(u);
    process_user_data(u->data);
    free(u);
  }

Since the ``data`` field is now an ``int`` instead of an ``int*`` the field no longer has any indirections, and so the use of ``asIndirectExpr`` in ``isAdditionalFlowStep`` no longer makes sense (and so the additional step will have no results). So there is no choice about whether to taint the value of the field or its indirection: it has to be the value.

However, since we pass the address of ``data`` to ``use_pointer`` on line 12 the tainted value is what is pointed to by the argument of ``use_pointer`` (since the value pointed to by ``&data`` is exactly ``data``). So to handle this case we need a mix of the two situations above:
  1. We need to taint the value of the field as described in the :ref:`Using asExpr <using-asExpr>` section.
  2. We need to select the indirection of the argument as described in the :ref:`Using asIndirectExpr <using-asIndirectExpr>` section.

With these changes the query looks like:

.. code-block:: ql

  /**
  * @kind path-problem
  */

  import semmle.code.cpp.dataflow.new.DataFlow
  import Flow::PathGraph

  module Config implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      exists(Call call |
        call.getTarget().hasName("write_user_input_to") and
        source.asDefiningArgument() = call.getArgument(0)
      )
    }

    predicate isSink(DataFlow::Node sink) {
      exists(Call call |
        call.getTarget().hasName("use_pointer") and
        sink.asIndirectExpr() = call.getAnArgument()
      )
    }

    predicate isAdditionalFlowStep(DataFlow::Node n1, DataFlow::Node n2) {
      exists(FieldAccess fa |
        n1.asIndirectExpr() = fa.getQualifier() and
        n2.asExpr() = fa
      )
    }
  }

  module Flow = DataFlow::Global<Config>;

  from Flow::PathNode source, Flow::PathNode sink
  where Flow::flowPath(source, sink)
  select sink.getNode(), source, sink, "Flow from user input to sink!"

And with that query the flow is identified.

Specifying implicit reads
-------------------------

The previous section demonstrated how to add flow from qualifiers to field accesses because a source implicitly tainted all the fields of a struct. This section considers the opposite scenario: A specific field is being tainted, and we want to find any place that may read from this object, including any place that reads an unknown set of fields.

To set the stage, consider the following scenario:

.. code-block:: cpp
  :caption: Example 5
  :linenos:

  struct A {
    const int *p;
    int x;
  };

  struct B {
    A *a;
    int z;
  };

  int user_input();
  void read_data(const void *);
  void *malloc(size_t);

  void get_input_and_read_data() {
    B b;
    b.a = (A *)malloc(sizeof(A));
    b.a->x = user_input();
    // ...
    read_data(&b);
    free(b.a);
  }

In this example, the data flows as follows:

  1. We write a user-controlled value into the object ``b`` at the access path ``[a, x]``.
  2. Afterwards, ``b`` is passed to ``read_data`` which we don't have the definition of in the database.

We now want to track this user-input flowing into ``read_data``.

The dataflow library has a specific predicate to handle this scenario, and thus we don't need to add any additional flow steps using ``isAdditionalFlowStep``. Instead, we tell the dataflow library that ``read_data`` is a sink and may implicitly read the data from fields in the object it is passed. To do that, we implement ``allowImplicitRead`` in our dataflow module:

.. code-block:: ql

  /**
  * @kind path-problem
  */

  import semmle.code.cpp.dataflow.new.DataFlow
  import Flow::PathGraph

  module Config implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node source) {
      exists(Call call |
        call.getTarget().hasName("user_input") and
        source.asExpr() = call
      )
    }

    predicate isSink(DataFlow::Node sink) {
      exists(Call call |
        call.getTarget().hasName("read_data") and
        sink.asIndirectExpr() = call.getAnArgument()
      )
    }

    predicate allowImplicitRead(DataFlow::Node n, DataFlow::ContentSet cs) {
      isSink(n) and
      cs.getAReadContent().(DataFlow::FieldContent).getField().hasName(["a", "x"])
    }
  }

  module Flow = DataFlow::Global<Config>;

  from Flow::PathNode source, Flow::PathNode sink
  where Flow::flowPath(source, sink)
  select sink.getNode(), source, sink, "Flow from user input to sink!"

The ``allowImplicitRead`` predicate specifies that if we're at a node that satisfies ``isSink`` then we're allowed to assume that there is an implicit read of a field named ``a`` or a field named ``x`` (in this case both). This gets us the flow we are interested in because the dataflow library now will see:

  1. User input starts at ``user_input()``.
  2. The data flowing into ``b`` with access path ``[a, x]``.
  3. The data flowing to the indirection of ``&b`` (i.e., the object ``b``).
  4. An implicit read of the field ``x`` followed by an implicit read of the field ``a`` at the sink.

Thus, we end up at a node that satisfies ``isSink`` with an empty access path, and successfully track the full dataflow path.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-csharp.rst
.. _codeql-library-for-csharp:

CodeQL library for C#
=====================

When you're analyzing a C# program, you can make use of the large collection of classes in the CodeQL library for C#.

About the CodeQL libraries for C#
---------------------------------

There is an extensive core library for analyzing CodeQL databases extracted from C# projects. The classes in this library present the data from a database in an object-oriented form and provide abstractions and predicates to help you with common analysis tasks. The library is implemented as a set of QL modules, that is, files with the extension ``.qll``. The module ``csharp.qll`` imports all the core C# library modules, so you can include the complete library by beginning your query with:

.. code-block:: ql

   import csharp

Since this is required for all C# queries, it's omitted from code snippets below.

The core library contains all the program elements, including `files <#files>`__, `types <#types>`__, methods, `variables <#variables>`__, `statements <#statements>`__, and `expressions <#expressions>`__. This is sufficient for most queries, however additional libraries can be imported for bespoke functionality such as control flow and data flow. For information about these additional libraries, see ":ref:`CodeQL for C# <codeql-for-csharp>`." 

Class hierarchies
~~~~~~~~~~~~~~~~~

Each section contains a class hierarchy, showing the inheritance structure between CodeQL classes. For example:

-  ``Expr``

   -  ``Operation``

      -  ``ArithmeticOperation``

         -  ``UnaryArithmeticOperation``

            -  ``UnaryMinusExpr``, ``UnaryPlusExpr``
            -  ``MutatorOperation``

               -  ``IncrementOperation``

                  -  ``PreIncrExpr``, ``PostIncrExpr``

               -  ``DecrementOperation``

                  -  ``PreDecrExpr``, ``PostDecrExpr``

         -  ``BinaryArithmeticOperation``

            -  ``AddExpr``, ``SubExpr``, ``MulExpr``, ``DivExpr``, ``RemExpr``

This means that the class ``AddExpr`` extends class ``BinaryArithmeticOperation``, which in turn extends class ``ArithmeticOperation`` and so on. If you want to query any arithmetic operation, use the class ``ArithmeticOperation``, but if you specifically want to limit the query to addition operations, use the class ``AddExpr``.

Classes can also be considered to be *sets*, and the ``extends`` relation between classes defines a subset. Every member of class ``AddExpr`` is also in the class ``BinaryArithmeticOperation``. In general, classes overlap and an entity can be a member of several classes.

This overview omits some of the less important or intermediate classes from the class hierarchy.

Each class has predicates, which are logical propositions about that class. They also define navigable relationships between classes. Predicates are inherited, so for example the ``AddExpr`` class inherits the predicates ``getLeftOperand()`` and ``getRightOperand()`` from ``BinaryArithmeticOperation``, and ``getType()`` from class ``Expr``. This is similar to how methods are inherited in object-oriented programming languages.

In this overview, we present the most common and useful predicates. For the complete list of predicates available on each class, you can look in the CodeQL source code, use autocomplete in the editor, or see the `C# reference <https://codeql.github.com/codeql-standard-libraries/csharp>`__.

Exercises
~~~~~~~~~

Each section in this topic contains exercises to check your understanding.

Exercise 1: Simplify this query:

.. code-block:: ql

   from BinaryArithmeticOperation op
   where op instanceof AddExpr
   select op

(`Answer <#exercise-1>`__)

Files
-----

Files are represented by the class `File <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/File.qll/type.File$File.html>`__, and directories by the class `Folder <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/File.qll/type.File$Folder.html>`__. The database contains all of the source files and assemblies used during the compilation.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``File`` - any file in the database (including source files, XML and assemblies)

   -  ``SourceFile`` - a file containing source code

-  ``Folder`` - a directory

Predicates
~~~~~~~~~~

-  ``getName()`` - gets the full path of the file (for example, ``C:\Temp\test.cs``).
-  ``getNumberOfLines()`` - gets the number of lines (for source files only).
-  ``getShortName()`` - gets the name of the file without the extension (for example, ``test``).
-  ``getBaseName()`` - gets the name and extension of the file (for example, ``test.cs``).
-  ``getParent()`` - gets the parent directory.

Examples
~~~~~~~~

Count the number of source files:

.. code-block:: ql

   select count(SourceFile f)

Count the number of lines of code, excluding the directory ``external``:

.. code-block:: ql

   select sum(SourceFile f |
     not exists(Folder ext | ext.getShortName() = "external" |
                ext.getAFolder*().getAFile() = f) |
     f.getNumberOfLines())

Exercises
~~~~~~~~~

Exercise 2: Write a query to find the source file with the largest number of lines. Hint: Find the source file with the same number of lines as the ``max`` number of lines in any file. (`Answer <#exercise-2>`__)

Elements
--------

The class `Element <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/cil/Element.qll/type.Element$Element.html>`__ is the base class for all parts of a C# program, and it's the root of the element class hierarchy. All program elements (such as types, methods, statements, and expressions) ultimately derive from this common base class.

``Element`` forms a hierarchical structure of the program, which can be navigated using the ``getParent()`` and ``getChild()`` predicates. This is much like an abstract syntax tree, and also applies to elements in assemblies.

Predicates
~~~~~~~~~~

The ``Element`` class provides common functionality for all program elements, including:

-  ``getLocation()`` - gets the text span in the source code.
-  ``getFile()`` - gets the ``File`` containing the ``Element``.
-  ``getParent()`` - gets the parent ``Element``, if any.
-  ``getAChild()`` - gets a child ``Element`` of this element, if any.

Examples
~~~~~~~~

To list all elements in ``Main.cs``, their QL class and location:

.. code-block:: ql

   from Element e
   where e.getFile().getShortName() = "Main"
   select e, e.getAQlClass(), e.getLocation()

Note that ``getAQlClass()`` is available on all entities and is a useful way to figure out the QL class of something. Often the same element will have several classes which are all returned by ``getAQlClass()``.

Locations
---------

`Location <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/Location.qll/type.Location$Location.html>`__ represents a section of text in the source code, or an assembly. All elements have a ``Location`` obtained by their ``getLocation()`` predicate. A ``SourceLocation`` represents a span of text in source code, whereas an ``Assembly`` location represents a referenced assembly.

Sometimes elements have several locations, for example if they occur in both source code and an assembly. In this case, only the ``SourceLocation`` is returned.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Location``

   -  ``SourceLocation``
   -  ``Assembly``

Predicates
~~~~~~~~~~

Some predicates of ``Location`` include:

-  ``getFile()`` - gets the ``File``.
-  ``getStartLine()`` - gets the first line of the text.
-  ``getEndLine()`` - gets the last line of the text.
-  ``getStartColumn()`` - gets the column of the start of the text.
-  ``getEndColumn()`` - gets the column of the end of the text.

Examples
~~~~~~~~

Find all elements that are one character wide:

.. code-block:: ql

   from Element e, Location l
   where l = e.getLocation()
     and l.getStartLine() = l.getEndLine()
     and l.getStartColumn() = l.getEndColumn()
   select e, "This element is a single character."

Declarations
------------

`Declaration <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/cil/Declaration.qll/type.Declaration$Declaration.html>`__ is the common class of all entities defined in the program, such as types, methods, variables etc. The database contains all declarations from the source code and all referenced assemblies.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``Declaration``

      -  ``Callable``
      -  ``UnboundGeneric``
      -  ``ConstructedGeneric``
      -  ``Modifiable`` - a declaration which can have a modifier (for example ``public``)

         -  ``Member`` - a declaration that is member of a type

      -  ``Assignable`` - an element that can be assigned to

         -  ``Variable``
         -  ``Property``
         -  ``Indexer``
         -  ``Event``

Predicates
~~~~~~~~~~

Useful member predicates on ``Declaration`` include:

-  ``getDeclaringType()`` - gets the type containing the declaration, if any.
-  ``getName()``/``hasName(string)`` - gets the name of the declared entity.
-  ``isSourceDeclaration()`` - whether the declaration is source code and is not a constructed type/method.
-  ``getSourceDeclaration()`` - gets the original (unconstructed) declaration.

Examples
~~~~~~~~

Find declarations containing a username:

.. code-block:: ql

   from Declaration decl
   where decl.getName().regexpMatch("[uU]ser([Nn]ame)?")
   select decl, "A username."

Variables
---------

The class `Variable <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/cil/Variable.qll/type.Variable$Variable.html>`__ represents C# variables, such as fields, parameters and local variables. The database contains all variables from the source code, as well as all fields and parameters from assemblies referenced by the program.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``Declaration``

      -  ``Variable`` - any type of variable

         -  ``Field`` - a field in a ``class``/``struct``

            -  ``MemberConstant`` - a ``const`` field

               -  ``EnumConstant`` - a field in an ``enum``

         -  ``LocalScopeVariable`` - a variable whose scope is limited to a single ``Callable``

            -  ``LocalVariable`` - a local variable in a ``Callable``

               -  ``LocalConstant`` - a locally defined constant in a ``Callable``

            -  ``Parameter`` - a parameter to a ``Callable``

Predicates
~~~~~~~~~~

Some common predicates on ``Variable`` are:

-  ``getType()`` - gets the ``Type`` of this variable.
-  ``getAnAccess()`` - gets an expression that accesses (reads or writes) this variable, if any.
-  ``getAnAssignedValue()`` - gets an expression that is assigned to this variable, if any.
-  ``getInitializer()`` - gets the expression used to initialize the variable, if any.

Examples
~~~~~~~~

Find all unused local variables:

.. code-block:: ql

   from LocalVariable v
   where not exists(v.getAnAccess())
   select v, "This local variable is unused."

Types
-----

Types are represented by the CodeQL class `Type <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/cil/Type.qll/type.Type$Type.html>`__ and consist of builtin types, interfaces, classes, structs, enums, and type parameters. The database contains types from the program and all referenced assemblies including mscorlib and the .NET framework.

The builtin types (``object``, ``int``, ``double`` etc.) have corresponding types (``System.Object``, ``System.Int32`` etc.) in mscorlib.

Class ``ValueOrRefType`` represents defined types, such as a ``class``, ``struct``, ``interface`` or ``enum``.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``Declaration``

      -  ``Modifiable`` - a declaration which can have a modifier (for example ``public``)

         -  ``Member`` - a declaration that is member of a type

            -  ``Type`` - all types

               -  ``ValueOrRefType`` - a defined type

                  -  ``ValueType`` - a value type (see below for further hierarchy)
                  -  ``RefType`` - a reference type (see below for further hierarchy)
                  -  ``NestedType`` - a type defined in another type

               -  ``VoidType`` - ``void``
               -  ``PointerType`` - a pointer type

The ``ValueType`` class extends further:

-  ``ValueType`` - a value type

   -  ``SimpleType`` - a simple built-in type

      -  ``BoolType`` - ``bool``
      -  ``CharType`` - ``char``
      -  ``IntegralType``

         -  ``UnsignedIntegralType``

            -  ``ByteType`` - ``byte``
            -  ``UShortType`` - ``unsigned short``/``System.UInt16``
            -  ``UIntType`` - ``unsigned int``/``System.UInt32``
            -  ``ULongType`` - ``unsigned long``/``System.UInt64``

         -  ``SignedIntegralType``

            -  ``SByteType`` - ``signed byte``
            -  ``ShortType`` - ``short``/``System.Int16``
            -  ``IntType`` - ``int``/``System.Int32``
            -  ``LongType`` - ``long``/``System.Int64``

         -  ``FloatingPointType``

            -  ``FloatType`` - ``float``/``System.Single``
            -  ``DoubleType`` - ``double``/``System.Double``

         -  ``DecimalType`` - ``decimal``/``System.Decimal``

      -  ``Enum`` - an ``enum``
      -  ``Struct`` - a ``struct``
      -  ``NullableType``
      -  ``ArrayType``

The ``RefType`` class extends further:

-  ``RefType``

   -  ``Class`` - a ``class``

      -  ``AnonymousClass``
      -  ``ObjectType`` - ``object``/``System.Object``
      -  ``StringType`` - ``string``/``System.String``

   -  ``Interface`` - an ``interface``
   -  ``DelegateType``
   -  ``NullType`` - the type of ``null``
   -  ``DynamicType`` - ``dynamic``

-  ``NestedType`` - a type defined in another type

These class hierarchies omit generic types for simplicity.

Predicates
~~~~~~~~~~

Useful members of ``ValueOrRefType`` include:

-  ``getQualifiedName()/hasQualifiedName(string)`` - gets the qualified name of the type (for example, ``"System.String"``).
-  ``getABaseInterface()`` - gets an immediate interface of this type, if any.
-  ``getABaseType()`` - gets an immediate base class or interface of this type, if any.
-  ``getBaseClass()`` - gets the immediate base class of this type, if any.
-  ``getASubType()`` - gets an immediate subtype, a type which directly inherits from this type, if any.
-  ``getAMember()`` - gets any member (field/method/property etc), if any.
-  ``getAMethod()`` - gets a method, if any.
-  ``getAProperty()`` - gets a property, if any.
-  ``getAnIndexer()`` - gets an indexer, if any.
-  ``getAnEvent()`` - gets an event, if any.
-  ``getAnOperator()`` - gets an operator, if any.
-  ``getANestedType()`` - gets a nested type.
-  ``getNamespace()`` - gets the enclosing namespace.

Examples
~~~~~~~~

Find all members of ``System.Object``:

.. code-block:: ql

   from ObjectType object
   select object.getAMember()

Find all types which directly implement ``System.Collections.IEnumerable``:

.. code-block:: ql

   from Interface ienumerable
   where ienumerable.hasQualifiedName("System.Collections.IEnumerable")
   select ienumerable.getASubType()

List all simple types in the ``System`` namespace:

.. code-block:: ql

   select any(SimpleType t | t.getNamespace().hasName("System"))

Find all variables of type ``PointerType``:

.. code-block:: ql

   from Variable v
   where v.fromSource()
     and v.getType() instanceof PointerType
   select v

List all classes in source files:

.. code-block:: ql

   from Class c
   where c.fromSource()
   select c

Exercises
~~~~~~~~~

Exercise 3: Write a query to list the methods in ``string``. (`Answer <#exercise-3>`__)

Exercise 4: Adapt the example to find all types which indirectly implement ``IEnumerable``. (`Answer <#exercise-4>`__)

Exercise 5: Write a query to find all classes starting with the letter ``A``. (`Answer <#exercise-5>`__)

Callables
---------

Callables are represented by the class `Callable <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/Callable.qll/type.Callable$Callable.html>`__ and are anything that can be called independently, such as methods, constructors, destructors, operators, anonymous functions, indexers, and property accessors.

The database contains all of the callables in your program and in all referenced assemblies.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``Declaration``

      -  ``Callable``

         -  ``Method``

            -  ``ExtensionMethod``

         -  ``Constructor``

            -  ``StaticConstructor``
            -  ``InstanceConstructor``

         -  ``Destructor``
         -  ``Operator``

            -  ``UnaryOperator``

               -  ``PlusOperator``, ``MinusOperator``, ``NotOperator``, ``ComplementOperator``, ``IncrementOperator``, ``DecrementOperator``, ``FalseOperator``, ``TrueOperator``

            -  ``BinaryOperator``

               -  ``AddOperator``, ``SubOperator``, ``MulOperator``, ``DivOperator``, ``RemOperator``, ``AndOperator``, ``OrOperator``, ``XorOperator``, ``LShiftOperator``, ``RShiftOperator``, ``EQOperator``, ``NEOperator``, ``LTOperator``, ``GTOperator``, ``LEOperator``, ``GEOperator``

            -  ``ConversionOperator``

               -  ``ImplicitConversionOperator``
               -  ``ExplicitConversionOperator``

         -  ``AnonymousFunctionExpr``

            -  ``LambdaExpr``
            -  ``AnonymousMethodExpr``

         -  ``Accessor``

            -  ``Getter``
            -  ``Setter``
            -  ``EventAccessor``

               -  ``AddEventAccessor``, ``RemoveEventAccessor``

Predicates
~~~~~~~~~~

Here are a few useful predicates on the ``Callable`` class:

-  ``getParameter(int)``/``getAParameter()`` - gets a parameter.
-  ``calls(Callable)`` - whether there's a direct call from one callable to another.
-  ``getReturnType()`` - gets the return type.
-  ``getBody()``/``getExpressionBody()`` - gets the body of the callable.

Since ``Callable`` extends ``Declaration``, it also has predicates from ``Declaration``, such as:

-  ``getName()``/``hasName(string)``
-  ``getSourceDeclaration()``
-  ``getName()``
-  ``getDeclaringType()``

Methods have additional predicates, including:

-  ``getAnOverridee()`` - gets a method that is immediately overridden by this method.
-  ``getAnOverrider()`` - gets a method that immediately overrides this method.
-  ``getAnImplementee()`` - gets an interface method that is immediately implemented by this method.
-  ``getAnImplementor()`` - gets a method that immediately implements this interface method.

Examples
~~~~~~~~

List all types which override ``ToString``:

.. code-block:: ql

   from Method m
   where m.hasName("ToString")
   select m

Find methods that look like ``ToString`` methods but don't override ``Object.ToString``:

.. code-block:: ql

   from Method toString, Method falseToString
   where toString.hasQualifiedName("System.Object.ToString")
    and falseToString.getName().toLowerCase() = "tostring"
    and not falseToString.overrides*(toString) 
    and falseToString.getNumberOfParameters() = 0
   select falseToString, "This method looks like it overrides Object.ToString but it doesn't."

Find all methods which take a pointer type:

.. code-block:: ql

   from Method m
   where m.getAParameter().getType() instanceof PointerType
   select m, "This method uses pointers."

Find all classes which have a destructor but aren't disposable:

.. code-block:: ql

   from Class c
   where c.getAMember() instanceof Destructor
     and not c.getABaseType*().hasQualifiedName("System.IDisposable")
   select c, "This class has a destructor but is not IDisposable."

Find ``Main`` methods which are not ``private``:

.. code-block:: ql

   from Method m
   where m.hasName("Main")
     and not m.isPrivate()
   select m, "Main method should be private."

Statements
----------

Statements are represented by the class `Stmt <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/Stmt.qll/type.Stmt$Stmt.html>`__ and make up the body of methods (and other callables). The database contains all statements in the source code, but does not contain any statements from referenced assemblies where the source code is not available.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``ControlFlowElement``

      -  ``Stmt``

         -  ``BlockStmt`` - ``{ ... }``
         -  ``ExprStmt``
         -  ``SelectionStmt``

            -  ``IfStmt`` - ``if``
            -  ``SwitchStmt`` - ``switch``

         -  ``LabeledStmt``

            -  ``ConstCase``
            -  ``DefaultCase`` - ``default``
            -  ``LabelStmt``

         -  ``LoopStmt``

            -  ``WhileStmt`` - ``while(...) { ... }``
            -  ``DoStmt`` - ``do { ... } while(...)``
            -  ``ForStmt`` - ``for``
            -  ``ForEachStmt`` - ``foreach``

         -  ``JumpStmt``

            -  ``BreakStmt`` - ``break``
            -  ``ContinueStmt`` - ``continue``
            -  ``GotoStmt`` - ``goto``

               -  ``GotoLabelStmt``
               -  ``GotoCaseStmt``
               -  ``GotoDefaultStmt``

            -  ``ThrowStmt`` - ``throw``
            -  ``ReturnStmt`` - ``return``
            -  ``YieldStmt``

               -  ``YieldBreakStmt`` - ``yield break``
               -  ``YieldReturnStmt`` - ``yield return``

         -  ``TryStmt`` - ``try``
         -  ``CatchClause`` - ``catch``

            -  ``SpecificCatchClause``
            -  ``GeneralCatchClause``

         -  ``CheckedStmt`` - ``checked``
         -  ``UncheckedStmt`` - ``unchecked``
         -  ``LockStmt`` - ``lock``
         -  ``UsingStmt`` - ``using``
         -  ``LocalVariableDeclStmt``

            -  ``LocalConstantDeclStmt``

         -  ``EmptyStmt`` - ``;``
         -  ``UnsafeStmt`` - ``unsafe``
         -  ``FixedStmt`` - ``fixed``

Examples
~~~~~~~~

Find long methods:

.. code-block:: ql

   from Method m
   where m.getBody().(BlockStmt).getNumberOfStmts() >= 100
   select m, "This is a long method!"

Find ``for(;;)``:

.. code-block:: ql

   from ForStmt for
   where not exists(for.getAnInitializer())
     and not exists(for.getUpdate(_))
     and not exists(for.getCondition())
   select for, "Infinite loop."

Find ``catch(NullDefererenceException)``:

.. code-block:: ql

   from SpecificCatchClause catch
   where catch.getCaughtExceptionType().hasQualifiedName("System.NullReferenceException")
   select catch, "Catch NullReferenceException."

Find an ``if`` statement with a constant condition:

.. code-block:: ql

   from IfStmt ifStmt
   where ifStmt.getCondition().hasValue()
   select ifStmt, "This 'if' statement is constant."

Find an ``if`` statement with an empty "then" block:

.. code-block:: ql

   from IfStmt ifStmt
   where ifStmt.getThen().(BlockStmt).isEmpty()
   select ifStmt, "If statement with empty 'then' block."

The ``(BlockStmt)`` is an inline cast, which restricts the query to cases where the result of ``getThen()`` has the QL class ``BlockStmt``, and allows predicates on ``BlockStmt`` to be used, such as ``isEmpty()``.

Exercises
~~~~~~~~~

Exercise 6: Write a query to list all empty methods. (`Answer <#exercise-6>`__)

Exercise 7: Modify the last example to also detect empty statements (``;``) in the "then" block. (`Answer <#exercise-7>`__)

Exercise 8: Modify the last example to exclude chains of ``if`` statements, where the ``else`` part is another ``if`` statement. (`Answer <#exercise-8>`__)

Expressions
-----------

The `Expr <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/csharp/exprs/Expr.qll/type.Expr$Expr.html>`__ class represents all C# expressions in the program. An expression is something producing a value such as ``a+b`` or ``new List<int>()``. The database contains all expressions from the source code, but no expressions from referenced assemblies where the source code is not available.

The ``Access`` class represents any use or cross-reference of another ``Declaration`` such a variable, property, method or field. The ``getTarget()`` predicate gets the declaration being accessed.

The ``Call`` class represents a call to a ``Callable``, for example to a ``Method`` or an ``Accessor``, and the ``getTarget()`` method gets the ``Callable`` being called. The ``Operation`` class consists of arithmetic, bitwise operations and logical operations.

Some expressions use a qualifier, which is the object on which the expression operates. A typical example is a ``MethodCall``. In this case, the ``getQualifier()`` predicate is used to get the expression on the left of the ``.``, and ``getArgument(int)`` is used to get the arguments of the call.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``ControlFlowElement``

      -  ``Expr``

         -  ``LocalVariableDeclExpr``

            -  ``LocalConstantDeclExpr``

         -  ``Operation``

            -  ``UnaryOperation``

               -  ``SizeofExpr``, ``PointerIndirectionExpr``, ``AddressOfExpr``

            -  ``BinaryOperation``

               -  ``ComparisonOperation``

                  -  ``EqualityOperation``

                     -  ``EQExpr``, ``NEExpr``
                     -  ``RelationalOperation``

                        -  ``GTExpr``, ``LTExpr``, ``GEExpr``, ``LEExpr``

            -  ``Assignment``

               -  ``AssignOperation``

                  -  ``AddOrRemoveEventExpr``

                     -  ``AddEventExpr``
                     -  ``RemoveEventExpr``

                  -  ``AssignArithmeticOperation``

                     -  ``AssignAddExpr``, ``AssignSubExpr``, ``AssignMulExpr``, ``AssignDivExpr``, ``AssignRemExpr``

                  -  ``AssignBitwiseOperation``

                     -  ``AssignAndExpr``, ``AssignOrExpr``, ``AssignXorExpr``, ``AssignLShiftExpr``, ``AssignRShiftExpr``

               -  ``AssignExpr``

                  -  ``MemberInitializer``

            -  ``ArithmeticOperation``

               -  ``UnaryArithmeticOperation``

                  -  ``UnaryMinusExpr``, ``UnaryPlusExpr``
                  -  ``MutatorOperation``

                     -  ``IncrementOperation``

                        -  ``PreIncrExpr``, ``PostIncrExpr``

                     -  ``DecrementOperation``

                        -  ``PreDecrExpr``, ``PostDecrExpr``

               -  ``BinaryArithmeticOperation``

                  -  ``AddExpr``, ``SubExpr``, ``MulExpr``, ``DivExpr``, ``RemExpr``

            -  ``BitwiseOperation``

               -  ``UnaryBitwiseOperation``

                  -  ``ComplementOperation``

               -  ``BinaryBitwiseOperation``

                  -  ``LShiftExpr``, ``RShiftExpr``, ``BitwiseAndExpr``, ``BitwiseOrExpr``, ``BitwiseXorExpr``

            -  ``LogicalOperation``

               -  ``UnaryLogicalOperation``

                  -  ``LogicalNotOperation``

               -  ``BinaryLogicalOperation``

                  -  ``LogicalAndExpr``, ``LogicalOrExpr``, ``NullCoalescingExpr``

               -  ``ConditionalExpr``

         -  ``ParenthesisedExpr``, ``CheckedExpr``, ``UncheckedExpr``, ``IsExpr``, ``AsExpr``, ``CastExpr``, ``TypeofExpr``, ``DefaultValueExpr``, ``AwaitExpr``, ``NameofExpr``, ``InterpolatedStringExpr``
         -  ``Access``

            -  ``ThisAccess``
            -  ``BaseAccess``
            -  ``MemberAccess``

               -  ``MethodAccess``

                  -  ``VirtualMethodAccess``

               -  ``FieldAccess``, ``PropertyAccess``, ``IndexerAccess``, ``EventAccess``, ``MethodAccess``

            -  ``AssignableAccess``

               -  ``VariableAccess``

                  -  ``ParameterAccess``
                  -  ``LocalVariableAccess``
                  -  ``LocalScopeVariableAccess``
                  -  ``FieldAccess``

                     -  ``MemberConstantAccess``

               -  ``PropertyAccess``

                  -  ``TrivialPropertyAccess``
                  -  ``VirtualPropertyAccess``

               -  ``IndexerAccess``

                  -  ``VirtualIndexerAccess``

               -  ``EventAccess``

                  -  ``VirtualEventAccess``

            -  ``TypeAccess``
            -  ``ArrayAccess``

         -  ``Call``

            -  ``PropertyCall``
            -  ``IndexerCall``
            -  ``EventCall``
            -  ``MethodCall``

               -  ``VirtualMethodCall``
               -  ``ElementInitializer``

            -  ``ConstructorInitializer``
            -  ``OperatorCall``

               -  ``MutatorOperatorCall``

            -  ``DelegateCall``
            -  ``ObjectCreation``

               -  ``DefaultValueTypeObjectCreation``
               -  ``TypeParameterObjectCreation``
               -  ``AnonymousObjectCreation``

         -  ``ObjectOrCollectionInitializer``

            -  ``ObjectInitializer``
            -  ``CollectionInitializer``

         -  ``DelegateCreation``

            -  ``ExplicitDelegateCreation``, ``ImplicitDelegateCreation``

         -  ``ArrayInitializer``
         -  ``ArrayCreation``
         -  ``AnonymousFunctionExpr``

            -  ``LambdaExpr``
            -  ``AnonymousMethodExpr``

         -  ``Literal``

            -  ``BoolLiteral``, ``CharLiteral``, ``IntegerLiteral``, ``IntLiteral``, ``LongLiteral``, ``UIntLiteral``, ``ULongLiteral``, ``RealLiteral``, ``FloatLiteral``, ``DoubleLiteral``, ``DecimalLiteral``, ``StringLiteral``, ``NullLiteral``

Predicates
~~~~~~~~~~

Useful predicates on ``Expr`` include:

-  ``getType()`` - gets the ``Type`` of the expression.
-  ``getValue()`` - gets the compile-time constant, if any.
-  ``hasValue()`` - whether the expression has a compile-time constant.
-  ``getEnclosingStmt()`` - gets the statement containing the expression, if any.
-  ``getEnclosingCallable()`` - gets the callable containing the expression, if any.
-  ``stripCasts()`` - remove all explicit or implicit casts.
-  ``isImplicit()`` - whether the expression was implicit, such as an implicit ``this`` qualifier (``ThisAccess``).

Examples
~~~~~~~~

Find calls to ``String.Format`` with just one argument:

.. code-block:: ql

   from MethodCall c
   where c.getTarget().hasQualifiedName("System.String.Format")
     and c.getNumberOfArguments() = 1
   select c, "Missing arguments to 'String.Format'."

Find all comparisons of floating point values:

.. code-block:: ql

   from ComparisonOperation cmp
   where (cmp instanceof EQExpr or cmp instanceof NEExpr)
     and cmp.getAnOperand().getType() instanceof FloatingPointType
   select cmp, "Comparison of floating point values."

Find hard-coded passwords:

.. code-block:: ql

   from Variable v, string value
   where v.getName().regexpMatch("[pP]ass(word|wd|)")
     and value = v.getAnAssignedValue().getValue()
   select v, "Hard-coded password '" + value + "'."

Exercises
~~~~~~~~~

Exercise 9: Limit the previous query to string types. Exclude empty passwords or null passwords. (`Answer <#exercise-9>`__)

Attributes
----------

C# attributes are represented by the class `Attribute <https://codeql.github.com/codeql-standard-libraries/csharp/semmle/code/cil/Attribute.qll/type.Attribute$Attribute.html>`__. They can be present on many C# elements, such as classes, methods, fields, and parameters. The database contains attributes from the source code and all assembly references.

The attribute of any ``Element`` can be obtained via ``getAnAttribute()``, whereas if you have an attribute, you can find its element via ``getTarget()``. These two query fragments are identical:

.. code-block:: ql

     attribute = element.getAnAttribute()
     element = attribute.getTarget() 

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Element``

   -  ``Attribute``

Predicates
~~~~~~~~~~

-  ``getTarget()`` - gets the ``Element`` to which this attribute applies.
-  ``getArgument(int)`` - gets the given argument of the attribute.
-  ``getType()`` - gets the type of this attribute. Note that the class name must end in ``"Attribute"``.

Examples
~~~~~~~~

Find all obsolete elements:

.. code-block:: ql

   from Element e, Attribute attribute
   where e = attribute.getTarget()
     and attribute.getType().hasName("ObsoleteAttribute")
   select e, "This is obsolete because " + attribute.getArgument(0).getValue()

Model NUnit test fixtures:

.. code-block:: ql

   class TestFixture extends Class
   {
     TestFixture() {
       this.getAnAttribute().getType().hasName("TestFixtureAttribute")
     }
     
     TestMethod getATest() {
       result = this.getAMethod()
     }
   }

   class TestMethod extends Method
   {
     TestMethod() {
       this.getAnAttribute().getType().hasName("TestAttribute")
     }
   }

   from TestFixture f
   select f, f.getATest()

Exercises
~~~~~~~~~

Exercise 10: Write a query to find just obsolete methods. (`Answer <#exercise-10>`__)

Exercise 11: Write a query to find all places where the ``Obsolete`` attribute is used without a reason string (that is, ``[Obsolete]``). (`Answer <#exercise-11>`__)

Exercise 12: In the first example, what happens if the ``Obsolete`` attribute doesn't have a reason string? How could the query be fixed to accommodate this? (`Answer <#exercise-12>`__)

--------------

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   from AddExpr op
   select op

or

.. code-block:: ql

   select any(AddExpr op)

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   from File f
   where f.getNumberOfLines() = max(any(File g).getNumberOfLines())
   select f

Exercise 3
~~~~~~~~~~

.. code-block:: ql

   from StringType s
   select s.getAMethod()

Exercise 4
~~~~~~~~~~

.. code-block:: ql

   from Interface ienumerable
   where ienumerable.hasQualifiedName("System.Collections.IEnumerable")
   select ienumerable.getASubType*()

Exercise 5
~~~~~~~~~~

.. code-block:: ql

   from Class a
   where a.getName().toLowerCase().matches("a%")
   select a

Exercise 6
~~~~~~~~~~

.. code-block:: ql

   select any(Method m | m.getBody().(BlockStmt).isEmpty())

Exercise 7
~~~~~~~~~~

.. code-block:: ql

   from IfStmt ifStmt
   where ifStmt.getThen().(BlockStmt).isEmpty() or ifStmt.getThen() instanceof EmptyStmt
   select ifStmt, "If statement with empty 'then' block."

Exercise 8
~~~~~~~~~~

.. code-block:: ql

   from IfStmt ifStmt
   where (ifStmt.getThen().(BlockStmt).isEmpty() or ifStmt.getThen() instanceof EmptyStmt)
     and not ifStmt.getElse() instanceof IfStmt
   select ifStmt, "If statement with empty 'then' block."

Exercise 9
~~~~~~~~~~

.. code-block:: ql

   from Variable v, StringLiteral value
   where v.getName().regexpMatch("[pP]ass(word|wd|)")
     and value = v.getAnAssignedValue()
     and value.getValue() != ""
   select v, "Hard-coded password '" + value.getValue() + "'."

Exercise 10
~~~~~~~~~~~

.. code-block:: ql

   from Method method, Attribute attribute
   where method = attribute.getTarget()
     and attribute.getType().hasName("ObsoleteAttribute")
   select method, "This is obsolete because " + attribute.getArgument(0).getValue()

Exercise 11
~~~~~~~~~~~

.. code-block:: ql

   from Attribute attribute
   where attribute.getType().hasName("ObsoleteAttribute")
     and not exists(attribute.getArgument(0))
   select attribute, "Missing reason in 'Obsolete' attribute."

Exercise 12
~~~~~~~~~~~

The query does not return results where the argument is missing.

Here is the fixed version:

.. code-block:: ql

   from Element e, Attribute attribute, string reason
   where e = attribute.getTarget()
     and attribute.getType().hasName("ObsoleteAttribute")
     and if exists(attribute.getArgument(0)) 
       then reason = attribute.getArgument(0).getValue() 
       else reason = "(not given)"
   select e, "This is obsolete because " + reason

Further reading
---------------

.. include:: ../reusables/csharp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-python.rst
.. _analyzing-data-flow-in-python:

Analyzing data flow in Python
=============================

You can use CodeQL to track the flow of data through a Python program to places where the data is used.

About this article
------------------

This article describes how data flow analysis is implemented in the CodeQL libraries for Python and includes examples to help you write your own data flow queries.
The following sections describe how to use the libraries for local data flow, global data flow, and taint tracking.
For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

.. include:: ../reusables/new-data-flow-api.rst

Local data flow
---------------

Local data flow is data flow within a single method or callable. Local data flow is easier, faster, and more precise than global data flow, and is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

The local data flow library is in the module ``DataFlow``, which defines the class ``Node`` denoting any element that data can flow through. The ``Node`` class has a number of useful subclasses, such as ``ExprNode`` for expressions, ``CfgNode`` for control-flow nodes, ``CallCfgNode`` for function and method calls, and ``ParameterNode`` for parameters. You can map between data flow nodes and expressions/control-flow nodes using the member predicates ``asExpr`` and ``asCfgNode``:

.. code-block:: ql

     class Node {
       /** Gets the expression corresponding to this node, if any. */
       Expr asExpr() { ... }

       /** Gets the control-flow node corresponding to this node, if any. */
       ControlFlowNode asCfgNode() { ... }

      ...
     }

or using the predicate ``exprNode``:

.. code-block:: ql

     /**
      * Gets a node corresponding to expression `e`.
      */
     ExprNode exprNode(Expr e) { ... }

Due to the control-flow graph being split, there can be multiple data-flow nodes associated with a single expression.

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``. You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localFlow``.

For example, you can find flow from an expression ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     DataFlow::localFlow(DataFlow::exprNode(source), DataFlow::exprNode(sink))

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow by including non-value-preserving flow steps. For example:

.. code-block:: python

     temp = x
     y = temp + ", " + temp

If ``x`` is a tainted string then ``y`` is also tainted.

The local taint tracking library is in the module ``TaintTracking``. Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``. You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localTaint``.

For example, you can find taint propagation from an expression ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     TaintTracking::localTaint(DataFlow::exprNode(source), DataFlow::exprNode(sink))


Using local sources
~~~~~~~~~~~~~~~~~~~

When asking for local data flow or taint propagation between two expressions as above, you would normally constrain the expressions to be relevant to a certain investigation. The next section will give some concrete examples, but there is a more abstract concept that we should call out explicitly, namely that of a local source.

A local source is a data-flow node with no local data flow into it. As such, it is a local origin of data flow, a place where a new value is created. This includes parameters (which only receive global data flow) and most expressions (because they are not value-preserving). Restricting attention to such local sources gives a much lighter and more performant data-flow graph and in most cases also a more suitable abstraction for the investigation of interest. The class ``LocalSourceNode`` represents data-flow nodes that are also local sources. It comes with a useful member predicate ``flowsTo(DataFlow::Node node)``, which holds if there is local data flow from the local source to ``node``.

Examples
~~~~~~~~

Python has builtin functionality for reading and writing files, such as the function ``open``. However, there is also the library ``os`` which provides low-level file access. This query finds the filename passed to ``os.open``:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call
    where
      call = API::moduleImport("os").getMember("open").getACall()
    select call.getArg(0)

Notice the use of the ``API`` module for referring to library functions. For more information, see ":doc:`Using API graphs in Python <using-api-graphs-in-python>`."

Unfortunately this query will only give the expression in the argument, not the values which could be passed to it. So we use local data flow to find all expressions that flow into the argument:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call, DataFlow::ExprNode expr
    where
      call = API::moduleImport("os").getMember("open").getACall() and
      DataFlow::localFlow(expr, call.getArg(0))
    select call, expr

Typically, you will see several data-flow nodes for an expression as it flows towards a call (notice repeated locations in the ``call`` column). We are mostly interested in the "first" of these, what might be called the local source for the file name. To restrict attention to such local sources, and to simultaneously make the analysis more performant, we have the QL class ``LocalSourceNode``. We could demand that ``expr`` is such a node:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call, DataFlow::ExprNode expr
    where
      call = API::moduleImport("os").getMember("open").getACall() and
      DataFlow::localFlow(expr, call.getArg(0)) and
      expr instanceof DataFlow::LocalSourceNode
    select call, expr

However, we could also enforce this by casting. That would allow us to use the member function ``flowsTo`` on ``LocalSourceNode`` like so:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call, DataFlow::ExprNode expr
    where
      call = API::moduleImport("os").getMember("open").getACall() and
      expr.(DataFlow::LocalSourceNode).flowsTo(call.getArg(0))
    select call, expr

As an alternative, we can ask more directly that ``expr`` is a local source of the first argument, via the predicate ``getALocalSource``:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call, DataFlow::ExprNode expr
    where
      call = API::moduleImport("os").getMember("open").getACall() and
      expr = call.getArg(0).getALocalSource()
    select call, expr

These three queries all give identical results. We now mostly have one expression per call.

We still have some cases of more than one expression flowing to a call, but then they flow through different code paths (possibly due to control-flow splitting).

We might want to make the source more specific, for example a parameter to a function or method. This query finds instances where a parameter is used as the name when opening a file:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call, DataFlow::ParameterNode p
    where
      call = API::moduleImport("os").getMember("open").getACall() and
      DataFlow::localFlow(p, call.getArg(0))
    select call, p

For most codebases, this will return only a few results and these could be inspected manually.

Using the exact name supplied via the parameter may be too strict. If we want to know if the parameter influences the file name, we can use taint tracking instead of data flow. This query finds calls to ``os.open`` where the filename is derived from a parameter:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.TaintTracking
    import semmle.python.ApiGraphs

    from DataFlow::CallCfgNode call, DataFlow::ParameterNode p
    where
      call = API::moduleImport("os").getMember("open").getACall() and
      TaintTracking::localTaint(p, call.getArg(0))
    select call, p

Typically, this finds more results.

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

The global data flow library is used by implementing the signature ``DataFlow::ConfigSig`` and applying the module ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import python

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = DataFlow::Global<MyFlowConfiguration>;

These predicates are defined in the configuration:

-  ``isSource`` - defines where data may flow from.
-  ``isSink`` - defines where data may flow to.
-  ``isBarrier`` - optionally, restricts the data flow.
-  ``isAdditionalFlowStep`` - optionally, adds additional flow steps.

The data flow analysis is performed using the predicate ``flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyFlow::flow(source, sink)
   select source, "Dataflow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow what local taint tracking is to local data flow. That is, global taint tracking extends global data flow with additional non-value-preserving steps. The global taint tracking library is used by applying the module ``TaintTracking::Global<ConfigSig>`` to your configuration instead of ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import python

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = TaintTracking::Global<MyFlowConfiguration>;

The resulting module has an identical signature to the one obtained from ``DataFlow::Global<ConfigSig>``.

Predefined sources and sinks
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The data flow library contains a number of predefined sources and sinks, providing a good starting point for defining data flow based security queries.

-  The class ``RemoteFlowSource`` (defined in module ``semmle.python.dataflow.new.RemoteFlowSources``) represents data flow from remote network inputs. This is useful for finding security problems in networked services.
-  The library ``Concepts`` (defined in module ``semmle.python.Concepts``) contain several subclasses of ``DataFlow::Node`` that are security relevant, such as ``FileSystemAccess`` and ``SqlExecution``.
-  The module ``Attributes`` (defined in module ``semmle.python.dataflow.new.internal.Attributes``) defines ``AttrRead`` and ``AttrWrite`` which handle both ordinary and dynamic attribute access.

For global flow, it is also useful to restrict sources to instances of ``LocalSourceNode``. The predefined sources generally do that.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``DataFlow::Node`` - an element behaving as a data flow node.

    -  ``DataFlow::CfgNode`` - a control-flow node behaving as a data flow node.

        -  ``DataFlow::ExprNode`` - an expression behaving as a data flow node.
        -  ``DataFlow::ParameterNode`` - a parameter data flow node representing the value of a parameter at function entry.
        -  ``DataFlow::CallCfgNode`` - a control-flow node for a function or method call behaving as a data flow node.

    -  ``RemoteFlowSource`` - data flow from network/remote input.
    -  ``Attributes::AttrRead`` - an attribute read as a data flow node.
    -  ``Attributes::AttrWrite`` - an attribute write as a data flow node.
    -  ``Concepts::SystemCommandExecution`` - a data-flow node that executes an operating system command, for instance by spawning a new process.
    -  ``Concepts::FileSystemAccess`` - a data flow node that performs a file system access, including reading and writing data, creating and deleting files and folders, checking and updating permissions, and so on.
    -  ``Concepts::Path::PathNormalization`` - a data-flow node that performs path normalization. This is often needed in order to safely access paths.
    -  ``Concepts::Decoding`` - a data-flow node that decodes data from a binary or textual format. A decoding (automatically) preserves taint from input to output. However, it can also be a problem in itself, for example if it allows code execution or could result in denial-of-service.
    -  ``Concepts::Encoding`` - a data-flow node that encodes data to a binary or textual format. An encoding (automatically) preserves taint from input to output.
    -  ``Concepts::CodeExecution`` - a data-flow node that dynamically executes Python code.
    -  ``Concepts::SqlExecution`` - a data-flow node that executes SQL statements.
    -  ``Concepts::HTTP::Server::RouteSetup`` - a data-flow node that sets up a route on a server.
    -  ``Concepts::HTTP::Server::HttpResponse`` - a data-flow node that creates a HTTP response on a server.

Examples
~~~~~~~~

This query shows a data flow configuration that uses all network input as data sources:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.DataFlow
    import semmle.python.dataflow.new.TaintTracking
    import semmle.python.dataflow.new.RemoteFlowSources
    import semmle.python.Concepts

    module RemoteToFileConfiguration implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node source) {
        source instanceof RemoteFlowSource
      }

      predicate isSink(DataFlow::Node sink) {
        sink = any(FileSystemAccess fa).getAPathArgument()
      }
    }

    module RemoteToFileFlow = TaintTracking::Global<RemoteToFileConfiguration>;

    from DataFlow::Node input, DataFlow::Node fileAccess
    where RemoteToFileFlow::flow(input, fileAccess)
    select fileAccess, "This file access uses data from $@.",
      input, "user-controllable input."

This data flow configuration tracks data flow from environment variables to opening files:

.. code-block:: ql

    import python
    import semmle.python.dataflow.new.TaintTracking
    import semmle.python.ApiGraphs

    module EnvironmentToFileConfiguration implements DataFlow::ConfigSig {
      predicate isSource(DataFlow::Node source) {
        source = API::moduleImport("os").getMember("getenv").getACall()
      }

      predicate isSink(DataFlow::Node sink) {
        exists(DataFlow::CallCfgNode call |
          call = API::moduleImport("os").getMember("open").getACall() and
          sink = call.getArg(0)
        )
      }
    }

    module EnvironmentToFileFlow = DataFlow::Global<EnvironmentToFileConfiguration>;

    from Expr environment, Expr fileOpen
    where EnvironmentToFileFlow::flow(DataFlow::exprNode(environment), DataFlow::exprNode(fileOpen))
    select fileOpen, "This call to 'os.open' uses data from $@.",
      environment, "call to 'os.getenv'"


Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/using-type-tracking-for-api-modeling.rst
.. _using-type-tracking-for-api-modeling:

Using type tracking for API modeling
====================================

You can track data through an API by creating a model using the CodeQL type-tracking library for JavaScript.

Overview
--------
The type-tracking library makes it possible to track values through properties and function calls,
usually to recognize method calls and properties accessed on a specific type of object.

This is an advanced topic and is intended for readers already familiar with the
`SourceNode <https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-javascript-and-typescript/#source-nodes>`__ class as well as
`taint tracking <https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-javascript-and-typescript/#using-global-taint-tracking>`__.
For TypeScript analysis also consider reading about `static type information <https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-typescript/#static-type-information>`__ first.


The problem of recognizing method calls
---------------------------------------

We'll start with a simple model of the `Firebase API <https://firebase.google.com/docs/reference/js/firebase.database>`__ and gradually build on it to use type tracking.
Knowledge of Firebase is not required.

Suppose we wish to find places where data is written to a Firebase database, as
in the following example:

.. code-block:: javascript

  var ref = firebase.database().ref("forecast");
  ref.set("Rain"); // <-- find this call

A simple way to do this is just to find
all method calls named "``set``":

.. code-block:: ql

  import javascript
  import DataFlow

  MethodCallNode firebaseSetterCall() {
    result.getMethodName() = "set"
  }

The obvious problem with this is that it finds calls to *all* methods named ``set``,
many of which are unrelated to Firebase.

Another approach is to use local data flow to match the chain of calls that led to this call:

.. code-block:: ql

  MethodCallNode firebaseSetterCall() {
    result = globalVarRef("firebase")
        .getAMethodCall("database")
        .getAMethodCall("ref")
        .getAMethodCall("set")
  }

This will find the ``set`` call from the example, but no spurious, unrelated ``set`` method calls.
We can split it up so each step is its own predicate:

.. code-block:: ql

  SourceNode firebase() {
    result = globalVarRef("firebase")
  }

  SourceNode firebaseDatabase() {
    result = firebase().getAMethodCall("database")
  }

  SourceNode firebaseRef() {
    result = firebaseDatabase().getAMethodCall("ref");
  }

  MethodCallNode firebaseSetterCall() {
    result = firebaseRef().getAMethodCall("set")
  }

The code above is equivalent to the previous version,
but it's easier to tinker with the individual steps.

The downside is that the model relies entirely on local data flow,
which means it won't look through properties and function calls.
For instance, ``firebaseSetterCall()`` fails to find anything in this example:

.. code-block:: javascript

  function getDatabase() {
    return firebase.database();
  }
  var ref = getDatabase().ref("forecast");
  ref.set("Rain");

Notice that the predicate ``firebaseDatabase()`` still finds the call to ``firebase.database()``,
but not the ``getDatabase()`` call.
This means ``firebaseRef()`` has no result, which in turn means ``firebaseSetterCall()`` has no result.

As a simple remedy, let's try to make ``firebaseDatabase()`` recognize the ``getDatabase()`` call:

.. code-block:: ql

  SourceNode firebaseDatabase() {
    result = firebase().getAMethodCall("database")
    or
    result.(CallNode).getACallee().getAReturn().getALocalSource() = firebaseDatabase()
  }

The second clause ensures ``firebaseDatabase()`` finds not only ``firebase.database()`` calls,
but also calls to functions that *return* ``firebase.database()``, such as ``getDatabase()`` seen above.
It's recursive, so it handles flow out of any number of nested function calls.

However, it still only tracks *out* of functions, not *into* functions through parameters, nor through properties.
Instead of adding these steps by hand, we'll use type tracking.

Type tracking in general
------------------------

Type tracking is a generalization of the above pattern, where a predicate matches the value to track,
and has a recursive clause that tracks the flow of that value.
But instead of us having to deal with function calls/returns and property reads/writes,
all of these steps are included in a single predicate,
`SourceNode.track <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/predicate.Sources$SourceNode$track.2.html>`__,
to be used with the companion class
`TypeTracker <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/TypeTracking.qll/type.TypeTracking$TypeTracker.html>`__.

Predicates that use type tracking usually conform to the following general pattern, which we explain below:

.. code-block:: ql

  SourceNode myType(TypeTracker t) {
    t.start() and
    result = /* SourceNode to track */
    or
    exists(TypeTracker t2 |
      result = myType(t2).track(t2, t)
    )
  }

  SourceNode myType() {
    result = myType(TypeTracker::end())
  }

We'll apply the pattern to our example model and use that to explain what's going on.


Tracking the database instance
------------------------------

Applying the above pattern to the ``firebaseDatabase()`` predicate we get the following:

.. code-block:: ql

  SourceNode firebaseDatabase(TypeTracker t) {
    t.start() and
    result = firebase().getAMethodCall("database")
    or
    exists(TypeTracker t2 |
      result = firebaseDatabase(t2).track(t2, t)
    )
  }

  SourceNode firebaseDatabase() {
    result = firebaseDatabase(TypeTracker::end())
  }

There are now two predicates named ``firebaseDatabase``.
The one with the ``TypeTracker`` parameter is the one actually doing the global data flow tracking
-- the other predicate exposes the result in a convenient way.

The new ``TypeTracker t`` parameter is a summary of the steps needed to track the value of interest to the resulting data flow node.

In the base case, when matching ``firebase.database()``, we use ``t.start()`` to indicate that no steps were needed, that is,
this is the starting point of type tracking:

.. code-block:: ql

  t.start() and
  result = firebase().getAMethodCall("database")

In the recursive case, we apply the ``track`` predicate on a previously-found Firebase database node, such as ``firebase.database()``.
The ``track`` predicate maps this to a successor of that node, such as ``getDatabase()``, and
binds ``t`` to the continuation of ``t2`` with this extra step included:

.. code-block:: ql

  exists(TypeTracker t2 |
    result = firebaseDatabase(t2).track(t2, t)
  )

To understand the role of ``t`` here, note that type tracking can step *into* a property, which means
the data flow node returned from ``track`` is not necessarily a Firebase database instance, it could be
an object *containing* a Firebase database in one of its properties.

For example, in the program below, the ``firebaseDatabase(t)`` predicate includes the ``obj`` node in its result,
but with ``t`` recording the fact that the actual value being tracked is inside the ``DB`` property:

.. code-block:: javascript

  let obj = { DB: firebase.database() };
  let db = obj.DB;

This brings us to the last predicate. This uses ``TypeTracker::end()`` to filter out
the paths where the Firebase database instance ended up inside a property of another object,
so it includes ``db`` but not ``obj``:

.. code-block:: ql

  SourceNode firebaseDatabase() {
    result = firebaseDatabase(TypeTracker::end())
  }

Here's see an example of what this can handle now:

.. code-block:: javascript

  class Firebase {
    constructor() {
      this.db = firebase.database();
    }

    getDatabase() { return this.db; }

    setForecast(value) {
      this.getDatabase().ref("forecast").set(value); // found by firebaseSetterCall()
    }
  }

Tracking in the whole model
---------------------------
We applied this pattern to ``firebaseDatabase()`` in the previous section, and we can
apply the model just as easily to other  predicates.
This example query uses the model to find `set` calls.
It's been modified slightly to handle a bit more of the API, which is beyond the scope of this tutorial.

.. code-block:: ql

  import javascript
  import DataFlow

  SourceNode firebase(TypeTracker t) {
    t.start() and
    (
      result = globalVarRef("firebase")
      or
      result = moduleImport("firebase/app")
    )
    or
    exists(TypeTracker t2 |
      result = firebase(t2).track(t2, t)
    )
  }

  SourceNode firebase() {
    result = firebase(TypeTracker::end())
  }

  SourceNode firebaseDatabase(TypeTracker t) {
    t.start() and
    result = firebase().getAMethodCall("database")
    or
    exists(TypeTracker t2 |
      result = firebaseDatabase(t2).track(t2, t)
    )
  }

  SourceNode firebaseDatabase() {
    result = firebaseDatabase(TypeTracker::end())
  }

  SourceNode firebaseRef(TypeTracker t) {
    t.start() and
    result = firebaseDatabase().getAMethodCall("ref")
    or
    exists(TypeTracker t2 |
      result = firebaseRef(t2).track(t2, t)
    )
  }

  SourceNode firebaseRef() {
    result = firebaseRef(TypeTracker::end())
  }

  MethodCallNode firebaseSetterCall() {
    result = firebaseRef().getAMethodCall("set")
  }

  select firebaseSetterCall()

Tracking associated data
------------------------

By adding extra parameters to the type-tracking predicate, we can carry along
extra bits of information about the result.

For example, here's a type-tracking version of ``firebaseRef()``, which
tracks the string that was passed to the ``ref`` call:

.. code-block:: ql

  SourceNode firebaseRef(string name, TypeTracker t) {
    t.start() and
    exists(CallNode call |
      call = firebaseDatabase().getAMethodCall("ref") and
      name = call.getArgument(0).getStringValue() and
      result = call
    )
    or
    exists(TypeTracker t2 |
      result = firebaseRef(name, t2).track(t2, t)
    )
  }

  SourceNode firebaseRef(string name) {
    result = firebaseRef(name, TypeTracker::end())
  }

  MethodCallNode firebaseSetterCall(string refName) {
    result = firebaseRef(refName).getAMethodCall("set")
  }

So now we can use ``firebaseSetterCall("forecast")`` to find assignments to the forecast.

Back-tracking callbacks
-----------------------

The type-tracking predicates we've seen above all use *forward* tracking.
That is, they all start with some value of interest and ask "where does this flow?".

Sometimes it's more useful to work backwards, starting at the desired end-point and asking "what flows to here?".

As a motivating example, we'll extend our model to look for places where we *read* a value
from the database, as opposed to writing it.
Reading is an asynchronous operation and the result is obtained through a callback, for example:

.. code-block:: javascript

  function fetchForecast(callback) {
    firebase.database().ref("forecast").once("value", callback);
  }

  function updateReminders() {
    fetchForecast((snapshot) => {
      let forecast = snapshot.val(); // <-- find this call
      addReminder(forecast === "Rain" ? "Umbrella" : "Sunscreen");
    })
  }

The actual forecast is obtained by the call to ``snapshot.val()``.

Looking for all method calls named ``val`` will in practice find many unrelated methods,
so we'll use type tracking again to take the receiver type into account.

The receiver ``snapshot`` is a parameter to a callback function, which ultimately escapes
into the ``once()`` call. We'll extend our model from above to use back-tracking to find
all functions that flow into the ``once()`` call.
Backwards type tracking is not too different from forwards type tracking. The differences are:

- The ``TypeTracker`` parameter instead has type ``TypeBackTracker``.
- The call to ``.track()`` is instead a call to ``.backtrack()``.
- To ensure the initial value is a source node, a call to ``getALocalSource()`` is usually required.

.. code-block:: ql

  SourceNode firebaseSnapshotCallback(string refName, TypeBackTracker t) {
    t.start() and
    result = firebaseRef(refName).getAMethodCall("once").getArgument(1).getALocalSource()
    or
    exists(TypeBackTracker t2 |
      result = firebaseSnapshotCallback(refName, t2).backtrack(t2, t)
    )
  }

  FunctionNode firebaseSnapshotCallback(string refName) {
    result = firebaseSnapshotCallback(refName, TypeBackTracker::end())
  }

Now, ``firebaseSnapshotCallback("forecast")`` finds the function being passed to ``fetchForecast``.
Based on that we can track the ``snapshot`` value and find the ``val()`` call itself:

.. code-block:: ql

  SourceNode firebaseSnapshot(string refName, TypeTracker t) {
    t.start() and
    result = firebaseSnapshotCallback(refName).getParameter(0)
    or
    exists(TypeTracker t2 |
      result = firebaseSnapshot(refName, t2).track(t2, t)
    )
  }

  SourceNode firebaseSnapshot(string refName) {
    result = firebaseSnapshot(refName, TypeTracker::end())
  }

  MethodCallNode firebaseDatabaseRead(string refName) {
    result = firebaseSnapshot(refName).getAMethodCall("val")
  }

With this addition, ``firebaseDatabaseRead("forecast")`` finds the call to ``snapshot.val()`` that contains the value of the forecast.

.. code-block:: ql

  import javascript
  import DataFlow

  SourceNode firebase(TypeTracker t) {
    t.start() and
    (
      result = globalVarRef("firebase")
      or
      result = moduleImport("firebase/app")
    )
    or
    exists(TypeTracker t2 |
      result = firebase(t2).track(t2, t)
    )
  }

  SourceNode firebase() {
    result = firebase(TypeTracker::end())
  }

  SourceNode firebaseDatabase(TypeTracker t) {
    t.start() and
    result = firebase().getAMethodCall("database")
    or
    exists(TypeTracker t2 |
      result = firebaseDatabase(t2).track(t2, t)
    )
  }

  SourceNode firebaseDatabase() {
    result = firebaseDatabase(TypeTracker::end())
  }

  SourceNode firebaseRef(Node name, TypeTracker t) {
    t.start() and
    exists(CallNode call |
      call = firebaseDatabase().getAMethodCall("ref") and
      name = call.getArgument(0) and
      result = call
    )
    or
    exists(TypeTracker t2 |
      result = firebaseRef(name, t2).track(t2, t)
    )
  }

  SourceNode firebaseRef(Node name) {
    result = firebaseRef(name, TypeTracker::end())
  }

  MethodCallNode firebaseSetterCall(Node name) {
    result = firebaseRef(name).getAMethodCall("set")
  }

  SourceNode firebaseSnapshotCallback(Node refName, TypeBackTracker t) {
    t.start() and
    (
      result = firebaseRef(refName).getAMethodCall("once").getArgument(1).getALocalSource()
      or
      result = firebaseRef(refName).getAMethodCall("once").getAMethodCall("then").getArgument(0).getALocalSource()
    )
    or
    exists(TypeBackTracker t2 |
      result = firebaseSnapshotCallback(refName, t2).backtrack(t2, t)
    )
  }

  FunctionNode firebaseSnapshotCallback(Node refName) {
    result = firebaseSnapshotCallback(refName, TypeBackTracker::end())
  }

  SourceNode firebaseSnapshot(Node refName, TypeTracker t) {
    t.start() and
    result = firebaseSnapshotCallback(refName).getParameter(0)
    or
    exists(TypeTracker t2 |
      result = firebaseSnapshot(refName, t2).track(t2, t)
    )
  }

  SourceNode firebaseSnapshot(Node refName) {
    result = firebaseSnapshot(refName, TypeTracker::end())
  }

  MethodCallNode firebaseDatabaseRead(Node refName) {
    result = firebaseSnapshot(refName).getAMethodCall("val")
  }

  from Node name
  select name, firebaseDatabaseRead(name)

Summary
-------

We have covered how to use the type-tracking library. To recap, use this template to define forward type-tracking predicates:

.. code-block:: ql

  SourceNode myType(TypeTracker t) {
    t.start() and
    result = /* SourceNode to track */
    or
    exists(TypeTracker t2 |
      result = myType(t2).track(t2, t)
    )
  }

  SourceNode myType() {
    result = myType(TypeTracker::end())
  }

Use this template to define backward type-tracking predicates:

.. code-block:: ql

  SourceNode myType(TypeBackTracker t) {
    t.start() and
    result = (/* argument to track */).getALocalSource()
    or
    exists(TypeBackTracker t2 |
      result = myType(t2).backtrack(t2, t)
    )
  }

  SourceNode myType() {
    result = myType(TypeBackTracker::end())
  }

Note that these predicates all return ``SourceNode``,
so attempts to track a non-source node, such as an identifier or string literal,
will not work.
If this becomes an issue, see
`TypeTracker.smallstep <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/TypeTracking.qll/predicate.TypeTracking$TypeTracker$smallstep.2.html>`__.

Also note that the predicates taking a ``TypeTracker`` or ``TypeBackTracker`` can often be made ``private``,
as they are typically only used as an intermediate result to compute the other predicate.

Limitations
-----------

As mentioned, type tracking will track values in and out of function calls and properties,
but only within some limits.

For example, type tracking does not always track *through* functions. That is, if a value flows into a parameter
and back out of the return value, it might not be tracked back out to the call site again.
Here's an example that the model from this tutorial won't find:

.. code-block:: javascript

  function wrapDB(database) {
    return { db: database }
  }
  let wrapper = wrapDB(firebase.database())
  wrapper.db.ref("forecast"); // <-- not found

This is an example of where `data-flow configurations <https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-javascript-and-typescript/#global-data-flow>`__ are more powerful.

When to use type tracking
-------------------------

Type tracking and data-flow configurations are different solutions to the same
problem, each with their own tradeoffs.

Type tracking can be used in any number of predicates, which may depend on each other
in fairly unrestricted ways. The result of one predicate may be the starting
point for another. Type-tracking predicates may be mutually recursive.
Type-tracking predicates can have any number of extra parameters, making it possible, but optional,
to construct source/sink pairs. Omitting source/sink pairs can be useful when there is a huge number
of sources and sinks.

Data-flow configurations have more restricted dependencies but are more powerful in other ways.
For performance reasons,
the sources, sinks, and steps of a configuration should not depend on whether a flow path has been found using
that configuration or any other configuration.
In that sense, the sources, sinks, and steps must be configured "up front" and can't be discovered on-the-fly.
The upside is that they track flow through functions and callbacks in some ways that type tracking doesn't,
which is particularly important for security queries.
Also, path queries can only be defined using data-flow configurations.

Prefer type tracking when:

- Disambiguating generically named methods or properties.
- Making reusable library components to be shared between queries.
- The set of source/sink pairs is too large to compute or has insufficient information.
- The information is needed as input to a data-flow configuration.

Prefer data-flow configurations when:

- Tracking user-controlled data -- use `taint tracking <https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-javascript-and-typescript/#using-global-taint-tracking>`__.
- Differentiating between different kinds of user-controlled data -- see ":doc:`Using flow labels for precise data flow analysis <using-flow-labels-for-precise-data-flow-analysis>`."
- Tracking transformations of a value through generic utility functions.
- Tracking values through string manipulation.
- Generating a path from source to sink -- see ":ref:`Creating path queries <creating-path-queries>`."

Lastly, depending on the code base being analyzed, some alternatives to consider are:

- Using `static type information <https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-typescript/#static-type-information>`__,
  if analyzing TypeScript code.

- Relying on local data flow.

- Relying on syntactic heuristics such as the name of a method, property, or variable.

Type tracking in the standard libraries
---------------------------------------

Type tracking is used in a few places in the standard libraries:

- The `DOM <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DOM.qll/module.DOM$DOM.html>`__ predicates,
  `documentRef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DOM.qll/predicate.DOM$DOM$documentRef.0.html>`__,
  `locationRef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DOM.qll/predicate.DOM$DOM$locationRef.0.html>`__, and
  `domValueRef <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/DOM.qll/predicate.DOM$DOM$domValueRef.0.html>`__,
  are implemented with type tracking.
- The `HTTP <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/HTTP.qll/module.HTTP$HTTP.html>`__ server models, such as `Express <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/Express.qll/module.Express$Express.html>`__, use type tracking to track the installation of router handler functions.
- The `Firebase <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/Firebase.qll/module.Firebase$Firebase.html>`__ and
  `Socket.io <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/frameworks/SocketIO.qll/module.SocketIO$SocketIO.html>`__ models use type tracking to track objects coming from their respective APIs.

Further reading
---------------

.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-java-code.rst
.. _basic-query-for-java-code:

Basic query for Java and Kotlin code
====================================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run searches for inefficient tests for empty strings. For example, Java code such as:

.. code-block:: java

    public class TestJava {
        void myJavaFun(String s) {
            boolean b = s.equals("");
        }
    }

or Kotlin code such as:

.. code-block:: kotlin

    void myKotlinFun(s: String) {
        var b = s.equals("")
    }

In either case, replacing ``s.equals("")`` with ``s.isEmpty()``
would be more efficient.

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete ``select ""`` and paste the following query beneath the import statement ``import java``.

   .. code-block:: ql

        from MethodAccess ma
        where
            ma.getMethod().hasName("equals") and
            ma.getArgument(0).(StringLiteral).getValue() = ""
        select ma, "This comparison to empty string is inefficient, use isEmpty() instead."

   Note that CodeQL treats Java and Kotlin as part of the same language, so even though this query starts with ``import java``, it will work for both Java and Kotlin code.

 .. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-java-query-results-1.png
   :align: center

If any matching code is found, click a link in the ``ma`` column to view the ``.equals`` expression in the code viewer.

.. image:: ../images/codeql-for-visual-studio-code/basic-java-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+
| Query part                                                                                       | Purpose                                                                                                           | Details                                                                                           |
+==================================================================================================+===================================================================================================================+===================================================================================================+
| ``import java``                                                                                  | Imports the standard CodeQL libraries for Java and Kotlin.                                                        | Every query begins with one or more ``import`` statements.                                        |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+
| ``from MethodAccess ma``                                                                         | Defines the variables for the query.                                                                              | We use:                                                                                           |
|                                                                                                  | Declarations are of the form:                                                                                     |                                                                                                   |
|                                                                                                  | ``<type> <variable name>``                                                                                        | - a ``MethodAccess`` variable for call expressions                                                |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+
| ``where ma.getMethod().hasName("equals") and ma.getArgument(0).(StringLiteral).getValue() = ""`` | Defines a condition on the variables.                                                                             | ``ma.getMethod().hasName("equals")`` restricts ``ma`` to only calls to methods call ``equals``.   |
|                                                                                                  |                                                                                                                   |                                                                                                   |
|                                                                                                  |                                                                                                                   | ``ma.getArgument(0).(StringLiteral).getValue() = ""`` says the argument must be literal ``""``.   |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+
| ``select ma, "This comparison to empty string is inefficient, use isEmpty() instead."``          | Defines what to report for each match.                                                                            | Reports the resulting ``.equals`` expression with a string that explains the problem.             |
|                                                                                                  |                                                                                                                   |                                                                                                   |
|                                                                                                  | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                   |
|                                                                                                  | ``select <program element>, "<alert message>"``                                                                   |                                                                                                   |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. For example, you may find results for code like:

.. code-block:: java

    public class TestJava {
        void myJavaFun(Object o) {
            boolean b = o.equals("");
        }
    }

In this case, it is not possible to simply use ``o.isEmpty()`` instead, as ``o`` has type ``Object`` rather than ``String``. One solution to this is to modify the query to only return results where the expression being tested has type ``String``:

#. Extend the where clause to include the following extra condition:

   .. code-block:: ql

    ma.getQualifier().getType() instanceof TypeString

   The ``where`` clause is now:

   .. code-block:: ql

      where
        ma.getQualifier().getType() instanceof TypeString and
        ma.getMethod().hasName("equals") and
        ma.getArgument(0).(StringLiteral).getValue() = ""

#. Re-run the query.

   There are now fewer results because ``.equals`` expressions with different types are no longer included.

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: Java/Kotlin

.. |language-code| replace:: ``java``

.. |example-url| replace:: https://github.com/apache/activemq

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-java.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``ma`` and is linked to the location in the source code of the project where ``ma`` occurs.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-python.rst
.. _codeql-for-python:

CodeQL for Python
=================

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from Python codebases.

.. toctree::
   :hidden:

   basic-query-for-python-code
   codeql-library-for-python
   analyzing-data-flow-in-python
   using-api-graphs-in-python
   functions-in-python
   expressions-and-statements-in-python
   analyzing-control-flow-in-python
   customizing-library-models-for-python

-  :doc:`Basic query for Python code <basic-query-for-python-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for Python <codeql-library-for-python>`: When you need to analyze a Python program, you can make use of the large collection of classes in the CodeQL library for Python.

-  :doc:`Analyzing data flow in Python <analyzing-data-flow-in-python>`: You can use CodeQL to track the flow of data through a Python program to places where the data is used.

-  :doc:`Using API graphs in Python <using-api-graphs-in-python>`: API graphs are a uniform interface for referring to functions, classes, and methods defined in external libraries.

-  :doc:`Functions in Python <functions-in-python>`: You can use syntactic classes from the standard CodeQL library to find Python functions and identify calls to them.

-  :doc:`Expressions and statements in Python <expressions-and-statements-in-python>`: You can use syntactic classes from the CodeQL library to explore how Python expressions and statements are used in a codebase.

-  :doc:`Analyzing control flow in Python <analyzing-control-flow-in-python>`: You can write CodeQL queries to explore the control-flow graph of a Python program, for example, to discover unreachable code or mutually exclusive blocks of code.

-  :doc:`Customizing library models for Python <customizing-library-models-for-python>`: You can model frameworks and libraries that your codebase depends on using data extensions and publish them as CodeQL model packs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-python-code.rst
.. _basic-query-for-python-code:

Basic query for Python code
===========================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run performs a basic search of the code for ``if`` statements that are redundant, in the sense that they only include a ``pass`` statement. For example, code such as:

.. code-block:: python

   if error: pass

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete ``select ""`` and paste the following query beneath the import statement ``import python``.

   .. code-block:: ql

      from If ifstmt, Stmt pass
      where pass = ifstmt.getStmt(0) and
        pass instanceof Pass
      select ifstmt, "This 'if' statement is redundant."

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-python-query-results-1.png
   :align: center

If any matching code is found, click a link in the ``ifstmt`` column to open the file and highlight the matching ``if`` statement.

.. image:: ../images/codeql-for-visual-studio-code/basic-python-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| Query part                                                    | Purpose                                                                                                           | Details                                                                                                                |
+===============================================================+===================================================================================================================+========================================================================================================================+
| ``import python``                                             | Imports the standard CodeQL libraries for Python.                                                                 | Every query begins with one or more ``import`` statements.                                                             |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``from If ifstmt, Stmt pass``                                 | Defines the variables for the query.                                                                              | We use:                                                                                                                |
|                                                               | Declarations are of the form:                                                                                     |                                                                                                                        |
|                                                               | ``<type> <variable name>``                                                                                        | - an ``If`` variable for ``if`` statements                                                                             |
|                                                               |                                                                                                                   | - a ``Stmt`` variable for the statement                                                                                |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``where pass = ifstmt.getStmt(0) and pass instanceof Pass``   | Defines a condition on the variables.                                                                             | ``pass = ifstmt.getStmt(0)``: ``pass`` is the first statement in the ``if`` statement.                                 |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               |                                                                                                                   | ``pass instanceof Pass``: ``pass`` must be a pass statement.                                                           |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               |                                                                                                                   | In other words, the first statement contained in the ``if`` statement is a ``pass`` statement.                         |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``select ifstmt, "This 'if' statement is redundant."``        | Defines what to report for each match.                                                                            | Reports the resulting ``if`` statement with a string that explains the problem.                                        |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                                        |
|                                                               | ``select <program element>, "<alert message>"``                                                                   |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find examples of ``if`` statements with an ``else`` branch, where a ``pass`` statement does serve a purpose. For example:

.. code-block:: python

   if cond():
     pass
   else:
     do_something()

In this case, identifying the ``if`` statement with the ``pass`` statement as redundant is a false positive. One solution to this is to modify the query to ignore ``pass`` statements if the ``if`` statement has an ``else`` branch.

To exclude ``if`` statements that have an ``else`` branch:

#. Extend the ``where`` clause to include the following extra condition:

   .. code-block:: ql

      and not exists(ifstmt.getOrelse())

   The ``where`` clause is now:

   .. code-block:: ql

      where pass = ifstmt.getStmt(0) and
        pass instanceof Pass and
        not exists(ifstmt.getOrelse())

#. Re-run the query.

   There are now fewer results because ``if`` statements with an ``else`` branch are no longer included.

Further reading
---------------

.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: Python

.. |language-code| replace:: ``python``

.. |example-url| replace:: https://github.com/saltstack/salt

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-python.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``ifstmt`` and is linked to the location in the source code of the project where ``ifstmt`` occurs.


# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/working-with-source-locations.rst
.. _working-with-source-locations:

Working with source locations
=============================

You can use the location of entities within Java/Kotlin code to look for potential errors. Locations allow you to deduce the presence, or absence, of white space which, in some cases, may indicate a problem.

About source locations
----------------------

Java offers a rich set of operators with complex precedence rules, which are sometimes confusing to developers. For instance, the class ``ByteBufferCache`` in the OpenJDK Java compiler (which is a member class of ``com.sun.tools.javac.util.BaseFileManager``) contains this code for allocating a buffer:

.. code-block:: java

   ByteBuffer.allocate(capacity + capacity>>1)

Presumably, the author meant to allocate a buffer that is 1.5 times the size indicated by the variable ``capacity``. In fact, however, operator ``+`` binds tighter than operator ``>>``, so the expression ``capacity + capacity>>1`` is parsed as ``(capacity + capacity)>>1``, which equals ``capacity`` (unless there is an arithmetic overflow).

Note that the source layout gives a fairly clear indication of the intended meaning: there is more white space around ``+`` than around ``>>``, suggesting that the latter is meant to bind more tightly.

We're going to develop a query that finds this kind of suspicious nesting, where the operator of the inner expression has more white space around it than the operator of the outer expression. This pattern may not necessarily indicate a bug, but at the very least it makes the code hard to read and prone to misinterpretation.

White space is not directly represented in the CodeQL database, but we can deduce its presence from the location information associated with program elements and AST nodes. So, before we write our query, we need an understanding of source location management in the standard library for Java.

Location API
------------

For every entity that has a representation in Java source code (including, in particular, program elements and AST nodes), the standard CodeQL library provides these predicates for accessing source location information:

-  ``getLocation`` returns a ``Location`` object describing the start and end position of the entity.
-  ``getFile`` returns a ``File`` object representing the file containing the entity.
-  ``getTotalNumberOfLines`` returns the number of lines the source code of the entity spans.
-  ``getNumberOfCommentLines`` returns the number of comment lines.
-  ``getNumberOfLinesOfCode`` returns the number of non-comment lines.

For example, let's assume this Java class is defined in the compilation unit ``SayHello.java``:

.. code-block:: java

   package pkg;

   class SayHello {
       public static void main(String[] args) {
           System.out.println(
               // Display personalized message
               "Hello, " + args[0];
           );
       }
   }

Invoking ``getFile`` on the expression statement in the body of ``main`` returns a ``File`` object representing the file ``SayHello.java``. The statement spans four lines in total ``(getTotalNumberOfLines``), of which one is a comment line (``getNumberOfCommentLines``), while three lines contain code (``getNumberOfLinesOfCode``).

Class ``Location`` defines member predicates ``getStartLine``, ``getEndLine``, ``getStartColumn`` and ``getEndColumn`` to retrieve the line and column number an entity starts and ends at, respectively. Both lines and columns are counted starting from 1 (not 0), and the end position is inclusive, that is, it is the position of the last character belonging to the source code of the entity.

In our example, the expression statement starts at line 5, column 3 (the first two characters on the line are tabs, which each count as one character), and it ends at line 8, column 4.

Class ``File`` defines these member predicates:

-  ``getAbsolutePath`` returns the fully qualified name of the file.
-  ``getRelativePath`` returns the path of the file relative to the base directory of the source code.
-  ``getExtension`` returns the extension of the file.
-  ``getStem`` returns the base name of the file, without its extension.

In our example, assume file ``A.java`` is located in directory ``/home/testuser/code/pkg``, where ``/home/testuser/code`` is the base directory of the program being analyzed. Then, a ``File`` object for ``A.java`` returns:

-  ``getAbsolutePath`` is ``/home/testuser/code/pkg/A.java``.
-  ``getRelativePath`` is ``pkg/A.java``.
-  ``getExtension`` is ``java``.
-  ``getStem`` is ``A``.

Determining white space around an operator
------------------------------------------

Let's start by considering how to write a predicate that computes the total amount of white space surrounding the operator of a given binary expression. If ``rcol`` is the start column of the expression's right operand and ``lcol`` is the end column of its left operand, then ``rcol - (lcol+1)`` gives us the total number of characters in between the two operands (note that we have to use ``lcol+1`` instead of ``lcol`` because end positions are inclusive).

This number includes the length of the operator itself, which we need to subtract out. For this, we can use predicate ``getOp``, which returns the operator string, surrounded by one white space on either side. Overall, the expression for computing the amount of white space around the operator of a binary expression ``expr`` is:

.. code-block:: ql

   rcol - (lcol+1) - (expr.getOp().length()-2)

Clearly, however, this only works if the entire expression is on a single line, which we can check using predicate ``getTotalNumberOfLines`` introduced above. We are now in a position to define our predicate for computing white space around operators:

.. code-block:: ql

   int operatorWS(BinaryExpr expr) {
       exists(int lcol, int rcol |
           expr.getNumberOfLinesOfCode() = 1 and
           lcol = expr.getLeftOperand().getLocation().getEndColumn() and
           rcol = expr.getRightOperand().getLocation().getStartColumn() and
           result = rcol - (lcol+1) - (expr.getOp().length()-2)
       )
   }

Notice that we use an ``exists`` to introduce our temporary variables ``lcol`` and ``rcol``. You could write the predicate without them by just inlining ``lcol`` and ``rcol`` into their use, at some cost in readability.

Find suspicious nesting
-----------------------

Here's a first version of our query:

.. code-block:: ql

   import java

   // Insert predicate defined above

   from BinaryExpr outer, BinaryExpr inner,
       int wsouter, int wsinner
   where inner = outer.getAChildExpr() and
       wsinner = operatorWS(inner) and wsouter = operatorWS(outer) and
       wsinner > wsouter
   select outer, "Whitespace around nested operators contradicts precedence."

This query is likely to find results on most codebases.

The first conjunct of the ``where`` clause restricts ``inner`` to be an operand of ``outer``, the second conjunct binds ``wsinner`` and ``wsouter``, while the last conjunct selects the suspicious cases.

At first, we might be tempted to write ``inner = outer.getAnOperand()`` in the first conjunct. This, however, wouldn't be quite correct: ``getAnOperand`` strips off any surrounding parentheses from its result, which is often useful, but not what we want here: if there are parentheses around the inner expression, then the programmer probably knew what they were doing, and the query should not flag this expression.

Improving the query
~~~~~~~~~~~~~~~~~~~

If we run this initial query, we might notice some false positives arising from asymmetric white space. For instance, the following expression is flagged as suspicious, although it is unlikely to cause confusion in practice:

.. code-block:: java

   i< start + 100

Note that our predicate ``operatorWS`` computes the **total** amount of white space around the operator, which, in this case, is one for the ``<`` and two for the ``+``. Ideally, we would like to exclude cases where the amount of white space before and after the operator are not the same. Currently, CodeQL databases don't record enough information to figure this out, but as an approximation we could require that the total number of white space characters is even:

.. code-block:: ql

   import java

   // Insert predicate definition from above

   from BinaryExpr outer, BinaryExpr inner,
       int wsouter, int wsinner
   where inner = outer.getAChildExpr() and
       wsinner = operatorWS(inner) and wsouter = operatorWS(outer) and
       wsinner % 2 = 0 and wsouter % 2 = 0 and
       wsinner > wsouter
   select outer, "Whitespace around nested operators contradicts precedence."

Any results will be refined by our changes to the query.

Another source of false positives are associative operators: in an expression of the form ``x + y+z``, the first plus is syntactically nested inside the second, since + in Java associates to the left; hence the expression is flagged as suspicious. But since + is associative to begin with, it does not matter which way around the operators are nested, so this is a false positive. To exclude these cases, let us define a new class identifying binary expressions with an associative operator:

.. code-block:: ql

   class AssociativeOperator extends BinaryExpr {
       AssociativeOperator() {
           this instanceof AddExpr or
           this instanceof MulExpr or
           this instanceof BitwiseExpr or
           this instanceof AndLogicalExpr or
           this instanceof OrLogicalExpr
       }
   }

Now we can extend our query to discard results where the outer and the inner expression both have the same, associative operator:

.. code-block:: ql

   import java

   // Insert predicate and class definitions from above

   from BinaryExpr inner, BinaryExpr outer, int wsouter, int wsinner
   where inner = outer.getAChildExpr() and
       not (inner.getOp() = outer.getOp() and outer instanceof AssociativeOperator) and
       wsinner = operatorWS(inner) and wsouter = operatorWS(outer) and
       wsinner % 2 = 0 and wsouter % 2 = 0 and
       wsinner > wsouter
   select outer, "Whitespace around nested operators contradicts precedence."

Notice that we again use ``getOp``, this time to determine whether two binary expressions have the same operator. Running our improved query now finds the Java/Kotlin standard library bug described in the Overview. It also flags up the following suspicious code in `Hadoop HBase <https://hbase.apache.org/>`__:

.. code-block:: java

   KEY_SLAVE = tmp[ i+1 % 2 ];

Whitespace suggests that the programmer meant to toggle ``i`` between zero and one, but in fact the expression is parsed as ``i + (1%2)``, which is the same as ``i + 1``, so ``i`` is simply incremented.

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-javascript.rst
.. _codeql-for-javascript:

CodeQL for JavaScript and TypeScript
====================================

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from JavaScript and TypeScript codebases.

.. toctree::
   :hidden:

   basic-query-for-javascript-code
   codeql-library-for-javascript
   codeql-library-for-typescript
   analyzing-data-flow-in-javascript-and-typescript
   using-flow-labels-for-precise-data-flow-analysis
   specifying-additional-remote-flow-sources-for-javascript
   using-type-tracking-for-api-modeling
   abstract-syntax-tree-classes-for-working-with-javascript-and-typescript-programs
   data-flow-cheat-sheet-for-javascript
   customizing-library-models-for-javascript

-  :doc:`Basic query for JavaScript and TypeScript code <basic-query-for-javascript-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`CodeQL library for JavaScript <codeql-library-for-javascript>`: When you're analyzing a JavaScript program, you can make use of the large collection of classes in the CodeQL library for JavaScript.

-  :doc:`CodeQL library for TypeScript <codeql-library-for-typescript>`: When you're analyzing a TypeScript program, you can make use of the large collection of classes in the CodeQL library for TypeScript.

-  :doc:`Analyzing data flow in JavaScript and TypeScript <analyzing-data-flow-in-javascript-and-typescript>`: This topic describes how data flow analysis is implemented in the CodeQL libraries for JavaScript/TypeScript and includes examples to help you write your own data flow queries.

-  :doc:`Using flow labels for precise data flow analysis <using-flow-labels-for-precise-data-flow-analysis>`: You can associate flow labels with each value tracked by the flow analysis to determine whether the flow contains potential vulnerabilities.

-  :doc:`Using type tracking for API modeling <using-type-tracking-for-api-modeling>`: You can track data through an API by creating a model using the CodeQL type-tracking library for JavaScript.

-  :doc:`Abstract syntax tree classes for working with JavaScript and TypeScript programs <abstract-syntax-tree-classes-for-working-with-javascript-and-typescript-programs>`: CodeQL has a large selection of classes for representing the abstract syntax tree of JavaScript and TypeScript programs.

-  :doc:`Data flow cheat sheet for JavaScript <data-flow-cheat-sheet-for-javascript>`: This article describes parts of the JavaScript libraries commonly used for variant analysis and in data flow queries.

- :doc:`Customizing library models for JavaScript <customizing-library-models-for-javascript>`: You can model frameworks and libraries that your codebase depends on using data extensions and publish them as CodeQL model packs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/detecting-a-potential-buffer-overflow.rst
.. _detecting-a-potential-buffer-overflow:

Detecting a potential buffer overflow
=====================================

You can use CodeQL to detect potential buffer overflows by checking for allocations equal to ``strlen`` in C and C++. This topic describes how a C/C++ query for detecting a potential buffer overflow was developed.

Problem—detecting memory allocation that omits space for a null termination character
-------------------------------------------------------------------------------------

The objective of this query is to detect C/C++ code which allocates an amount of memory equal to the length of a null terminated string, without adding +1 to make room for a null termination character. For example the following code demonstrates this mistake, and results in a buffer overflow:

.. code-block:: cpp

   void processString(const char *input)
   {
       char *buffer = malloc(strlen(input));

       strcpy(buffer, input);

       ...
   }

Basic query
-----------

Before you can write a query you need to decide what entities to search for and then define how to identify them.

Defining the entities of interest
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You could approach this problem either by searching for code similar to the call to ``malloc`` in line 3 or the call to ``strcpy`` in line 5 (see example above). For our basic query, we start with a simple assumption: any call to ``malloc`` with only a ``strlen`` to define the memory size is likely to cause an error when the memory is populated.

Calls to ``strlen`` can be identified using the library `StrlenCall <https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/commons/StringAnalysis.qll/type.StringAnalysis$StrlenCall.html>`__ class, but we need to define a new class to identify calls to ``malloc``. Both the library class and the new class need to extend the standard class ``FunctionCall``, with the added restriction of the function name that they apply to:

.. code-block:: ql

   import cpp

   class MallocCall extends FunctionCall
   {
       MallocCall() { this.getTarget().hasGlobalName("malloc") }
   }

.. pull-quote::
    
   Note

   You could easily extend this class to include similar functions such as ``realloc``, or your own custom allocator. With a little effort they could even include C++ ``new`` expressions (to do this, ``MallocCall`` would need to extend a common superclass of both ``FunctionCall`` and ``NewExpr``, such as ``Expr``).

Finding the ``strlen(string)`` pattern
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Before we start to write our query, there's one remaining task. We need to modify our new ``MallocCall`` class, so it returns an expression for the size of the allocation. Currently this will be the first argument to the ``malloc`` call, ``FunctionCall.getArgument(0)``, but converting this into a predicate makes it more flexible for future refinements.

.. code-block:: ql

   class MallocCall extends FunctionCall
   {
       MallocCall() { this.getTarget().hasGlobalName("malloc") }
       Expr getAllocatedSize() {
           result = this.getArgument(0)
       }
   }

Defining the basic query
~~~~~~~~~~~~~~~~~~~~~~~~

Now we can write a query using these classes:

.. code-block:: ql

   import cpp

   class MallocCall extends FunctionCall
   {
       MallocCall() { this.getTarget().hasGlobalName("malloc") }
       Expr getAllocatedSize() {
           result = this.getArgument(0)
       }
   }

   from MallocCall malloc
   where malloc.getAllocatedSize() instanceof StrlenCall
   select malloc, "This allocation does not include space to null-terminate the string."

Note that there is no need to check whether anything is added to the ``strlen`` expression, as it would be in the corrected C code ``malloc(strlen(string) + 1)``. This is because the corrected code would in fact be an ``AddExpr`` containing a ``StrlenCall``, not an instance of ``StrlenCall`` itself. A side-effect of this approach is that we omit certain unlikely patterns such as ``malloc(strlen(string) + 0``). In practice we can always come back and extend our query to cover this pattern if it is a concern.

.. pull-quote::

   Tip

   For some projects, this query may not return any results. Possibly the project you are querying does not have any problems of this kind, but it is also important to make sure the query itself is working properly. One solution is to set up a test project with examples of correct and incorrect code to run the query against (the C code at the very top of this page makes a good starting point). Another approach is to test each part of the query individually to make sure everything is working.

When you have defined the basic query then you can refine the query to include further coding patterns or to exclude false positives:

Improving the query using the 'SSA' library
-------------------------------------------

The ``SSA`` library represents variables in static single assignment (SSA) form. In this form, each variable is assigned exactly once and every variable is defined before it is used. The use of SSA variables simplifies queries considerably as much of the local data flow analysis has been done for us. For more information, see `Static single assignment <https://en.wikipedia.org/wiki/Static_single_assignment_form>`__ on Wikipedia.

Including examples where the string size is stored before use
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The query above works for simple cases, but does not identify a common coding pattern where ``strlen(string)`` is stored in a variable before being passed to ``malloc``, as in the following example:

.. code-block:: cpp

       int len = strlen(input);
       buffer = malloc(len);

To identify this case we can use the standard library ``SSA.qll`` (imported as ``semmle.code.cpp.controlflow.SSA``).

This library helps us identify where values assigned to local variables may subsequently be used.

For example, consider the following code:

.. code-block:: cpp

   void myFunction(bool condition)
   {
       const char* x = "alpha"; // definition #1 of x

       printf("x = %s\n", x); // use #1 of x

       if (condition)
       {
           x = "beta"; // definition #2 of x
       } else {
           x = "gamma"; // definition #3 of x
       }

       printf("x = %s\n", x); // use #2 of x
   }

If we run the following query on the code, we get three results:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.controlflow.SSA

   from Variable var, Expr defExpr, Expr use
   where exists(SsaDefinition ssaDef |
       defExpr = ssaDef.getAnUltimateDefiningValue(var)
       and use = ssaDef.getAUse(var))
   select var, defExpr.getLocation().getStartLine() as dline, use.getLocation().getStartLine() as uline

**Results:**

+---------+-----------+-----------+
| ``var`` | ``dline`` | ``uline`` |
+=========+===========+===========+
| ``x``   | 3         | 5         |
+---------+-----------+-----------+
| ``x``   | 9         | 14        |
+---------+-----------+-----------+
| ``x``   | 11        | 14        |
+---------+-----------+-----------+

It is often useful to also display the defining expression ``defExpr``, if there is one. For example we might adjust the query above as follows:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.controlflow.SSA

   from Variable var, Expr defExpr, Expr use
   where exists(SsaDefinition ssaDef |
       defExpr = ssaDef.getAnUltimateDefiningValue(var)
       and use = ssaDef.getAUse(var))
   select var, defExpr.getLocation().getStartLine() as dline, use.getLocation().getStartLine() as uline, defExpr

Now we can see the assigned expression in our results:

+---------+-----------+-----------+-------------+
| ``var`` | ``dline`` | ``uline`` | ``defExpr`` |
+=========+===========+===========+=============+
| ``x``   | 3         | 5         | alpha       |
+---------+-----------+-----------+-------------+
| ``x``   | 9         | 14        | beta        |
+---------+-----------+-----------+-------------+
| ``x``   | 11        | 14        | gamma       |
+---------+-----------+-----------+-------------+

Extending the query to include allocations passed via a variable
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Using our experiments above we can expand our simple implementation of ``MallocCall.getAllocatedSize()``. With the following refinement, if the argument is an access to a variable, ``getAllocatedSize()`` returns a value assigned to that variable instead of the variable access itself:

.. code-block:: ql

   Expr getAllocatedSize() {
       if this.getArgument(0) instanceof VariableAccess then
           exists(LocalScopeVariable v, SsaDefinition ssaDef |
                   result = ssaDef.getAnUltimateDefiningValue(v)
                   and this.getArgument(0) = ssaDef.getAUse(v))
       else
           result = this.getArgument(0)
   }

The completed query will now identify cases where the result of ``strlen`` is stored in a local variable before it is used in a call to ``malloc``. Here is the query in full:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.controlflow.SSA

   class MallocCall extends FunctionCall
   {
       MallocCall() { this.getTarget().hasGlobalName("malloc") }

       Expr getAllocatedSize() {
           if this.getArgument(0) instanceof VariableAccess then
               exists(LocalScopeVariable v, SsaDefinition ssaDef |
                   result = ssaDef.getAnUltimateDefiningValue(v)
                   and this.getArgument(0) = ssaDef.getAUse(v))
           else
               result = this.getArgument(0)
       }
   }

   from MallocCall malloc
   where malloc.getAllocatedSize() instanceof StrlenCall
   select malloc, "This allocation does not include space to null-terminate the string."

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-cpp-new.rst
.. _analyzing-data-flow-in-cpp-new:

.. include:: ../reusables/cpp-new-dataflow-api-note.rst

Analyzing data flow in C and C++ (new)
======================================

You can use data flow analysis to track the flow of potentially malicious or insecure data that can cause vulnerabilities in your codebase.

About data flow
---------------

Data flow analysis computes the possible values that a variable can hold at various points in a program, determining how those values propagate through the program, and where they are used. In CodeQL, you can model both local data flow and global data flow. For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

Local data flow
---------------

Local data flow is data flow within a single function. Local data flow is usually easier, faster, and more precise than global data flow, and is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

The local data flow library is in the module ``DataFlow``, which defines the class ``Node`` denoting any element that data can flow through. ``Node``\ s are divided into expression nodes (``ExprNode``, ``IndirectExprNode``) and parameter nodes (``ParameterNode``, ``IndirectParameterNode``). The indirect nodes represent expressions or parameters after a fixed number of pointer dereferences.

It is possible to map between data flow nodes and expressions or parameters using the member predicates ``asExpr``, ``asIndirectExpr``, and ``asParameter``:

.. code-block:: ql

   class Node {
     /**
      * Gets the expression corresponding to this node, if any.
      */
     Expr asExpr() { ... }

     /**
      * Gets the expression corresponding to a node that is obtained after dereferencing
      * the expression `index` times, if any.
      */
     Expr asIndirectExpr(int index) { ... }

     /**
      * Gets the parameter corresponding to this node, if any.
      */
     Parameter asParameter() { ... }

     /**
      * Gets the parameter corresponding to a node that is obtained after dereferencing
      * the parameter `index` times.
      */
     Parameter asParameter(int index) { ... }

     ...
   }

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``. The predicate can be applied recursively (using the ``+`` and ``*`` operators), or through the predefined recursive predicate ``localFlow``, which is equivalent to ``localFlowStep*``.

For example, finding flow from a parameter ``source`` to an expression ``sink`` in zero or more local steps can be achieved as follows, where ``nodeFrom`` and ``nodeTo`` are of type ``DataFlow::Node``:

.. code-block:: ql

   nodeFrom.asParameter() = source and
   nodeTo.asExpr() = sink and
   DataFlow::localFlow(nodeFrom, nodeTo)

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow by including non-value-preserving flow steps. For example:

.. code-block:: cpp

   int i = tainted_user_input();
   some_big_struct *array = malloc(i * sizeof(some_big_struct));

In this case, the argument to ``malloc`` is tainted.

The local taint tracking library is in the module ``TaintTracking``. Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``. The predicate can be applied recursively (using the ``+`` and ``*`` operators), or through the predefined recursive predicate ``localTaint``, which is equivalent to ``localTaintStep*``.

For example, finding taint propagation from a parameter ``source`` to an expression ``sink`` in zero or more local steps can be achieved as follows, where ``nodeFrom`` and ``nodeTo`` are of type ``DataFlow::Node``:

.. code-block:: ql

   nodeFrom.asParameter() = source and
   nodeTo.asExpr() = sink and
   TaintTracking::localTaint(nodeFrom, nodeTo)

Examples
~~~~~~~~

The following query finds the filename passed to ``fopen``:

.. code-block:: ql

   import cpp

   from Function fopen, FunctionCall fc
   where
     fopen.hasGlobalName("fopen") and
     fc.getTarget() = fopen
   select fc.getArgument(0)

However, this will only give the expression in the argument, not the values which could be passed to it. Instead we can use local data flow to find all expressions that flow into the argument, where we use ``asIndirectExpr(1)``. This is because we are interested in the value of the string passed to `fopen`, not the pointer pointing to it:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   from Function fopen, FunctionCall fc, Expr src, DataFlow::Node source, DataFlow::Node sink
   where
     fopen.hasGlobalName("fopen") and
     fc.getTarget() = fopen and
     source.asIndirectExpr(1) = src and
     sink.asIndirectExpr(1) = fc.getArgument(0) and
     DataFlow::localFlow(source, sink)
   select src

Then we can vary the source and, for example, use the parameter of a function. The following query finds where a parameter is used when opening a file:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   from Function fopen, FunctionCall fc, Parameter p, DataFlow::Node source, DataFlow::Node sink
   where
     fopen.hasGlobalName("fopen") and
     fc.getTarget() = fopen and
     source.asParameter(1) = p and
     sink.asIndirectExpr(1) = fc.getArgument(0) and
     DataFlow::localFlow(source, sink)
   select p

The following example finds calls to formatting functions where the format string is not hard-coded.

.. code-block:: ql

   import semmle.code.cpp.dataflow.new.DataFlow
   import semmle.code.cpp.commons.Printf

   from FormattingFunction format, FunctionCall call, Expr formatString, DataFlow::Node sink
   where
     call.getTarget() = format and
     call.getArgument(format.getFormatParameterIndex()) = formatString and
     sink.asIndirectExpr(1) = formatString and
     not exists(DataFlow::Node source |
       DataFlow::localFlow(source, sink) and
       source.asIndirectExpr(1) instanceof StringLiteral
     )
   select call, "Argument to " + format.getQualifiedName() + " isn't hard-coded."

Exercises
~~~~~~~~~

Exercise 1: Write a query that finds all hard-coded strings used to create a ``host_ent`` via ``gethostbyname``, using local data flow. (`Answer <#exercise-1>`__)

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

The global data flow library is used by implementing the signature ``DataFlow::ConfigSig`` and applying the module ``DataFlow::Global<ConfigSig>`` as follows:

.. code-block:: ql

   import semmle.code.cpp.dataflow.new.DataFlow

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = DataFlow::Global<MyFlowConfiguration>;

The following predicates are defined in the configuration:

-  ``isSource``—defines where data may flow from
-  ``isSink``—defines where data may flow to
-  ``isBarrier``—optional, restricts the data flow
-  ``isAdditionalFlowStep``—optional, adds additional flow steps

The data flow analysis is performed using the predicate ``flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyFlow::flow(source, sink)
   select source, "Data flow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow as local taint tracking is to local data flow. That is, global taint tracking extends global data flow with additional non-value-preserving steps. The global taint tracking library is used by applying the module ``TaintTracking::Global<ConfigSig>`` to your configuration instead of ``DataFlow::Global<ConfigSig>`` as follows:

.. code-block:: ql

   import semmle.code.cpp.dataflow.new.TaintTracking

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = TaintTracking::Global<MyFlowConfiguration>;

The resulting module has an identical signature to the one obtained from ``DataFlow::Global<ConfigSig>``.

Examples
~~~~~~~~

The following data flow configuration tracks data flow from environment variables to opening files in a Unix-like environment:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   module EnvironmentToFileConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       exists(Function getenv |
         source.asIndirectExpr(1).(FunctionCall).getTarget() = getenv and
         getenv.hasGlobalName("getenv")
       )
     }

     predicate isSink(DataFlow::Node sink) {
       exists(FunctionCall fc |
         sink.asIndirectExpr(1) = fc.getArgument(0) and
         fc.getTarget().hasGlobalName("fopen")
       )
     }
   }

   module EnvironmentToFileFlow = DataFlow::Global<EnvironmentToFileConfiguration>;

   from
     Expr getenv, Expr fopen, DataFlow::Node source, DataFlow::Node sink
   where
     source.asIndirectExpr(1) = getenv and
     sink.asIndirectExpr(1) = fopen and
     EnvironmentToFileFlow::flow(source, sink)
   select fopen, "This 'fopen' uses data from $@.", getenv, "call to 'getenv'"

The following taint-tracking configuration tracks data from a call to ``ntohl`` to an array index operation. It uses the ``Guards`` library to recognize expressions that have been bounds-checked, and defines ``isBarrier`` to prevent taint from propagating through them. It also uses ``isAdditionalFlowStep`` to add flow from loop bounds to loop indexes.

.. code-block:: ql

   import cpp
   import semmle.code.cpp.controlflow.Guards
   import semmle.code.cpp.dataflow.new.TaintTracking

   module NetworkToBufferSizeConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node node) {
       node.asExpr().(FunctionCall).getTarget().hasGlobalName("ntohl")
     }

     predicate isSink(DataFlow::Node node) {
       exists(ArrayExpr ae | node.asExpr() = ae.getArrayOffset())
     }

     predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {
       exists(Loop loop, LoopCounter lc |
         loop = lc.getALoop() and
         loop.getControllingExpr().(RelationalOperation).getGreaterOperand() = pred.asExpr()
       |
         succ.asExpr() = lc.getVariableAccessInLoop(loop)
       )
     }

     predicate isBarrier(DataFlow::Node node) {
       exists(GuardCondition gc, Variable v |
         gc.getAChild*() = v.getAnAccess() and
         node.asExpr() = v.getAnAccess() and
         gc.controls(node.asExpr().getBasicBlock(), _) and
         not exists(Loop loop | loop.getControllingExpr() = gc)
       )
     }
   }

   module NetworkToBufferSizeFlow = TaintTracking::Global<NetworkToBufferSizeConfiguration>;

   from DataFlow::Node ntohl, DataFlow::Node offset
   where NetworkToBufferSizeFlow::flow(ntohl, offset)
   select offset, "This array offset may be influenced by $@.", ntohl,
     "converted data from the network"

Exercises
~~~~~~~~~

Exercise 2: Write a query that finds all hard-coded strings used to create a ``host_ent`` via ``gethostbyname``, using global data flow. (`Answer <#exercise-2>`__)

Exercise 3: Write a class that represents flow sources from ``getenv``. (`Answer <#exercise-3>`__)

Exercise 4: Using the answers from 2 and 3, write a query which finds all global data flows from ``getenv`` to ``gethostbyname``. (`Answer <#exercise-4>`__)

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   from StringLiteral sl, FunctionCall fc, DataFlow::Node source, DataFlow::Node sink
   where
     fc.getTarget().hasName("gethostbyname") and
     source.asIndirectExpr(1) = sl and
     sink.asIndirectExpr(1) = fc.getArgument(0) and
     DataFlow::localFlow(source, sink)
   select sl, fc

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   module LiteralToGethostbynameConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source.asIndirectExpr(1) instanceof StringLiteral
     }

     predicate isSink(DataFlow::Node sink) {
       exists(FunctionCall fc |
         sink.asIndirectExpr(1) = fc.getArgument(0) and
         fc.getTarget().hasName("gethostbyname")
       )
     }
   }

   module LiteralToGethostbynameFlow = DataFlow::Global<LiteralToGethostbynameConfiguration>;

   from
     StringLiteral sl, FunctionCall fc, DataFlow::Node source, DataFlow::Node sink
   where
     source.asIndirectExpr(1) = sl and
     sink.asIndirectExpr(1) = fc.getArgument(0) and
     LiteralToGethostbynameFlow::flow(source, sink)
   select sl, fc

Exercise 3
~~~~~~~~~~

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   class GetenvSource extends DataFlow::Node {
     GetenvSource() { this.asIndirectExpr(1).(FunctionCall).getTarget().hasGlobalName("getenv") }
   }

Exercise 4
~~~~~~~~~~

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.new.DataFlow

   class GetenvSource extends DataFlow::Node {
     GetenvSource() { this.asIndirectExpr(1).(FunctionCall).getTarget().hasGlobalName("getenv") }
   }

   module GetenvToGethostbynameConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) { source instanceof GetenvSource }

     predicate isSink(DataFlow::Node sink) {
       exists(FunctionCall fc |
         sink.asIndirectExpr(1) = fc.getArgument(0) and
         fc.getTarget().hasName("gethostbyname")
       )
     }
   }

   module GetenvToGethostbynameFlow = DataFlow::Global<GetenvToGethostbynameConfiguration>;

   from
     Expr getenv, FunctionCall fc, DataFlow::Node source, DataFlow::Node sink
   where
     source.asIndirectExpr(1) = getenv and
     sink.asIndirectExpr(1) = fc.getArgument(0) and
     GetenvToGethostbynameFlow::flow(source, sink)
   select getenv, fc

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/conversions-and-classes-in-cpp.rst
.. _conversions-and-classes-in-cpp:

Conversions and classes in C and C++
====================================

You can use the standard CodeQL libraries for C and C++ to detect when the type of an expression is changed.

Conversions
-----------

In C and C++, conversions change the type of an expression. They may be implicit conversions generated by the compiler, or explicit conversions requested by the user.

Let's take a look at the `Conversion <https://codeql.github.com/codeql-standard-libraries/cpp/semmle/code/cpp/exprs/Cast.qll/type.Cast$Conversion.html>`__ class in the standard library:

-  ``Expr``

   -  ``Conversion``

      -  ``Cast``

         -  ``CStyleCast``
         -  ``StaticCast``
         -  ``ConstCastReinterpretCast``
         -  ``DynamicCast``

      -  ``ArrayToPointerConversion``
      -  ``VirtualMemberToFunctionPointerConversion``

Exploring the subexpressions of an assignment
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let us consider the following C code:

.. code-block:: cpp

   typedef signed int myInt;
   int main(int argc, char *argv[])
   {
       unsigned int i;
       i = (myInt)1;
       return 0;
   }

And this simple query:

.. code-block:: ql

   import cpp

   from AssignExpr a
   select a, a.getLValue().getType(), a.getRValue().getType()

The query examines the code for assignments, and tells us the type of their left and right subexpressions. In the example C code above, there is just one assignment. Notably, this assignment has two conversions (of type ``CStyleCast``) on the right side:

#. Explicit cast of the integer ``1`` to a ``myInt``.
#. Implicit conversion generated by the compiler, in preparation for the assignment, converting that expression into an ``unsigned int``.

The query actually reports the result:

.. code-block:: cpp

   ... = ... | unsigned int | int

It is as though the conversions are not there! The reason for this is that ``Conversion`` expressions do not wrap the objects they convert; instead conversions are attached to expressions and can be accessed using ``Expr.getConversion()``. The whole assignment in our example is seen by the standard library classes like this:

.. |arrow| unicode:: U+21b3

| ``AssignExpr, i = (myInt)1`` 
| |arrow| ``VariableAccess, i``
| |arrow|  ``Literal, 1``
|   |arrow|  ``CStyleCast, myInt (explicit)``
|     |arrow|  ``CStyleCast, unsigned int (implicit)``

Accessing parts of the assignment:

-  Left side—access value using ``Assignment.getLValue()``.
-  Right side—access value using ``Assignment.getRValue()``.
-  Conversions of the ``Literal`` on the right side—access both using calls to ``Expr.getConversion()``. As a shortcut, you can use ``Expr.GetFullyConverted()`` to follow all the way to the resulting type, or ``Expr.GetExplicitlyConverted()`` to find the last explicit conversion from an expression.

Using these predicates we can refine our query so that it reports the results that we expected:

.. code-block:: ql

   import cpp

   from AssignExpr a
   select a, a.getLValue().getExplicitlyConverted().getType(), a.getRValue().getExplicitlyConverted().getType()

The result is now:

.. code-block:: cpp

   ... = ... | unsigned int | myInt

We can refine the query further by adding ``Type.getUnderlyingType()`` to resolve the ``typedef``:

.. code-block:: ql

   import cpp

   from AssignExpr a
   select a, a.getLValue().getExplicitlyConverted().getType().getUnderlyingType(), a.getRValue().getExplicitlyConverted().getType().getUnderlyingType()

The result is now:

.. code-block:: cpp

   ... = ... | unsigned int | signed int

If you simply wanted to get the values of all assignments in expressions, regardless of position, you could replace ``Assignment.getLValue()`` and ``Assignment.getRValue()`` with ``Operation.getAnOperand()``:

.. code-block:: ql

   import cpp

   from AssignExpr a
   select a, a.getAnOperand().getExplicitlyConverted().getType()

Unlike the earlier versions of the query, this query would return each side of the expression as a separate result:

.. code-block:: cpp

   ... = ... | unsigned int
   ... = ... | myInt

.. pull-quote::

   Note
   
    In general, predicates named ``getAXxx`` exploit the ability to return multiple results (multiple instances of ``Xxx``) whereas plain ``getXxx`` predicates usually return at most one specific instance of ``Xxx``.

Classes
-------

Next we're going to look at C++ classes, using the following CodeQL classes:

-  ``Type``

   -  ``UserType``—includes classes, typedefs, and enums

      -  ``Class``—a class or struct

         -  ``Struct``—a struct, which is treated as a subtype of ``Class``
         -  ``TemplateClass``—a C++ class template

Finding derived classes
~~~~~~~~~~~~~~~~~~~~~~~

We want to create a query that checks for destructors that should be ``virtual``. Specifically, when a class and a class derived from it both have destructors, the base class destructor should generally be virtual. This ensures that the derived class destructor is always invoked. In the CodeQL library, ``Destructor`` is a subtype of ``MemberFunction``:

-  ``Function``

   -  ``MemberFunction``

      -  ``Constructor``
      -  ``Destructor``

Our starting point for the query is pairs of a base class and a derived class, connected using ``Class.getABaseClass()``:

.. code-block:: ql

   import cpp

   from Class base, Class derived
   where derived.getABaseClass+() = base
   select base, derived, "The second class is derived from the first."

Note that the transitive closure symbol ``+`` indicates that ``Class.getABaseClass()`` may be followed one or more times, rather than only accepting a direct base class.

A lot of the results are uninteresting template parameters. You can remove those results by updating the ``where`` clause as follows:

.. code-block:: ql

   where derived.getABaseClass+() = base
     and not exists(base.getATemplateArgument())
     and not exists(derived.getATemplateArgument())

Finding derived classes with destructors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we can extend the query to find derived classes with destructors, using the ``Class.getDestructor()`` predicate:

.. code-block:: ql

   import cpp

   from Class base, Class derived, Destructor d1, Destructor d2
   where derived.getABaseClass+() = base
     and not exists(base.getATemplateArgument())
     and not exists(derived.getATemplateArgument())
     and d1 = base.getDestructor()
     and d2 = derived.getDestructor()
   select base, derived, "The second class is derived from the first, and both have a destructor."

Notice that getting the destructor implicitly asserts that one exists. As a result, this version of the query returns fewer results than before.

Finding base classes where the destructor is not virtual
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our last change is to use ``Function.isVirtual()`` to find cases where the base destructor is not virtual:

.. code-block:: ql

   import cpp

   from Class base, Destructor d1, Class derived, Destructor d2
   where derived.getABaseClass+() = base
     and d1.getDeclaringType() = base
     and d2.getDeclaringType() = derived
     and not d1.isVirtual()
   select d1, "This destructor should probably be virtual."

That completes the query.

There is a similar standard query `Non-virtual destructor in base class <https://codeql.github.com/codeql-query-help/cpp/cpp-virtual-destructor/>`__ that finds classes in a C/C++ project with virtual functions but no virtual destructor.

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-for-swift.rst
.. _codeql-for-swift:

CodeQL for Swift
================

Experiment and learn how to write effective and efficient queries for CodeQL databases generated from Swift codebases.

.. toctree::
   :hidden:

   basic-query-for-swift-code
   analyzing-data-flow-in-swift

-  :doc:`Basic query for Swift code <basic-query-for-swift-code>`: Learn to write and run a simple CodeQL query.

-  :doc:`Analyzing data flow in Swift <analyzing-data-flow-in-swift>`: You can use CodeQL to track the flow of data through a Swift program to places where the data is used.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-cpp.rst
.. _analyzing-data-flow-in-cpp:

.. pull-quote:: Note

   The data flow library used in this article has been replaced with an improved library which is available from CodeQL 2.12.5 onwards, see :ref:`Analyzing data flow in C and C++ (new) <analyzing-data-flow-in-cpp-new>`. The old library has been deprecated in CodeQL 2.14.1 and will be removed in a later release. With the release of CodeQL 2.13.0 both libraries use the new modular API for data flow.

Analyzing data flow in C and C++
================================

You can use data flow analysis to track the flow of potentially malicious or insecure data that can cause vulnerabilities in your codebase.

About data flow
---------------

Data flow analysis computes the possible values that a variable can hold at various points in a program, determining how those values propagate through the program, and where they are used. In CodeQL, you can model both local data flow and global data flow. For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

Local data flow
---------------

Local data flow is data flow within a single function. Local data flow is usually easier, faster, and more precise than global data flow, and is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

The local data flow library is in the module ``DataFlow``, which defines the class ``Node`` denoting any element that data can flow through. ``Node``\ s are divided into expression nodes (``ExprNode``) and parameter nodes (``ParameterNode``). It is possible to map between data flow nodes and expressions/parameters using the member predicates ``asExpr`` and ``asParameter``:

.. code-block:: ql

   class Node {
     /** Gets the expression corresponding to this node, if any. */
     Expr asExpr() { ... }

     /** Gets the parameter corresponding to this node, if any. */
     Parameter asParameter() { ... }

     ...
   }

or using the predicates ``exprNode`` and ``parameterNode``:

.. code-block:: ql

   /**
    * Gets the node corresponding to expression `e`.
    */
   ExprNode exprNode(Expr e) { ... }

   /**
    * Gets the node corresponding to the value of parameter `p` at function entry.
    */
   ParameterNode parameterNode(Parameter p) { ... }

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``. The predicate can be applied recursively (using the ``+`` and ``*`` operators), or through the predefined recursive predicate ``localFlow``, which is equivalent to ``localFlowStep*``.

For example, finding flow from a parameter ``source`` to an expression ``sink`` in zero or more local steps can be achieved as follows:

.. code-block:: ql

   DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow by including non-value-preserving flow steps. For example:

.. code-block:: cpp

   int i = tainted_user_input();
   some_big_struct *array = malloc(i * sizeof(some_big_struct));

In this case, the argument to ``malloc`` is tainted.

The local taint tracking library is in the module ``TaintTracking``. Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``. The predicate can be applied recursively (using the ``+`` and ``*`` operators), or through the predefined recursive predicate ``localTaint``, which is equivalent to ``localTaintStep*``.

For example, finding taint propagation from a parameter ``source`` to an expression ``sink`` in zero or more local steps can be achieved as follows:

.. code-block:: ql

   TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))

Examples
~~~~~~~~

The following query finds the filename passed to ``fopen``.

.. code-block:: ql

   import cpp

   from Function fopen, FunctionCall fc
   where fopen.hasGlobalName("fopen")
     and fc.getTarget() = fopen
   select fc.getArgument(0)

Unfortunately, this will only give the expression in the argument, not the values which could be passed to it. So we use local data flow to find all expressions that flow into the argument:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.DataFlow

   from Function fopen, FunctionCall fc, Expr src
   where fopen.hasGlobalName("fopen")
     and fc.getTarget() = fopen
     and DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(fc.getArgument(0)))
   select src

Then we can vary the source and, for example, use the parameter of a function. The following query finds where a parameter is used when opening a file:

.. code-block:: ql

   import cpp
   import semmle.code.cpp.dataflow.DataFlow

   from Function fopen, FunctionCall fc, Parameter p
   where fopen.hasGlobalName("fopen")
     and fc.getTarget() = fopen
     and DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(fc.getArgument(0)))
   select p

The following example finds calls to formatting functions where the format string is not hard-coded.

.. code-block:: ql

   import semmle.code.cpp.dataflow.DataFlow
   import semmle.code.cpp.commons.Printf

   from FormattingFunction format, FunctionCall call, Expr formatString
   where call.getTarget() = format
     and call.getArgument(format.getFormatParameterIndex()) = formatString
     and not exists(DataFlow::Node source, DataFlow::Node sink |
       DataFlow::localFlow(source, sink) and
       source.asExpr() instanceof StringLiteral and
       sink.asExpr() = formatString
     )
   select call, "Argument to " + format.getQualifiedName() + " isn't hard-coded."

Exercises
~~~~~~~~~

Exercise 1: Write a query that finds all hard-coded strings used to create a ``host_ent`` via ``gethostbyname``, using local data flow. (`Answer <#exercise-1>`__)

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

The global data flow library is used by implementing the signature ``DataFlow::ConfigSig`` and applying the module ``DataFlow::Global<ConfigSig>`` as follows:

.. code-block:: ql

   import semmle.code.cpp.dataflow.DataFlow

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = DataFlow::Global<MyFlowConfiguration>;


The following predicates are defined in the configuration:

-  ``isSource``—defines where data may flow from
-  ``isSink``—defines where data may flow to
-  ``isBarrier``—optional, restricts the data flow
-  ``isAdditionalFlowStep``—optional, adds additional flow steps

The data flow analysis is performed using the predicate ``flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyFlow::flow(source, sink)
   select source, "Data flow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow as local taint tracking is to local data flow. That is, global taint tracking extends global data flow with additional non-value-preserving steps. The global taint tracking library is used by applying the module ``TaintTracking::Global<ConfigSig>`` to your configuration instead of ``DataFlow::Global<ConfigSig>`` as follows:

.. code-block:: ql

   import semmle.code.cpp.dataflow.TaintTracking

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = TaintTracking::Global<MyFlowConfiguration>;

The resulting module has an identical signature to the one obtained from ``DataFlow::Global<ConfigSig>``.

Examples
~~~~~~~~

The following data flow configuration tracks data flow from environment variables to opening files in a Unix-like environment:

.. code-block:: ql

   import semmle.code.cpp.dataflow.DataFlow

   module EnvironmentToFileConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       exists (Function getenv |
         source.asExpr().(FunctionCall).getTarget() = getenv and
         getenv.hasGlobalName("getenv")
       )
     }

     predicate isSink(DataFlow::Node sink) {
       exists (FunctionCall fc |
         sink.asExpr() = fc.getArgument(0) and
         fc.getTarget().hasGlobalName("fopen")
       )
     }
   }

   module EnvironmentToFileFlow = DataFlow::Global<EnvironmentToFileConfiguration>;

   from Expr getenv, Expr fopen
   where EnvironmentToFileFlow::flow(DataFlow::exprNode(getenv), DataFlow::exprNode(fopen))
   select fopen, "This 'fopen' uses data from $@.",
     getenv, "call to 'getenv'"

The following taint-tracking configuration tracks data from a call to ``ntohl`` to an array index operation. It uses the ``Guards`` library to recognize expressions that have been bounds-checked, and defines ``isBarrier`` to prevent taint from propagating through them. It also uses ``isAdditionalFlowStep`` to add flow from loop bounds to loop indexes.

.. code-block:: ql

  import cpp
  import semmle.code.cpp.controlflow.Guards
  import semmle.code.cpp.dataflow.TaintTracking

  module NetworkToBufferSizeConfiguration implements DataFlow::ConfigSig {
    predicate isSource(DataFlow::Node node) {
      node.asExpr().(FunctionCall).getTarget().hasGlobalName("ntohl")
    }

    predicate isSink(DataFlow::Node node) {
      exists(ArrayExpr ae | node.asExpr() = ae.getArrayOffset())
    }

    predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {
      exists(Loop loop, LoopCounter lc |
        loop = lc.getALoop() and
        loop.getControllingExpr().(RelationalOperation).getGreaterOperand() = pred.asExpr() |
        succ.asExpr() = lc.getVariableAccessInLoop(loop)
      )
    }

    predicate isBarrier(DataFlow::Node node) {
      exists(GuardCondition gc, Variable v |
        gc.getAChild*() = v.getAnAccess() and
        node.asExpr() = v.getAnAccess() and
        gc.controls(node.asExpr().getBasicBlock(), _)
      )
    }
  }

  module NetworkToBufferSizeFlow = TaintTracking::Global<NetworkToBufferSizeConfiguration>;

  from DataFlow::Node ntohl, DataFlow::Node offset
  where NetworkToBufferSizeFlow::flow(ntohl, offset)
  select offset, "This array offset may be influenced by $@.", ntohl,
    "converted data from the network"



Exercises
~~~~~~~~~

Exercise 2: Write a query that finds all hard-coded strings used to create a ``host_ent`` via ``gethostbyname``, using global data flow. (`Answer <#exercise-2>`__)

Exercise 3: Write a class that represents flow sources from ``getenv``. (`Answer <#exercise-3>`__)

Exercise 4: Using the answers from 2 and 3, write a query which finds all global data flows from ``getenv`` to ``gethostbyname``. (`Answer <#exercise-4>`__)

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   import semmle.code.cpp.dataflow.DataFlow

   from StringLiteral sl, FunctionCall fc
   where fc.getTarget().hasName("gethostbyname")
     and DataFlow::localFlow(DataFlow::exprNode(sl), DataFlow::exprNode(fc.getArgument(0)))
   select sl, fc

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   import semmle.code.cpp.dataflow.DataFlow

   module LiteralToGethostbynameConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source.asExpr() instanceof StringLiteral
     }

     predicate isSink(DataFlow::Node sink) {
       exists (FunctionCall fc |
         sink.asExpr() = fc.getArgument(0) and
         fc.getTarget().hasName("gethostbyname"))
     }
   }

   module LiteralToGethostbynameFlow = DataFlow::Global<LiteralToGethostbynameConfiguration>;

   from StringLiteral sl, FunctionCall fc
   where LiteralToGethostbynameFlow::flow(DataFlow::exprNode(sl), DataFlow::exprNode(fc.getArgument(0)))
   select sl, fc

Exercise 3
~~~~~~~~~~

.. code-block:: ql

   import cpp

   class GetenvSource extends FunctionCall {
     GetenvSource() {
       this.getTarget().hasGlobalName("getenv")
     }
   }

Exercise 4
~~~~~~~~~~

.. code-block:: ql

   import semmle.code.cpp.dataflow.DataFlow

   class GetenvSource extends DataFlow::Node {
     GetenvSource() {
       this.asExpr().(FunctionCall).getTarget().hasGlobalName("getenv")
     }
   }

   module GetenvToGethostbynameConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source instanceof GetenvSource
     }

     predicate isSink(DataFlow::Node sink) {
       exists (FunctionCall fc |
         sink.asExpr() = fc.getArgument(0) and
         fc.getTarget().hasName("gethostbyname"))
     }
   }

   module GetenvToGethostbynameFlow = DataFlow::Global<GetenvToGethostbynameConfiguration>;

   from DataFlow::Node getenv, FunctionCall fc
   where GetenvToGethostbynameFlow::flow(getenv, DataFlow::exprNode(fc.getArgument(0)))
   select getenv.asExpr(), fc

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/overflow-prone-comparisons-in-java.rst
.. _overflow-prone-comparisons-in-java:

Overflow-prone comparisons in Java and Kotlin
=============================================

You can use CodeQL to check for comparisons in Java/Kotlin code where one side of the comparison is prone to overflow.

About this article
------------------

In this tutorial article you'll write a query for finding comparisons between integers and long integers in loops that may lead to non-termination due to overflow.

To begin, consider this code snippet:

.. code-block:: java

   void foo(long l) {
       for(int i=0; i<l; i++) {
           // do something
       }
   }

If ``l`` is bigger than 2\ :sup:`31`\ - 1 (the largest positive value of type ``int``), then this loop will never terminate: ``i`` will start at zero, being incremented all the way up to 2\ :sup:`31`\ - 1, which is still smaller than ``l``. When it is incremented once more, an arithmetic overflow occurs, and ``i`` becomes -2\ :sup:`31`\, which also is smaller than ``l``! Eventually, ``i`` will reach zero again, and the cycle repeats.

.. pull-quote::   

   More about overflow

   All primitive numeric types have a maximum value, beyond which they will wrap around to their lowest possible value (called an "overflow"). For ``int``, this maximum value is 2\ :sup:`31`\ - 1. Type ``long`` can accommodate larger values up to a maximum of 2\ :sup:`63`\ - 1. In this example, this means that ``l`` can take on a value that is higher than the maximum for type ``int``; ``i`` will never be able to reach this value, instead overflowing and returning to a low value.

We're going to develop a query that finds code that looks like it might exhibit this kind of behavior. We'll be using several of the standard library classes for representing statements and functions. For a full list, see ":doc:`Abstract syntax tree classes for working with Java programs <abstract-syntax-tree-classes-for-working-with-java-programs>`."

Initial query
-------------

We'll start by writing a query that finds less-than expressions (CodeQL class ``LTExpr``) where the left operand is of type ``int`` and the right operand is of type ``long``:

.. code-block:: ql

   import java

   from LTExpr expr
   where expr.getLeftOperand().getType().hasName("int") and
       expr.getRightOperand().getType().hasName("long")
   select expr

This query usually finds results on most codebases.

Notice that we use the predicate ``getType`` (available on all subclasses of ``Expr``) to determine the type of the operands. Types, in turn, define the ``hasName`` predicate, which allows us to identify the primitive types ``int`` and ``long``. As it stands, this query finds *all* less-than expressions comparing ``int`` and ``long``, but in fact we are only interested in comparisons that are part of a loop condition. Also, we want to filter out comparisons where either operand is constant, since these are less likely to be real bugs. The revised query looks like this:

.. code-block:: ql

   import java

   from LTExpr expr
   where expr.getLeftOperand().getType().hasName("int") and
       expr.getRightOperand().getType().hasName("long") and
       exists(LoopStmt l | l.getCondition().getAChildExpr*() = expr) and
       not expr.getAnOperand().isCompileTimeConstant()
   select expr

Notice that fewer results are found.

The class ``LoopStmt`` is a common superclass of all loops, including, in particular, ``for`` loops as in our example above. While different kinds of loops have different syntax, they all have a loop condition, which can be accessed through predicate ``getCondition``. We use the reflexive transitive closure operator ``*`` applied to the ``getAChildExpr`` predicate to express the requirement that ``expr`` should be nested inside the loop condition. In particular, it can be the loop condition itself.

The final conjunct in the ``where`` clause takes advantage of the fact that :ref:`predicates <predicates>` can return more than one value (they are really relations). In particular, ``getAnOperand`` may return *either* operand of ``expr``, so ``expr.getAnOperand().isCompileTimeConstant()`` holds if at least one of the operands is constant. Negating this condition means that the query will only find expressions where *neither* of the operands is constant.

Generalizing the query
----------------------

Of course, comparisons between ``int`` and ``long`` are not the only problematic case: any less-than comparison between a narrower and a wider type is potentially suspect, and less-than-or-equals, greater-than, and greater-than-or-equals comparisons are just as problematic as less-than comparisons.

In order to compare the ranges of types, we define a predicate that returns the width (in bits) of a given integral type:

.. code-block:: ql

   int width(PrimitiveType pt) {
       (pt.hasName("byte") and result=8) or
       (pt.hasName("short") and result=16) or
       (pt.hasName("char") and result=16) or
       (pt.hasName("int") and result=32) or
       (pt.hasName("long") and result=64)
   }

We now want to generalize our query to apply to any comparison where the width of the type on the smaller end of the comparison is less than the width of the type on the greater end. Let's call such a comparison *overflow prone*, and introduce an abstract class to model it:

.. code-block:: ql

   abstract class OverflowProneComparison extends ComparisonExpr {
       Expr getLesserOperand() { none() }
       Expr getGreaterOperand() { none() }
   }

There are two concrete child classes of this class: one for ``<=`` or ``<`` comparisons, and one for ``>=`` or ``>`` comparisons. In both cases, we implement the constructor in such a way that it only matches the expressions we want:

.. code-block:: ql

   class LTOverflowProneComparison extends OverflowProneComparison {
       LTOverflowProneComparison() {
           (this instanceof LEExpr or this instanceof LTExpr) and
           width(this.getLeftOperand().getType()) < width(this.getRightOperand().getType())
       }
   }

   class GTOverflowProneComparison extends OverflowProneComparison {
       GTOverflowProneComparison() {
           (this instanceof GEExpr or this instanceof GTExpr) and
           width(this.getRightOperand().getType()) < width(this.getLeftOperand().getType())
       }
   }

Now we rewrite our query to make use of these new classes:

.. code-block:: ql

    import java

    // Return the width (in bits) of a given integral type 
    int width(PrimitiveType pt) {
    (pt.hasName("byte") and result=8) or
    (pt.hasName("short") and result=16) or
    (pt.hasName("char") and result=16) or
    (pt.hasName("int") and result=32) or
    (pt.hasName("long") and result=64)
    }

    // Find any comparison where the width of the type on the smaller end of 
    // the comparison is less than the width of the type on the greater end
    abstract class OverflowProneComparison extends ComparisonExpr {
    Expr getLesserOperand() { none() }
    Expr getGreaterOperand() { none() }
    }

    // Return `<=` and `<` comparisons
    class LTOverflowProneComparison extends OverflowProneComparison {
    LTOverflowProneComparison() {
        (this instanceof LEExpr or this instanceof LTExpr) and
        width(this.getLeftOperand().getType()) < width(this.getRightOperand().getType())
    }
    }

    // Return `>=` and `>` comparisons
    class GTOverflowProneComparison extends OverflowProneComparison {
    GTOverflowProneComparison() {
        (this instanceof GEExpr or this instanceof GTExpr) and
        width(this.getRightOperand().getType()) < width(this.getLeftOperand().getType())
    }
    }

    from OverflowProneComparison expr
    where exists(LoopStmt l | l.getCondition().getAChildExpr*() = expr) and
        not expr.getAnOperand().isCompileTimeConstant()
    select expr

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/customizing-library-models-for-ruby.rst
.. _customizing-library-models-for-ruby:


Customizing Library Models for Ruby
===================================

.. include:: ../reusables/beta-note-customizing-library-models.rst

Ruby analysis can be customized by adding library models in data extension files.

A data extension for Ruby is a YAML file of the form:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: <name of extensible predicate>
      data:
        - <tuple1>
        - <tuple2>
        - ...

The CodeQL library for Ruby exposes the following extensible predicates:

- **sourceModel**\(type, path, kind)
- **sinkModel**\(type, path, kind)
- **typeModel**\(type1, type2, path)
- **summaryModel**\(type, path, input, output, kind)

We'll explain how to use these using a few examples, and provide some reference material at the end of this article.

Example: Taint sink in the 'tty-command' gem
--------------------------------------------

In this example, we'll show how to add the following argument, passed to **tty-command**, as a command-line injection sink:

.. code-block:: ruby

  tty = TTY::Command.new
  tty.run(cmd) # <-- add 'cmd' as a taint sink

For this example, you can use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: sinkModel
      data:
        - ["TTY::Command", "Method[run].Argument[0]", "command-injection"]


- Since we're adding a new sink, we add a tuple to the **sinkModel** extensible predicate.
- The first column, **"TTY::Command"**, identifies a set of values from which to begin the search for the sink.
  The string **"TTY::Command""** means we start at the places where the codebase constructs instances of the class **TTY::Command**.
- The second column is an access path that is evaluated from left to right, starting at the values that were identified by the first column.

  - **Method[run]** selects calls to the **run** method of the **TTY::Command** class.
  - **Argument[0]** selects the first argument to calls to that member.

- **command-injection** indicates that this is considered a sink for the command injection query.

Example: Taint sources from 'sinatra' block parameters
------------------------------------------------------

In this example, we'll show how the 'x' parameter below could be marked as a remote flow source:

.. code-block:: ruby

  class MyApp < Sinatra::Base
    get '/' do |x| # <-- add 'x' as a taint source
      # ...
    end
  end

For this example you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: sourceModel
      data:
        - [
            "Sinatra::Base!",
            "Method[get].Argument[block].Parameter[0]",
            "remote",
          ]

- Since we're adding a new taint source, we add a tuple to the **sourceModel** extensible predicate.
- The first column, **"Sinatra::Base!"**, begins the search at references to the **Sinatra::Base** class.
  The **!** suffix indicates that we want to search for references to the class itself, rather than instances of the class.
- **Method[get]** selects calls to the **get** method of the **Sinatra::Base** class.
- **Argument[block]** selects the block argument to the **get** method call.
- **Parameter[0]** selects the first parameter of the block argument (the parameter named **x**).
- Finally, the kind **remote** indicates that this is considered a source of remote flow.

Example: Using types to add MySQL injection sinks
-------------------------------------------------

In this example, we'll show how to add the following SQL injection sink:

.. code-block:: ruby

  def submit(q)
    client = Mysql2::Client.new
    client.query(q) # <-- add 'q' as a SQL injection sink
  end

We can recognize this using the following extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: sinkModel
      data:
        - ["Mysql2::Client", "Method[query].Argument[0]", "sql-injection"]

- The first column, **"Mysql2::Client"**, begins the search at any instance of the **Mysql2::Client** class.
- **Method[query]** selects any call to the **query** method on that instance.
- **Argument[0]** selects the first argument to the method call.
- **sql-injection** indicates that this is considered a sink for the SQL injection query.

Continued example: Using type models
------------------------------------

Consider this variation on the previous example, the mysql2 EventMachine API is used.
The client is obtained via a call to **Mysql2::EM::Client.new**.

.. code-block:: ruby

  def submit(client, q)
    client = Mysql2::EM::Client.new
    client.query(q)
  end

So far we have only one model for **Mysql2::Client**, but in the real world we
may have many models for the various methods available. Because **Mysql2::EM::Client** is a subclass of **Mysql2::Client**, it inherits all of the same methods.
Instead of updating all our models to include both classes, we can add a type
model to indicate that **Mysql2::EM::Client** is a subclass of **Mysql2::Client**:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: typeModel
      data:
        - ["Mysql2::Client", "Mysql2::EM::Client", ""]

Example: Adding flow through 'URI.decode_uri_component'
-------------------------------------------------------

In this example, we'll show how to add flow through calls to 'URI.decode_uri_component':

.. code-block:: ruby

  y = URI.decode_uri_component(x); # add taint flow from 'x' to 'y'

We can model this using the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: summaryModel
      data:
        - [
            "URI!",
            "Method[decode_uri_component]",
            "Argument[0]",
            "ReturnValue",
            "taint",
          ]


- Since we're adding flow through a method call, we add a tuple to the **summaryModel** extensible predicate.
- The first column, **"URI!"**, begins the search for relevant calls at references to the **URI** class.
- The **!** suffix indicates that we are looking for the class itself, rather than instances of the class.
- The second column, **Method[decode_uri_component]**, is a path leading to the method calls we wish to model.
  In this case, we select references to the **decode_uri_component** method from the **URI** class.
- The third column, **Argument[0]**, indicates the input of the flow. In this case, the first argument to the method call.
- The fourth column, **ReturnValue**, indicates the output of the flow. In this case, the return value of the method call.
- The last column, **taint**, indicates the kind of flow to add. The value **taint** means the output is not necessarily equal
  to the input, but was derived from the input in a taint-preserving way.

Example: Adding flow through 'File#each'
----------------------------------------

In this example, we'll show how to add flow through calls to **File#each** from the standard library, which iterates over the lines of a file:

.. code-block:: ruby

  f = File.new("example.txt")
  f.each { |line| ... } # add taint flow from `f` to `line`

We can model this using the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: summaryModel
      data:
        - [
            "File",
            "Method[each]",
            "Argument[self]",
            "Argument[block].Parameter[0]",
            "taint",
          ]


- Since we're adding flow through a method call, we add a tuple to the **summaryModel** extensible predicate.
- The first column, **"File"**, begins the search for relevant calls at places where the **File** class is used.
- The second column, **Method[each]**, selects references to the **each** method on the **File** class.
- The third column specifies the input of the flow. **Argument[self]** selects the **self** argument of **each**, which is the **File** instance being iterated over.

- The fourth column specifies the output of the flow:

  - **Argument[block]** selects the block argument of **each** (the block which is executed for each line in the file).
  - **Parameter[0]** selects the first parameter of the block (the parameter named **line**).

- The last column, **taint**, indicates the kind of flow to add.

Reference material
------------------

The following sections provide reference material for extensible predicates, access paths, types, and kinds.

Extensible predicates
---------------------

sourceModel(type, path, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new taint source. Most taint-tracking queries will use the new source.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to the source.
- **kind**: Kind of source to add. Currently only **remote** is used.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: sourceModel
      data:
        - ["User", "Method[name]", "remote"]

sinkModel(type, path, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new taint sink. Sinks are query-specific and will typically affect one or two queries.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to the sink.
- **kind**: Kind of sink to add. See the section on sink kinds for a list of supported kinds.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: sinkModel
      data:
        - ["ExecuteShell", "Method[run].Argument[0]", "command-injection"]

summaryModel(type, path, input, output, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds flow through a method call.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to a method call.
- **input**: Path relative to the method call that leads to input of the flow.
- **output**: Path relative to the method call leading to the output of the flow.
- **kind**: Kind of summary to add. Can be **taint** for taint-propagating flow, or **value** for value-preserving flow.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/ruby-all
        extensible: summaryModel
      data:
        - [
            "URI",
            "Method[decode_uri_component]",
            "Argument[0]",
            "ReturnValue",
            "taint",
          ]

typeModel(type1, type2, path)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new definition of a type.

- **type1**: Name of the type to define.
- **type2**: Name of the type from which to evaluate **path**.
- **path**: Access path leading from **type2** to **type1**.

Example:

.. code-block:: yaml

  extensions:
  - addsTo:
      pack: codeql/ruby-all
      extensible: typeModel
    data:
      - [
          "Mysql2::Client",
          "MyDbWrapper",
          "Method[getConnection].ReturnValue",
        ]

Types
-----

A type is a string that identifies a set of values.
In each of the extensible predicates mentioned in previous section, the first column is always the name of a type.
A type can be defined by adding **typeModel** tuples for that type.

Access paths
------------

The **path**, **input**, and **output** columns consist of a **.**-separated list of components, which is evaluated from left to right,
with each step selecting a new set of values derived from the previous set of values.

The following components are supported:

- **Argument[**\ `number`\ **]** selects the argument at the given index.
- **Argument[**\ `string`:\ **]** selects the keyword argument with the given name.
- **Argument[self]** selects the receiver of a method call.
- **Argument[block]** selects the block argument.
- **Argument[any]** selects any argument, except self or block arguments.
- **Argument[any-named]** selects any keyword argument.
- **Argument[hash-splat]** selects a special argument representing all keyword arguments passed in the method call.
- **Parameter[**\ `number`\ **]** selects the argument at the given index.
- **Parameter[**\ `string`:\ **]** selects the keyword argument with the given name.
- **Parameter[self]** selects the **self** parameter of a method.
- **Parameter[block]** selects the block parameter.
- **Parameter[any]** selects any parameter, except self or block parameters.
- **Parameter[any-named]** selects any keyword parameter.
- **Parameter[hash-splat]** selects the hash splat parameter, often written as **\*\*kwargs**.
- **ReturnValue** selects the return value of a call.
- **Method[**\ `name`\ **]** selects a call to the method with the given name.
- **Element[any]** selects any element of an array or hash.
- **Element[**\ `number`\ **]** selects an array element at the given index.
- **Element[**\ `string`\ **]** selects a hash element at the given key.
- **Field[@**\ `string`\ **]** selects an instance variable with the given name.
- **Fuzzy** selects all values that are derived from the current value through a combination of the other operations described in this list.
  For example, this can be used to find all values that appear to originate from a particular class. This can be useful for finding method calls
  from a known class, but where the receiver type is not known or is difficult to model.

Additional notes about the syntax of operands:

- Multiple operands may be given to a single component, as a shorthand for the union of the operands. For example, **Method[foo,bar]** matches the union of **Method[foo]** and **Method[bar]**.
- Numeric operands to **Argument**, **Parameter**, and **Element** may be given as a lower bound. For example, **Argument[1..]** matches all arguments except 0.

Kinds
-----

Source kinds
~~~~~~~~~~~~

- **remote**: A generic source of remote flow. Most taint-tracking queries will use such a source. Currently this is the only supported source kind.

Sink kinds
~~~~~~~~~~

Unlike sources, sinks tend to be highly query-specific, rarely affecting more than one or two queries.
Not every query supports customizable sinks. If the following sinks are not suitable for your use case, you should add a new query.

- **code-injection**: A sink that can be used to inject code, such as in calls to **eval**.
- **command-injection**: A sink that can be used to inject shell commands, such as in calls to **Process.spawn**.
- **path-injection**: A sink that can be used for path injection in a file system access, such as in calls to **File.open**.
- **sql-injection**: A sink that can be used for SQL injection, such as in an ActiveRecord **where** call.
- **url-redirection**: A sink that can be used to redirect the user to a malicious URL.
- **log-injection**: A sink that can be used for log injection, such as in a **Rails.logger** call.

Summary kinds
~~~~~~~~~~~~~

- **taint**: A summary that propagates taint. This means the output is not necessarily equal to the input, but it was derived from the input in an unrestrictive way. An attacker who controls the input will have significant control over the output as well.
- **value**: A summary that preserves the value of the input or creates a copy of the input such that all of its object properties are preserved.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/customizing-library-models-for-java-and-kotlin.rst
.. _customizing-library-models-for-java-and-kotlin:

Customizing library models for Java and Kotlin
==============================================

You can model the methods and callables that control data flow in any framework or library. This is especially useful for custom frameworks or niche libraries, that are not supported by the standard CodeQL libraries.

.. include:: ../reusables/beta-note-customizing-library-models.rst

About this article
------------------

This article contains reference material about how to define custom models for sources, sinks and flow summaries for Java dependencies in data extension files.

The best way to create your own models is using the CodeQL model editor in the CodeQL extension for Visual Studio Code. The model editor automatically guides you through the process of defining models, displaying the properties you need to define and the options available. You can save the resulting models as data extension files in CodeQL model packs and use them without worrying about the syntax.

For more information, see `Using the CodeQL model editor  <https://docs.github.com/en/code-security/codeql-for-vs-code/using-the-advanced-functionality-of-the-codeql-for-vs-code-extension/using-the-codeql-model-editor>`__ in the GitHub documentation.


About data extensions
---------------------

You can customize analysis by defining models (summaries, sinks, and sources) of your code's dependencies in data extension files. Each model defines the behavior of one or more elements of your library or framework, such as methods and callables. When you run dataflow analysis, these models expand the potential sources and sinks tracked by dataflow analysis and improve the precision of results.

Most of the security queries search for paths from a source of untrusted input to a sink that represents a vulnerability. This is known as taint tracking. Each source is a starting point for dataflow analysis to track tainted data and each sink is an end point.

Taint tracking queries also need to know how data can flow through elements that are not included in the source code. These are modeled as summaries. A summary model enables queries to synthesize the flow behavior through elements in dependency code that is not stored in your repository.

Syntax used to define an element in an extension file
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Each model of an element is defined using a data extension where each tuple constitutes a model.
A data extension file to extend the standard Java queries included with CodeQL is a YAML file with the form:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/java-all
         extensible: <name of extensible predicate>
       data:
         - <tuple1>
         - <tuple2>
         - ...

Each YAML file may contain one or more top-level extensions.

- ``addsTo`` defines the CodeQL pack name and extensible predicate that the extension is injected into.
- ``data`` defines one or more rows of tuples that are injected as values into the extensible predicate. The number of columns and their types must match the definition of the extensible predicate.

Data extensions use union semantics, which means that the tuples of all extensions for a single extensible predicate are combined, duplicates are removed, and all of the remaining tuples are queryable by referencing the extensible predicate.

Publish data extension files in a CodeQL model pack to share
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can group one or more data extension files into a CodeQL model pack and publish it to the GitHub Container Registry. This makes it easy for anyone to download the model pack and use it to extend their analysis. For more information, see `Creating a CodeQL model pack <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack>`__ and `Publishing and using CodeQL packs <https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/publishing-and-using-codeql-packs/>`__ in the CodeQL CLI documentation.

Extensible predicates used to create custom models in Java and Kotlin
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The CodeQL library for Java and Kotlin analysis exposes the following extensible predicates:

- ``sourceModel(package, type, subtypes, name, signature, ext, output, kind, provenance)``. This is used to model sources of potentially tainted data. The ``kind`` of the sources defined using this predicate determine which threat model they are associated with. Different threat models can be used to customize the sources used in an analysis. For more information, see ":ref:`Threat models <threat-models-java>`."
- ``sinkModel(package, type, subtypes, name, signature, ext, input, kind, provenance)``. This is used to model sinks where tainted data maybe used in a way that makes the code vulnerable.
- ``summaryModel(package, type, subtypes, name, signature, ext, input, output, kind, provenance)``. This is used to model flow through elements.
- ``neutralModel(package, type, name, signature, kind, provenance)``. This is similar to a summary model but used to model the flow of values that have only a minor impact on the dataflow analysis. Manual neutral models (those with a provenance such as ``manual`` or ``ai-manual``) override generated summary models (those with a provenance such as ``df-generated``) so that the summary will be ignored. Other than that, neutral models have a slight impact on the dataflow dispatch logic, which is out of scope for this documentation.

The extensible predicates are populated using the models defined in data extension files.

Examples of custom model definitions
------------------------------------

The examples in this section are taken from the standard CodeQL Java query pack published by GitHub. They demonstrate how to add tuples to extend extensible predicates that are used by the standard queries.

Example: Taint sink in the ``java.sql`` package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This example shows how the Java query pack models the argument of the ``execute`` method as a SQL injection sink.
This is the ``execute`` method in the ``Statement`` class, which is located in the ``java.sql`` package.

.. code-block:: java

   public static void taintsink(Connection conn, String query) throws SQLException {
       Statement stmt = conn.createStatement();
       stmt.execute(query); // The argument to this method is a SQL injection sink.
   }

We need to add a tuple to the ``sinkModel``\(package, type, subtypes, name, signature, ext, input, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/java-all
         extensible: sinkModel
       data:
         - ["java.sql", "Statement", True, "execute", "(String)", "", "Argument[0]", "sql-injection", "manual"]


Since we want to add a new sink, we need to add a tuple to the ``sinkModel`` extensible predicate.
The first five values identify the callable (in this case a method) to be modeled as a sink.

- The first value ``java.sql`` is the package name.
- The second value ``Statement`` is the name of the class (type) that contains the method.
- The third value ``True`` is a flag that indicates whether or not the sink also applies to all overrides of the method.
- The fourth value ``execute`` is the method name.
- The fifth value ``(String)`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the sink.

- The seventh value ``Argument[0]`` is the ``access path`` to the first argument passed to the method, which means that this is the location of the sink.
- The eighth value ``sql-injection`` is the kind of the sink. The sink kind is used to define the queries where the sink is in scope. In this case - the SQL injection queries.
- The ninth value ``manual`` is the provenance of the sink, which is used to identify the origin of the sink.

Example: Taint source from the ``java.net`` package
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the Java query pack models the return value from the ``getInputStream`` method as a ``remote`` source.
This is the ``getInputStream`` method in the ``Socket`` class, which is located in the ``java.net`` package.

.. code-block:: java

   public static void tainted(Socket socket) throws IOException {
       InputStream stream = socket.getInputStream(); // The return value of this method is a remote source of taint.
       ...
   }

We need to add a tuple to the ``sourceModel``\(package, type, subtypes, name, signature, ext, output, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/java-all
         extensible: sourceModel
       data:
         - ["java.net", "Socket", False, "getInputStream", "()", "", "ReturnValue", "remote", "manual"]


Since we are adding a new source, we need to add a tuple to the ``sourceModel`` extensible predicate.
The first five values identify the callable (in this case a method) to be modeled as a source.

- The first value ``java.net`` is the package name.
- The second value ``Socket`` is the name of the class (type) that contains the source.
- The third value ``False`` is a flag that indicates whether or not the source also applies to all overrides of the method.
- The fourth value ``getInputStream`` is the method name.
- The fifth value ``()`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the source.

- The seventh value ``ReturnValue`` is the access path to the return of the method, which means that it is the return value that should be considered a source of tainted input.
- The eighth value ``remote`` is the kind of the source. The source kind is used to define the threat model where the source is in scope. ``remote`` applies to many of the security related queries as it means a remote source of untrusted data. As an example the SQL injection query uses ``remote`` sources. For more information, see ":ref:`Threat models <threat-models-java>`."
- The ninth value ``manual`` is the provenance of the source, which is used to identify the origin of the source.

Example: Add flow through the ``concat`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the Java query pack models flow through a method for a simple case.
This pattern covers many of the cases where we need to summarize flow through a method that is stored in a library or framework outside the repository.

.. code-block:: java

   public static void taintflow(String s1, String s2) {
       String t = s1.concat(s2); // There is taint flow from s1 and s2 to t.
       ...
   }

We need to add tuples to the ``summaryModel``\(package, type, subtypes, name, signature, ext, input, output, kind, provenance) extensible predicate by updating a data extension file:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/java-all
         extensible: summaryModel
       data:
         - ["java.lang", "String", False, "concat", "(String)", "", "Argument[this]", "ReturnValue", "taint", "manual"]
         - ["java.lang", "String", False, "concat", "(String)", "", "Argument[0]", "ReturnValue", "taint", "manual"]

Since we are adding flow through a method, we need to add tuples to the ``summaryModel`` extensible predicate.
Each tuple defines flow from one argument to the return value.
The first row defines flow from the qualifier (``s1`` in the example) to the return value (``t`` in the example) and the second row defines flow from the first argument (``s2`` in the example) to the return value (``t`` in the example).

The first five values identify the callable (in this case a method) to be modeled as a summary.
These are the same for both of the rows above as we are adding two summaries for the same method.

- The first value ``java.lang`` is the package name.
- The second value ``String`` is the class (type) name.
- The third value ``False`` is a flag that indicates whether or not the summary also applies to all overrides of the method.
- The fourth value ``concat`` is the method name.
- The fifth value ``(String)`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the summary.

- The seventh value is the access path to the input (where data flows from). ``Argument[this]`` is the access path to the qualifier (``s1`` in the example) and ``Argument[0]`` is the access path to the first argument (``s2`` in the example).
- The eighth value ``ReturnValue`` is the access path to the output (where data flows to), in this case ``ReturnValue``, which means that the input flows to the return value.
- The ninth value ``taint`` is the kind of the flow. ``taint`` means that taint is propagated through the call.
- The tenth value ``manual`` is the provenance of the summary, which is used to identify the origin of the summary.

Example: Add flow through the ``map`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the Java query pack models a more complex flow through a method.
Here we model flow through higher order methods and collection types.

.. code-block:: java

   public static void taintflow(Stream<String> s) {
     Stream<String> l = s.map(e -> e.concat("\n"));
     ...
   }

We need to add tuples to the ``summaryModel``\(package, type, subtypes, name, signature, ext, input, output, kind, provenance) extensible predicate by updating a data extension file:

.. code-block:: yaml

   extensions:
     - addsTo:
         pack: codeql/java-all
         extensible: summaryModel
       data:
         - ["java.util.stream", "Stream", True, "map", "(Function)", "", "Argument[this].Element", "Argument[0].Parameter[0]", "value", "manual"]
         - ["java.util.stream", "Stream", True, "map", "(Function)", "", "Argument[0].ReturnValue", "ReturnValue.Element", "value", "manual"]


Since we are adding flow through a method, we need to add tuples to the ``summaryModel`` extensible predicate.
Each tuple defines part of the flow that comprises the total flow through the ``map`` method.
The first five values identify the callable (in this case a method) to be modeled as a summary.
These are the same for both of the rows above as we are adding two summaries for the same method.

- The first value ``java.util.stream`` is the package name.
- The second value ``Stream`` is the class (type) name.
- The third value ``True`` is a flag that indicates whether or not the summary also applies to all overrides of the method.
- The fourth value ``map`` is the method name.
- The fifth value ``Function`` is the method input type signature.

The sixth value should be left empty and is out of scope for this documentation.
The remaining values are used to define the ``access path``, the ``kind``, and the ``provenance`` (origin) of the summary definition.

- The seventh value is the access path to the ``input`` (where data flows from).
- The eighth value is the access path to the ``output`` (where data flows to).

For the first row:

- The seventh value is ``Argument[this].Element``, which is the access path to the elements of the qualifier (the elements of the stream ``s`` in the example).
- The eight value is ``Argument[0].Parameter[0]``, which is the access path to the first parameter of the ``Function`` argument of ``map`` (the lambda parameter ``e`` in the example).

For the second row:

- The seventh value is ``Argument[0].ReturnValue``, which is the access path to the return value of the ``Function`` argument of ``map`` (the return value of the lambda in the example).
- The eighth value is ``ReturnValue.Element``, which is the access path to the elements of the return value of ``map`` (the elements of the stream ``l`` in the example).

For the remaining values for both rows:

- The ninth value ``value`` is the kind of the flow. ``value`` means that the value is preserved.
- The tenth value ``manual`` is the provenance of the summary, which is used to identify the origin of the summary.

That is, the first row specifies that values can flow from the elements of the qualifier stream into the first argument of the function provided to ``map``.  The second row specifies that values can flow from the return value of the function to the elements of the stream returned from ``map``.

Example: Add a ``neutral`` method
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
This example shows how the Java query pack models the ``now`` method as being neutral with respect to flow.
A neutral model is used to define that there is no flow through a method.

.. code-block:: java

   public static void taintflow() {
       Instant t = Instant.now(); // There is no flow from now to t.
       ...
   }

We need to add a tuple to the ``neutralModel``\(package, type, name, signature, kind, provenance) extensible predicate by updating a data extension file.

.. code-block:: yaml

   extensions:
   - addsTo:
       pack: codeql/java-all
       extensible: neutralModel
     data:
       - ["java.time", "Instant", "now", "()", "summary", "manual"]


Since we are adding a neutral model, we need to add tuples to the ``neutralModel`` extensible predicate.
The first four values identify the callable (in this case a method) to be modeled as a neutral, the fifth value is the kind, and the sixth value is the provenance (origin) of the neutral.

- The first value ``java.time`` is the package name.
- The second value ``Instant`` is the class (type) name.
- The third value ``now`` is the method name.
- The fourth value ``()`` is the method input type signature.
- The fifth value ``summary`` is the kind of the neutral.
- The sixth value ``manual`` is the provenance of the neutral.

.. _threat-models-java:

Threat models
-------------

.. include:: ../reusables/threat-model-description.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-csharp.rst
.. _analyzing-data-flow-in-csharp:

Analyzing data flow in C#
=========================

You can use CodeQL to track the flow of data through a C# program to its use.

About this article
------------------

This article describes how data flow analysis is implemented in the CodeQL libraries for C# and includes examples to help you write your own data flow queries.
The following sections describe how to use the libraries for local data flow, global data flow, and taint tracking.
For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

.. include:: ../reusables/new-data-flow-api.rst

Local data flow
---------------

Local data flow is data flow within a single method or callable. Local data flow is easier, faster, and more precise than global data flow, and is sufficient for many queries.

Using local data flow
~~~~~~~~~~~~~~~~~~~~~

The local data flow library is in the module ``DataFlow``, which defines the class ``Node`` denoting any element that data can flow through. ``Node``\ s are divided into expression nodes (``ExprNode``) and parameter nodes (``ParameterNode``). You can map between data flow nodes and expressions/parameters using the member predicates ``asExpr`` and ``asParameter``:

.. code-block:: ql

     class Node {
       /** Gets the expression corresponding to this node, if any. */
       Expr asExpr() { ... }

       /** Gets the parameter corresponding to this node, if any. */
       Parameter asParameter() { ... }

      ...
     }

or using the predicates ``exprNode`` and ``parameterNode``:

.. code-block:: ql

     /**
      * Gets the node corresponding to expression `e`.
      */
     ExprNode exprNode(Expr e) { ... }

     /**
      * Gets the node corresponding to the value of parameter `p` at function entry.
      */
     ParameterNode parameterNode(Parameter p) { ... }

The predicate ``localFlowStep(Node nodeFrom, Node nodeTo)`` holds if there is an immediate data flow edge from the node ``nodeFrom`` to the node ``nodeTo``. You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localFlow``.

For example, you can find flow from a parameter ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))

Using local taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~

Local taint tracking extends local data flow by including non-value-preserving flow steps. For example:

.. code-block:: csharp

     var temp = x;
     var y = temp + ", " + temp;

If ``x`` is a tainted string then ``y`` is also tainted.

The local taint tracking library is in the module ``TaintTracking``. Like local data flow, a predicate ``localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)`` holds if there is an immediate taint propagation edge from the node ``nodeFrom`` to the node ``nodeTo``. You can apply the predicate recursively, by using the ``+`` and ``*`` operators, or you can use the predefined recursive predicate ``localTaint``.

For example, you can find taint propagation from a parameter ``source`` to an expression ``sink`` in zero or more local steps:

.. code-block:: ql

     TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))

Examples
~~~~~~~~

This query finds the filename passed to ``System.IO.File.Open``:

.. code-block:: ql

   import csharp

   from Method fileOpen, MethodCall call
   where fileOpen.hasQualifiedName("System.IO.File.Open")
     and call.getTarget() = fileOpen
   select call.getArgument(0)

Unfortunately this will only give the expression in the argument, not the values which could be passed to it. So we use local data flow to find all expressions that flow into the argument:

.. code-block:: ql

   import csharp

   from Method fileOpen, MethodCall call, Expr src
   where fileOpen.hasQualifiedName("System.IO.File.Open")
     and call.getTarget() = fileOpen
     and DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(0)))
   select src

Then we can make the source more specific, for example an access to a public parameter. This query finds instances where a public parameter is used to open a file:

.. code-block:: ql

   import csharp

   from Method fileOpen, MethodCall call, Parameter p
   where fileOpen.hasQualifiedName("System.IO.File.Open")
     and call.getTarget() = fileOpen
     and DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(call.getArgument(0)))
     and call.getEnclosingCallable().(Member).isPublic()
   select p, "Opening a file from a public method."

This query finds calls to ``String.Format`` where the format string isn't hard-coded:

.. code-block:: ql

   import csharp

   from Method format, MethodCall call, Expr formatString
   where format.hasQualifiedName("System.String.Format")
     and call.getTarget() = format
     and formatString = call.getArgument(0)
     and formatString.getType() instanceof StringType
     and not exists(StringLiteral source | DataFlow::localFlow(DataFlow::exprNode(source), DataFlow::exprNode(formatString)))
   select call, "Argument to 'string.Format' isn't hard-coded."

Exercises
~~~~~~~~~

Exercise 1: Write a query that finds all hard-coded strings used to create a ``System.Uri``, using local data flow. (`Answer <#exercise-1>`__)

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise than local data flow, and the analysis typically requires significantly more time and memory to perform.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

The global data flow library is used by implementing the signature ``DataFlow::ConfigSig`` and applying the module ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import csharp

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = DataFlow::Global<MyFlowConfiguration>;

These predicates are defined in the configuration:

-  ``isSource`` - defines where data may flow from.
-  ``isSink`` - defines where data may flow to.
-  ``isBarrier`` - optionally, restricts the data flow.
-  ``isAdditionalFlowStep`` - optionally, adds additional flow steps.

The data flow analysis is performed using the predicate ``flow(DataFlow::Node source, DataFlow::Node sink)``:

.. code-block:: ql

   from DataFlow::Node source, DataFlow::Node sink
   where MyFlow::flow(source, sink)
   select source, "Dataflow to $@.", sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking is to global data flow what local taint tracking is to local data flow. That is, global taint tracking extends global data flow with additional non-value-preserving steps. The global taint tracking library is used by applying the module ``TaintTracking::Global<ConfigSig>`` to your configuration instead of ``DataFlow::Global<ConfigSig>``:

.. code-block:: ql

   import csharp

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       ...
     }

     predicate isSink(DataFlow::Node sink) {
       ...
     }
   }

   module MyFlow = TaintTracking::Global<MyFlowConfiguration>;

The resulting module has an identical signature to the one obtained from ``DataFlow::Global<ConfigSig>``.

Flow sources
~~~~~~~~~~~~

The data flow library contains some predefined flow sources. The class ``PublicCallableParameterFlowSource`` (defined in module ``semmle.code.csharp.dataflow.flowsources.PublicCallableParameter``) represents data flow from public parameters, which is useful for finding security problems in a public API.

The class ``RemoteFlowSource`` (defined in module ``semmle.code.csharp.dataflow.flowsources.Remote``) represents data flow from remote network inputs. This is useful for finding security problems in networked services.

Example
~~~~~~~

This query shows a data flow configuration that uses all public API parameters as data sources:

.. code-block:: ql

   import csharp
   import semmle.code.csharp.dataflow.flowsources.PublicCallableParameter

   module MyFlowConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       source instanceof PublicCallableParameterFlowSource
     }

     ...
   }

Class hierarchy
~~~~~~~~~~~~~~~

-  ``DataFlow::Node`` - an element behaving as a data flow node.

   -  ``DataFlow::ExprNode`` - an expression behaving as a data flow node.
   -  ``DataFlow::ParameterNode`` - a parameter data flow node representing the value of a parameter at function entry.

      -  ``PublicCallableParameter`` - a parameter to a public method/callable in a public class.

   -  ``RemoteFlowSource`` - data flow from network/remote input.

      -  ``AspNetRemoteFlowSource`` - data flow from remote ASP.NET user input.

         -  ``AspNetQueryStringRemoteFlowSource`` - data flow from ``System.Web.HttpRequest``.
         -  ``AspNetUserInputRemoveFlowSource`` - data flow from ``System.Web.IO.WebControls.TextBox``.

      -  ``WcfRemoteFlowSource`` - data flow from a WCF web service.
      -  ``AspNetServiceRemoteFlowSource`` - data flow from an ASP.NET web service.

Examples
~~~~~~~~

This data flow configuration tracks data flow from environment variables to opening files:

.. code-block:: ql

   import csharp

   module EnvironmentToFileConfiguration implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
       exists(Method m |
         m = source.asExpr().(MethodCall).getTarget() and
         m.hasQualifiedName("System.Environment.GetEnvironmentVariable")
       )
     }

     predicate isSink(DataFlow::Node sink) {
       exists(MethodCall mc |
         mc.getTarget().hasQualifiedName("System.IO.File.Open") and
         sink.asExpr() = mc.getArgument(0)
       )
     }
   }

   module EnvironmentToFileFlow = DataFlow::Global<EnvironmentToFileConfiguration>;

   from Expr environment, Expr fileOpen
   where EnvironmentToFileFlow::flow(DataFlow::exprNode(environment), DataFlow::exprNode(fileOpen))
   select fileOpen, "This 'File.Open' uses data from $@.",
     environment, "call to 'GetEnvironmentVariable'"

Exercises
~~~~~~~~~

Exercise 2: Find all hard-coded strings passed to ``System.Uri``, using global data flow. (`Answer <#exercise-2>`__)

Exercise 3: Define a class that represents flow sources from ``System.Environment.GetEnvironmentVariable``. (`Answer <#exercise-3>`__)

Exercise 4: Using the answers from 2 and 3, write a query to find all global data flow from ``System.Environment.GetEnvironmentVariable`` to ``System.Uri``. (`Answer <#exercise-4>`__)

Extending library data flow
---------------------------

Library data flow defines how data flows through libraries where the source code is not available, such as the .NET Framework, third-party libraries or proprietary libraries.

To define new library data flow, extend the class ``LibraryTypeDataFlow`` from the module ``semmle.code.csharp.dataflow.LibraryTypeDataFlow``. Override the predicate ``callableFlow`` to define how data flows through the methods in the class. ``callableFlow`` has the signature

.. code-block:: ql

   predicate callableFlow(CallableFlowSource source, CallableFlowSink sink, SourceDeclarationCallable callable, boolean preservesValue)

-  ``callable`` - the ``Callable`` (such as a method, constructor, property getter or setter) performing the data flow.
-  ``source`` - the data flow input.
-  ``sink`` - the data flow output.
-  ``preservesValue`` - whether the flow step preserves the value, for example if ``x`` is a string then ``x.ToString()`` preserves the value where as ``x.ToLower()`` does not.

Class hierarchy
~~~~~~~~~~~~~~~

-  ``Callable`` - a callable (methods, accessors, constructors etc.)

   -  ``SourceDeclarationCallable`` - an unconstructed callable.

-  ``CallableFlowSource`` - the input of data flow into the callable.

   -  ``CallableFlowSourceQualifier`` - the data flow comes from the object itself.
   -  ``CallableFlowSourceArg`` - the data flow comes from an argument to the call.

-  ``CallableFlowSink`` - the output of data flow from the callable.

   -  ``CallableFlowSinkQualifier`` - the output is to the object itself.
   -  ``CallableFlowSinkReturn`` - the output is returned from the call.
   -  ``CallableFlowSinkArg`` - the output is an argument.
   -  ``CallableFlowSinkDelegateArg`` - the output flows through a delegate argument (for example, LINQ).

Example
~~~~~~~

This example is adapted from ``LibraryTypeDataFlow.qll``. It declares data flow through the class ``System.Uri``, including the constructor, the ``ToString`` method, and the properties ``Query``, ``OriginalString``, and ``PathAndQuery``.

.. code-block:: ql

   import semmle.code.csharp.dataflow.LibraryTypeDataFlow
   import semmle.code.csharp.frameworks.System

   class SystemUriFlow extends LibraryTypeDataFlow, SystemUriClass {
     override predicate callableFlow(CallableFlowSource source, CallableFlowSink sink, SourceDeclarationCallable c, boolean preservesValue) {
       (
         constructorFlow(source, c) and
         sink instanceof CallableFlowSinkQualifier
         or
         methodFlow(c) and
         source instanceof CallableFlowSourceQualifier and
         sink instanceof CallableFlowSinkReturn
         or
         exists(Property p |
           propertyFlow(p) and
           source instanceof CallableFlowSourceQualifier and
           sink instanceof CallableFlowSinkReturn and
           c = p.getGetter()
         )
       )
       and
       preservesValue = false
     }

     private predicate constructorFlow(CallableFlowSourceArg source, Constructor c) {
       c = getAMember()
       and
       c.getParameter(0).getType() instanceof StringType
       and
       source.getArgumentIndex() = 0
     }

     private predicate methodFlow(Method m) {
       m.getDeclaringType() = getABaseType*()
       and
       m = getSystemObjectClass().getToStringMethod().getAnOverrider*()
     }

     private predicate propertyFlow(Property p) {
       p = getPathAndQueryProperty()
       or
       p = getQueryProperty()
       or
       p = getOriginalStringProperty()
     }
   }

This defines a new class ``SystemUriFlow`` which extends ``LibraryTypeDataFlow`` to add another case. It extends ``SystemUriClass`` (the class representing ``System.Uri``, defined in the module ``semmle.code.csharp.frameworks.System``) to access methods such as ``getQueryProperty``.

The predicate ``callableFlow`` declares data flow through ``System.Uri``. The first case (``constructorFlow``) declares data flow from the first argument of the constructor to the object itself (``CallableFlowSinkQualifier``).

The second case declares data flow from the object (``CallableFlowSourceQualifier``) to the result of calling ``ToString`` on the object (``CallableFlowSinkReturn``).

The third case declares data flow from the object (``CallableFlowSourceQualifier``) to the return (``CallableFlowSinkReturn``) of the getters for the properties ``PathAndQuery``, ``Query`` and ``OriginalString``. Note that the properties (``getPathAndQueryProperty``, ``getQueryProperty`` and ``getOriginalStringProperty``) are inherited from the class ``SystemUriClass``.

In all three cases ``preservesValue = false``, which means that these steps will only be included in taint tracking, not in (normal) data flow.

Exercises
~~~~~~~~~

Exercise 5: In ``System.Uri``, what other properties could expose data? How could they be added to ``SystemUriFlow``? (`Answer <#exercise-5>`__)

Exercise 6: Implement the data flow for the class ``System.Exception``. (`Answer <#exercise-6>`__)

--------------

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

   import csharp

   from Expr src, Call c
   where DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(c.getArgument(0)))
     and c.getTarget().(Constructor).getDeclaringType().hasQualifiedName("System.Uri")
     and src.hasValue()
   select src, "This string constructs 'System.Uri' $@.", c, "here"

Exercise 2
~~~~~~~~~~

.. code-block:: ql

   import csharp

   module StringToUriConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node src) {
       src.asExpr().hasValue()
     }

     predicate isSink(DataFlow::Node sink) {
       exists(Call c | c.getTarget().(Constructor).getDeclaringType().hasQualifiedName("System.Uri")
       and sink.asExpr()=c.getArgument(0))
     }
   }

   module StringToUriFlow = DataFlow::Global<StringToUriConfig>;

   from DataFlow::Node src, DataFlow::Node sink
   where StringToUriFlow::flow(src, sink)
   select src, "This string constructs a 'System.Uri' $@.", sink, "here"

Exercise 3
~~~~~~~~~~

.. code-block:: ql

   class EnvironmentVariableFlowSource extends DataFlow::ExprNode {
     EnvironmentVariableFlowSource() {
       this.getExpr().(MethodCall).getTarget().hasQualifiedName("System.Environment.GetEnvironmentVariable")
     }
   }

Exercise 4
~~~~~~~~~~

.. code-block:: ql

   import csharp

   class EnvironmentVariableFlowSource extends DataFlow::ExprNode {
     EnvironmentVariableFlowSource() {
       this.getExpr().(MethodCall).getTarget().hasQualifiedName("System.Environment.GetEnvironmentVariable")
     }
   }

   module EnvironmentToUriConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node src) {
       src instanceof EnvironmentVariableFlowSource
     }

     predicate isSink(DataFlow::Node sink) {
       exists(Call c | c.getTarget().(Constructor).getDeclaringType().hasQualifiedName("System.Uri")
       and sink.asExpr()=c.getArgument(0))
     }
   }

   module EnvironmentToUriFlow = DataFlow::Global<EnvironmentToUriConfig>;

   from DataFlow::Node src, DataFlow::Node sink
   where EnvironmentToUriFlow::flow(src, sink)
   select src, "This environment variable constructs a 'System.Uri' $@.", sink, "here"

Exercise 5
~~~~~~~~~~

All properties can flow data:

.. code-block:: ql

     private predicate propertyFlow(Property p) {
       p = getAMember()
     }

Exercise 6
~~~~~~~~~~

This can be adapted from the ``SystemUriFlow`` class:

.. code-block:: ql

   import semmle.code.csharp.dataflow.LibraryTypeDataFlow
   import semmle.code.csharp.frameworks.System

   class SystemExceptionFlow extends LibraryTypeDataFlow, SystemExceptionClass {
     override predicate callableFlow(CallableFlowSource source, CallableFlowSink sink, SourceDeclarationCallable c, boolean preservesValue) {
       (
         constructorFlow(source, c) and
         sink instanceof CallableFlowSinkQualifier
         or
         methodFlow(source, sink, c)
         or
         exists(Property p |
           propertyFlow(p) and
           source instanceof CallableFlowSourceQualifier and
           sink instanceof CallableFlowSinkReturn and
           c = p.getGetter()
         )
       )
       and
       preservesValue = false
     }

     private predicate constructorFlow(CallableFlowSourceArg source, Constructor c) {
       c = getAMember()
       and
       c.getParameter(0).getType() instanceof StringType
       and
       source.getArgumentIndex() = 0
     }

     private predicate methodFlow(CallableFlowSourceQualifier source, CallableFlowSinkReturn sink, SourceDeclarationMethod m) {
       m.getDeclaringType() = getABaseType*()
       and
       m = getSystemObjectClass().getToStringMethod().getAnOverrider*()
     }

     private predicate propertyFlow(Property p) {
       p = getAProperty() and p.hasName("Message")
     }
   }

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/csharp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-python.rst
.. _codeql-library-for-python:

CodeQL library for Python
=========================

When you need to analyze a Python program, you can make use of the large collection of classes in the CodeQL library for Python.

About the CodeQL library for Python
-----------------------------------

The CodeQL library for each programming language uses classes with abstractions and predicates to present data in an object-oriented form.

Each CodeQL library is implemented as a set of QL modules, that is, files with the extension ``.qll``. The module ``python.qll`` imports all the core Python library modules, so you can include the complete library by beginning your query with:

.. code-block:: ql

   import python

The CodeQL library for Python incorporates a large number of classes. Each class corresponds either to one kind of entity in Python source code or to an entity that can be derived from the source code using static analysis. These classes can be divided into four categories:

-  **Syntactic** - classes that represent entities in the Python source code.
-  **Control flow** - classes that represent entities from the control flow graphs.
-  **Data flow** - classes that represent entities from the data flow graphs.
-  **API graphs** - classes that represent entities from the API graphs.

The first two categories are described below. 
For a description of data flow and associated classes, see ":doc:`Analyzing data flow in Python <analyzing-data-flow-in-python>`".
For a description of API graphs and their use, see ":doc:`Using API graphs in Python <using-api-graphs-in-python>`."

Syntactic classes
-----------------

This part of the library represents the Python source code. The ``Module``, ``Class``, and ``Function`` classes correspond to Python modules, classes, and functions respectively, collectively these are known as ``Scope`` classes. Each ``Scope`` contains a list of statements each of which is represented by a subclass of the class ``Stmt``. Statements themselves can contain other statements or expressions which are represented by subclasses of ``Expr``. Finally, there are a few additional classes for the parts of more complex expressions such as list comprehensions. Collectively these classes are subclasses of ``AstNode`` and form an Abstract syntax tree (AST). The root of each AST is a ``Module``. Symbolic information is attached to the AST in the form of variables (represented by the class ``Variable``). For more information, see `Abstract syntax tree <https://en.wikipedia.org/wiki/Abstract_syntax_tree>`__ and `Symbolic information <https://en.wikipedia.org/wiki/Symbol_table>`__ on Wikipedia.

Scope
^^^^^

A Python program is a group of modules. Technically a module is just a list of statements, but we often think of it as composed of classes and functions. These top-level entities, the module, class, and function are represented by the three CodeQL classes `Module <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Module.qll/type.Module$Module.html>`__, `Class <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Class.qll/type.Class$Class.html>`__ and `Function <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Function.qll/type.Function$Function.html>`__ which are all subclasses of ``Scope``.

-  ``Scope``

   -  ``Module``
   -  ``Class``
   -  ``Function``

All scopes are basically a list of statements, although ``Scope`` classes have additional attributes such as names. For example, the following query finds all functions whose scope (the scope in which they are declared) is also a function:

.. code-block:: ql

   import python

   from Function f
   where f.getScope() instanceof Function
   select f

Many codebases use nested functions.

Statement
^^^^^^^^^

A statement is represented by the `Stmt <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Stmts.qll/type.Stmts$Stmt.html>`__ class which has about 20 subclasses representing the various kinds of statements, such as the ``Pass`` statement, the ``Return`` statement or the ``For`` statement. Statements are usually made up of parts. The most common of these is the expression, represented by the ``Expr`` class. For example, take the following Python ``for`` statement:

.. code-block:: python

   for var in seq:
       pass
   else:
       return 0

The `For <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Stmts.qll/type.Stmts$For.html>`__ class representing the ``for`` statement has a number of member predicates to access its parts:

-  ``getTarget()`` returns the ``Expr`` representing the variable ``var``.
-  ``getIter()`` returns the ``Expr`` resenting the variable ``seq``.
-  ``getBody()`` returns the statement list body.
-  ``getStmt(0)`` returns the pass ``Stmt``.
-  ``getOrElse()`` returns the ``StmtList`` containing the return statement.

Expression
^^^^^^^^^^

Most statements are made up of expressions. The `Expr <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Exprs.qll/type.Exprs$Expr.html>`__ class is the superclass of all expression classes, of which there are about 30 including calls, comprehensions, tuples, lists and arithmetic operations. For example, the Python expression ``a+2`` is represented by the ``BinaryExpr`` class:

-  ``getLeft()`` returns the ``Expr`` representing the ``a``.
-  ``getRight()`` returns the ``Expr`` representing the ``2``.

As an example, to find expressions of the form ``a+2`` where the left is a simple name and the right is a numeric constant we can use the following query:

**Finding expressions of the form "a+2"**

.. code-block:: ql

   import python

   from BinaryExpr bin
   where bin.getLeft() instanceof Name and bin.getRight() instanceof Num
   select bin

Many codebases include examples of this pattern.

Variable
^^^^^^^^

Variables are represented by the `Variable <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Variables.qll/type.Variables$Variable.html>`__ class in the CodeQL library. There are two subclasses, ``LocalVariable`` for function-level and class-level variables and ``GlobalVariable`` for module-level variables.

Other source code elements
^^^^^^^^^^^^^^^^^^^^^^^^^^

Although the meaning of the program is encoded by the syntactic elements, ``Scope``, ``Stmt`` and ``Expr`` there are some parts of the source code not covered by the abstract syntax tree. The most useful of these is the `Comment <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Comment.qll/type.Comment$Comment.html>`__ class which describes comments in the source code.

Examples
^^^^^^^^

Each syntactic element in Python source is recorded in the CodeQL database. These can be queried via the corresponding class. Let us start with a couple of simple examples.

1. Finding all ``finally`` blocks
'''''''''''''''''''''''''''''''''

For our first example, we can find all ``finally`` blocks by using the ``Try`` class:

**Find all** ``finally`` **blocks**

.. code-block:: ql

   import python

   from Try t
   select t.getFinalbody()

Many codebases include examples of this pattern.

2. Finding ``except`` blocks that do nothing
''''''''''''''''''''''''''''''''''''''''''''

For our second example, we can use a simplified version of a query from the standard query set. We look for all ``except`` blocks that do nothing.

A block that does nothing is one that contains no statements except ``pass`` statements. We can encode this as:

.. code-block:: ql

   not exists(Stmt s | s = ex.getAStmt() | not s instanceof Pass)

where ``ex`` is an ``ExceptStmt`` and ``Pass`` is the class representing ``pass`` statements. Instead of using the double negative, "**no** \ *statements that are* \ **not** \ *pass statements"*, this can also be expressed positively, *"all statements must be pass statements."* The positive form is expressed using the ``forall`` quantifier:

.. code-block:: ql

   forall(Stmt s | s = ex.getAStmt() | s instanceof Pass)

Both forms are equivalent. Using the positive expression, the whole query looks like this:

**Find pass-only** ``except`` **blocks**

.. code-block:: ql

   import python

   from ExceptStmt ex
   where forall(Stmt s | s = ex.getAStmt() | s instanceof Pass)
   select ex

Many codebases include pass-only ``except`` blocks.

Summary
^^^^^^^

The most commonly used standard classes in the syntactic part of the library are organized as follows:

``Module``, ``Class``, ``Function``, ``Stmt``, and ``Expr`` - they are all subclasses of `AstNode <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/AstExtended.qll/type.AstExtended$AstNode.html>`__.

Abstract syntax tree
''''''''''''''''''''

-  ``AstNode``

   -  ``Module`` – A Python module
   -  ``Class`` – The body of a class definition
   -  ``Function`` – The body of a function definition
   -  ``Stmt`` – A statement

      -  ``Assert`` – An ``assert`` statement
      -  ``Assign`` – An assignment

         -  ``AssignStmt`` – An assignment statement, ``x = y``
         -  ``ClassDef`` – A class definition statement
         -  ``FunctionDef`` – A function definition statement

      -  ``AugAssign`` – An augmented assignment, ``x += y``
      -  ``Break`` – A ``break`` statement
      -  ``Continue`` – A ``continue`` statement
      -  ``Delete`` – A ``del`` statement
      -  ``ExceptStmt`` – The ``except`` part of a ``try`` statement
      -  ``Exec`` – An exec statement
      -  ``For`` – A ``for`` statement
      -  ``If`` – An ``if`` statement
      -  ``Pass`` – A ``pass`` statement
      -  ``Print`` – A ``print`` statement (Python 2 only)
      -  ``Raise`` – A raise statement
      -  ``Return`` – A ``return`` statement
      -  ``Try`` – A ``try`` statement
      -  ``While`` – A ``while`` statement
      -  ``With`` – A ``with`` statement

   -  ``Expr`` – An expression

      -  ``Attribute`` – An attribute, ``obj.attr``
      -  ``Call`` – A function call, ``f(arg)``
      -  ``IfExp`` – A conditional expression, ``x if cond else y``
      -  ``Lambda – A lambda expression``
      -  ``Yield`` – A ``yield`` expression
      -  ``Bytes`` – A bytes literal, ``b"x"`` or (in Python 2) ``"x"``
      -  ``Unicode`` – A unicode literal, ``u"x"`` or (in Python 3) ``"x"``
      -  ``Num`` – A numeric literal, ``3`` or ``4.2``

         -  ``IntegerLiteral``
         -  ``FloatLiteral``
         -  ``ImaginaryLiteral``

      -  ``Dict`` – A dictionary literal, ``{'a': 2}``
      -  ``Set`` – A set literal, ``{'a', 'b'}``
      -  ``List`` – A list literal, ``['a', 'b']``
      -  ``Tuple`` – A tuple literal, ``('a', 'b')``
      -  ``DictComp`` – A dictionary comprehension, ``{k: v for ...}``
      -  ``SetComp`` – A set comprehension, ``{x for ...}``
      -  ``ListComp`` – A list comprehension, ``[x for ...]``
      -  ``GenExpr`` – A generator expression, ``(x for ...)``
      -  ``Subscript`` – A subscript operation, ``seq[index]``
      -  ``Name`` – A reference to a variable, ``var``
      -  ``UnaryExpr`` – A unary operation, ``-x``
      -  ``BinaryExpr`` – A binary operation, ``x+y``
      -  ``Compare`` – A comparison operation, ``0 < x < 10``
      -  ``BoolExpr`` – Short circuit logical operations, ``x and y``, ``x or y``

Variables
'''''''''

-  ``Variable`` – A variable

   -  ``LocalVariable`` – A variable local to a function or a class
   -  ``GlobalVariable`` – A module level variable

Other
'''''

-  ``Comment`` – A comment

Control flow classes
--------------------

This part of the library represents the control flow graph of each ``Scope`` (classes, functions, and modules). Each ``Scope`` contains a graph of ``ControlFlowNode`` elements. Each scope has a single entry point and at least one (potentially many) exit points. To speed up control and data flow analysis, control flow nodes are grouped into basic blocks. For more information, see `Basic block <https://en.wikipedia.org/wiki/Basic_block>`__ on Wikipedia.

Example
^^^^^^^

If we want to find the longest sequence of code without any branches, we need to consider control flow. A ``BasicBlock`` is, by definition, a sequence of code without any branches, so we just need to find the longest ``BasicBlock``.

First of all we introduce a simple predicate ``bb_length()`` which relates ``BasicBlock``\ s to their length.

.. code-block:: ql

   int bb_length(BasicBlock b) {
       result = max(int i | exists(b.getNode(i))) + 1
   }

Each ``ControlFlowNode`` within a ``BasicBlock`` is numbered consecutively, starting from zero, therefore the length of a ``BasicBlock`` is equal to one more than the largest index within that ``BasicBlock``.

Using this predicate we can select the longest ``BasicBlock`` by selecting the ``BasicBlock`` whose length is equal to the maximum length of any ``BasicBlock``:

**Find the longest sequence of code without branches**

.. code-block:: ql

   import python

   int bb_length(BasicBlock b) {
       result = max(int i | exists(b.getNode(i)) | i) + 1
   }

   from BasicBlock b
   where bb_length(b) = max(bb_length(_))
   select b

.. pull-quote::

   Note

   The special underscore variable ``_`` means any value; so ``bb_length(_)`` is the length of any block.

Summary
^^^^^^^

The classes in the control-flow part of the library are:

-  `ControlFlowNode <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Flow.qll/type.Flow$ControlFlowNode.html>`__ – A control-flow node. There is a one-to-many relation between AST nodes and control-flow nodes.
-  `BasicBlock <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Flow.qll/type.Flow$BasicBlock.html>`__ – A non branching list of control-flow nodes.


Further reading
---------------

.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/using-flow-labels-for-precise-data-flow-analysis.rst
.. _using-flow-labels-for-precise-data-flow-analysis:

Using flow labels for precise data flow analysis
================================================

You can associate flow labels with each value tracked by the flow analysis to determine whether the flow contains potential vulnerabilities.

Overview
--------

You can use basic inter-procedural data-flow analysis and taint tracking as described in
":doc:`Analyzing data flow in JavaScript and TypeScript <analyzing-data-flow-in-javascript-and-typescript>`" to check whether there is a path in
the data-flow graph from some source node to a sink node that does not pass through any sanitizer
nodes. Another way of thinking about this is that it statically models the flow of data through the
program, and associates a flag with every data value telling us whether it might have come from a
source node.

In some cases, you may want to track more detailed information about data values. This can be done
by associating flow labels with data values, as shown in this tutorial. We will first discuss the
general idea behind flow labels and then show how to use them in practice. Finally, we will give an
overview of the API involved and provide some pointers to standard queries that use flow labels.

Limitations of basic data-flow analysis
---------------------------------------

In many applications we are interested in tracking more than just the reachability information provided by inter-procedural data flow analysis.

For example, when tracking object values that originate from untrusted input, we might want to
remember whether the entire object is tainted or whether only part of it is tainted. The former
happens, for example, when parsing a user-controlled string as JSON, meaning that the entire
resulting object is tainted. A typical example of the latter is assigning a tainted value to a
property of an object, which only taints that property but not the rest of the object.

While reading a property of a completely tainted object yields a tainted value, reading a property
of a partially tainted object does not. On the other hand, JSON-encoding even a partially tainted
object and including it in an HTML document is not safe.

Another example where more fine-grained information about tainted values is needed is for tracking
partial sanitization. For example, before interpreting a user-controlled string as a file-system
path, we generally want to make sure that it is neither an absolute path (which could refer to any
file on the file system) nor a relative path containing ``..`` components (which still could refer
to any file). Usually, checking both of these properties would involve two separate checks. Both
checks taken together should count as a sanitizer, but each individual check is not by itself enough
to make the string safe for use as a path. To handle this case precisely, we want to associate two
bits of information with each tainted value, namely whether it may be absolute, and whether it may
contain ``..`` components. Untrusted user input has both bits set initially, individual checks turn
off individual bits, and if a value that has at least one bit set is interpreted as a path, a
potential vulnerability is flagged.

Using flow labels
-----------------

You can handle these cases and others like them by associating a set of `flow labels` (sometimes
also referred to as `taint kinds`) with each value being tracked by the analysis. Value-preserving
data-flow steps (such as flow steps from writes to a variable to its reads) preserve the set of flow
labels, but other steps may add or remove flow labels. Sanitizers, in particular, are simply flow
steps that remove some or all flow labels. The initial set of flow labels for a value is determined
by the source node that gives rise to it. Similarly, sink nodes can specify that an incoming value
needs to have a certain flow label (or one of a set of flow labels) in order for the flow to be
flagged as a potential vulnerability.

Example
-------

As an example of using flow labels, we will show how to write a query that flags property accesses
on JSON values that come from user-controlled input where we have not checked whether the value is
``null``, so that the property access may cause a runtime exception.

For example, we would like to flag this code:

.. code-block:: javascript

  function test(str) {
    var data = JSON.parse(str);
    if (data.length > 0) {  // problematic: `data` may be `null`
      ...
    }
  }

This code, on the other hand, should not be flagged:

.. code-block:: javascript

  function test(str) {
    var data = JSON.parse(str);
    if (data && data.length > 0) { // unproblematic: `data` is first checked for nullness
      ...
    }
  }

We will first try to write a query to find this kind of problem without flow labels, and use the
difficulties we encounter as a motivation for bringing flow labels into play, which will make the
query much easier to implement.

To get started, let's write a query that simply flags any flow from ``JSON.parse`` into the base of
a property access:

.. code-block:: ql

  import javascript

  class JsonTrackingConfig extends DataFlow::Configuration {
    JsonTrackingConfig() { this = "JsonTrackingConfig" }

    override predicate isSource(DataFlow::Node nd) {
      exists(JsonParserCall jpc |
        nd = jpc.getOutput()
      )
    }

    override predicate isSink(DataFlow::Node nd) {
      exists(DataFlow::PropRef pr |
        nd = pr.getBase()
      )
    }
  }

  from JsonTrackingConfig cfg, DataFlow::Node source, DataFlow::Node sink
  where cfg.hasFlow(source, sink)
  select sink, "Property access on JSON value originating $@.", source, "here"

Note that we use the ``JsonParserCall`` class from the standard library to model various JSON
parsers, including the standard ``JSON.parse`` API as well as a number of popular npm packages.

Of course, as written this query flags both the good and the bad example above, since we have not
introduced any sanitizers yet.

There are many ways of checking for nullness directly or indirectly. Since this is not the main
focus of this tutorial, we will only show how to model one specific case: if some variable ``v`` is
known to be truthy, it cannot be ``null``. This kind of condition is easily expressed using a
``BarrierGuardNode`` (or its counterpart ``SanitizerGuardNode`` for taint-tracking configurations).
A barrier guard node is a data-flow node ``b`` that blocks flow through some other node ``nd``,
provided that some condition checked at ``b`` is known to hold, that is, evaluate to a truthy value.

In our case, the barrier guard node is a use of some variable ``v``, and the condition is that use
itself: it blocks flow through any use of ``v`` where the guarding use is known to evaluate to a
truthy value. In our second example above, the use of ``data`` on the left-hand side of the ``&&``
is a barrier guard blocking flow through the use of ``data`` on the right-hand side of the ``&&``.
At this point we know that ``data`` has evaluated to a truthy value, so it cannot be ``null``
anymore.

Implementing this additional condition is easy. We implement a subclass of ``DataFlow::BarrierGuardNode``:

.. code-block:: ql

  class TruthinessCheck extends DataFlow::BarrierGuardNode, DataFlow::ValueNode {
    SsaVariable v;

    TruthinessCheck() {
      astNode = v.getAUse()
    }

    override predicate blocks(boolean outcome, Expr e) {
      outcome = true and
      e = astNode
    }
  }

and then use it to override predicate ``isBarrierGuard`` in our configuration class:

.. code-block:: ql

  override predicate isBarrierGuard(DataFlow::BarrierGuardNode guard) {
    guard instanceof TruthinessCheck
  }

With this change, we now flag the problematic case and don't flag the unproblematic case above.

However, as it stands our analysis has many false negatives: if we read a property of a JSON object,
our analysis will not continue tracking it, so property accesses on the resulting value will not be
checked for null-guardedness:

.. code-block:: javascript

  function test(str) {
    var root = JSON.parse(str);
    if (root) {
      var payload = root.data;   // unproblematic: `root` cannot be `null` here
      if (payload.length > 0) {  // problematic: `payload` may be `null` here
        ...
      }
    }
  }

We could try to remedy the situation by overriding ``isAdditionalFlowStep`` in our configuration class to track values through property reads:

.. code-block:: ql

  override predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) {
    succ.(DataFlow::PropRead).getBase() = pred
  }

But this does not actually allow us to flag the problem above as once we have checked ``root`` for
truthiness, all further uses are considered to be sanitized. In particular, the reference to
``root`` in ``root.data`` is sanitized, so no flow tracking through the property read happens.

The problem is, of course, that our sanitizer sanitizes too much. It should not stop flow
altogether, it should simply record the fact that ``root`` itself is known to be non-null.
Any property read from ``root``, on the other hand, may well be null and needs to be checked
separately.

We can achieve this by introducing two different flow labels, ``json`` and ``maybe-null``. The former
means that the value we are dealing with comes from a JSON object, the latter that it may be
``null``. The result of any call to ``JSON.parse`` has both labels. A property read from a value
with label ``json`` also has both labels. Checking truthiness removes the ``maybe-null`` label.
Accessing a property on a value that has the ``maybe-null`` label should be flagged.

To implement this, we start by defining two new subclasses of the class ``DataFlow::FlowLabel``:

.. code-block:: ql

  class JsonLabel extends DataFlow::FlowLabel {
    JsonLabel() {
      this = "json"
    }
  }

  class MaybeNullLabel extends DataFlow::FlowLabel {
    MaybeNullLabel() {
      this = "maybe-null"
    }
  }

Then we extend our ``isSource`` predicate from above to track flow labels by overriding the two-argument version instead of the one-argument version:

.. code-block:: ql

  override predicate isSource(DataFlow::Node nd, DataFlow::FlowLabel lbl) {
    exists(JsonParserCall jpc |
      nd = jpc.getOutput() and
      (lbl instanceof JsonLabel or lbl instanceof MaybeNullLabel)
    )
  }

Similarly, we make ``isSink`` flow-label aware and require the base of the property read to have the ``maybe-null`` label:

.. code-block:: ql

  override predicate isSink(DataFlow::Node nd, DataFlow::FlowLabel lbl) {
    exists(DataFlow::PropRef pr |
      nd = pr.getBase() and
      lbl instanceof MaybeNullLabel
    )
  }

Our overriding definition of ``isAdditionalFlowStep`` now needs to specify two flow labels, a
predecessor label ``predlbl`` and a successor label ``succlbl``. In addition to specifying flow from
the predecessor node ``pred`` to the successor node ``succ``, it requires that ``pred`` has label
``predlbl``, and adds label ``succlbl`` to ``succ``. In our case, we use this to add both the
``json`` label and the ``maybe-null`` label to any property read from a value labeled with ``json``
(no matter whether it has the ``maybe-null`` label):

.. code-block:: ql

  override predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ,
                                DataFlow::FlowLabel predlbl, DataFlow::FlowLabel succlbl) {
    succ.(DataFlow::PropRead).getBase() = pred and
    predlbl instanceof JsonLabel and
    (succlbl instanceof JsonLabel or succlbl instanceof MaybeNullLabel)
  }

Finally, we turn ``TruthinessCheck`` from a ``BarrierGuardNode`` into a ``LabeledBarrierGuardNode``,
specifying that it only removes the ``maybe-null`` label (but not the ``json`` label) from the
sanitized value:

.. code-block:: ql

  class TruthinessCheck extends DataFlow::LabeledBarrierGuardNode, DataFlow::ValueNode {
    ...

    override predicate blocks(boolean outcome, Expr e, DataFlow::FlowLabel lbl) {
      outcome = true and
      e = astNode and
      lbl instanceof MaybeNullLabel
    }
  }

Here is the final query, expressed as a :ref:`path query <creating-path-queries>` so we can examine paths from sources to sinks
step by step in the UI:

.. code-block:: ql

  /** @kind path-problem */

  import javascript
  import DataFlow::PathGraph

  class JsonLabel extends DataFlow::FlowLabel {
    JsonLabel() {
      this = "json"
    }
  }

  class MaybeNullLabel extends DataFlow::FlowLabel {
    MaybeNullLabel() {
      this = "maybe-null"
    }
  }

  class TruthinessCheck extends DataFlow::LabeledBarrierGuardNode, DataFlow::ValueNode {
    SsaVariable v;

    TruthinessCheck() {
      astNode = v.getAUse()
    }

    override predicate blocks(boolean outcome, Expr e, DataFlow::FlowLabel lbl) {
      outcome = true and
      e = astNode and
      lbl instanceof MaybeNullLabel
    }
  }

  class JsonTrackingConfig extends DataFlow::Configuration {
    JsonTrackingConfig() { this = "JsonTrackingConfig" }

    override predicate isSource(DataFlow::Node nd, DataFlow::FlowLabel lbl) {
      exists(JsonParserCall jpc |
        nd = jpc.getOutput() and
        (lbl instanceof JsonLabel or lbl instanceof MaybeNullLabel)
      )
    }

    override predicate isSink(DataFlow::Node nd, DataFlow::FlowLabel lbl) {
      exists(DataFlow::PropRef pr |
        nd = pr.getBase() and
        lbl instanceof MaybeNullLabel
      )
    }

    override predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ,
                               DataFlow::FlowLabel predlbl, DataFlow::FlowLabel succlbl) {
      succ.(DataFlow::PropRead).getBase() = pred and
      predlbl instanceof JsonLabel and
      (succlbl instanceof JsonLabel or succlbl instanceof MaybeNullLabel)
    }

    override predicate isBarrierGuard(DataFlow::BarrierGuardNode guard) {
      guard instanceof TruthinessCheck
    }
  }

  from JsonTrackingConfig cfg, DataFlow::PathNode source, DataFlow::PathNode sink
  where cfg.hasFlowPath(source, sink)
  select sink, source, sink, "Property access on JSON value originating $@.", source, "here"

We ran this query on the https://github.com/finos/plexus-interop repository. Many of the
results were false positives since the query does not currently model many ways in which we can check
a value for nullness. In particular, after a property reference ``x.p`` we implicitly know that
``x`` cannot be null anymore, since otherwise the reference would have thrown an exception.
Modeling this would allow us to get rid of most of the false positives, but is beyond the scope of
this tutorial.

API
---

Plain data-flow configurations implicitly use a single flow label "data", which indicates that a
data value originated from a source. You can use the predicate ``DataFlow::FlowLabel::data()``,
which returns this flow label, as a symbolic name for it.

Taint-tracking configurations add a second flow label "taint" (``DataFlow::FlowLabel::taint()``),
which is similar to "data", but includes values that have passed through non-value preserving steps
such as string operations.

Each of the three member predicates ``isSource``, ``isSink`` and
``isAdditionalFlowStep``/``isAdditionalTaintStep`` has one version that uses the default flow
labels, and one version that allows specifying custom flow labels through additional arguments.

For ``isSource``, there is one additional argument specifying which flow label(s) should be
associated with values originating from this source. If multiple flow labels are specified, each
value is associated with `all` of them.

For ``isSink``, the additional argument specifies which flow label(s) a value that flows into this
source may be associated with. If multiple flow labels are specified, then any value that is
associated with `at least one` of them will be considered by the configuration.

For ``isAdditionalFlowStep`` there are two additional arguments ``predlbl`` and ``succlbl``, which
allow flow steps to act as flow label transformers. If a value associated with ``predlbl`` arrives
at the start node of the additional step, it is propagated to the end node and associated with
``succlbl``. Of course, ``predlbl`` and ``succlbl`` may be the same, indicating that the flow step
preserves this label. There can also be multiple values of ``succlbl`` for a single ``predlbl`` or
vice versa.

Note that if you do not restrict ``succlbl`` then it will be allowed to range over all flow labels.
This may cause labels that were previously blocked on a path to reappear, which is not usually what
you want.

The flow label-aware version of ``isBarrier`` is called ``isLabeledBarrier``: unlike ``isBarrier``,
which prevents any flow past the given node, it only blocks flow of values associated with one of
the specified flow labels.

Standard queries using flow labels
----------------------------------

Some of our standard security queries use flow labels. You can look at their implementation
to get a feeling for how to use flow labels in practice.

In particular, both of the examples mentioned in the section on limitations of basic data flow above
are from standard security queries that use flow labels. The `Prototype-polluting merge call
<https://codeql.github.com/codeql-query-help/javascript/js-prototype-pollution/>`_ query uses two flow labels to distinguish completely
tainted objects from partially tainted objects. The `Uncontrolled data used in path expression
<https://codeql.github.com/codeql-query-help/javascript/js-path-injection/>`_ query uses four flow labels to track whether a user-controlled
string may be an absolute path and whether it may contain ``..`` components.

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/abstract-syntax-tree-classes-for-working-with-go-programs.rst
.. _abstract-syntax-tree-classes-for-working-with-go-programs:

Abstract syntax tree classes for working with Go programs
=========================================================

CodeQL has a large selection of classes for representing the abstract syntax tree of Go programs.

.. include:: ../reusables/abstract-syntax-tree.rst

Statement classes
-----------------

This table lists all subclasses of Stmt_.

+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
|  Statement syntax                                                             |     CodeQL class      |           Superclasses           |  Remarks                                          |
+===============================================================================+=======================+==================================+===================================================+
| ``;``                                                                         | EmptyStmt_            |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_                                                                         | ExprStmt_             |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``{`` Stmt_ ``...`` ``}``                                                     | BlockStmt_            |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``if`` Expr_  BlockStmt_                                                      | IfStmt_               |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``if`` Expr_  BlockStmt_ ``else`` Stmt_                                       |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``if`` Stmt_\ ``;`` Expr_  BlockStmt_                                         |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``for`` Expr_ BlockStmt_                                                      | ForStmt_              | LoopStmt_                        |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``for`` Stmt_\ ``;`` Expr_\ ``;`` Stmt_ BlockStmt_                            |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``for`` Expr_ ``...`` ``=`` ``range`` Expr_ BlockStmt_                        | RangeStmt_            | LoopStmt_                        |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``switch`` Expr_ ``{`` CaseClause_ ``...`` ``}``                              | ExpressionSwitchStmt_ | SwitchStmt_                      |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``switch`` Stmt_\ ``;`` Expr_ ``{`` CaseClause_ ``...`` ``}``                 |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``switch`` Expr_\ ``.(type)`` ``{`` CaseClause_ ``...`` ``}``                 | TypeSwitchStmt_       | SwitchStmt_                      |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``switch`` SimpleAssignStmt_\ ``.(type)`` ``{`` CaseClause_ ``...`` ``}``     |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``switch`` Stmt_\ ``;`` Expr_\ ``.(type)`` ``{`` CaseClause_ ``...`` ``}``    |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``select`` ``{`` CommClause_ ``...`` ``}``                                    | SelectStmt_           |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``return``                                                                    | ReturnStmt_           |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``break``                                                                     | BreakStmt_            | BranchStmt_                      |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``continue``                                                                  | ContinueStmt_         | BranchStmt_                      |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``goto`` LabelName_                                                           | GotoStmt_             | BranchStmt_                      |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``fallthrough``                                                               | FallthroughStmt_      | BranchStmt_                      | can only occur as final non-empty child of        |
|                                                                               |                       |                                  | a CaseClause_ in an ExpressionSwitchStmt_         |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| LabelName_\ ``:`` Stmt_                                                       | LabeledStmt_          |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``var`` VariableName_ TypeName_                                               | DeclStmt_             |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``const`` VariableName_ ``=`` Expr_                                           |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``type`` TypeName_ TypeExpr_                                                  |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``type`` TypeName_ ``=`` TypeExpr_                                            |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``...`` ``=`` Expr_ ``...``                                             | AssignStmt_           | SimpleAssignStmt_, Assignment_   |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| VariableName_ ``...`` ``:=`` Expr_ ``...``                                    | DefineStmt_           | SimpleAssignStmt_, Assignment_   |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``+=`` Expr_                                                            | AddAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``-=`` Expr_                                                            | SubAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``*=`` Expr_                                                            | MulAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``/=`` Expr_                                                            | QuoAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``%=`` Expr_                                                            | RemAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``*=`` Expr_                                                            | MulAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``&=`` Expr_                                                            | AndAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``|=`` Expr_                                                            | OrAssignStmt_         | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``^=`` Expr_                                                            | XorAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``<<=`` Expr_                                                           | ShlAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``>>=`` Expr_                                                           | ShrAssignStmt_        | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``&^=`` Expr_                                                           | AndNotAssignStmt_     | CompoundAssignStmt_, Assignment_ |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``++``                                                                  | IncStmt_              | IncDecStmt_                      |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``--``                                                                  | DecStmt_              | IncDecStmt_                      |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``go`` CallExpr_                                                              | GoStmt_               |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``defer`` CallExpr_                                                           | DeferStmt_            |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``<-`` Expr_                                                            | SendStmt_             |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``case`` Expr_ ``...``\ ``:`` Stmt_ ``...``                                   | CaseClause_           |                                  | can only occur as child of a SwitchStmt_          |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``case`` TypeExpr_ ``...``\ ``:`` Stmt_ ``...``                               |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``default:`` Stmt_ ``...``                                                    |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| ``case`` SendStmt_\ ``:`` Stmt_ ``...``                                       | CommClause_           |                                  | can only occur as child of a SelectStmt_          |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``case`` RecvStmt_\ ``:`` Stmt_ ``...``                                       |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| ``default:`` Stmt_ ``...``                                                    |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| Expr_ ``...`` ``=`` RecvExpr_                                                 | RecvStmt_             |                                  | can only occur as child of a CommClause_          |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+                       |                                  |                                                   |
| VariableName_ ``...`` ``:=`` RecvExpr_                                        |                       |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+
| (anything unparseable)                                                        | BadStmt_              |                                  |                                                   |
|                                                                               |                       |                                  |                                                   |
+-------------------------------------------------------------------------------+-----------------------+----------------------------------+---------------------------------------------------+

Expression classes
------------------

There are many expression classes, so we present them by category.
All classes in this section are subclasses of
Expr_.

Literals
~~~~~~~~

+-----------------------------------------+--------------+---------------+
|        Expression syntax example        | CodeQL class |  Superclass   |
+=========================================+==============+===============+
| ``23``                                  | IntLit_      | BasicLit_     |
+-----------------------------------------+--------------+---------------+
| ``4.2``                                 | FloatLit_    | BasicLit_     |
+-----------------------------------------+--------------+---------------+
| ``4.2 + 2.7i``                          | ImagLit_     | BasicLit_     |
+-----------------------------------------+--------------+---------------+
| ``'a'``                                 | CharLit_     | BasicLit_     |
+-----------------------------------------+--------------+---------------+
| ``"Hello"``                             | StringLit_   | BasicLit_     |
+-----------------------------------------+--------------+---------------+
| ``func(x, y int) int { return x + y }`` | FuncLit_     | FuncDef_      |
+-----------------------------------------+--------------+---------------+
| ``map[string]int{"A": 1, "B": 2}``      | MapLit_      | CompositeLit_ |
+-----------------------------------------+--------------+---------------+
| ``Point3D{0.5, -0.5, 0.5}``             | StructLit_   | CompositeLit_ |
+-----------------------------------------+--------------+---------------+

Unary expressions
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of
UnaryExpr_.

+-------------------+-----------------+----------------------+
| Expression syntax |  CodeQL class   |     Superclasses     |
+===================+=================+======================+
| ``+``\ Expr_      | PlusExpr_       | ArithmeticUnaryExpr_ |
+-------------------+-----------------+----------------------+
| ``-``\ Expr_      | MinusExpr_      | ArithmeticUnaryExpr_ |
+-------------------+-----------------+----------------------+
| ``!``\ Expr_      | NotExpr_        | LogicalUnaryExpr_    |
+-------------------+-----------------+----------------------+
| ``^``\ Expr_      | ComplementExpr_ | BitwiseUnaryExpr_    |
+-------------------+-----------------+----------------------+
| ``&``\ Expr_      | AddressExpr_    |                      |
+-------------------+-----------------+----------------------+
| ``<-``\ Expr_     | RecvExpr_       |                      |
+-------------------+-----------------+----------------------+

Binary expressions
~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of
BinaryExpr_.

+--------------------+--------------+---------------------------+
| Expression syntax  | CodeQL class |       Superclasses        |
+====================+==============+===========================+
| Expr_ ``*`` Expr_  | MulExpr_     | ArithmeticBinaryExpr_     |
+--------------------+--------------+---------------------------+
| Expr_ ``/`` Expr_  | QuoExpr_     | ArithmeticBinaryExpr_     |
+--------------------+--------------+---------------------------+
| Expr_ ``%`` Expr_  | RemExpr_     | ArithmeticBinaryExpr_     |
+--------------------+--------------+---------------------------+
| Expr_ ``+`` Expr_  | AddExpr_     | ArithmeticBinaryExpr_     |
+--------------------+--------------+---------------------------+
| Expr_ ``-`` Expr_  | SubExpr_     | ArithmeticBinaryExpr_     |
+--------------------+--------------+---------------------------+
| Expr_ ``<<`` Expr_ | ShlExpr_     | ShiftExpr_                |
+--------------------+--------------+---------------------------+
| Expr_ ``>>`` Expr_ | ShrExpr_     | ShiftExpr_                |
+--------------------+--------------+---------------------------+
| Expr_ ``&&`` Expr_ | LandExpr_    | LogicalBinaryExpr_        |
+--------------------+--------------+---------------------------+
| Expr_ ``||`` Expr_ | LorExpr_     | LogicalBinaryExpr_        |
+--------------------+--------------+---------------------------+
| Expr_ ``<`` Expr_  | LssExpr_     | RelationalComparisonExpr_ |
+--------------------+--------------+---------------------------+
| Expr_ ``>`` Expr_  | GtrExpr_     | RelationalComparisonExpr_ |
+--------------------+--------------+---------------------------+
| Expr_ ``<=`` Expr_ | LeqExpr_     | RelationalComparisonExpr_ |
+--------------------+--------------+---------------------------+
| Expr_ ``>=`` Expr_ | GeqExpr_     | RelationalComparisonExpr_ |
+--------------------+--------------+---------------------------+
| Expr_ ``==`` Expr_ | EqlExpr_     | EqualityTestExpr_         |
+--------------------+--------------+---------------------------+
| Expr_ ``!=`` Expr_ | NeqExpr_     | EqualityTestExpr_         |
+--------------------+--------------+---------------------------+
| Expr_ ``&`` Expr_  | AndExpr_     | BitwiseBinaryExpr_        |
+--------------------+--------------+---------------------------+
| Expr_ ``|`` Expr_  | OrExpr_      | BitwiseBinaryExpr_        |
+--------------------+--------------+---------------------------+
| Expr_ ``^`` Expr_  | XorExpr_     | BitwiseBinaryExpr_        |
+--------------------+--------------+---------------------------+
| Expr_ ``&^`` Expr_ | AndNotExpr_  | BitwiseBinaryExpr_        |
+--------------------+--------------+---------------------------+

Type expressions
~~~~~~~~~~~~~~~~

These classes represent different expressions for types. They do
not have a common superclass.

+-----------------------------------------+-----------------------+---------------+
|            Expression syntax            |     CodeQL class      | Superclasses  |
+=========================================+=======================+===============+
| ``[``\ Expr_\ ``]`` TypeExpr_           | ArrayTypeExpr_        |               |
+-----------------------------------------+-----------------------+---------------+
| ``struct { ... }``                      | StructTypeExpr_       |               |
+-----------------------------------------+-----------------------+---------------+
| ``func`` FunctionName_\ ``(...) (...)`` | FuncTypeExpr_         |               |
+-----------------------------------------+-----------------------+---------------+
| ``interface { ... }``                   | InterfaceTypeExpr_    |               |
+-----------------------------------------+-----------------------+---------------+
| ``map[``\ TypeExpr_\ ``]``\ TypeExpr_   | MapTypeExpr_          |               |
+-----------------------------------------+-----------------------+---------------+
| ``chan<-`` TypeExpr_                    | SendChanTypeExpr_     | ChanTypeExpr_ |
+-----------------------------------------+-----------------------+---------------+
| ``<-chan`` TypeExpr_                    | RecvChanTypeExpr_     | ChanTypeExpr_ |
+-----------------------------------------+-----------------------+---------------+
| ``chan`` TypeExpr_                      | SendRecvChanTypeExpr_ | ChanTypeExpr_ |
+-----------------------------------------+-----------------------+---------------+

Name expressions
~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of
Name_.

The following classes relate to the structure of the name.

+-----------------------+----------------+---------------+
|   Expression syntax   |  CodeQL class  | Superclasses  |
+=======================+================+===============+
| Ident_                | SimpleName_    | Ident_        |
+-----------------------+----------------+---------------+
| Ident_\ ``.``\ Ident_ | QualifiedName_ | SelectorExpr_ |
+-----------------------+----------------+---------------+

The following classes relate to what sort of entity the name refers to.


-  PackageName_
-  TypeName_
-  LabelName_
-  ValueName_

   -  ConstantName_
   -  VariableName_
   -  FunctionName_

Miscellaneous
~~~~~~~~~~~~~

+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
|                   Expression syntax                    |  CodeQL class   |     Superclasses      |                        Remarks                        |
+========================================================+=================+=======================+=======================================================+
| ``foo``                                                | Ident_          |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| ``_``                                                  | BlankIdent_     |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| ``...``                                                | Ellipsis_       |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| ``(``\ Expr_\ ``)``                                    | ParenExpr_      |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| Ident_\ ``.``\ Ident_                                  | SelectorExpr_   |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| Expr_\ ``[``\ Expr_\ ``]``                             | IndexExpr_      |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| Expr_\ ``[``\ Expr_\ ``:``\ Expr_\ ``:``\ Expr_\ ``]`` | SliceExpr_      |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| Expr_\ ``.(``\ TypeExpr_\ ``)``                        | TypeAssertExpr_ |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| ``*``\ Expr_                                           | StarExpr_       |                       | can be a ValueExpr_ or TypeExpr_ depending on context |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| Expr_\ ``:`` Expr_                                     | KeyValueExpr_   |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| TypeExpr_\ ``(``\ Expr_\ ``)``                         | ConversionExpr_ | CallOrConversionExpr_ |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| Expr_\ ``(...)``                                       | CallExpr_       | CallOrConversionExpr_ |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+
| (anything unparseable)                                 | BadExpr_        |                       |                                                       |
+--------------------------------------------------------+-----------------+-----------------------+-------------------------------------------------------+

The following classes organize expressions by the kind of entity they refer to.

+----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
|  CodeQL class  |                                                                            Explanation                                                                            |
+================+===================================================================================================================================================================+
| TypeExpr_      | an expression that denotes a type                                                                                                                                 |
+----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ReferenceExpr_ | an expression that refers to a variable, a constant, a function, a field, or an element of an array or a slice                                                    |
+----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| ValueExpr_     | an expression that can be evaluated to a value (as opposed to expressions that refer to a package, a type, or a statement label). This generalizes ReferenceExpr_ |
+----------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+


Further reading
---------------

.. include:: ../reusables/go-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Links used in tables. For information about using these links, see
   https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#hyperlinks.

.. _Stmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$Stmt.html
.. _Expr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$Expr.html
.. _IntLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$IntLit.html
.. _BasicLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$BasicLit.html
.. _FloatLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$FloatLit.html
.. _ImagLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ImagLit.html
.. _CharLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$CharLit.html
.. _StringLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$StringLit.html
.. _FuncLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$FuncLit.html
.. _FuncDef: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Decls.qll/type.Decls$FuncDef.html
.. _MapLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$MapLit.html
.. _CompositeLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$CompositeLit.html
.. _StructLit: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$StructLit.html
.. _UnaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$UnaryExpr.html
.. _PlusExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$PlusExpr.html
.. _ArithmeticUnaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ArithmeticUnaryExpr.html
.. _MinusExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$MinusExpr.html
.. _NotExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$NotExpr.html
.. _LogicalUnaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LogicalUnaryExpr.html
.. _ComplementExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ComplementExpr.html
.. _BitwiseUnaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$BitwiseUnaryExpr.html
.. _AddressExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$AddressExpr.html
.. _RecvExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$RecvExpr.html
.. _BinaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$BinaryExpr.html
.. _MulExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$MulExpr.html
.. _ArithmeticBinaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ArithmeticBinaryExpr.html
.. _QuoExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$QuoExpr.html
.. _RemExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$RemExpr.html
.. _AddExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$AddExpr.html
.. _SubExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$SubExpr.html
.. _ShlExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ShlExpr.html
.. _ShiftExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ShiftExpr.html
.. _ShrExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ShrExpr.html
.. _LandExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LandExpr.html
.. _LogicalBinaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LogicalBinaryExpr.html
.. _LorExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LorExpr.html
.. _LssExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LssExpr.html
.. _RelationalComparisonExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$RelationalComparisonExpr.html
.. _GtrExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$GtrExpr.html
.. _LeqExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LeqExpr.html
.. _GeqExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$GeqExpr.html
.. _EqlExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$EqlExpr.html
.. _EqualityTestExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$EqualityTestExpr.html
.. _NeqExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$NeqExpr.html
.. _AndExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$AndExpr.html
.. _BitwiseBinaryExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$BitwiseBinaryExpr.html
.. _OrExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$OrExpr.html
.. _XorExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$XorExpr.html
.. _AndNotExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$AndNotExpr.html
.. _TypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$TypeExpr.html
.. _ArrayTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ArrayTypeExpr.html
.. _StructTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$StructTypeExpr.html
.. _FunctionName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$FunctionName.html
.. _FuncTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$FuncTypeExpr.html
.. _InterfaceTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$InterfaceTypeExpr.html
.. _MapTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$MapTypeExpr.html
.. _SendChanTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$SendChanTypeExpr.html
.. _ChanTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ChanTypeExpr.html
.. _RecvChanTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$RecvChanTypeExpr.html
.. _SendRecvChanTypeExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$SendRecvChanTypeExpr.html
.. _Name: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$Name.html
.. _Ident: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$Ident.html
.. _SimpleName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$SimpleName.html
.. _QualifiedName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$QualifiedName.html
.. _SelectorExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$SelectorExpr.html
.. _PackageName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$PackageName.html
.. _TypeName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$TypeName.html
.. _LabelName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$LabelName.html
.. _ValueName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ValueName.html
.. _ConstantName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ConstantName.html
.. _VariableName: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$VariableName.html
.. _BlankIdent: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$BlankIdent.html
.. _Ellipsis: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$Ellipsis.html
.. _ParenExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ParenExpr.html
.. _IndexExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$IndexExpr.html
.. _SliceExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$SliceExpr.html
.. _TypeAssertExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$TypeAssertExpr.html
.. _StarExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$StarExpr.html
.. _ValueExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ValueExpr.html
.. _KeyValueExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$KeyValueExpr.html
.. _ConversionExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ConversionExpr.html
.. _CallOrConversionExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$CallOrConversionExpr.html
.. _CallExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$CallExpr.html
.. _BadExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$BadExpr.html
.. _ReferenceExpr: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Expr.qll/type.Expr$ReferenceExpr.html
.. _EmptyStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$EmptyStmt.html
.. _ExprStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ExprStmt.html
.. _BlockStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$BlockStmt.html
.. _IfStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$IfStmt.html
.. _ForStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ForStmt.html
.. _LoopStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$LoopStmt.html
.. _RangeStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$RangeStmt.html
.. _ExpressionSwitchStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ExpressionSwitchStmt.html
.. _SwitchStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$SwitchStmt.html
.. _CaseClause: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$CaseClause.html
.. _TypeSwitchStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$TypeSwitchStmt.html
.. _SimpleAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$SimpleAssignStmt.html
.. _CommClause: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$CommClause.html
.. _SelectStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$SelectStmt.html
.. _ReturnStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ReturnStmt.html
.. _BreakStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$BreakStmt.html
.. _BranchStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$BranchStmt.html
.. _ContinueStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ContinueStmt.html
.. _GotoStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$GotoStmt.html
.. _FallthroughStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$FallthroughStmt.html
.. _LabeledStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$LabeledStmt.html
.. _DeclStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$DeclStmt.html
.. _AssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$AssignStmt.html
.. _Assignment: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$Assignment.html
.. _DefineStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$DefineStmt.html
.. _AddAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$AddAssignStmt.html
.. _CompoundAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$CompoundAssignStmt.html
.. _SubAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$SubAssignStmt.html
.. _MulAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$MulAssignStmt.html
.. _QuoAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$QuoAssignStmt.html
.. _RemAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$RemAssignStmt.html
.. _AndAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$AndAssignStmt.html
.. _OrAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$OrAssignStmt.html
.. _XorAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$XorAssignStmt.html
.. _ShlAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ShlAssignStmt.html
.. _ShrAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$ShrAssignStmt.html
.. _AndNotAssignStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$AndNotAssignStmt.html
.. _IncStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$IncStmt.html
.. _IncDecStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$IncDecStmt.html
.. _DecStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$DecStmt.html
.. _GoStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$GoStmt.html
.. _DeferStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$DeferStmt.html
.. _SendStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$SendStmt.html
.. _RecvStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$RecvStmt.html
.. _BadStmt: https://codeql.github.com/codeql-standard-libraries/go/semmle/go/Stmt.qll/type.Stmt$BadStmt.html



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/customizing-library-models-for-javascript.rst
.. _customizing-library-models-for-javascript:

Customizing Library Models for JavaScript
=========================================

.. include:: ../reusables/beta-note-customizing-library-models.rst

JavaScript analysis can be customized by adding library models in data extension files.

A data extension for JavaScript is a YAML file of the form:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: <name of extensible predicate>
      data:
        - <tuple1>
        - <tuple2>
        - ...

The CodeQL library for JavaScript exposes the following extensible predicates:

- **sourceModel**\(type, path, kind)
- **sinkModel**\(type, path, kind)
- **typeModel**\(type1, type2, path)
- **summaryModel**\(type, path, input, output, kind)

We'll explain how to use these using a few examples, and provide some reference material at the end of this article.

Example: Taint sink in the 'execa' package
------------------------------------------

In this example, we'll show how to add the following argument, passed to **execa**, as a command-line injection sink:

.. code-block:: js

  import { shell } from "execa";
  shell(cmd); // <-- add 'cmd' as a taint sink

Note that this sink is already recognized by the CodeQL JS analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sinkModel
      data:
        - ["execa", "Member[shell].Argument[0]", "command-injection"]


- Since we're adding a new sink, we add a tuple to the **sinkModel** extensible predicate.
- The first column, **"execa"**, identifies a set of values from which to begin the search for the sink.
  The string **"execa"** means we start at the places where the codebase imports the NPM package **execa**.
- The second column is an access path that is evaluated from left to right, starting at the values that were identified by the first column.

  - **Member[shell]** selects accesses to the **shell** member of the **execa** package.
  - **Argument[0]** selects the first argument to calls to that member.

- **command-injection** indicates that this is considered a sink for the command injection query.

Example: Taint sources from window 'message' events
---------------------------------------------------

In this example, we'll show how the **event.data** expression below could be marked as a remote flow source:

.. code-block:: js

  window.addEventListener("message", function (event) {
    let data = event.data; // <-- add 'event.data' as a taint source
  });

Note that this source is already known by the CodeQL JS analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sourceModel
      data:
        - [
            "global",
            "Member[addEventListener].Argument[1].Parameter[0].Member[data]",
            "remote",
          ]


- Since we're adding a new taint source, we add a tuple to the **sourceModel** extensible predicate.
- The first column, **"global"**, begins the search at references to the global object (also known as **window** in browser contexts). This is a special JavaScript object that contains all global variables and methods.
- **Member[addEventListener]** selects accesses to the **addEventListener** member.
- **Argument[1]** selects the second argument of calls to that member (the argument containing the callback).
- **Parameter[0]** selects the first parameter of the callback (the parameter named **event**).
- **Member[data]** selects accesses to the **data** property of the event object.
- Finally, the kind **remote** indicates that this is considered a source of remote flow.

In the next section, we'll show how to restrict the model to recognize events of a specific type.

Continued example: Restricting the event type
---------------------------------------------

The model above treats all events as sources of remote flow, not just **message** events.
For example, it would also pick up this irrelevant source:

.. code-block:: js

  window.addEventListener("onclick", function (event) {
    let data = event.data; // <-- 'event.data' became a spurious taint source
  });


We can refine the model by adding the **WithStringArgument** component to restrict the set of calls being considered:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sourceModel
      data:
        - [
            "global",
            "Member[addEventListener].WithStringArgument[0=message].Argument[1].Parameter[0].Member[data]",
            "remote",
          ]

The **WithStringArgument[0=message]** component here selects the subset of calls to **addEventListener** where the first argument is a string literal with the value **"message"**.

Example: Using types to add MySQL injection sinks
-------------------------------------------------

In this example, we'll show how to add the following SQL injection sink:

.. code-block:: ts

  import { Connection } from "mysql";

  function submit(connection: Connection, q: string) {
    connection.query(q); // <-- add 'q' as a SQL injection sink
  }

We can recognize this using the following extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sinkModel
      data:
        - ["mysql.Connection", "Member[query].Argument[0]", "sql-injection"]


- The first column, **"mysql.Connection"**, begins the search at any expression whose value is known to be an instance of
  the **Connection** type from the **mysql** package. This will select the **connection** parameter above because of its type annotation.
- **Member[query]** selects the **query** member from the connection object.
- **Argument[0]** selects the first argument of a call to that member.
- **sql-injection** indicates that this is considered a sink for the SQL injection query.

This works in this example because the **connection** parameter has a type annotation that matches what the model is looking for.

Note that there is a significant difference between the following two rows:

.. code-block:: yaml

        data:
        - ["mysql.Connection", "", ...]
        - ["mysql", "Member[Connection]", ...]

The first row matches instances of **mysql.Connection**, which are objects that encapsulate a MySQL connection.
The second row would match something like **require('mysql').Connection**, which is not itself a connection object.

In the next section, we'll show how to generalize the model to handle the absence of type annotations.

Continued example: Dealing with untyped code
--------------------------------------------

Suppose we want the model from above to detect the sink in this snippet:

.. code-block:: js

  import { getConnection } from "@example/db";
  let connection = getConnection();
  connection.query(q); // <-- add 'q' as a SQL injection sink

There is no type annotation on **connection**, and there is no indication of what **getConnection()** returns.
Using a **typeModel** tuple we can tell our model that this function returns an instance of **mysql.Connection**:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: typeModel
      data:
        - ["mysql.Connection", "@example/db", "Member[getConnection].ReturnValue"]


- Since we're providing type information, we add a tuple to the **typeModel** extensible predicate.
- The first column, **"mysql.Connection"**, names the type that we're adding a new definition for.
- The second column, **"@example/db"**, begins the search at imports of the hypothetical NPM package **@example/db**.
- **Member[getConnection]** selects references to the **getConnection** member from that package.
- **ReturnValue** selects the return value from a call to that member.

The new model states that the return value of **getConnection()** has type **mysql.Connection**.
Combining this with the sink model we added earlier, the sink in the example is detected by the model.

The mechanism used here is how library models work for both TypeScript and plain JavaScript.
A good library model contains **typeModel** tuples to ensure it works even in codebases without type annotations.
For example, the **mysql** model that is included with the CodeQL JS analysis includes this type definition (among many others):

.. code-block:: yaml

  - ["mysql.Connection", "mysql", "Member[createConnection].ReturnValue"]

Example: Using fuzzy models to simplify modeling
------------------------------------------------

In this example, we'll show how to add the following SQL injection sink using a "fuzzy" model:

.. code-block:: ts

  import * as mysql from 'mysql';
  const pool = mysql.createPool({...});
  pool.getConnection((err, conn) => {
    conn.query(q, (err, rows) => {...}); // <-- add 'q' as a SQL injection sink
  });

We can recognize this using a fuzzy model, as shown in the following extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sinkModel
      data:
        - ["mysql", "Fuzzy.Member[query].Argument[0]", "sql-injection"]

- The first column, **"mysql"**, begins the search at places where the `mysql` package is imported.
- **Fuzzy** selects all objects that appear to originate from the `mysql` package, such as the `pool`, `conn`, `err`, and `rows` objects.
- **Member[query]** selects the **query** member from any of those objects. In this case, the only such member is `conn.query`.
  In principle, this would also find expressions such as `pool.query` and `err.query`, but in practice such expressions
  are not likely to occur, because the `pool` and `err` objects do not have a member named `query`.
- **Argument[0]** selects the first argument of a call to the selected member, that is, the `q` argument to `conn.query`.
- **sql-injection** indicates that this is considered as a sink for the SQL injection query.

For reference, a more detailed model might look like this, as described in the preceding examples:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sinkModel
      data:
        - ["mysql.Connection", "Member[query].Argument[0]", "sql-injection"]

    - addsTo:
        pack: codeql/javascript-all
        extensible: typeModel
      data:
        - ["mysql.Pool", "mysql", "Member[createPool].ReturnValue"]
        - ["mysql.Connection", "mysql.Pool", "Member[getConnection].Argument[0].Parameter[1]"]

The model using the **Fuzzy** component is simpler, at the cost of being approximate.
This technique is useful when modeling a large or complex library, where it is difficult to write a detailed model.

Example: Adding flow through 'decodeURIComponent'
-------------------------------------------------

In this example, we'll show how to add flow through calls to `decodeURIComponent`:

.. code-block:: js

  let y = decodeURIComponent(x); // add taint flow from 'x' to 'y'

Note that this flow is already recognized by the CodeQL JS analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: summaryModel
      data:
        - [
            "global",
            "Member[decodeURIComponent]",
            "Argument[0]",
            "ReturnValue",
            "taint",
          ]


- Since we're adding flow through a function call, we add a tuple to the **summaryModel** extensible predicate.
- The first column, **"global"**, begins the search for relevant calls at references to the global object.
  In JavaScript, global variables are properties of the global object, so this lets us access global variables or functions.
- The second column, **Member[decodeURIComponent]**, is a path leading to the function calls we wish to model.
  In this case, we select references to the **decodeURIComponent** member from the global object, that is,
  the global variable named **decodeURIComponent**.
- The third column, **Argument[0]**, indicates the input of the flow. In this case, the first argument to the function call.
- The fourth column, **ReturnValue**, indicates the output of the flow. In this case, the return value of the function call.
- The last column, **taint**, indicates the kind of flow to add. The value **taint** means the output is not necessarily equal
  to the input, but was derived from the input in a taint-preserving way.

Example: Adding flow through 'underscore.forEach'
-------------------------------------------------

In this example, we'll show how to add flow through calls to **forEach** from the **underscore** package:

.. code-block:: js

  require('underscore').forEach([x, y], (v) => { ... }); // add value flow from 'x' and 'y' to 'v'

Note that this flow is already recognized by the CodeQL JS analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: summaryModel
      data:
        - [
            "underscore",
            "Member[forEach]",
            "Argument[0].ArrayElement",
            "Argument[1].Parameter[0]",
            "value",
          ]


- Since we're adding flow through a function call, we add a tuple to the **summaryModel** extensible predicate.
- The first column, **"underscore"**, begins the search for relevant calls at places where the **underscore** package is imported.
- The second column, **Member[forEach]**, selects references to the **forEach** member from the **underscore** package.
- The third column specifies the input of the flow:

  - **Argument[0]** selects the first argument of **forEach**, which is the array being iterated over.
  - **ArrayElement** selects the elements of that array (the expressions **x** and **y**).

- The fourth column specifies the output of the flow:

  - **Argument[1]** selects the second argument of **forEach** (the argument containing the callback function).
  - **Parameter[0]** selects the first parameter of the callback function (the parameter named **v**).

- The last column, **value**, indicates the kind of flow to add. The value **value** means the input value is unchanged as
  it flows to the output.

Reference material
------------------

The following sections provide reference material for extensible predicates, access paths, types, and kinds.

Extensible predicates
---------------------

sourceModel(type, path, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new taint source. Most taint-tracking queries will use the new source.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to the source.
- **kind**: Kind of source to add. Currently only **remote** is used.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sourceModel
      data:
        - ["global", "Member[user].Member[name]", "remote"]

sinkModel(type, path, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new taint sink. Sinks are query-specific and will typically affect one or two queries.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to the sink.
- **kind**: Kind of sink to add. See the section on sink kinds for a list of supported kinds.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: sinkModel
      data:
        - ["global", "Member[eval].Argument[0]", "code-injection"]

summaryModel(type, path, input, output, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds flow through a function call.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to a function call.
- **input**: Path relative to the function call that leads to input of the flow.
- **output**: Path relative to the function call leading to the output of the flow.
- **kind**: Kind of summary to add. Can be **taint** for taint-propagating flow, or **value** for value-preserving flow.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/javascript-all
        extensible: summaryModel
      data:
        - [
            "global",
            "Member[decodeURIComponent]",
            "Argument[0]",
            "ReturnValue",
            "taint",
          ]

typeModel(type1, type2, path)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new definition of a type.

- **type1**: Name of the type to define.
- **type2**: Name of the type from which to evaluate **path**.
- **path**: Access path leading from **type2** to **type1**.

Example:

.. code-block:: yaml

  extensions:
  - addsTo:
      pack: codeql/javascript-all
      extensible: typeModel
    data:
      - [
          "mysql.Connection",
          "@example/db",
          "Member[getConnection].ReturnValue",
        ]

Types
-----

A type is a string that identifies a set of values.
In each of the extensible predicates mentioned in previous section, the first column is always the name of a type.
A type can be defined by adding **typeModel** tuples for that type. Additionally, the following built-in types are available:

- The name of an NPM package matches imports of that package. For example, the type **express** matches the expression **require("express")**. If the package name includes dots, it must be surrounded by single quotes, such as in **'lodash.escape'**.
- The type **global** identifies the global object, also known as **window**. In JavaScript, global variables are properties of the global object, so global variables can be identified using this type. (This type also matches imports of the NPM package named **global**, which is a package that happens to export the global object.)
- A qualified type name of form **<package>.<type>** identifies expressions of type **<type>** from **<package>**. For example, **mysql.Connection** identifies expression of type **Connection** from the **mysql** package. Note that this only works if type annotations are present in the codebase, or if sufficient **typeModel** tuples have been provided for that type.

Access paths
------------

The **path**, **input**, and **output** columns consist of a **.**-separated list of components, which is evaluated from left to right, with each step selecting a new set of values derived from the previous set of values.

The following components are supported:

- **Argument[**\ `number`\ **]** selects the argument at the given index.
- **Argument[this]** selects the receiver of a method call.
- **Parameter[**\ `number`\ **]** selects the parameter at the given index.
- **Parameter[this]** selects the **this** parameter of a function.
- **ReturnValue** selects the return value of a function or call.
- **Member[**\ `name`\ **]** selects the property with the given name.
- **AnyMember** selects any property regardless of name.
- **ArrayElement** selects an element of an array.
- **Element** selects an element of an array, iterator, or set object.
- **MapValue** selects a value of a map object.
- **Awaited** selects the value of a promise.
- **Instance** selects instances of a class, including instances of its subclasses.
- **Fuzzy** selects all values that are derived from the current value through a combination of the other operations described in this list.
  For example, this can be used to find all values that appear to originate from a particular package. This can be useful for finding method calls
  from a known package, but where the receiver type is not known or is difficult to model.

The following components are called "call site filters". They select a subset of the previously-selected calls, if the call fits certain criteria:

- **WithArity[**\ `number`\ **]** selects the subset of calls that have the given number of arguments.
- **WithStringArgument[**\ `number`\ **=**\ `value`\ **]** selects the subset of calls where the argument at the given index is a string literal with the given value.

Components related to decorators:

- **DecoratedClass** selects a class that has the current value as a decorator. For example, **Member[Component].DecoratedClass** selects any class that is decorated with **@Component**.
- **DecoratedParameter** selects a parameter that is decorated by the current value.
- **DecoratedMember** selects a method, field, or accessor that is decorated by the current value.

Additional notes about the syntax of operands:

- Multiple operands may be given to a single component, as a shorthand for the union of the operands. For example, **Member[foo,bar]** matches the union of **Member[foo]** and **Member[bar]**.
- Numeric operands to **Argument**, **Parameter**, and **WithArity** may be given as an interval. For example, **Argument[0..2]** matches argument 0, 1, or 2.
- **Argument[N-1]** selects the last argument of a call, and **Parameter[N-1]** selects the last parameter of a function, with **N-2** being the second-to-last and so on.

Kinds
-----

Source kinds
~~~~~~~~~~~~

- **remote**: A generic source of remote flow. Most taint-tracking queries will use such a source. Currently this is the only supported source kind.

Sink kinds
~~~~~~~~~~

Unlike sources, sinks tend to be highly query-specific, rarely affecting more than one or two queries. Not every query supports customizable sinks. If the following sinks are not suitable for your use case, you should add a new query.

- **code-injection**: A sink that can be used to inject code, such as in calls to **eval**.
- **command-injection**: A sink that can be used to inject shell commands, such as in calls to **child_process.spawn**.
- **path-injection**: A sink that can be used for path injection in a file system access, such as in calls to **fs.readFile**.
- **sql-injection**: A sink that can be used for SQL injection, such as in a MySQL **query** call.
- **nosql-injection**: A sink that can be used for NoSQL injection, such as in a MongoDB **findOne** call.
- **html-injection**: A sink that can be used for HTML injection, such as in a jQuery **$()** call.
- **request-forgery**: A sink that controls the URL of a request, such as in a **fetch** call.
- **url-redirection**: A sink that can be used to redirect the user to a malicious URL.
- **unsafe-deserialization**: A deserialization sink that can lead to code execution or other unsafe behaviour, such as an unsafe YAML parser.
- **log-injection**: A sink that can be used for log injection, such as in a **console.log** call.

Summary kinds
~~~~~~~~~~~~~

- **taint**: A summary that propagates taint. This means the output is not necessarily equal to the input, but it was derived from the input in an unrestrictive way. An attacker who controls the input will have significant control over the output as well.
- **value**: A summary that preserves the value of the input or creates a copy of the input such that all of its object properties are preserved.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/abstract-syntax-tree-classes-for-working-with-java-programs.rst
.. _abstract-syntax-tree-classes-for-working-with-java-programs:

Abstract syntax tree classes for working with Java and Kotlin programs
======================================================================

CodeQL has a large selection of classes for representing the abstract syntax tree of Java and Kotlin programs.

.. include:: ../reusables/abstract-syntax-tree.rst

.. include:: ../reusables/kotlin-java-differences.rst

Statement classes
-----------------

This table lists all subclasses of `Stmt`_.

+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
|                                  Statement syntax                                  |          CodeQL class           |          Superclasses           |                  Remarks                   |
+====================================================================================+=================================+=================================+============================================+
| ``;``                                                                              | EmptyStmt_                      |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| `Expr`_ ``;``                                                                      | ExprStmt_                       |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``{`` `Stmt`_  ``... }``                                                           | BlockStmt_                      |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``if (`` `Expr`_ ``)`` `Stmt`_  ``else`` `Stmt`_                                   | IfStmt_                         | `ConditionalStmt`_              |                                            |
+------------------------------------------------------------------------------------+                                 |                                 |                                            |
| ``if (`` `Expr`_ ``)`` `Stmt`_                                                     |                                 |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``while (`` `Expr`_ ``)`` `Stmt`_                                                  | WhileStmt_                      | `ConditionalStmt`_, `LoopStmt`_ |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``do`` `Stmt`_  ``while (`` `Expr`_ ``)``                                          | DoStmt_                         | `ConditionalStmt`_, `LoopStmt`_ |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``for (`` `Expr`_ ``;`` `Expr`_ ``;`` `Expr`_ ``)`` `Stmt`_                        | ForStmt_                        | `ConditionalStmt`_, `LoopStmt`_ |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``for (`` `VarAccess`_ ``:`` `Expr`_ ``)`` `Stmt`_                                 | EnhancedForStmt_                | `LoopStmt`_                     |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``switch (`` `Expr`_ ``) {`` `SwitchCase`_ ``... }``                               | SwitchStmt_                     |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``try {`` `Stmt`_  ``... } finally {`` `Stmt`_  ``... }``                          | TryStmt_                        |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``return`` `Expr`_ ``;``                                                           | ReturnStmt_                     |                                 |                                            |
+------------------------------------------------------------------------------------+                                 |                                 |                                            |
| ``return ;``                                                                       |                                 |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``throw`` `Expr`_ ``;``                                                            | ThrowStmt_                      |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``break ;``                                                                        | BreakStmt_                      | `JumpStmt`_                     |                                            |
+------------------------------------------------------------------------------------+                                 |                                 |                                            |
| ``break label ;``                                                                  |                                 |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``continue ;``                                                                     | ContinueStmt_                   | `JumpStmt`_                     |                                            |
+------------------------------------------------------------------------------------+                                 |                                 |                                            |
| ``continue label ;``                                                               |                                 |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``label :`` `Stmt`_                                                                | LabeledStmt_                    |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``synchronized (`` `Expr`_ ``)`` `Stmt`_                                           | SynchronizedStmt_               |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``assert`` `Expr`_ ``:`` `Expr`_ ``;``                                             | AssertStmt_                     |                                 |                                            |
+------------------------------------------------------------------------------------+                                 |                                 |                                            |
| ``assert`` `Expr`_ ``;``                                                           |                                 |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| `TypeAccess`_ ``name ;``                                                           | LocalVariableDeclStmt_          |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``class name {`` `Member`_ ``... } ;``                                             | LocalClassDeclStmt_             |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``this (`` `Expr`_ ``, ... ) ;``                                                   | ThisConstructorInvocationStmt_  |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``super (`` `Expr`_ ``, ... ) ;``                                                  | SuperConstructorInvocationStmt_ |                                 |                                            |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``catch (`` `TypeAccess`_ ``name ) {`` `Stmt`_  ``... }``                          | CatchClause_                    |                                 | can only occur as child of a `TryStmt`_    |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``case`` `Literal`_ ``:`` `Stmt`_  ``...``                                         | ConstCase_                      |                                 | can only occur as child of a `SwitchStmt`_ |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+
| ``default :`` `Stmt`_  ``...``                                                     | DefaultCase_                    |                                 | can only occur as child of a `SwitchStmt`_ |
+------------------------------------------------------------------------------------+---------------------------------+---------------------------------+--------------------------------------------+

Expression classes
------------------

There are many expression classes, so we present them by category. All classes in this section are subclasses of Expr_.

Literals
~~~~~~~~

All classes in this subsection are subclasses of Literal_.

+---------------------------+-------------------------+
| Expression syntax example |      CodeQL class       |
+===========================+=========================+
| ``true``                  | `BooleanLiteral`_       |
+---------------------------+-------------------------+
| ``23``                    | `IntegerLiteral`_       |
+---------------------------+-------------------------+
| ``23l``                   | `LongLiteral`_          |
+---------------------------+-------------------------+
| ``4.2f``                  | `FloatingPointLiteral`_ |
+---------------------------+-------------------------+
| ``4.2``                   | `DoubleLiteral`_        |
+---------------------------+-------------------------+
| ``'a'``                   | `CharacterLiteral`_     |
+---------------------------+-------------------------+
| ``"Hello"``               | `StringLiteral`_        |
+---------------------------+-------------------------+
| ``null``                  | `NullLiteral`_          |
+---------------------------+-------------------------+

Unary expressions
~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of UnaryExpr_.

+-------------------+----------------+--------------------+--------------------------------------------------+
| Expression syntax |  CodeQL class  |    Superclasses    |                     Remarks                      |
+===================+================+====================+==================================================+
| `Expr`_\ ``++``   | `PostIncExpr`_ | `UnaryAssignExpr`_ |                                                  |
+-------------------+----------------+--------------------+--------------------------------------------------+
| `Expr`_\ ``--``   | `PostDecExpr`_ | `UnaryAssignExpr`_ |                                                  |
+-------------------+----------------+--------------------+--------------------------------------------------+
| ``++``\ `Expr`_   | `PreIncExpr`_  | `UnaryAssignExpr`_ |                                                  |
+-------------------+----------------+--------------------+--------------------------------------------------+
| ``--``\ `Expr`_   | `PreDecExpr`_  | `UnaryAssignExpr`_ |                                                  |
+-------------------+----------------+--------------------+--------------------------------------------------+
| ``~``\ `Expr`_    | `BitNotExpr`_  | `BitwiseExpr`_     | see below for other subclasses of `BitwiseExpr`_ |
+-------------------+----------------+--------------------+--------------------------------------------------+
| ``-``\ `Expr`_    | `MinusExpr`_   |                    |                                                  |
+-------------------+----------------+--------------------+--------------------------------------------------+
| ``+``\ `Expr`_    | `PlusExpr`_    |                    |                                                  |
+-------------------+----------------+--------------------+--------------------------------------------------+
| ``!``\ `Expr`_    | `LogNotExpr`_  | `LogicExpr`_       | see below for other subclasses of `LogicExpr`_   |
+-------------------+----------------+--------------------+--------------------------------------------------+

Binary expressions
~~~~~~~~~~~~~~~~~~

All classes in this subsection are subclasses of BinaryExpr_.

+-------------------------+-------------------+-------------------+
|    Expression syntax    |   CodeQL class    |   Superclasses    |
+=========================+===================+===================+
| `Expr`_ ``*`` `Expr`_   | `MulExpr`_        |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``/`` `Expr`_   | `DivExpr`_        |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``%`` `Expr`_   | `RemExpr`_        |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``+`` `Expr`_   | `AddExpr`_        |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``-`` `Expr`_   | `SubExpr`_        |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``<<`` `Expr`_  | `LShiftExpr`_     |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``>>`` `Expr`_  | `RShiftExpr`_     |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``>>>`` `Expr`_ | `URShiftExpr`_    |                   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``&&`` `Expr`_  | `AndLogicalExpr`_ | `LogicExpr`_      |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``||``  `Expr`_ | `OrLogicalExpr`_  | `LogicExpr`_      |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``<`` `Expr`_   | `LTExpr`_         | `ComparisonExpr`_ |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``>`` `Expr`_   | `GTExpr`_         | `ComparisonExpr`_ |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``<=`` `Expr`_  | `LEExpr`_         | `ComparisonExpr`_ |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``>=`` `Expr`_  | `GEExpr`_         | `ComparisonExpr`_ |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``==`` `Expr`_  | `EQExpr`_         | `EqualityTest`_   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``!=`` `Expr`_  | `NEExpr`_         | `EqualityTest`_   |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``&`` `Expr`_   | `AndBitwiseExpr`_ | `BitwiseExpr`_    |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``|`` `Expr`_   | `OrBitwiseExpr`_  | `BitwiseExpr`_    |
+-------------------------+-------------------+-------------------+
| `Expr`_ ``^`` `Expr`_   | `XorBitwiseExpr`_ | `BitwiseExpr`_    |
+-------------------------+-------------------+-------------------+

Assignment expressions
~~~~~~~~~~~~~~~~~~~~~~

All classes in this table are subclasses of Assignment_.

+--------------------------+----------------------+-----------------+
|    Expression syntax     |     CodeQL class     |  Superclasses   |
+==========================+======================+=================+
| `Expr`_ ``=`` `Expr`_    | `AssignExpr`_        |                 |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``+=`` `Expr`_   | `AssignAddExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``-=`` `Expr`_   | `AssignSubExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``*=`` `Expr`_   | `AssignMulExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``/=`` `Expr`_   | `AssignDivExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``%=`` `Expr`_   | `AssignRemExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``&=`` `Expr`_   | `AssignAndExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``|=`` `Expr`_   | `AssignOrExpr`_      | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``^=`` `Expr`_   | `AssignXorExpr`_     | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``<<=`` `Expr`_  | `AssignLShiftExpr`_  | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``>>=`` `Expr`_  | `AssignRShiftExpr`_  | `AssignOp`_     |
+--------------------------+----------------------+-----------------+
| `Expr`_ ``>>>=`` `Expr`_ | `AssignURShiftExpr`_ | `AssignOp`_     |
+--------------------------+----------------------+-----------------+

Accesses
~~~~~~~~

+--------------------------------+---------------------+
|   Expression syntax examples   |    CodeQL class     |
+================================+=====================+
| ``this``                       | ThisAccess_         |
+--------------------------------+                     |
| ``Outer.this``                 |                     |
+--------------------------------+---------------------+
| ``super``                      | SuperAccess_        |
+--------------------------------+                     |
| ``Outer.super``                |                     |
+--------------------------------+---------------------+
| ``x``                          | VarAccess_          |
+--------------------------------+                     |
| ``e.f``                        |                     |
+--------------------------------+---------------------+
| ``a[i]``                       | ArrayAccess_        |
+--------------------------------+---------------------+
| ``f(...)``                     | MethodAccess_       |
+--------------------------------+                     |
| ``e.m(...)``                   |                     |
+--------------------------------+---------------------+
| ``String``                     | TypeAccess_         |
+--------------------------------+                     |
| ``java.lang.String``           |                     |
+--------------------------------+---------------------+
| ``? extends Number``           | WildcardTypeAccess_ |
+--------------------------------+                     |
| ``? super Double``             |                     |
+--------------------------------+---------------------+

A VarAccess_ that refers to a field is a FieldAccess_.

Miscellaneous
~~~~~~~~~~~~~

+-------------------------------------+--------------------+----------------------------------------------------------------------------+
|     Expression syntax examples      |    CodeQL class    | Remarks                                                                    |
+=====================================+====================+============================================================================+
| ``(int) f``                         | CastExpr_          |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| ``o instanceof String``             | InstanceOfExpr_    |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| `Expr`_ ``?`` `Expr`_ ``:`` `Expr`_ | ConditionalExpr_   |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| ``String. class``                   | TypeLiteral_       |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| ``new A()``                         | ClassInstanceExpr_ |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| ``new String[3][2]``                | ArrayCreationExpr_ |                                                                            |
+-------------------------------------+                    |                                                                            |                                          
| ``new int[] { 23, 42 }``            |                    |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| ``{ 23, 42 }``                      | ArrayInit_         | can only appear as an initializer or as a child of an `ArrayCreationExpr`_ |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+
| ``@Annot(key=val)``                 | Annotation_        |                                                                            |
+-------------------------------------+--------------------+----------------------------------------------------------------------------+

Further reading
---------------

.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Links used in tables. For information about using these links, see
   https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html#hyperlinks.

.. _Expr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$Expr.html
.. _Stmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$Stmt.html
.. _VarAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$VarAccess.html
.. _SwitchCase: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$SwitchCase.html
.. _TypeAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$TypeAccess.html
.. _Member: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Member.qll/type.Member$Member.html
.. _Literal: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$Literal.html
.. _ConditionalStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ConditionalStmt.html
.. _LoopStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$LoopStmt.html
.. _JumpStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$JumpStmt.html
.. _TryStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$TryStmt.html
.. _SwitchStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$SwitchStmt.html
.. _BooleanLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$BooleanLiteral.html
.. _IntegerLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$IntegerLiteral.html
.. _LongLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$LongLiteral.html
.. _FloatingPointLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$FloatingPointLiteral.html
.. _DoubleLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$DoubleLiteral.html
.. _CharacterLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$CharacterLiteral.html
.. _StringLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$StringLiteral.html
.. _NullLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$NullLiteral.html
.. _PostIncExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$PostIncExpr.html
.. _PostDecExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$PostDecExpr.html
.. _PreIncExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$PreIncExpr.html
.. _PreDecExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$PreDecExpr.html
.. _BitNotExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$BitNotExpr.html
.. _MinusExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$MinusExpr.html
.. _PlusExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$PlusExpr.html
.. _LogNotExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$LogNotExpr.html
.. _UnaryAssignExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$UnaryAssignExpr.html
.. _BitwiseExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$BitwiseExpr.html
.. _LogicExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$LogicExpr.html
.. _MulExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$MulExpr.html
.. _DivExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$DivExpr.html
.. _RemExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$RemExpr.html
.. _AddExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AddExpr.html
.. _SubExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$SubExpr.html
.. _LShiftExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$LShiftExpr.html
.. _RShiftExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$RShiftExpr.html
.. _URShiftExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$URShiftExpr.html
.. _AndLogicalExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AndLogicalExpr.html
.. _OrLogicalExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$OrLogicalExpr.html
.. _LTExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$LTExpr.html
.. _GTExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$GTExpr.html
.. _LEExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$LEExpr.html
.. _GEExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$GEExpr.html
.. _EQExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$EQExpr.html
.. _NEExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$NEExpr.html
.. _AndBitwiseExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AndBitwiseExpr.html
.. _OrBitwiseExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$OrBitwiseExpr.html
.. _XorBitwiseExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$XorBitwiseExpr.html
.. _ComparisonExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ComparisonExpr.html
.. _EqualityTest: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$EqualityTest.html
.. _AssignExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignExpr.html
.. _AssignAddExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignAddExpr.html
.. _AssignSubExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignSubExpr.html
.. _AssignMulExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignMulExpr.html
.. _AssignDivExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignDivExpr.html
.. _AssignRemExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignRemExpr.html
.. _AssignAndExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignAndExpr.html
.. _AssignOrExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignOrExpr.html
.. _AssignXorExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignXorExpr.html
.. _AssignLShiftExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignLShiftExpr.html
.. _AssignRShiftExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignRShiftExpr.html
.. _AssignURShiftExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignURShiftExpr.html
.. _AssignOp: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$AssignOp.html
.. _ArrayCreationExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ArrayCreationExpr.html
.. _EmptyStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$EmptyStmt.html
.. _ExprStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ExprStmt.html
.. _BlockStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$BlockStmt.html
.. _IfStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$IfStmt.html
.. _WhileStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$WhileStmt.html
.. _DoStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$DoStmt.html
.. _ForStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ForStmt.html
.. _EnhancedForStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$EnhancedForStmt.html
.. _ReturnStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ReturnStmt.html
.. _ThrowStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ThrowStmt.html
.. _BreakStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$BreakStmt.html
.. _ContinueStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ContinueStmt.html
.. _LabeledStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$LabeledStmt.html
.. _SynchronizedStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$SynchronizedStmt.html
.. _AssertStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$AssertStmt.html
.. _LocalVariableDeclStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$LocalVariableDeclStmt.html
.. _LocalClassDeclStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$LocalClassDeclStmt.html
.. _ThisConstructorInvocationStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ThisConstructorInvocationStmt.html
.. _SuperConstructorInvocationStmt: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$SuperConstructorInvocationStmt.html
.. _CatchClause: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$CatchClause.html
.. _ConstCase: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$ConstCase.html
.. _DefaultCase: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Statement.qll/type.Statement$DefaultCase.html
.. _UnaryExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$UnaryExpr.html
.. _BinaryExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$BinaryExpr.html
.. _Assignment: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$Assignment.html
.. _ThisAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ThisAccess.html
.. _SuperAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$SuperAccess.html
.. _ArrayAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ArrayAccess.html
.. _MethodAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$MethodAccess.html
.. _WildcardTypeAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$WildcardTypeAccess.html
.. _FieldAccess: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$FieldAccess.html
.. _CastExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$CastExpr.html
.. _InstanceOfExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$InstanceOfExpr.html
.. _ConditionalExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ConditionalExpr.html
.. _TypeLiteral: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$TypeLiteral.html
.. _ClassInstanceExpr: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ClassInstanceExpr.html
.. _ArrayInit: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Expr.qll/type.Expr$ArrayInit.html
.. _Annotation: https://codeql.github.com/codeql-standard-libraries/java/semmle/code/java/Annotation.qll/type.Annotation$Annotation.html



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/functions-in-cpp.rst
.. _functions-in-cpp:

Functions in C and C++
=======================

You can use CodeQL to explore functions in C and C++ code.

Overview
--------

The standard CodeQL library for C and C++ represents functions using the ``Function`` class (see :doc:`CodeQL libraries for C and C++ <codeql-library-for-cpp>`).

The example queries in this topic explore some of the most useful library predicates for querying functions.

Finding all static functions
----------------------------

Using the member predicate ``Function.isStatic()`` we can list all the static functions in a database:

.. code-block:: ql

   import cpp

   from Function f
   where f.isStatic()
   select f, "This is a static function."

This query is very general, so there are probably too many results to be interesting for most nontrivial projects.

Finding functions that are not called
-------------------------------------

It might be more interesting to find functions that are not called, using the standard CodeQL ``FunctionCall`` class from the **abstract syntax tree** category (see :doc:`CodeQL libraries for C and C++ <codeql-library-for-cpp>`). The ``FunctionCall`` class can be used to identify places where a function is actually used, and it is related to ``Function`` through the ``FunctionCall.getTarget()`` predicate.

.. code-block:: ql

   import cpp

   from Function f
   where not exists(FunctionCall fc | fc.getTarget() = f)
   select f, "This function is never called."

The new query finds functions that are not the target of any ``FunctionCall``—in other words, functions that are never called. You may be surprised by how many results the query finds. However, if you examine the results, you can see that many of the functions it finds are used indirectly. To create a query that finds only unused functions, we need to refine the query and exclude other ways of using a function.

Excluding functions that are referenced with a function pointer
---------------------------------------------------------------

You can modify the query to remove functions where a function pointer is used to reference the function:

.. code-block:: ql

   import cpp

   from Function f
   where not exists(FunctionCall fc | fc.getTarget() = f)
     and not exists(FunctionAccess fa | fa.getTarget() = f)
   select f, "This function is never called, or referenced with a function pointer."

This query returns fewer results. However, if you examine the results then you can probably still find potential refinements.

For example, there is a more complicated standard query, `Unused static function <https://codeql.github.com/codeql-query-help/cpp/cpp-unused-static-function/>`__, that finds unused static functions.

   You can explore the definition of an element in the standard libraries and see what predicates are available. Right-click the element to display the context menu, and click **Go to Definition**. The library file is opened in a new tab with the definition of the element highlighted.

Finding a specific function
---------------------------

This query uses ``Function`` and ``FunctionCall`` to find calls to the function ``sprintf`` that have a variable format string—which is potentially a security hazard.

.. code-block:: ql

   import cpp

   from FunctionCall fc
   where fc.getTarget().getQualifiedName() = "sprintf"
     and not fc.getArgument(1) instanceof StringLiteral
   select fc, "sprintf called with variable format string."

This uses:

-  ``Declaration.getQualifiedName()`` to identify calls to the specific function ``sprintf``.
-  ``FunctionCall.getArgument(1)`` to fetch the format string argument.

Note that we could have used ``Declaration.getName()``, but ``Declaration.getQualifiedName()`` is a better choice because it includes the namespace. For example: ``getName()`` would return ``vector`` where ``getQualifiedName`` would return ``std::vector``.

The published version of this query is considerably more complicated, but if you look carefully you will find that its structure is the same. See `Non-constant format string <https://codeql.github.com/codeql-query-help/cpp/cpp-non-constant-format/>`__.

Further reading
---------------

.. include:: ../reusables/cpp-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-go-code.rst
.. _basic-query-for-go-code:

Basic query for Go code
=======================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run searches the code for methods defined on value types that modify their receiver by writing a field:

.. code-block:: go

   func (s MyStruct) valueMethod() { s.f = 1 } // method on value

This is problematic because the receiver argument is passed by value, not by reference. Consequently, valueMethod is called with a copy of the receiver object, so any changes it makes to the receiver will be invisible to the caller. To prevent this, the method should be defined on a pointer instead:

.. code-block:: go

   func (s *MyStruct) pointerMethod() { s.f = 1 } // method on pointer

For further information on using methods on values or pointers in Go, see the `Go FAQ <https://golang.org/doc/faq#methods_on_values_or_pointers>`__.

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete ``select ""`` and paste the following query beneath the import statement ``import go``.

   .. code-block:: ql

      from Method m, Variable recv, Write w, Field f
      where
        recv = m.getReceiver() and
        w.writesField(recv.getARead(), f, _) and
        not recv.getType() instanceof PointerType
      select w, "This update to " + f + " has no effect, because " + recv + " is not a pointer."

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-go-query-results-1.png
   :align: center

If any matching code is found, click a link in the ``w`` column to open the file and highlight the matching location.

.. image:: ../images/codeql-for-visual-studio-code/basic-go-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| Query part                                                    | Purpose                                                                                                           | Details                                                                                                                              |
+===============================================================+===================================================================================================================+======================================================================================================================================+
| ``import go``                                                 | Imports the standard CodeQL libraries for Go.                                                                     | Every query begins with one or more ``import`` statements.                                                                           |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| ``from Method m, Variable recv, Write w, Field f``            | Defines the variables for the query.                                                                              | We declare:                                                                                                                          |
|                                                               | Declarations are of the form:                                                                                     |                                                                                                                                      |
|                                                               | ``<type> <variable name>``                                                                                        | - ``m`` as a variable for all methods                                                                                                |
|                                                               |                                                                                                                   | - a ``recv`` variable, which is the receiver of ``m``                                                                                |
|                                                               |                                                                                                                   | - ``w`` as the location in the code where the receiver is modified                                                                   |
|                                                               |                                                                                                                   | - ``f`` as the field that is written when ``m`` is called                                                                            |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| ``where recv = m.getReceiver() and                            | Defines a condition on the variables.                                                                             | ``recv = m.getReceiver()`` states that ``recv`` must be the receiver variable of ``m``.                                              |
| w.writesField(recv.getARead(), f, _) and                      |                                                                                                                   |                                                                                                                                      |
| not recv.getType() instanceof PointerType``                   |                                                                                                                   | ``w.writesField(recv.getARead(), f, _)`` states that ``w`` must be a location in the code where field ``f`` of ``recv`` is modified. |
|                                                               |                                                                                                                   | We use a :ref:`'don't-care' expression <don-t-care-expressions>` ``_``                                                               |
|                                                               |                                                                                                                   | for the value that is written to ``f``—the actual value doesn't matter in this query.                                                |
|                                                               |                                                                                                                   |                                                                                                                                      |
|                                                               |                                                                                                                   | ``not recv.getType() instanceof PointerType`` states that ``m`` is not a pointer method.                                             |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+
| ``select w, "This update to " + f +                           | Defines what to report for each match.                                                                            | Reports ``w`` with a message that explains the potential problem.                                                                    |
| " has no effect, because " + recv + " is not a pointer."``    |                                                                                                                   |                                                                                                                                      |
|                                                               | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                                                      |
|                                                               | ``select <program element>, "<alert message>"``                                                                   |                                                                                                                                      |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Among the results generated by the first iteration of this query, you can find cases where a value method is called but the receiver variable is returned. In such cases, the change to the receiver is not invisible to the caller, so a pointer method is not required. These are false positive results and you can improve the query by adding an extra condition to remove them.

To exclude these values:

#. Extend the where clause to include the following extra condition:

   .. code-block:: ql

      not exists(ReturnStmt ret | ret.getExpr() = recv.getARead().asExpr())

   The ``where`` clause is now:

   .. code-block:: ql

      where e.isPure() and
        recv = m.getReceiver() and
        w.writesField(recv.getARead(), f, _) and
        not recv.getType() instanceof PointerType and
        not exists(ReturnStmt ret | ret.getExpr() = recv.getARead().asExpr())

#. Re-run the query.

   There are now fewer results because value methods that return their receiver variable are no longer reported.

Further reading
---------------

.. include:: ../reusables/go-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: Go

.. |language-code| replace:: ``go``

.. |example-url| replace:: https://github.com/go-gorm/gorm

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-go.png

.. |result-col-1| replace:: The first column corresponds to ``w``, which is the location in the source code where the receiver ``recv`` is modified.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/codeql-library-for-typescript.rst
.. _codeql-library-for-typescript:

CodeQL library for TypeScript
=============================

When you're analyzing a TypeScript program, you can make use of the large collection of classes in the CodeQL library for TypeScript.

Overview
--------

Support for analyzing TypeScript code is bundled with the CodeQL libraries for JavaScript, so you can include the full TypeScript library by importing the ``javascript.qll`` module:

.. code-block:: ql

   import javascript

:doc:`CodeQL libraries for JavaScript <codeql-library-for-javascript>` covers most of this library, and is also relevant for TypeScript analysis. This document supplements the JavaScript documentation with the TypeScript-specific classes and predicates.

Syntax
------

Most syntax in TypeScript is represented in the same way as its JavaScript counterpart. For example, ``a+b`` is represented by an `AddExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Expr.qll/type.Expr$AddExpr.html>`__; the same as it would be in JavaScript. On the other hand, ``x as number`` is represented by `TypeAssertion <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAssertion.html>`__, a class that is specific to TypeScript.

Type annotations
~~~~~~~~~~~~~~~~

The `TypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeExpr.html>`__ class represents anything that is part of a type annotation.

Only type annotations that are explicit in the source code occur as a ``TypeExpr``. Types inferred by the TypeScript compiler are ``Type`` entities; for details about this, see the section on `static type information <#static-type-information>`__.

There are several ways to access type annotations, for example:

-  ``VariableDeclaration.getTypeAnnotation()``
-  ``Function.getReturnTypeAnnotation()``
-  ``BindingPattern.getTypeAnnotation()``
-  ``Parameter.getTypeAnnotation()`` (special case of ``BindingPattern.getTypeAnnotation()``)
-  ``VarDecl.getTypeAnnotation()`` (special case of ``BindingPattern.getTypeAnnotation()``)
-  ``FieldDeclaration.getTypeAnnotation()``

The `TypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeExpr.html>`__ class provides some convenient member predicates such as ``isString()`` and ``isVoid()`` to recognize commonly used types.

The subclasses that represent type annotations are:

-  `TypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAccess.html>`__: a name referring to a type, such as ``Date`` or ``http.ServerRequest``.

   -  `LocalTypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalTypeAccess.html>`__: an unqualified name, such as ``Date``.
   -  `QualifiedTypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$QualifiedTypeAccess.html>`__: a name prefixed by a namespace, such as ``http.ServerRequest``.
   -  `ImportTypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ImportTypeAccess.html>`__: an ``import`` used as a type, such as ``import("./foo")``.

-  `PredefinedTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$PredefinedTypeExpr.html>`__: a predefined type, such as ``number``, ``string``, ``void``, or ``any``.
-  `ThisTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ThisTypeExpr.html>`__: the ``this`` type.
-  `InterfaceTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$InterfaceTypeExpr.html>`__, also known as a literal type, such as ``{x: number}``.
-  `FunctionTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$FunctionTypeExpr.html>`__: a type such as ``(x: number) => string``.
-  `GenericTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$GenericTypeExpr.html>`__: a named type with type arguments, such as ``Array<string>``.
-  `LiteralTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LiteralTypeExpr.html>`__: a string, number, or boolean constant used as a type, such as ``'foo'``.
-  `ArrayTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ArrayTypeExpr.html>`__: a type such as ``string[]``.
-  `UnionTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$UnionTypeExpr.html>`__: a type such as ``string | number``.
-  `IntersectionTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$IntersectionTypeExpr.html>`__: a type such as ``S & T``.
-  `IndexedAccessTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$IndexedAccessTypeExpr.html>`__: a type such as ``T[K]``.
-  `ParenthesizedTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ParenthesizedTypeExpr.html>`__: a type such as ``(string)``.
-  `TupleTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TupleTypeExpr.html>`__: a type such as ``[string, number]``.
-  `KeyofTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$KeyofTypeExpr.html>`__: a type such as ``keyof T``.
-  `TypeofTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeofTypeExpr.html>`__: a type such as ``typeof x``.
-  `IsTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$IsTypeExpr.html>`__: a type such as ``x is string``.
-  `MappedTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$MappedTypeExpr.html>`__: a type such as ``{ [K in C]: T }``.

There are some subclasses that may be part of a type annotation, but are not themselves types:

-  `TypeParameter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeParameter.html>`__: a type parameter declared on a type or function, such as ``T`` in ``class C<T> {}``.
-  `NamespaceAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceAccess.html>`__: a name referring to a namespace from inside a type, such as ``http`` in ``http.ServerRequest``.

   -  `LocalNamespaceAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalNamespaceAccess.html>`__: the initial identifier in a prefix, such as ``http`` in ``http.ServerRequest``.
   -  `QualifiedNamespaceAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$QualifiedNamespaceAccess.html>`__: a qualified name in a prefix, such as ``net.client`` in ``net.client.Connection``.
   -  `ImportNamespaceAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ImportNamespaceAccess.html>`__: an ``import`` used as a namespace in a type, such as in ``import("http").ServerRequest``.

-  `VarTypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$VarTypeAccess.html>`__: a reference to a value from inside a type, such as ``x`` in ``typeof x`` or ``x is string``.

Function signatures
~~~~~~~~~~~~~~~~~~~

The `Function <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Functions.qll/type.Functions$Function.html>`__ class is a broad class that includes both concrete functions and function signatures.

Function signatures can take several forms:

-  Function types, such as ``(x: number) => string``.
-  Abstract methods, such as ``abstract foo(): void``.
-  Overload signatures, such as ``foo(x: number): number`` followed by an implementation of ``foo``.
-  Call signatures, such as in ``{ (x: string): number }``.
-  Index signatures, such as in ``{ [x: string]: number }``.
-  Functions in an ambient context, such as ``declare function foo(x: number): string``.

We recommend that you use the predicate ``Function.hasBody()`` to distinguish concrete functions from signatures.

Type parameters
~~~~~~~~~~~~~~~

The `TypeParameter <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeParameter.html>`__ class represents type parameters, and the `TypeParameterized <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeParameterized.html>`__ class represents entities that can declare type parameters. Classes, interfaces, type aliases, functions, and mapped type expressions are all ``TypeParameterized``.

You can access type parameters using the following predicates:

-  ``TypeParameterized.getTypeParameter(n)`` gets the ``n``\ th declared type parameter.
-  ``TypeParameter.getHost()`` gets the entity declaring a given type parameter.

You can access type arguments using the following predicates:

-  ``GenericTypeExpr.getTypeArgument(n)`` gets the ``n``\ th type argument of a type.
-  ``TypeAccess.getTypeArgument(n)`` is a convenient alternative for the above (a `TypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAccess.html>`__ with type arguments is wrapped in a `GenericTypeExpr <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$GenericTypeExpr.html>`__).
-  ``InvokeExpr.getTypeArgument(n)`` gets the ``n``\ th type argument of a call.
-  ``ExpressionWithTypeArguments.getTypeArgument(n)`` gets the ``n``\ th type argument of a generic superclass expression.

To select references to a given type parameter, use ``getLocalTypeName()`` (see `Name binding <#name-binding>`__ below).

Examples
^^^^^^^^

Select expressions that cast a value to a type parameter:

.. code-block:: ql

   import javascript

   from TypeParameter param, TypeAssertion assertion
   where assertion.getTypeAnnotation() = param.getLocalTypeName().getAnAccess()
   select assertion, "Cast to type parameter."

Classes and interfaces
~~~~~~~~~~~~~~~~~~~~~~

The CodeQL class `ClassOrInterface <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Classes.qll/type.Classes$ClassOrInterface.html>`__ is a common supertype of classes and interfaces, and provides some TypeScript-specific member predicates:

-  ``ClassOrInterface.isAbstract()`` holds if this is an interface or a class with the ``abstract`` modifier.
-  ``ClassOrInterface.getASuperInterface()`` gets a type from the ``implements`` clause of a class or from the ``extends`` clause of an interface.
-  ``ClassOrInterface.getACallSignature()`` gets a call signature of an interface, such as in ``{ (arg: string): number }``.
-  ``ClassOrInterface.getAnIndexSignature()`` gets an index signature, such as in ``{ [key: string]: number }``.
-  ``ClassOrInterface.getATypeParameter()`` gets a declared type parameter (special case of ``TypeParameterized.getATypeParameter()``).

Note that the superclass of a class is an expression, not a type annotation. If the superclass has type arguments, it will be an expression of kind `ExpressionWithTypeArguments <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExpressionWithTypeArguments.html>`__.

Also see the documentation for classes in the "`CodeQL libraries for JavaScript <https://codeql.github.com/docs/codeql-language-guides/codeql-library-for-javascript/#classes>`__."

To select the type references to a class or an interface, use ``getTypeName()``.

Statements
~~~~~~~~~~

The following are TypeScript-specific statements:

-  `NamespaceDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceDeclaration.html>`__: a statement such as ``namespace M {}``.
-  `EnumDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$EnumDeclaration.html>`__: a statement such as ``enum Color { red, green, blue }``.
-  `TypeAliasDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAliasDeclaration.html>`__: a statement such as ``type A = number``.
-  `InterfaceDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$InterfaceDeclaration.html>`__: a statement such as ``interface Point { x: number; y: number; }``.
-  `ImportEqualsDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ImportEqualsDeclaration.html>`__: a statement such as ``import fs = require("fs")``.
-  `ExportAssignDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExportAssignDeclaration.html>`__: a statement such as ``export = M``.
-  `ExportAsNamespaceDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExportAsNamespaceDeclaration.html>`__: a statement such as ``export as namespace M``.
-  `ExternalModuleDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExternalModuleDeclaration.html>`__: a statement such as ``module "foo" {}``.
-  `GlobalAugmentationDeclaration <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$GlobalAugmentationDeclaration.html>`__: a statement such as ``global {}``

Expressions
~~~~~~~~~~~

The following are TypeScript-specific expressions:

-  `ExpressionWithTypeArguments <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExpressionWithTypeArguments.html>`__: occurs when the ``extends`` clause of a class has type arguments, such as in ``class C extends D<string>``.
-  `TypeAssertion <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAssertion.html>`__: asserts that a value has a given type, such as ``x as number`` or ``<number> x``.
-  `NonNullAssertion <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NonNullAssertion.html>`__: asserts that a value is not null or undefined, such as ``x!``.
-  `ExternalModuleReference <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$ExternalModuleReference.html>`__: a ``require`` call on the right-hand side of an import-assign, such as ``import fs = require("fs")``.

Ambient declarations
~~~~~~~~~~~~~~~~~~~~

Type annotations, interfaces, and type aliases are considered ambient AST nodes, as is anything with a ``declare`` modifier.

The predicate ``ASTNode.isAmbient()`` can be used to determine if an AST node is ambient.

Ambient nodes are mostly ignored by control flow and data flow analysis. The outermost part of an ambient declaration has a single no-op node in the control flow graph, and it has no internal control flow.

Static type information
-----------------------

Static type information and global name binding is available for projects with "full" TypeScript extraction enabled. This option is enabled by default when you create databases with the CodeQL CLI.

Basic usage
~~~~~~~~~~~

The `Type <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$Type.html>`__ class represents a static type, such as ``number`` or ``string``. The type of an expression can be obtained with ``Expr.getType()``.

Types that refer to a specific named type can be recognized in various ways:

-  ``type.(TypeReference).hasQualifiedName(name)`` holds if the type refers to the given named type.
-  ``type.(TypeReference).hasUnderlyingType(name)`` holds if the type refers to the given named type or a transitive subtype thereof.
-  ``type.hasUnderlyingType(name)`` is like the above, but additionally holds if the reference is wrapped in a union and/or intersection type.

The ``hasQualifiedName`` and ``hasUnderlyingType`` predicates have two overloads:

-  The single-argument version takes a qualified name relative to the global scope.
-  The two-argument version takes the name of a module and qualified name relative to that module.

Example
^^^^^^^

The following query can be used to find all ``toString`` calls on a Node.js ``Buffer`` object:

.. code-block:: ql

   import javascript

   from MethodCallExpr call
   where call.getReceiver().getType().hasUnderlyingType("Buffer")
     and call.getMethodName() = "toString"
   select call

Working with types
~~~~~~~~~~~~~~~~~~

``Type`` entities are not associated with a specific source location. For instance, there can be many uses of the ``number`` keyword, but there is only one ``number`` type.

Some important member predicates of ``Type`` are:

-  ``Type.getProperty(name)`` gets the type of a named property.
-  ``Type.getMethod(name)`` gets the signature of a named method.
-  ``Type.getSignature(kind,n)`` gets the ``n``\ th overload of a call or constructor signature.
-  ``Type.getStringIndexType()`` gets the type of the string index signature.
-  ``Type.getNumberIndexType()`` gets the type of the number index signature.

A ``Type`` entity always belongs to exactly one of the following subclasses:

-  ``TypeReference``: a named type, possibly with type arguments.
-  ``UnionType``: a union type such as ``string | number``.
-  ``IntersectionType``: an intersection type such as ``T & U``.
-  ``TupleType``: a tuple type such as ``[string, number]``.
-  ``StringType``: the ``string`` type.
-  ``NumberType``: the ``number`` type.
-  ``AnyType``: the ``any`` type.
-  ``NeverType``: the ``never`` type.
-  ``VoidType``: the ``void`` type.
-  ``NullType``: the ``null`` type.
-  ``UndefinedType``: the ``undefined`` type.
-  ``ObjectKeywordType``: the ``object`` type.
-  ``SymbolType``: a ``symbol`` or ``unique symbol`` type.
-  ``AnonymousInterfaceType``: an anonymous type such as ``{x: number}``.
-  ``TypeVariableType``: a reference to a type variable.
-  ``ThisType``: the ``this`` type within a specific type.
-  ``TypeofType``: the type of a named value, such as ``typeof X``.
-  ``BooleanLiteralType``: the ``true`` or ``false`` type.
-  ``StringLiteralType``: the type of a string constant.
-  ``NumberLiteralType``: the type of a number constant.

Additionally, ``Type`` has the following subclasses which overlap partially with those above:

-  ``BooleanType``: the type ``boolean``, internally represented as the union type ``true | false``.
-  ``PromiseType``: a type that describes a promise such as ``Promise<T>``.
-  ``ArrayType``: a type that describes an array object, possibly a tuple type.

   -  ``PlainArrayType``: a type of form ``Array<T>``.
   -  ``ReadonlyArrayType``: a type of form ``ReadonlyArray<T>``.

-  ``LiteralType``: a boolean, string, or number literal type.
-  ``NumberLikeType``: the ``number`` type or a number literal type.
-  ``StringLikeType``: the ``string`` type or a string literal type.
-  ``BooleanLikeType``: the ``true``, ``false``, or ``boolean`` type.

Canonical names and named types
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``CanonicalName`` is a CodeQL class representing a qualified name relative to a root scope, such as a module or the global scope. It typically represents an entity such as a type, namespace, variable, or function. ``TypeName`` and ``Namespace`` are subclasses of this class.

Canonical names can be recognized using the ``hasQualifiedName`` predicate:

-  ``hasQualifiedName(name)`` holds if the qualified name is ``name`` relative to the global scope.
-  ``hasQualifiedName(module,name)`` holds if the qualified name is ``name`` relative to the given module name.

For convenience, this predicate is also available on other classes, such as ``TypeReference`` and ``TypeofType``, where it forwards to the underlying canonical name.

Function types
~~~~~~~~~~~~~~

There is no CodeQL class for function types, as any type with a call or construct signature is usable as a function. The type ``CallSignatureType`` represents such a signature (with or without the ``new`` keyword).

Signatures can be obtained in several ways:

-  ``Type.getFunctionSignature(n)`` gets the ``n``\ th overloaded function signature.
-  ``Type.getConstructorSignature(n)`` gets the ``n``\ th overloaded constructor signature.
-  ``Type.getLastFunctionSignature()`` gets the last declared function signature.
-  ``Type.getLastConstructorSignature()`` gets the last declared constructor signature.

Some important member predicates of ``CallSignatureType`` are:

-  ``CallSignatureType.getParameter(n)`` gets the type of the ``n``\ th parameter.
-  ``CallSignatureType.getParameterName(n)`` gets the name of the ``n``\ th parameter.
-  ``CallSignatureType.getReturnType()`` gets the return type.

Note that a signature is not associated with a specific declaration site.

Call resolution
~~~~~~~~~~~~~~~

Additional type information is available for invocation expressions:

-  ``InvokeExpr.getResolvedCallee()`` gets the callee as a concrete ``Function``.
-  ``InvokeExpr.getResolvedCalleeName()`` get the callee as a canonical name.
-  ``InvokeExpr.getResolvedSignature()`` gets the signature of the invoked function, with overloading resolved and type arguments substituted.

Note that these refer to the call target as determined by the type system. The actual call target may differ at runtime, for instance, if the target is a method that has been overridden in a subclass.

Inheritance and subtyping
~~~~~~~~~~~~~~~~~~~~~~~~~

The declared supertypes of a named type can be obtained using ``TypeName.getABaseTypeName()``.

This operates at the level of type names, hence the specific type arguments used in the inheritance chain are not available. However, these can often be deduced using ``Type.getProperty`` or ``Type.getMethod`` which both take inheritance into account.

This only accounts for types explicitly mentioned in the ``extends`` or ``implements`` clause of a type. There is no predicate that determines subtyping or assignability between types in general.

The following two predicates can be useful for recognising subtypes of a given type:

-  ``Type.unfold()`` unfolds unions and/or intersection types and get the underlying types, or the type itself if it is not a union or intersection.
-  ``Type.hasUnderlyingType(name)`` holds if the type is a reference to the given named type, possibly after unfolding unions/intersections and following declared supertypes.

Example
^^^^^^^

The following query can be used to find all classes that are React components, along with the type of their ``props`` property, which generally coincides with its first type argument:

.. code-block:: ql

   import javascript

   from ClassDefinition cls, TypeName name
   where name = cls.getTypeName()
     and name.getABaseTypeName+().hasQualifiedName("React.Component")
   select cls, name.getType().getProperty("props")

Name binding
------------

In TypeScript, names can refer to variables, types, and namespaces, or a combination of these.

These concepts are modeled as distinct entities: `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__, `TypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$TypeName.html>`__, and `Namespace <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$Namespace.html>`__. For example, the class ``C`` below introduces both a variable and a type:

.. code-block:: typescript

   class C {}
   let x = C; // refers to the variable C
   let y: C;  // refers to the type C

The variable ``C`` and the type ``C`` are modeled as distinct entities. One is a `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__, the other is a `TypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$TypeName.html>`__.

TypeScript also allows you to import types and namespaces, and give them local names in different scopes. For example, the import below introduces a local type name ``B``:

.. code-block:: typescript

   import {C as B} from "./foo"

The local name ``B`` is represented as a `LocalTypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalTypeName.html>`__ named ``B``, restricted to just the file containing the import. An import statement can also introduce a `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__ and a `LocalNamespaceName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalNamespaceName.html>`__.

The following table shows the relevant classes for working with each kind of name. The classes are described in more detail below.

+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
|   Kind    |                                                                           Local alias                                                                            |                                                                     Canonical name                                                                     |                                                                             Definition                                                                              |                                                                           Access                                                                           |
+===========+==================================================================================================================================================================+========================================================================================================================================================+=====================================================================================================================================================================+============================================================================================================================================================+
| Value     | `Variable <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$Variable.html>`__                       |                                                                                                                                                        |                                                                                                                                                                     | `VarAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/Variables.qll/type.Variables$VarAccess.html>`__               |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Type      | `LocalTypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalTypeName.html>`__           | `TypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$TypeName.html>`__   | `TypeDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeDefinition.html>`__            | `TypeAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeAccess.html>`__           |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Namespace | `LocalNamespaceName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalNamespaceName.html>`__ | `Namespace <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$Namespace.html>`__ | `NamespaceDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceDeclaration.html>`__ | `NamespaceAccess <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceAccess.html>`__ |
+-----------+------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Note:** ``TypeName`` and ``Namespace`` are only populated if the database is generated using full TypeScript extraction. ``LocalTypeName`` and ``LocalNamespaceName`` are always populated.

Type names
~~~~~~~~~~

A `TypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$TypeName.html>`__ is a qualified name for a type and is not bound to a specific lexical scope. The `TypeDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$TypeDefinition.html>`__ class represents an entity that defines a type, namely a class, interface, type alias, enum, or enum member. The relevant predicates for working with type names are:

-  ``TypeAccess.getTypeName()`` gets the qualified name being referenced (if any).
-  ``TypeDefinition.getTypeName()`` gets the qualified name of a class, interface, type alias, enum, or enum member.
-  ``TypeName.getAnAccess()``, gets an access to a given type.
-  ``TypeName.getADefinition()``, get a definition of a given type. Note that interfaces can have multiple definitions.

A `LocalTypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalTypeName.html>`__ behaves like a block-scoped variable, that is, it has an unqualified name and is restricted to a specific scope. The relevant predicates are:

-  ``LocalTypeAccess.getLocalTypeName()`` gets the local name referenced by an unqualified type access.
-  ``LocalTypeName.getAnAccess()`` gets an access to a local type name.
-  ``LocalTypeName.getADeclaration()`` gets a declaration of this name.
-  ``LocalTypeName.getTypeName()`` gets the qualified name to which this name refers.

Examples
^^^^^^^^

Find references that omit type arguments to a generic type.

It is best to use `TypeName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$TypeName.html>`__ to resolve through imports and qualified names:

.. code-block:: ql

   import javascript

   from TypeDefinition def, TypeAccess access
   where access.getTypeName().getADefinition() = def
     and def.(TypeParameterized).hasTypeParameters()
     and not access.hasTypeArguments()
   select access, "Type arguments are omitted"

Find imported names that are used as both a type and a value:

.. code-block:: ql

   import javascript

   from ImportSpecifier spec
   where exists (LocalTypeAccess access | access.getLocalTypeName().getADeclaration() = spec.getLocal())
     and exists (VarAccess access | access.getVariable().getADeclaration() = spec.getLocal())
   select spec, "Used as both variable and type"

Namespace names
~~~~~~~~~~~~~~~

Namespaces are represented by the classes `Namespace <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$Namespace.html>`__ and `LocalNamespaceName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalNamespaceName.html>`__. The `NamespaceDefinition <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$NamespaceDefinition.html>`__ class represents a syntactic definition of a namespace, which includes ordinary namespace declarations as well as enum declarations.

Note that these classes deal exclusively with namespaces referenced from inside type annotations, not through expressions.

A `Namespace <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/CanonicalNames.qll/type.CanonicalNames$Namespace.html>`__ is a qualified name for a namespace, and is not bound to a specific scope. The relevant predicates for working with namespaces are:

-  ``NamespaceAccess.getNamespace()`` gets the namespace being referenced by a namespace access.
-  ``NamespaceDefinition.getNamespace()`` gets the namespace defined by a namespace or enum declaration.
-  ``Namespace.getAnAccess()`` gets an access to a namespace from inside a type.
-  ``Namespace.getADefinition()`` gets a definition of this namespace. Note that namespaces can have multiple definitions.
-  ``Namespace.getNamespaceMember(name)`` gets an inner namespace with a given name.
-  ``Namespace.getTypeMember(name)`` gets a type exported under a given name.
-  ``Namespace.getAnExportingContainer()`` gets a `StmtContainer <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/AST.qll/type.AST$StmtContainer.html>`__ whose exports contribute to this namespace. This can be a the body of a namespace declaration or the top-level of a module. Enums have no exporting containers.

A `LocalNamespaceName <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/TypeScript.qll/type.TypeScript$LocalNamespaceName.html>`__ behaves like a block-scoped variable, that is, it has an unqualified name and is restricted to a specific scope. The relevant predicates are:

-  ``LocalNamespaceAccess.getLocalNamespaceName()`` gets the local name referenced by an identifier.
-  ``LocalNamespaceName.getAnAccess()`` gets an identifier that refers to this local name.
-  ``LocalNamespaceName.getADeclaration()`` gets an identifier that declares this local name.
-  ``LocalNamespaceName.getNamespace()`` gets the namespace to which this name refers.

Further reading
---------------

.. include:: ../reusables/javascript-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-control-flow-in-python.rst
.. _analyzing-control-flow-in-python:

Analyzing control flow in Python
================================

You can write CodeQL queries to explore the control-flow graph of a Python program, for example, to discover unreachable code or mutually exclusive blocks of code.

About analyzing control flow
--------------------------------------

To analyze the control-flow graph of a ``Scope`` we can use the two CodeQL classes ``ControlFlowNode`` and ``BasicBlock``. These classes allow you to ask such questions as "can you reach point A from point B?" or "Is it possible to reach point B *without* going through point A?". To report results we use the class ``AstNode``, which represents a syntactic element and corresponds to the source code - allowing the results of the query to be more easily understood. For more information, see `Control-flow graph <https://en.wikipedia.org/wiki/Control_flow_graph>`__ on Wikipedia.

The ``ControlFlowNode`` class
-----------------------------

The ``ControlFlowNode`` class represents nodes in the control flow graph. There is a one-to-many relation between AST nodes and control flow nodes. Each syntactic element, the ``AstNode,`` maps to zero, one, or many ``ControlFlowNode`` classes, but each ``ControlFlowNode`` maps to exactly one ``AstNode``.

To show why this complex relation is required consider the following Python code:

.. code-block:: python

   try:
       might_raise()
       if cond:
           break
   finally:
       close_resource()

There are many paths through the above code. There are three different paths through the call to ``close_resource();`` one normal path, one path that breaks out of the loop, and one path where an exception is raised by ``might_raise()``.

An annotated flow graph:

|Python control flow graph|

.. |Python control flow graph| image:: ../images/python-flow-graph.png

The simplest use of the ``ControlFlowNode`` and ``AstNode`` classes is to find unreachable code. There is one ``ControlFlowNode`` per path through any ``AstNode`` and any ``AstNode`` that is unreachable has no paths flowing through it. Therefore, any ``AstNode`` without a corresponding ``ControlFlowNode`` is unreachable.

Example finding unreachable AST nodes
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: ql

   import python

   from AstNode node
   where not exists(node.getAFlowNode())
   select node

Many codebases have some code that has no control flow node, and is therefore unreachable. However, since the ``Module`` class is also a subclass of the ``AstNode`` class, the query also finds any modules implemented in C or with no source code. Therefore, it is better to find all unreachable statements.

Example finding unreachable statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: ql

   import python

   from Stmt s
   where not exists(s.getAFlowNode())
   select s

This query should give fewer results. You can also find unreachable code using the standard "Unreachable code" query. For more information, see `Unreachable code <https://codeql.github.com/codeql-query-help/python/py-unreachable-statement/>`__.

The ``BasicBlock`` class
------------------------

The ``BasicBlock`` class represents a basic block of control flow nodes. The ``BasicBlock`` class is not that useful for writing queries directly, but is very useful for building complex analyses, such as data flow. The reason it is useful is that it shares many of the interesting properties of control flow nodes, such as, what can reach what, and what dominates what, but there are fewer basic blocks than control flow nodes - resulting in queries that are faster and use less memory. For more information, see `Basic block <https://en.wikipedia.org/wiki/Basic_block>`__ and `Dominator <https://en.wikipedia.org/wiki/Dominator_%28graph_theory%29>`__ on Wikipedia.

Example finding mutually exclusive basic blocks
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Suppose we have the following Python code:

.. code-block:: python

   if condition():
       return 0
   pass

Can we determine that it is impossible to reach both the ``return 0`` statement and the ``pass`` statement in a single execution of this code? For two basic blocks to be mutually exclusive it must be impossible to reach either of them from the other. We can write:

.. code-block:: ql

   import python

   from BasicBlock b1, BasicBlock b2
   where b1 != b2 and not b1.strictlyReaches(b2) and not b2.strictlyReaches(b1)
   select b1, b2

However, by that definition, two basic blocks are mutually exclusive if they are in different scopes. To make the results more useful, we require that both basic blocks can be reached from the same function entry point:

.. code-block:: ql

   exists(Function shared, BasicBlock entry |
       entry.contains(shared.getEntryNode()) and
       entry.strictlyReaches(b1) and entry.strictlyReaches(b2)
   )

Combining these conditions we get:

Example finding mutually exclusive blocks within the same function
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: ql

   import python

   from BasicBlock b1, BasicBlock b2
   where b1 != b2 and not b1.strictlyReaches(b2) and not b2.strictlyReaches(b1) and
   exists(Function shared, BasicBlock entry |
       entry.contains(shared.getEntryNode()) and
       entry.strictlyReaches(b1) and entry.strictlyReaches(b2)
   )
   select b1, b2

This typically gives a very large number of results, because it is a common occurrence in normal control flow. It is, however, an example of the sort of control-flow analysis that is possible. Control-flow analyses such as this are an important aid to data flow analysis. For more information, see ":doc:`Analyzing data flow in Python <analyzing-data-flow-in-python>`."

Further reading
---------------

.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/analyzing-data-flow-in-javascript-and-typescript.rst
.. _analyzing-data-flow-in-javascript-and-typescript:

Analyzing data flow in JavaScript and TypeScript
================================================

This topic describes how data flow analysis is implemented in the CodeQL libraries for JavaScript/TypeScript and includes examples to help you write your own data flow queries.

Overview
--------
The various sections in this article describe how to utilize the libraries for local data flow, global data flow, and taint tracking.
As our running example, we will develop a query that identifies command-line arguments that are passed as a file path to the standard Node.js ``readFile`` function.
While this is not a problematic pattern as such, it is typical of the kind of reasoning that is frequently used in security queries.

For a more general introduction to modeling data flow, see ":ref:`About data flow analysis <about-data-flow-analysis>`."

Data flow nodes
---------------

Both local and global data flow, as well as taint tracking, work on a representation of the program known as the :ref:`data flow graph <data-flow-graph>`.
Nodes on the data flow flow graph may also correspond to nodes on the abstract syntax tree, but they are not the same.
While AST nodes belong to class ``ASTNode`` and its subclasses, data flow nodes belong to class ``DataFlow::Node`` and its subclasses:

  - ``DataFlow::ValueNode``: a *value node*, that is, a data flow node that corresponds either to an expression, or to a declaration of a function, class, TypeScript namespace,
    or TypeScript enum.
  - ``DataFlow::SsaDefinitionNode``: a data flow node that corresponds to an SSA variable, that is, a local variable with additional information to reason more precisely
    about different assignments to the same variable. This kind of data flow node does not correspond to an AST node.
  - ``DataFlow::PropRef``: a data flow node that corresponds to a read or a write of an object property, for example, in an assignment, in an object literal, or in a
    destructuring assignment.
  - ``DataFlow::PropRead``, ``DataFlow::PropWrite``: subclasses of ``DataFlow::PropRef`` that correspond to reads and writes, respectively.

Apart from these fairly general classes, there are some more specialized classes:

  - ``DataFlow::ParameterNode``: a data flow node that corresponds to a function parameter.
  - ``DataFlow::InvokeNode``: a data flow node that corresponds to a function call; its subclasses ``DataFlow::NewNode`` and ``DataFlow::CallNode`` represent calls with
    and without ``new`` respectively, while ``DataFlow::MethodCallNode`` represents method calls. Note that these classes also model reflective calls using ``.call`` and
    ``.apply``, which do not correspond to any AST nodes.
  - ``DataFlow::ThisNode``: a data flow node that corresponds to the value of ``this`` in a function or top level. This kind of data flow node also does not correspond to an AST node.
  - ``DataFlow::GlobalVarRefNode``: a data flow node that corresponds to a direct reference to a global variable. This class is rarely used directly, instead you would normally
    use the predicate ``globalVarRef`` (introduced below), which also considers indirect references through ``window`` or global ``this``.
  - ``DataFlow::FunctionNode``, ``DataFlow::ObjectLiteralNode``, ``DataFlow::ArrayLiteralNode``: a data flow node that corresponds to a function (expression or declaration),
    an object literal, or an array literal, respectively.
  - ``DataFlow::ClassNode``: a data flow node corresponding to a class, either defined using an ECMAScript 2015 ``class`` declaration or an old-style constructor
    function.
  - ``DataFlow::ModuleImportNode``: a data flow node corresponding to an ECMAScript 2015 import or an AMD or CommonJS ``require`` import.

The following predicates are available for mapping from AST nodes and other elements to their corresponding data flow nodes:

  - ``DataFlow::valueNode(x)``: maps ``x``, which must be an expression or a declaration of a function, class, namespace or enum, to its corresponding ``DataFlow::ValueNode``.
  - ``DataFlow::ssaDefinitionNode(ssa)``: maps an SSA definition ``ssa`` to its corresponding ``DataFlow::SsaDefinitionNode``.
  - ``DataFlow::parameterNode(p)``: maps a function parameter ``p`` to its corresponding ``DataFlow::ParameterNode``.
  - ``DataFlow::thisNode(s)``: maps a function or top-level ``s`` to the ``DataFlow::ThisNode`` representing the value of ``this`` in ``s``.

Class ``DataFlow::Node`` also has a member predicate ``asExpr()`` that you can use to map from a ``DataFlow::ValueNode`` to the expression it corresponds to. Note that
this predicate is undefined for other kinds of nodes, and for value nodes that do not correspond to expressions.

There are also some other predicates available for accessing commonly used data flow nodes:

  - ``DataFlow::globalVarRef(g)``: gets a data flow node corresponding to an access to global variable ``g``, either directly or through ``window`` or (top-level) ``this``.
    For example, you can use ``DataFlow::globalVarRef("document")`` to find references to the DOM ``document`` object.
  - ``DataFlow::moduleMember(p, m)``: gets a data flow node that references a member ``m`` of a module loaded from path ``p``. For example, you can use
    ``DataFlow::moduleMember("fs", "readFile")`` to find references to the ``fs.readFile`` function from the Node.js standard library.

Local data flow
---------------

Local data flow is data flow within a single function. Data flow through function calls and returns or through property writes and reads is not modeled.

Local data flow is faster to compute and easier to use than global data flow, but less complete. It is, however, sufficient for many purposes.

To reason about local data flow, use the member predicates ``getAPredecessor`` and ``getASuccessor`` on ``DataFlow::Node``. For a data flow node ``nd``,
``nd.getAPredecessor()`` returns all data flow nodes from which data flows to ``nd`` in one local step. Conversely, ``nd.getASuccessor()`` returns all
nodes to which data flows from ``nd`` in one local step.

To follow one or more steps of local data flow, use the transitive closure operator ``+``, and for zero or more steps the reflexive transitive closure operator ``*``.

For example, the following query finds all data flow nodes ``source`` whose value may flow into the first argument of a call to a method with name ``readFile``:

.. code-block:: ql

  import javascript

  from DataFlow::MethodCallNode readFile, DataFlow::Node source
  where
    readFile.getMethodName() = "readFile" and
    source.getASuccessor*() = readFile.getArgument(0)
  select source

Source nodes
~~~~~~~~~~~~

Explicit reasoning about data flow edges can be cumbersome and is rare in practice. Typically, we are not interested in flow originating from arbitrary nodes, but
from nodes that in some sense are the "source" of some kind of data, either because they create a new object, such as object literals or functions, or because they
represent a point where data enters the local data flow graph, such as parameters or property reads.

The data flow library represents such nodes by the class ``DataFlow::SourceNode``, which provides a convenient API to reason about local data flow involving
source nodes.

By default, the following kinds of data flow nodes are considered source nodes:

  - classes, functions, object and array literals, regular expressions, and JSX elements
  - property reads, global variable references and ``this`` nodes
  - function parameters
  - function calls
  - imports

You can extend the set of source nodes by defining additional subclasses of ``DataFlow::SourceNode::Range``.

The ``DataFlow::SourceNode`` class defines a number of member predicates that can be used to track where data originating from a source node flows, and to find
places where properties are accessed or methods are called on them.

For example, the following query finds all references to properties of ``process.argv``, the array through which Node.js applications receive their command-line
arguments:

.. code-block:: ql

  import javascript

  select DataFlow::globalVarRef("process").getAPropertyRead("argv").getAPropertyReference()

First, we use ``DataFlow::globalVarRef`` (mentioned above) to find all references to the global variable ``process``. Since global variable references are source
nodes, we can then use the predicate ``getAPropertyRead`` (defined in class ``DataFlow::SourceNode``) to find all places where the property ``argv`` of that
global variable is read. The results of this predicate are again source nodes, so we can chain it with a call to ``getAPropertyReference``, which is a predicate
that finds all references to any property (even references with a computed name) on its base source node.

Note that many predicates on ``DataFlow::SourceNode`` have source nodes as their result in turn, allowing calls to be chained to concisely express the relationship
between several data flow nodes.

Most importantly, predicates like ``getAPropertyRead`` implicitly follow local data flow, so the above query not only finds direct property references like
``process.argv[2]``, but also more indirect ones as in this example:

.. code-block:: javascript

  var args = process.argv;
  var firstArg = args[2];

Analogous to ``getAPropertyRead`` there is also a predicate ``getAPropertyWrite`` for identifying property writes.

Another common task is to find calls to a function originating from a source node. For this purpose, ``DataFlow::SourceNode`` offers predicates ``getACall``,
``getAnInstantiation`` and ``getAnInvocation``: the first one only considers invocations without ``new``, the second one only invocations with ``new``, and
the third one considers all invocations.

We can use these predicates in combination with ``DataFlow::moduleMember`` (mentioned above) to find calls to the function ``readFile`` imported from the
standard Node.js ``fs`` library:

.. code-block:: ql

  import javascript

  select DataFlow::moduleMember("fs", "readFile").getACall()

For identifying method calls there is also a predicate ``getAMethodCall``, and the slightly more general ``getAMemberCall``. The difference between the
two is that the former only finds calls that have the syntactic shape of a method call such as ``x.m(...)``, while the latter also finds calls where
``x.m`` is first stored into a local variable ``f`` and then invoked as ``f(...)``.

Finally, the predicate ``flowsTo(nd)`` holds for any node ``nd`` into which data originating from the source node may flow. Conversely, ``DataFlow::Node``
offers a predicate ``getALocalSource()`` that can be used to find any source node that flows to it.

Putting all of the above together, here is a query that finds (local) data flow from command line arguments to ``readFile`` calls:

.. code-block:: ql

  import javascript

  from DataFlow::SourceNode arg, DataFlow::CallNode call
  where
    arg = DataFlow::globalVarRef("process").getAPropertyRead("argv").getAPropertyReference() and
    call = DataFlow::moduleMember("fs", "readFile").getACall() and
    arg.flowsTo(call.getArgument(0))
  select arg, call

There are two points worth making about the source node API:

  1. All data flow tracking is purely local, and in particular flow through global variables is not tracked. If ``args`` in our ``process.argv`` example
     above is a global variable, then the query will not find the reference through ``args[2]``.
  2. Strings are not source nodes and cannot be tracked using this API. You can, however, use the ``mayHaveStringValue`` predicate on class ``DataFlow::Node``
     to reason about the possible string values flowing into a data flow node.

For a full description of the ``DataFlow::SourceNode`` API, see the `JavaScript standard library <https://codeql.github.com/codeql-standard-libraries/javascript/semmle/javascript/dataflow/Sources.qll/type.Sources$SourceNode.html>`__.

Exercises
~~~~~~~~~

Exercise 1: Write a query that finds all hard-coded strings used as the ``tagName`` argument to the ``createElement`` function from the DOM ``document`` object,
using local data flow. (`Answer <#exercise-1>`__).

Global data flow
----------------

Global data flow tracks data flow throughout the entire program, and is therefore more powerful than local data flow. However, global data flow is less precise
than local data flow. That is, the analysis may report spurious flows that cannot in fact happen. Moreover, global data flow analysis typically requires significantly
more time and memory than local analysis.

.. pull-quote:: Note

   .. include:: ../reusables/path-problem.rst

Using global data flow
~~~~~~~~~~~~~~~~~~~~~~

For performance reasons, it is not generally feasible to compute all global data flow across the entire program. Instead, you can define a data flow `configuration`,
which specifies `source` data flow nodes and `sink` data flow nodes ("sources" and "sinks" for short) of interest. The data flow library provides a generic
data flow solver that can check whether there is (global) data flow from a source to a sink.

Optionally, configurations may specify extra data flow edges to be added to the data flow graph, and may also specify  `barriers`. Barriers are data flow nodes or edges through
which data should not be tracked for the purposes of this analysis.

To define a configuration, extend the class ``DataFlow::Configuration`` as follows:

.. code-block:: ql

  class MyDataFlowConfiguration extends DataFlow::Configuration {
    MyDataFlowConfiguration() { this = "MyDataFlowConfiguration" }

    override predicate isSource(DataFlow::Node source) { /* ... */ }

    override predicate isSink(DataFlow::Node sink) { /* ... */ }

    // optional overrides:
    override predicate isBarrier(DataFlow::Node nd) { /* ... */ }
    override predicate isBarrierEdge(DataFlow::Node pred, DataFlow::Node succ) { /* ... */ }
    override predicate isAdditionalFlowStep(DataFlow::Node pred, DataFlow::Node succ) { /* ... */ }
  }

The characteristic predicate ``MyDataFlowConfiguration()`` defines the name of the configuration, so ``"MyDataFlowConfiguration"`` should be replaced by a suitable
name describing your particular analysis configuration.

The data flow analysis is performed using the predicate ``hasFlow(source, sink)``:

.. code-block:: ql

   from MyDataFlowConfiguration dataflow, DataFlow::Node source, DataFlow::Node sink
   where dataflow.hasFlow(source, sink)
   select source, "Data flow from $@ to $@.", source, source.toString(), sink, sink.toString()

Using global taint tracking
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Global taint tracking extends global data flow with additional non-value-preserving steps, such as flow through string-manipulating operations. To use it, simply extend
``TaintTracking::Configuration`` instead of ``DataFlow::Configuration``:

.. code-block:: ql

  class MyTaintTrackingConfiguration extends TaintTracking::Configuration {
    MyTaintTrackingConfiguration() { this = "MyTaintTrackingConfiguration" }

    override predicate isSource(DataFlow::Node source) { /* ... */ }

    override predicate isSink(DataFlow::Node sink) { /* ... */ }
  }

Analogous to ``isAdditionalFlowStep``, there is a predicate ``isAdditionalTaintStep`` that you can override to specify custom flow steps to consider in the analysis.
Instead of the ``isBarrier`` and ``isBarrierEdge`` predicates, the taint tracking configuration includes ``isSanitizer`` and ``isSanitizerEdge`` predicates that specify
data flow nodes or edges that act as taint sanitizers and hence stop flow from a source to a sink.

Similar to global data flow, the characteristic predicate ``MyTaintTrackingConfiguration()`` defines the unique name of the configuration, so ``"MyTaintTrackingConfiguration"``
should be replaced by an appropriate descriptive name.

The taint tracking analysis is again performed using the predicate ``hasFlow(source, sink)``.

Examples
~~~~~~~~

The following taint-tracking configuration is a generalization of our example query above, which tracks flow from command-line arguments to ``readFile`` calls, this
time using global taint tracking.

.. code-block:: ql

  import javascript

  class CommandLineFileNameConfiguration extends TaintTracking::Configuration {
    CommandLineFileNameConfiguration() { this = "CommandLineFileNameConfiguration" }

    override predicate isSource(DataFlow::Node source) {
      DataFlow::globalVarRef("process").getAPropertyRead("argv").getAPropertyRead() = source
    }

    override predicate isSink(DataFlow::Node sink) {
      DataFlow::moduleMember("fs", "readFile").getACall().getArgument(0) = sink
    }
  }

  from CommandLineFileNameConfiguration cfg, DataFlow::Node source, DataFlow::Node sink
  where cfg.hasFlow(source, sink)
  select source, sink

This query will now find flows that involve inter-procedural steps, like in the following example (where the individual steps have been marked with comments
``#1`` to ``#4``):

.. code-block:: javascript

  const fs = require('fs'),
        path = require('path');

  function readFileHelper(p) {     // #2
    p = path.resolve(p);           // #3
    fs.readFile(p,                 // #4
      'utf8', (err, data) => {
      if (err) throw err;
      console.log(data);
    });
  }

  readFileHelper(process.argv[2]); // #1

Note that for step #3 we rely on the taint-tracking library's built-in model of the Node.js ``path`` library, which adds a taint step from ``p`` to
``path.resolve(p)``. This step is not value preserving, but it preserves taint in the sense that if ``p`` is user-controlled, then so is
``path.resolve(p)`` (at least partially).

Other standard taint steps include flow through string-manipulating operations such as concatenation, ``JSON.parse`` and ``JSON.stringify``, array
transformations, promise operations, and many more.

Sanitizers
~~~~~~~~~~

The above JavaScript program allows the user to read any file, including sensitive system files like ``/etc/passwd``. If the program may be invoked
by an untrusted user, this is undesirable, so we may want to constrain the path. For example, instead of using ``path.resolve`` we could implement
a function ``checkPath`` that first makes the path absolute and then checks that it starts with the current working directory, aborting the program
with an error if it does not. We could then use that function in ``readFileHelper`` like this:

.. code-block:: javascript

  function readFileHelper(p) {
    p = checkPath(p);
    ...
  }

For the purposes of our above analysis, ``checkPath`` is a `sanitizer`: its output is always untainted, even if its input is tainted. To model this
we can add an override of ``isSanitizer`` to our taint-tracking configuration like this:

.. code-block:: ql

  class CommandLineFileNameConfiguration extends TaintTracking::Configuration {

    // ...

    override predicate isSanitizer(DataFlow::Node nd) {
      nd.(DataFlow::CallNode).getCalleeName() = "checkPath"
    }
  }

This says that any call to a function named ``checkPath`` is to be considered a sanitizer, so any flow through this node is blocked. In particular,
the query would no longer flag the flow from ``process.argv[2]`` to ``fs.readFile`` in our updated example above.

Sanitizer guards
~~~~~~~~~~~~~~~~

A perhaps more natural way of implementing the path check in our example would be to have ``checkPath`` return a Boolean value indicating whether
the path is safe to read (instead of returning the path if it is safe and aborting otherwise). We could then use it in ``readFileHelper`` like this:

.. code-block:: javascript

  function readFileHelper(p) {
    if (!checkPath(p))
      return;
    ...
  }

Note that ``checkPath`` is now no longer a sanitizer in the sense described above, since the flow from ``process.argv[2]`` to ``fs.readFile`` does not go
through ``checkPath`` any more. The flow is, however, `guarded` by ``checkPath`` in the sense that the expression ``checkPath(p)`` has to evaluate
to ``true`` (or, more precisely, to a truthy value) in order for the flow to happen.

Such sanitizer guards can be supported by defining a new subclass of ``TaintTracking::SanitizerGuardNode`` and overriding the predicate
``isSanitizerGuard`` in the taint-tracking configuration class to add all instances of this class as sanitizer guards to the configuration.

For our above example, we would begin by defining a subclass of ``SanitizerGuardNode`` that identifies guards of the form ``checkPath(...)``:

.. code-block:: ql

  class CheckPathSanitizerGuard extends TaintTracking::SanitizerGuardNode, DataFlow::CallNode {
    CheckPathSanitizerGuard() { this.getCalleeName() = "checkPath" }

    override predicate sanitizes(boolean outcome, Expr e) {
      outcome = true and
      e = getArgument(0).asExpr()
    }
  }

The characteristic predicate of this class checks that the sanitizer guard is a call to a function named ``checkPath``. The overriding definition
of ``sanitizes`` says such a call sanitizes its first argument (that is, ``getArgument(0)``) if it evaluates to ``true`` (or rather, a truthy
value).

Now we can override ``isSanitizerGuard`` to add these sanitizer guards to our configuration:

.. code-block:: ql

  class CommandLineFileNameConfiguration extends TaintTracking::Configuration {

    // ...

    override predicate isSanitizerGuard(TaintTracking::SanitizerGuardNode nd) {
      nd instanceof CheckPathSanitizerGuard
    }
  }

With these two additions, the query recognizes the ``checkPath(p)`` check as sanitizing ``p`` after the ``return``, since execution can only
reach there if ``checkPath(p)`` evaluates to a truthy value. Consequently, there is no longer a path from ``process.argv[2]`` to
``readFile``.

Additional taint steps
~~~~~~~~~~~~~~~~~~~~~~

Sometimes the default data flow and taint steps provided by ``DataFlow::Configuration`` and ``TaintTracking::Configuration`` are not sufficient
and we need to add additional flow or taint steps to our configuration to make it find the expected flow. For example, this can happen because
the analyzed program uses a function from an external library whose source code is not available to the analysis, or because it uses a function
that is too difficult to analyze.

In the context of our running example, assume that the JavaScript program we are analyzing uses a (fictitious) npm package ``resolve-symlinks``
to resolve any symlinks in the path ``p`` before passing it to ``readFile``:

.. code-block:: javascript

  const resolveSymlinks = require('resolve-symlinks');

  function readFileHelper(p) {
    p = resolveSymlinks(p);
    fs.readFile(p,
    ...
  }

Resolving symlinks does not make an unsafe path any safer, so we would still like our query to flag this, but since the standard library does
not have a model of ``resolve-symlinks`` it will no longer return any results.

We can fix this quite easily by adding an overriding definition of the ``isAdditionalTaintStep`` predicate to our configuration, introducing an
additional taint step from the first argument of ``resolveSymlinks`` to its result:

.. code-block:: ql

  class CommandLineFileNameConfiguration extends TaintTracking::Configuration {

    // ...

    override predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) {
      exists(DataFlow::CallNode c |
        c = DataFlow::moduleImport("resolve-symlinks").getACall() and
        pred = c.getArgument(0) and
        succ = c
      )
    }
  }

We might even consider adding this as a default taint step to be used by all taint-tracking configurations. In order to do this, we need
to wrap it in a new subclass of ``TaintTracking::SharedTaintStep`` like this:

.. code-block:: ql

  class StepThroughResolveSymlinks extends TaintTracking::SharedTaintStep {
    override predicate step(DataFlow::Node pred, DataFlow::Node succ) {
      exists(DataFlow::CallNode c |
        c = DataFlow::moduleImport("resolve-symlinks").getACall() and
        pred = c.getArgument(0) and
        succ = c
      )
    }
  }

If we add this definition to the standard library, it will be picked up by all taint-tracking configurations. Obviously, one has to be
careful when adding such new additional taint steps to ensure that they really make sense for `all` configurations.

Analogous to ``TaintTracking::SharedTaintStep``, there is also a class ``DataFlow::SharedFlowStep`` that can be extended to add
extra steps to all data-flow configurations, and hence also to all taint-tracking configurations.

Exercises
~~~~~~~~~

Exercise 2: Write a query that finds all hard-coded strings used as the ``tagName`` argument to the ``createElement`` function from the DOM ``document`` object,
using global data flow. (`Answer <#exercise-2>`__).

Exercise 3: Write a class which represents flow sources from the array elements of the result of a call, for example the expression ``myObject.myMethod(myArgument)[myIndex]``.
Hint: array indices are properties with numeric names; you can use regular expression matching to check this. (`Answer <#exercise-3>`__)

Exercise 4: Using the answers from 2 and 3, write a query which finds all global data flows from array elements of the result of a call to the ``tagName`` argument to the
``createElement`` function. (`Answer <#exercise-4>`__)

Answers
-------

Exercise 1
~~~~~~~~~~

.. code-block:: ql

  import javascript

  from DataFlow::CallNode create, string name
  where
    create = DataFlow::globalVarRef("document").getAMethodCall("createElement") and
    create.getArgument(0).mayHaveStringValue(name)
  select name

Exercise 2
~~~~~~~~~~

.. code-block:: ql

  import javascript

  class HardCodedTagNameConfiguration extends DataFlow::Configuration {
    HardCodedTagNameConfiguration() { this = "HardCodedTagNameConfiguration" }

    override predicate isSource(DataFlow::Node source) { source.asExpr() instanceof ConstantString }

    override predicate isSink(DataFlow::Node sink) {
      sink = DataFlow::globalVarRef("document").getAMethodCall("createElement").getArgument(0)
    }
  }

  from HardCodedTagNameConfiguration cfg, DataFlow::Node source, DataFlow::Node sink
  where cfg.hasFlow(source, sink)
  select source, sink

Exercise 3
~~~~~~~~~~

.. code-block:: ql

  import javascript

  class ArrayEntryCallResult extends DataFlow::Node {
    ArrayEntryCallResult() {
      exists(DataFlow::CallNode call, string index |
        this = call.getAPropertyRead(index) and
        index.regexpMatch("\\d+")
      )
    }
  }

Exercise 4
~~~~~~~~~~

.. code-block:: ql

  import javascript

  class ArrayEntryCallResult extends DataFlow::Node {
    ArrayEntryCallResult() {
      exists(DataFlow::CallNode call, string index |
        this = call.getAPropertyRead(index) and
        index.regexpMatch("\\d+")
      )
    }
  }

  class HardCodedTagNameConfiguration extends DataFlow::Configuration {
    HardCodedTagNameConfiguration() { this = "HardCodedTagNameConfiguration" }

    override predicate isSource(DataFlow::Node source) { source instanceof ArrayEntryCallResult }

    override predicate isSink(DataFlow::Node sink) {
      sink = DataFlow::globalVarRef("document").getAMethodCall("createElement").getArgument(0)
    }
  }

  from HardCodedTagNameConfiguration cfg, DataFlow::Node source, DataFlow::Node sink
  where cfg.hasFlow(source, sink)
  select source, sink

Further reading
---------------

- `Exploring data flow with path queries  <https://docs.github.com/en/code-security/codeql-for-vs-code/getting-started-with-codeql-for-vs-code/exploring-data-flow-with-path-queries>`__ in the GitHub documentation.


.. include:: ../reusables/java-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/basic-query-for-ruby-code.rst
.. _basic-query-for-ruby-code:

Basic query for Ruby code
=========================

Learn to write and run a simple CodeQL query using Visual Studio Code with the CodeQL extension.

.. include:: ../reusables/vs-code-basic-instructions/setup-to-run-queries.rst

About the query
---------------

The query we're going to run performs a basic search of the code for ``if`` expressions that are redundant, in the sense that they have an empty ``then`` branch. For example, code such as:

.. code-block:: ruby

   if error
     # Handle the error

.. include:: ../reusables/vs-code-basic-instructions/find-database.rst

Running a quick query
---------------------

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-1.rst

#. In the quick query tab, delete the content and paste in the following query.

   .. code-block:: ql

      import codeql.ruby.AST

      from IfExpr ifexpr
      where
      not exists(ifexpr.getThen())
      select ifexpr, "This 'if' expression is redundant."

.. include:: ../reusables/vs-code-basic-instructions/run-quick-query-2.rst

.. image:: ../images/codeql-for-visual-studio-code/basic-ruby-query-results-1.png
   :align: center

If any matching code is found, click a link in the ``ifexpr`` column to open the file and highlight the matching ``if`` statement.

.. image:: ../images/codeql-for-visual-studio-code/basic-ruby-query-results-2.png
   :align: center

.. include:: ../reusables/vs-code-basic-instructions/note-store-quick-query.rst

About the query structure
~~~~~~~~~~~~~~~~~~~~~~~~~

After the initial ``import`` statement, this simple query comprises three parts that serve similar purposes to the FROM, WHERE, and SELECT parts of an SQL query.

+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| Query part                                                    | Purpose                                                                                                           | Details                                                                                                                |
+===============================================================+===================================================================================================================+========================================================================================================================+
| ``import codeql.ruby.AST``                                    | Imports the standard CodeQL AST libraries for Ruby.                                                               | Every query begins with one or more ``import`` statements.                                                             |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``from IfExpr ifexpr``                                        | Defines the variables for the query.                                                                              | We use: an ``IfExpr`` variable for ``if`` expressions.                                                                 |
|                                                               | Declarations are of the form:                                                                                     |                                                                                                                        |
|                                                               | ``<type> <variable name>``                                                                                        |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``where not exists(ifexpr.getThen())``                        | Defines a condition on the variables.                                                                             | ``ifexpr.getThen()``: gets the ``then`` branch of the ``if`` expression.                                               |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               |                                                                                                                   | ``exists(...)``: requires that there is a matching element, in this case a ``then`` branch.                            |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+
| ``select ifexpr, "This 'if' expression is redundant."``       | Defines what to report for each match.                                                                            | Reports the resulting ``if`` expression with a string that explains the problem.                                       |
|                                                               |                                                                                                                   |                                                                                                                        |
|                                                               | ``select`` statements for queries that are used to find instances of poor coding practice are always in the form: |                                                                                                                        |
|                                                               | ``select <program element>, "<alert message>"``                                                                   |                                                                                                                        |
+---------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------+

Extend the query
----------------

Query writing is an inherently iterative process. You write a simple query and then, when you run it, you discover examples that you had not previously considered, or opportunities for improvement.

Remove false positive results
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Browsing the results of our basic query shows that it could be improved. Among the results you are likely to find examples of ``if`` statements with an ``else`` branch, where an empty ``then`` branch does serve a purpose. For example:

.. code-block:: ruby

   if option == "-verbose"
     # nothing to do - handled earlier
   else
     error "unrecognized option"

In this case, identifying the ``if`` statement with the empty ``then`` branch as redundant is a false positive. One solution to this is to modify the query to select ``if`` statements where both the ``then`` and ``else`` branches are missing.

To exclude ``if`` statements that have an ``else`` branch:

#. Add the following to the where clause:

   .. code-block:: ql

      and not exists(ifstmt.getElse())

   The ``where`` clause is now:

   .. code-block:: ql

      where
         not exists(ifexpr.getThen()) and
         not exists(ifexpr.getElse())

#. Re-run the query.

   There are now fewer results because ``if`` expressions with an ``else`` branch are no longer included.

Further reading
---------------

.. include:: ../reusables/ruby-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst

.. Article-specific substitutions for the reusables used in docs/codeql/reusables/vs-code-basic-instructions

.. |language-text| replace:: Ruby

.. |language-code| replace:: ``ruby``

.. |example-url| replace:: https://github.com/discourse/discourse

.. |image-quick-query| image:: ../images/codeql-for-visual-studio-code/quick-query-tab-ruby.png

.. |result-col-1|  replace:: The first column corresponds to the expression ``ifexpr`` and is linked to the location in the source code of the project where ``ifexpr`` occurs.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/customizing-library-models-for-python.rst
.. _customizing-library-models-for-python:

Customizing Library Models for Python
=========================================

.. include:: ../reusables/beta-note-customizing-library-models.rst

Python analysis can be customized by adding library models in data extension files.

A data extension for Python is a YAML file of the form:

.. code-block:: yaml 

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: <name of extensible predicate>
      data:
        - <tuple1>
        - <tuple2>
        - ...

The CodeQL library for Python exposes the following extensible predicates:

- **sourceModel**\(type, path, kind)
- **sinkModel**\(type, path, kind)
- **typeModel**\(type1, type2, path)
- **summaryModel**\(type, path, input, output, kind)

We'll explain how to use these using a few examples, and provide some reference material at the end of this article.

Example: Taint sink in the 'fabric' package
-------------------------------------------

In this example, we'll show how to add the following argument, passed to **sudo** from the **fabric** package, as a command-line injection sink:

.. code-block:: python

  from fabric.operations import sudo
  sudo(cmd) # <-- add 'cmd' as a taint sink

Note that this sink is already recognized by the CodeQL Python analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: sinkModel
      data:
        - ["fabric", "Member[operations].Member[sudo].Argument[0]", "command-injection"]


- Since we're adding a new sink, we add a tuple to the **sinkModel** extensible predicate.
- The first column, **"fabric"**, identifies a set of values from which to begin the search for the sink.
  The string **"fabric"** means we start at the places where the codebase imports the package **fabric**.
- The second column is an access path that is evaluated from left to right, starting at the values that were identified by the first column.

  - **Member[operations]** selects accesses to the **operations** module.
  - **Member[sudo]** selects accesses to the **sudo** function in the **operations** module.
  - **Argument[0]** selects the first argument to calls to that function.

- **"command-injection"** indicates that this is considered a sink for the command injection query.

Example: Taint sink in the 'invoke' package
-------------------------------------------

Often sinks are found as arguments to methods rather than functions. In this example, we'll show how to add the following argument, passed to **run** from the **invoke** package, as a command-line injection sink:

.. code-block:: python

  import invoke
  c = invoke.Context()
  c.run(cmd) # <-- add 'cmd' as a taint sink

Note that this sink is already recognized by the CodeQL Python analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: sinkModel
      data:
        - ["invoke", "Member[Context].Instance.Member[run].Argument[0]", "command-injection"]

- The first column, **"invoke"**, begins the search at places where the codebase imports the package **invoke**.
- The second column is an access path that is evaluated from left to right, starting at the values that were identified by the first column.

  - **Member[Context]** selects accesses to the **Context** class.
  - **Instance** selects instances of the **Context** class.
  - **Member[run]** selects accesses to the **run** method in the **Context** class.
  - **Argument[0]** selects the first argument to calls to that method.

- **"command-injection"** indicates that this is considered a sink for the command injection query.

Note that the **Instance** component is used to select instances of a class, including instances of its subclasses.
Since methods on instances are common targets, we have a more compact syntax for selecting them. The first column, the type, is allowed to contain a dotted path ending in a class name.
This will begin the search at instances of that class. Using this syntax, the previous example could be written as:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: sinkModel
      data:
        - ["invoke.Context", "Member[run].Argument[0]", "command-injection"]

Continued example: Multiple ways to obtain a type
-------------------------------------------------

The invoke package provides multiple ways to obtain a **Context** instance. The following example shows how to add a new way to obtain a **Context** instance:

.. code-block:: python

  from invoke import context
  c = context.Context()
  c.run(cmd) # <-- add 'cmd' as a taint sink

Comparing to the previous Python snippet, the **Context** class is now found as **invoke.context.Context** instead of **invoke.Context**.
We could add a data extension similar to the previous one, but with the type **invoke.context.Context**. However, we can also use the **typeModel** extensible predicate to describe how to reach **invoke.Context** from **invoke.context.Context**:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: typeModel
      data:
        - ["invoke.Context", "invoke.context.Context", ""]

- The first column, **"invoke.Context"**, is the name of the type to reach.
- The second column, **"invoke.context.Context"**, is the name of the type from which to evaluate the path.
- The third column is just an empty string, indicating that any instance of **invoke.context.Context** is also an instance of **invoke.Context**.

Combining this with the sink model we added earlier, the sink in the example is detected by the model.

Example: Taint sources from Django 'upload_to' argument
-------------------------------------------------------

This example is a bit more advanced, involving both a callback function and a class constructor.
The Django web framework allows you to specify a function that determines the path where uploaded files are stored (see the `Django documentation <https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.FileField.upload_to>`_).
This function is passed as an argument to the **FileField** constructor.
The function is called with two arguments: the instance of the model and the filename of the uploaded file.
This filename is what we want to mark as a taint source. An example use looks as follows:

.. code-block:: python

  from django.db import models

  def user_directory_path(instance, filename): # <-- add 'filename' as a taint source
    # file will be uploaded to MEDIA_ROOT/user_<id>/<filename>
    return "user_{0}/{1}".format(instance.user.id, filename)

  class MyModel(models.Model):
    upload = models.FileField(upload_to=user_directory_path) # <-- the 'upload_to' parameter defines our custom function

Note that this source is already known by the CodeQL Python analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: sourceModel
      data:
        - [
            "django.db.models.FileField!",
            "Call.Argument[0,upload_to:].Parameter[1]",
            "remote",
          ]


- Since we're adding a new taint source, we add a tuple to the **sourceModel** extensible predicate.
- The first column, **"django.db.models.FileField!"**, is a dotted path to the **FileField** class from the **django.db.models** package.
  The **!** at the end of the type name indicates that we are looking for the class itself rather than instances of this class.

- The second column is an access path that is evaluated from left to right, starting at the values that were identified by the first column.
  
    - **Call** selects calls to the class. That is, constructor calls.
    - **Argument[0,upload_to:]** selects the first positional argument, or the named argument named **upload_to**. Note that the colon at the end of the argument name indicates that we are looking for a named argument.
    - **Parameter[1]** selects the second parameter of the callback function, which is the parameter receiving the filename.

- Finally, the kind **"remote"** indicates that this is considered a source of remote flow.

Example: Adding flow through 're.compile'
----------------------------------------------

In this example, we'll show how to add flow through calls to ``re.compile``.
``re.compile`` returns a compiled regular expression for efficient evaluation, but the pattern to be compiled is stored in the ``pattern`` attribute of the resulting object.

.. code-block:: python

  import re

  let y = re.compile(pattern = x); // add value flow from 'x' to 'y.pattern'

Note that this flow is already recognized by the CodeQL Python analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: summaryModel
      data:
        - [
            "re",
            "Member[compile]",
            "Argument[0,pattern:]",
            "ReturnValue.Attribute[pattern]",
            "value",
          ]


- Since we're adding flow through a function call, we add a tuple to the **summaryModel** extensible predicate.
- The first column, **"re"**, begins the search for relevant calls at places where the **re** package is imported.
- The second column, **"Member[compile]"**, is a path leading to the function calls we wish to model.
  In this case, we select references to the **compile** function from the ``re`` package.
- The third column, **"Argument[0,pattern:]"**, indicates the input of the flow. In this case, either the first argument to the function call or the argument named **pattern**.
- The fourth column, **"ReturnValue.Attribute[pattern]"**, indicates the output of the flow. In this case, the ``pattern`` attribute of the return value of the function call.
- The last column, **"value"**, indicates the kind of flow to add. The value **value** means the input value is unchanged as
  it flows to the output.

Example: Adding flow through 'sorted'
-------------------------------------------------

In this example, we'll show how to add flow through calls to the built-in function **sorted**:

.. code-block:: python

  y = sorted(x) # add taint flow from 'x' to 'y'

Note that this flow is already recognized by the CodeQL Python analysis, but for this example, you could use the following data extension:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: summaryModel
      data:
        - [
            "builtins",
            "Member[sorted]",
            "Argument[0]",
            "ReturnValue",
            "taint",
          ]


- Since we're adding flow through a function call, we add a tuple to the **summaryModel** extensible predicate.
- The first column, **"builtins"**, begins the search for relevant calls among references to the built-in names.
  In Python, many built-in functions are available. Technically, most of these are part of the **builtins** package, but they can be accessed without an explicit import. When we write **builtins** in the first column, we will find both the implicit and explicit references to the built-in functions.
- The second column, **"Member[sorted]"**, selects references to the **sorted** function from the **builtins** package; that is, the built-in function **sorted**.
- The third column, **"Argument[0]"**, indicates the input of the flow. In this case, the first argument to the function call.
- The fourth column, **"ReturnValue"**, indicates the output of the flow. In this case, the return value of the function call.
- The last column, **"taint"**, indicates the kind of flow to add. The value **taint** means the output is not necessarily equal
  to the input, but was derived from the input in a taint-preserving way.

We might also provide a summary stating that the elements of the input list are preserved in the output list:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: summaryModel
      data:
        - [
            "builtins",
            "Member[sorted]",
            "Argument[0].ListElement",
            "ReturnValue.ListElement",
            "value",
          ]

The tracking of list elements is imprecise in that the analysis does not know where in the list the tracked value is found.
So this summary simply states that if the value is found somewhere in the input list, it will also be found somewhere in the output list, unchanged.

Reference material
------------------

The following sections provide reference material for extensible predicates, access paths, types, and kinds.

Extensible predicates
---------------------

sourceModel(type, path, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new taint source. Most taint-tracking queries will use the new source.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to the source.
- **kind**: Kind of source to add. Currently only **remote** is used.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: sourceModel
      data:
        - ["flask", "Member[request]", "remote"]

sinkModel(type, path, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds a new taint sink. Sinks are query-specific and will typically affect one or two queries.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to the sink.
- **kind**: Kind of sink to add. See the section on sink kinds for a list of supported kinds.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: sinkModel
      data:
        - ["builtins", "Member[exec].Argument[0]", "code-injection"]

summaryModel(type, path, input, output, kind)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Adds flow through a function call.

- **type**: Name of a type from which to evaluate **path**.
- **path**: Access path leading to a function call.
- **input**: Path relative to the function call that leads to input of the flow.
- **output**: Path relative to the function call leading to the output of the flow.
- **kind**: Kind of summary to add. Can be **taint** for taint-propagating flow, or **value** for value-preserving flow.

Example:

.. code-block:: yaml

  extensions:
    - addsTo:
        pack: codeql/python-all
        extensible: summaryModel
      data:
        - [
            "builtins",
            "Member[reversed]",
            "Argument[0]",
            "ReturnValue",
            "taint",
          ]

typeModel(type1, type2, path)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A description of how to reach **type1** from **type2**.
If this is the only way to reach **type1**, for instance if **type1** is a name we made up to represent the inner workings of a library, we think of this as a definition of **type1**.
In the context of instances, this describes how to obtain an instance of **type1** from an instance of **type2**.

- **type1**: Name of the type to reach.
- **type2**: Name of the type from which to evaluate **path**.
- **path**: Access path leading from **type2** to **type1**.

Example:

.. code-block:: yaml

  extensions:
  - addsTo:
      pack: codeql/python-all
      extensible: typeModel
    data:
      - [
          "flask.Response",
          "flask",
          "Member[jsonify].ReturnValue",
        ]

Types
-----

A type is a string that identifies a set of values.
In each of the extensible predicates mentioned in previous section, the first column is always the name of a type.
A type can be defined by adding **typeModel** tuples for that type. Additionally, the following built-in types are available:

- The name of a package matches imports of that package. For example, the type **django** matches the expression **import django**.
- The type **builtins** identifies the builtins package. In Python, all built-in values are found in this package, so they can be identified using this type.
- A dotted path ending in a class name identifies instances of that class. If the suffix **!** is added, the type refers to the class itself.

Access paths
------------

The **path**, **input**, and **output** columns consist of a **.**-separated list of components, which is evaluated from left to right, with each step selecting a new set of values derived from the previous set of values.

The following components are supported:

- **Argument[**\ ``number``\ **]** selects the argument at the given index.
- **Argument[**\ ``name``:\ **]** selects the argument with the given name.
- **Argument[this]** selects the receiver of a method call.
- **Parameter[**\ ``number``\ **]** selects the parameter at the given index.
- **Parameter[**\ ``name``:\ **]** selects the named parameter with the given name.
- **Parameter[this]** selects the **this** parameter of a function.
- **ReturnValue** selects the return value of a function or call.
- **Member[**\ ``name``\ **]** selects the function/method/class/value with the given name.
- **Instance** selects instances of a class, including instances of its subclasses.
- **Attribute[**\ ``name``\ **]** selects the attribute with the given name.
- **ListElement** selects an element of a list.
- **SetElement** selects an element of a set.
- **TupleElement[**\ ``number``\ **]** selects the subscript at the given index.
- **DictionaryElement[**\ ``name``\ **]** selects the subscript at the given name.


Additional notes about the syntax of operands:

- Multiple operands may be given to a single component, as a shorthand for the union of the operands. For example, **Member[foo,bar]** matches the union of **Member[foo]** and **Member[bar]**.
- Numeric operands to **Argument**, **Parameter**, and **WithArity** may be given as an interval. For example, **Argument[0..2]** matches argument 0, 1, or 2.
- **Argument[N-1]** selects the last argument of a call, and **Parameter[N-1]** selects the last parameter of a function, with **N-2** being the second-to-last and so on.

Kinds
-----

Source kinds
~~~~~~~~~~~~

- **remote**: A generic source of remote flow. Most taint-tracking queries will use such a source. Currently this is the only supported source kind.

Sink kinds
~~~~~~~~~~

Unlike sources, sinks tend to be highly query-specific, rarely affecting more than one or two queries. Not every query supports customizable sinks. If the following sinks are not suitable for your use case, you should add a new query.

- **code-injection**: A sink that can be used to inject code, such as in calls to **exec**.
- **command-injection**: A sink that can be used to inject shell commands, such as in calls to **os.system**.
- **path-injection**: A sink that can be used for path injection in a file system access, such as in calls to **flask.send_from_directory**.
- **sql-injection**: A sink that can be used for SQL injection, such as in a MySQL **query** call.
- **html-injection**: A sink that can be used for HTML injection, such as a server response body.
- **js-injection**: A sink that can be used for JS injection, such as a server response body.
- **url-redirection**: A sink that can be used to redirect the user to a malicious URL.
- **unsafe-deserialization**: A deserialization sink that can lead to code execution or other unsafe behavior, such as an unsafe YAML parser.
- **log-injection**: A sink that can be used for log injection, such as in a **logging.info** call.

Summary kinds
~~~~~~~~~~~~~

- **taint**: A summary that propagates taint. This means the output is not necessarily equal to the input, but it was derived from the input in an unrestrictive way. An attacker who controls the input will have significant control over the output as well.
- **value**: A summary that preserves the value of the input or creates a copy of the input such that all of its object properties are preserved.



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/codeql/codeql-language-guides/functions-in-python.rst
.. _functions-in-python:

Functions in Python
===================

You can use syntactic classes from the standard CodeQL library to find Python functions and identify calls to them.

These examples use the standard CodeQL class `Function <https://codeql.github.com/codeql-standard-libraries/python/semmle/python/Function.qll/type.Function$Function.html>`__. For more information, see ":doc:`CodeQL library for Python <codeql-library-for-python>`."

Finding all functions called "get..."
-------------------------------------

In this example we look for all the "getters" in a program. Programmers moving to Python from Java are often tempted to write lots of getter and setter methods, rather than use properties. We might want to find those methods.

Using the member predicate ``Function.getName()``, we can list all of the getter functions in a database:

.. pull-quote::

   Tip

   Instead of copying this query, try typing the code. As you start to write a name that matches a library class, a pop-up is displayed making it easy for you to select the class that you want.

.. code-block:: ql

   import python

   from Function f
   where f.getName().matches("get%")
   select f, "This is a function called get..."

This query typically finds a large number of results. Usually, many of these results are for functions (rather than methods) which we are not interested in.

Finding all methods called "get..."
-----------------------------------

You can modify the query above to return more interesting results. As we are only interested in methods, we can use the ``Function.isMethod()`` predicate to refine the query.

.. code-block:: ql

   import python

   from Function f
   where f.getName().matches("get%") and f.isMethod()
   select f, "This is a method called get..."

This finds methods whose name starts with ``"get"``, but many of those are not the sort of simple getters we are interested in.

Finding one line methods called "get..."
----------------------------------------

We can modify the query further to include only methods whose body consists of a single statement. We do this by counting the number of lines in each method.

.. code-block:: ql

   import python

   from Function f
   where f.getName().matches("get%") and f.isMethod()
    and count(f.getAStmt()) = 1
   select f, "This function is (probably) a getter."

This query returns fewer results, but if you examine the results you can see that there are still refinements to be made. This is refined further in ":doc:`Expressions and statements in Python <expressions-and-statements-in-python>`."

Finding a call to a specific function
-------------------------------------

This query uses ``Call`` and ``Name`` to find calls to the function ``eval`` - which might potentially be a security hazard.

.. code-block:: ql

   import python

   from Call call, Name name
   where call.getFunc() = name and name.getId() = "eval"
   select call, "call to 'eval'."

The ``Call`` class represents calls in Python. The ``Call.getFunc()`` predicate gets the expression being called. ``Name.getId()`` gets the identifier (as a string) of the ``Name`` expression.
This query will select any call of the form ``eval(...)`` regardless of whether it is a call to the built-in function ``eval`` or not.
Due to the dynamic nature of Python, such syntactic queries can be inaccurate. If one is looking for invocations of the built-in function ``eval``,
it is preferred to use the API graph, see ":doc:`Using API graphs in Python <using-api-graphs-in-python>`."

Further reading
---------------

.. include:: ../reusables/python-further-reading.rst
.. include:: ../reusables/codeql-ref-tools-further-reading.rst



# /Users/sherif/Documents/SASTDocs/CodeQL/docs/ql-libraries/dataflow/dataflow.md
# Using the shared data-flow library

This document is aimed towards language maintainers and contains implementation
details that should be mostly irrelevant to query writers.

## Overview

The shared data-flow library implements sophisticated global data flow on top
of a language-specific data-flow graph. The language-specific bits supply the
graph through a number of predicates and classes, and the shared implementation
takes care of matching call-sites with returns and field writes with reads to
ensure that the generated paths are well-formed. The library also supports a
number of additional features for improving precision, for example pruning
infeasible paths based on type information.

## File organisation

The data-flow library consists of a number of files typically located in
`<lang>/dataflow` and `<lang>/dataflow/internal`:

```
dataflow/DataFlow.qll
dataflow/internal/DataFlowImpl.qll
dataflow/internal/DataFlowCommon.qll
dataflow/internal/DataFlowImplSpecific.qll
```

`DataFlow.qll` provides the user interface for the library and consists of just
a few lines of code importing the implementation:

#### `DataFlow.qll`
```ql
import <lang>

module DataFlow {
  import semmle.code.java.dataflow.internal.DataFlowImpl
}
```

The `DataFlowImpl.qll` and `DataFlowCommon.qll` files contain the library code
that is shared across languages. These contain `Configuration`-specific and
`Configuration`-independent code, respectively. This organization allows
multiple copies of the library to exist without duplicating the
`Configuration`-independent predicates (for the use case when a query wants to
use two instances of global data flow and the configuration of one depends on
the results from the other). Using multiple copies just means duplicating
`DataFlow.qll` and `DataFlowImpl.qll`, for example as:

```
dataflow/DataFlow2.qll
dataflow/DataFlow3.qll
dataflow/internal/DataFlowImpl2.qll
dataflow/internal/DataFlowImpl3.qll
```

The file `DataFlowImplSpecific.qll` provides all the language-specific classes
and predicates that the library needs as input and is the topic of the rest of
this document.

This file must provide two modules named `Public` and `Private`, which the
shared library code will import publicly and privately, respectively, thus
allowing the language-specific part to choose which classes and predicates
should be exposed by `DataFlow.qll`.

A typical implementation looks as follows, thereby organizing the predicates in
two files, which we'll subsequently assume:

#### `DataFlowImplSpecific.qll`
```ql
module Private {
  import DataFlowPrivate
}

module Public {
  import DataFlowPublic
}
```

## Defining the data-flow graph

The main input to the library is the data-flow graph. One must define a class
`Node` and an edge relation `simpleLocalFlowStep(Node node1, Node node2)`. The
`Node` class should be in `DataFlowPublic`.

Recommendations:
* Make `Node` an IPA type. There is commonly a need for defining various
  data-flow nodes that are not necessarily represented in the AST of the
  language.
* Define `predicate localFlowStep(Node node1, Node node2)` as an alias of
  `simpleLocalFlowStep` and expose it publicly. The reason for this indirection
  is that it gives the option of exposing local flow augmented with field flow.
  See the C/C++ implementation, which makes use of this feature. Another use of
  this indirection is to hide synthesized local steps that are only relevant
  for global flow. See the C# implementation for an example of this.
* Define `pragma[inline] predicate localFlow(Node node1, Node node2) { localFlowStep*(node1, node2) }`.
* Make the local flow step relation in `simpleLocalFlowStep` follow
  def-to-first-use and use-to-next-use steps for SSA variables. Def-use steps
  also work, but the upside of `use-use` steps is that sources defined in terms
  of variable reads just work out of the box. It also makes certain
  barrier-implementations simpler.

The shared library does not use `localFlowStep` nor `localFlow` but users of
`DataFlow.qll` may expect the existence of `DataFlow::localFlowStep` and
`DataFlow::localFlow`.

### `Node` subclasses

The `Node` class needs a number of subclasses. As a minimum the following are needed:
```
ExprNode
ParameterNode
PostUpdateNode

OutNode
ArgumentNode
ReturnNode
CastNode
```
and possibly more depending on the language and its AST. Of the above, the
first 3 should be public, but the last 4 can be private. Also, the last 4 will
likely be subtypes of `ExprNode`. For further details about `ParameterNode`,
`ArgumentNode`, `ReturnNode`, and `OutNode` see [The call-graph](#the-call-graph)
below. For further details about `CastNode` see [Type pruning](#type-pruning) below.
For further details about `PostUpdateNode` see [Field flow](#field-flow) below.

Nodes corresponding to expressions and parameters are the most common for users
to interact with so a couple of convenience predicates are generally included:
```ql
DataFlowExpr Node::asExpr()
Parameter Node::asParameter()
ExprNode exprNode(DataFlowExpr n)
ParameterNode parameterNode(Parameter n)
```
Here `DataFlowExpr` should be an alias for the language-specific class of
expressions (typically called `Expr`). Parameters do not need an alias for the
shared implementation to refer to, so here you can just use the
language-specific class name (typically called `Parameter`).

### The call-graph

In order to make inter-procedural flow work a number of classes and predicates
must be provided.

First, two types, `DataFlowCall` and `DataFlowCallable`, must be defined. These
should be aliases for whatever language-specific class represents calls and
callables (a "callable" is intended as a broad term covering functions,
methods, constructors, lambdas, etc.). It can also be useful to represent
`DataFlowCall` as an IPA type if implicit calls need to be modelled. The
call-graph should be defined as a predicate:
```ql
/** Gets a viable target for the call `c`. */
DataFlowCallable viableCallable(DataFlowCall c)
```
Furthermore, each `Node` must be associated with exactly one callable and this
relation should be defined as:
```ql
/** Gets the callable in which node `n` occurs. */
DataFlowCallable nodeGetEnclosingCallable(Node n)
```

In order to connect data-flow across calls, the 4 `Node` subclasses
`ArgumentNode`, `ParameterNode`, `ReturnNode`, and `OutNode` are used.
Flow into callables from arguments to parameters are matched up using
language-defined classes `ParameterPosition` and `ArgumentPosition`,
so these three predicates must be defined:
```ql
/** Holds if `p` is a `ParameterNode` of `c` with position `pos`. */
predicate isParameterNode(ParameterNode p, DataFlowCallable c, ParameterPosition pos)

/** Holds if `arg` is an `ArgumentNode` of `c` with position `pos`. */
predicate isArgumentNode(ArgumentNode arg, DataFlowCall c, ArgumentPosition pos)

/** Holds if arguments at position `apos` match parameters at position `ppos`. */
predicate parameterMatch(ParameterPosition ppos, ArgumentPosition apos)
```

For most languages return-flow is simpler and merely consists of matching up a
`ReturnNode` with the data-flow node corresponding to the value of the call,
represented as `OutNode`.  For this use-case we would define a singleton type
`ReturnKind`, a trivial `ReturnNode::getKind()`, and `getAnOutNode` to relate
calls and `OutNode`s:
```ql
private newtype TReturnKind = TNormalReturnKind()

/** Gets the kind of this return node. */
ReturnKind ReturnNode::getKind() { any() }

/**
 * Gets a node that can read the value returned from `call` with return kind
 * `kind`.
 */
OutNode getAnOutNode(DataFlowCall call, ReturnKind kind) {
  result = call.getNode() and
  kind = TNormalReturnKind()
}
```

For more complex use-cases when a language allows a callable to return multiple
values, for example through `out` parameters in C#, the `ReturnKind` class can
be defined and used to match up different kinds of `ReturnNode`s with the
corresponding `OutNode`s.

#### First-class functions

For calls to first-class functions, the library supports built-in call resolution based on data flow between a function creation expression and a call. The interface that needs to be implemented is

```ql
class LambdaCallKind

/** Holds if `creation` is an expression that creates a lambda of kind `kind` for `c`. */
predicate lambdaCreation(Node creation, LambdaCallKind kind, DataFlowCallable c)

/** Holds if `call` is a lambda call of kind `kind` where `receiver` is the lambda expression. */
predicate lambdaCall(DataFlowCall call, LambdaCallKind kind, Node receiver)

/** Extra data-flow steps needed for lambda flow analysis. */
predicate additionalLambdaFlowStep(Node nodeFrom, Node nodeTo, boolean preservesValue)
```

with the semantics that `call` will resolve to `c` if there is a data-flow path from `creation` to `receiver`, with matching `kind`s.

The implementation keeps track of a one-level call context, which means that we are able to handle situations like this:
```csharp
Apply(f, x) { f(x); }

Apply(x => NonSink(x), "tainted"); // GOOD

Apply(x => Sink(x), "not tainted"); // GOOD
```

However, since we only track one level the following example will have false-positive flow:
```csharp
Apply(f, x) { f(x); }

ApplyWrapper(f, x) { Apply(f, x) }

ApplyWrapper(x => NonSink(x), "tainted"); // GOOD (FALSE POSITIVE)

ApplyWrapper(x => Sink(x), "not tainted"); // GOOD (FALSE POSITIVE)
```

## Flow through global variables

Flow through global variables are called jump-steps, since such flow steps
essentially jump from one callable to another completely discarding call
contexts.

Adding support for this type of flow is done with the following predicate:
```ql
predicate jumpStep(Node node1, Node node2)
```

If global variables are common and certain databases have many reads and writes
of the same global variable, then a direct step may have performance problems,
since the straight-forward implementation is just a cartesian product of reads
and writes for each global variable. In this case it can be beneficial to
remove the cartesian product by introducing an intermediate `Node` for the
value of each global variable.

Note that, jump steps of course also can be used to implement other
cross-callable flow. As an example Java also uses this mechanism for variable
capture flow. But beware that this will lose the call context, so normal
inter-procedural flow should use argument-parameter-, and return-outnode-flow
as described above.

## Field flow

The library supports tracking flow through field stores and reads. In order to
support this, two classes `ContentSet` and `Content`, and two predicates
`storeStep(Node node1, ContentSet f, Node node2)` and
`readStep(Node node1, ContentSet f, Node node2)`, must be defined. The interaction
between `ContentSet` and `Content` is defined through

```ql
Content ContentSet::getAStoreContent();
Content ContentSet::getAReadContent();
```

which means that a `storeStep(n1, cs, n2)` will be interpreted as storing into _any_
of `cs.getAStoreContent()`, and dually that a `readStep(n1, cs, n2)` will be
interpreted as reading from _any_ of `cs.getAReadContent()`. In most cases, there
will be a simple bijection between `ContentSet` and `Content`, but when modelling
for example flow through arrays it can be more involved (see [Example 4](#example-4)).

It generally makes sense for stores to target `PostUpdateNode`s, but this is not a strict
requirement. Besides this, certain nodes must have associated
`PostUpdateNode`s. The node associated with a `PostUpdateNode` should be
defined by `PostUpdateNode::getPreUpdateNode()`.

`PostUpdateNode`s are generally used when we need two data-flow nodes for a
single AST element in order to distinguish the value before and after some
side-effect (typically a field store, but it may also be addition of taint
through an additional step targeting a `PostUpdateNode`).

It is recommended to introduce `PostUpdateNode`s for all `ArgumentNode`s (this
can be skipped for immutable arguments), and all field qualifiers for both
reads and stores. Note also that in the case of compound arguments, such as
`b ? x : y`, it is recommended to have post-update nodes for `x` and `y` (and
not the compound argument itself), and let `[post update] x` have both `x`
and `b ? x : y` as pre-update nodes (and similarly for `[post update] y`).

Remember to define local flow for `PostUpdateNode`s as well in
`simpleLocalFlowStep`.  In general out-going local flow from `PostUpdateNode`s
should be use-use flow, and there is generally no need for in-going local flow
edges for `PostUpdateNode`s.

We will illustrate how the shared library makes use of `PostUpdateNode`s
through a couple of examples.

### Example 1

Consider the following setter and its call:
```java
setFoo(obj, x) {
  sink1(obj.foo);
  obj.foo = x;
}

setFoo(myobj, source);
sink2(myobj.foo);
```
Here `source` should flow to the argument of `sink2` but not the argument of
`sink1`. The shared library handles most of the complexity involved in this
flow path, but needs a little bit of help in terms of available nodes. In
particular it is important to be able to distinguish between the value of the
`myobj` argument to `setFoo` before the call and after the call, since without
this distinction it is hard to avoid also getting flow to `sink1`. The value
before the call should be the regular `ArgumentNode` (which will get flow into
the call), and the value after the call should be a `PostUpdateNode`. Thus a
`PostUpdateNode` should exist for the `myobj` argument with the `ArgumentNode`
as its pre-update node. In general `PostUpdateNode`s should exist for any
mutable `ArgumentNode`s to support flow returning through a side-effect
updating the argument.

This example also suggests how `simpleLocalFlowStep` should be implemented for
`PostUpdateNode`s: we need a local flow step between the `PostUpdateNode` for
the `myobj` argument and the following `myobj` in the qualifier of `myobj.foo`.

Inside `setFoo` the actual store should also target a
`PostUpdateNode` - in this case associated with the qualifier `obj` - as this
is the mechanism the shared library uses to identify side-effects that should
be reflected at call sites as setter-flow.  The shared library uses the
following rule to identify setters: If the value of a parameter may flow to a
node that is the pre-update node of a `PostUpdateNode` that is reached by some
flow, then this represents an update to the parameter, which will be reflected
in flow continuing to the `PostUpdateNode` of the corresponding argument in
call sites.

### Example 2

In the following two lines we would like flow from `x` to reach the
`PostUpdateNode` of `a` through a sequence of two store steps, and this is
indeed handled automatically by the shared library.
```java
a.b.c = x;
a.getB().c = x;
```
The only requirement for this to work is the existence of `PostUpdateNode`s.
For a specified read step (in `readStep(Node n1, ContentSet c, Node n2)`) the
shared library will generate a store step in the reverse direction between the
corresponding `PostUpdateNode`s. A similar store-through-reverse-read will be
generated for calls that can be summarized by the shared library as getters.
This usage of `PostUpdateNode`s ensures that `x` will not flow into the `getB`
call after reaching `a`.

### Example 3

Consider a constructor and its call (for this example we will use Java, but the
idea should generalize):
```java
MyObj(Content content) {
  this.content = content;
}

obj = new MyObj(source);
sink(obj.content);
```

We would like the constructor call to act in the same way as a setter, and
indeed this is quite simple to achieve. We can introduce a synthetic data-flow
node associated with the constructor call, let us call it `MallocNode`, and
make this an `ArgumentNode` with position `-1` such that it hooks up with the
implicit `this`-parameter of the constructor body. Then we can set the
corresponding `PostUpdateNode` of the `MallocNode` to be the constructor call
itself as this represents the value of the object after construction, that is
after the constructor has run. With this setup of `ArgumentNode`s and
`PostUpdateNode`s we will achieve the desired flow from `source` to `sink`

### Example 4

Assume we want to track flow through arrays precisely:

```rb
a[0] = tainted
a[1] = not_tainted
sink(a[0]) # bad
sink(a[1]) # good
sink(a[unknown]) # bad; unknown may be 0

b[unknown] = tainted
sink(b[0]) # bad; unknown may be 0

c[unknown][0] = tainted
c[unknown][1] = not_tainted
sink(c[0][0]) # bad; unknown may be 0
sink(c[0][1]) # good
```

This can be done by defining

```ql
newtype TContent =
  TKnownArrayElementContent(int i) { i in [0 .. 10] } or
  TUnknownArrayElementContent()

class Content extends TContent {
  ...
}

newtype TContentSet =
  TSingletonContent(Content c) or
  TKnownOrUnknownArrayElementContent(TKnownArrayElementContent c) or
  TAnyArrayElementContent()

class ContentSet extends TContentSet {
  Content getAStoreContent() {
    this = TSingletonContent(result)
    or
    // for reverse stores
    this = TKnownOrUnknownArrayElementContent(result)
    or
    // for reverse stores
    this = TAnyArrayElementContent() and
    result = TUnknownArrayElementContent()
  }

  Content getAReadContent() {
    this = TSingletonContent(result)
    or
    exists(TKnownArrayElementContent c |
      this = TKnownOrUnknownArrayElementContent(c) |
      result = c
      or
      result = TUnknownArrayElementContent()
    )
    or
    this = TAnyArrayElementContent() and
    (result = TUnknownArrayElementContent() or result = TKnownArrayElementContent(_))
  }
}
```

and we will have the following store/read steps
```rb
# storeStep(tainted, TSingletonContent(TKnownArrayElementContent(0)), [post update] a)
a[0] = tainted

# storeStep(not_tainted, TSingletonContent(TKnownArrayElementContent(1)), [post update] a)
a[1] = not_tainted

# readStep(a, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(0)), a[0])
sink(a[0]) # bad

# readStep(a, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(1)), a[1])
sink(a[1]) # good

# readStep(a, TAnyArrayElementContent(), a[unknown])
sink(a[unknown]) # bad; unknown may be 0

# storeStep(tainted, TSingletonContent(TUnknownArrayElementContent()), [post update] b)
b[unknown] = tainted

# readStep(b, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(0)), b[0])
sink(b[0]) # bad; unknown may be 0

# storeStep(tainted, TSingletonContent(TUnknownArrayElementContent()), [post update] c[0])
# storeStep(not_tainted, TSingletonContent(TUnknownArrayElementContent()), [post update] c[1])
# readStep(c, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(0)), c[0])
# readStep(c, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(1)), c[1])
# storeStep([post update] c[0], TSingletonContent(TKnownArrayElementContent(0)), [post update] c) # auto-generated reverse store (see Example 2)
# storeStep([post update] c[1], TSingletonContent(TKnownArrayElementContent(1)), [post update] c) # auto-generated reverse store (see Example 2)
c[0][unknown] = tainted
c[1][unknown] = not_tainted

# readStep(c[0], TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(0)), c[0][0])
# readStep(c[1], TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(0)), c[1][0])
# readStep(c, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(0)), c[0])
# readStep(c, TKnownOrUnknownArrayElementContent(TKnownArrayElementContent(1)), c[1])
sink(c[0][0]) # bad; unknown may be 0
sink(c[1][0]) # good
```

### Field flow barriers

Consider this field flow example:
```java
obj.f = source;
obj.f = safeValue;
sink(obj.f);
```
or the similar case when field flow is used to model collection content:
```java
obj.add(source);
obj.clear();
sink(obj.get(key));
```
Clearing a field or content like this should act as a barrier, and this can be
achieved by marking the relevant `Node, ContentSet` pair as a clear operation in
the `clearsContent` predicate. A reasonable default implementation for fields
looks like this:
```ql
predicate clearsContent(Node n, ContentSet c) {
  n = any(PostUpdateNode pun | storeStep(_, c, pun)).getPreUpdateNode()
}
```
However, this relies on the local step relation using the smallest possible
use-use steps. If local flow is implemented using def-use steps, then
`clearsContent` might not be easy to use.

Note that `clearsContent(n, cs)` is interpreted using `cs.getAReadContent()`.

Dually, there exists a predicate
```ql
predicate expectsContent(Node n, ContentSet c);
```
which acts as a barrier when data is _not_ stored inside one of `c.getAReadContent()`.

## Type pruning

The library supports pruning paths when a sequence of value-preserving steps
originate in a node with one type, but reaches a node with another and
incompatible type, thus making the path impossible.

The type system for this is specified with the class `DataFlowType` and the
compatibility relation `compatibleTypes(DataFlowType t1, DataFlowType t2)`.
Using a singleton type as `DataFlowType` means that this feature is effectively
disabled.

It can be useful to use a simpler type system for pruning than whatever type
system might come with the language, as collections of types that would
otherwise be equivalent with respect to compatibility can then be represented
as a single entity (this improves performance). As an example, Java uses erased
types for this purpose and a single equivalence class for all numeric types.

The type of a `Node` is given by the following predicate
```ql
DataFlowType getNodeType(Node n)
```
and every `Node` should have a type.

One also needs to define the string representation of a `DataFlowType`.
The `DataFlowType.toString` predicate is used for printing a type in the labels of
`PathNode`s, this should be defined as `result = ""` if type pruning is not used.

Finally, one must define `CastNode` as a subclass of `Node` as those nodes
where types should be checked. Usually this will be things like explicit casts.
The shared library will also check types at `ParameterNode`s and `OutNode`s
without needing to include these in `CastNode`.  It is semantically perfectly
valid to include all nodes in `CastNode`, but this can hurt performance as it
will reduce the opportunity for the library to compact several local steps into
one. It is also perfectly valid to leave `CastNode` as the empty set, and this
should be the default if type pruning is not used.

## Virtual dispatch with call context

Consider a virtual call that may dispatch to multiple different targets. If we
know the call context of the call then this can sometimes be used to reduce the
set of possible dispatch targets and thus eliminate impossible call chains.

The library supports a one-level call context for improving virtual dispatch.

Conceptually, the following predicate should be implemented as follows:
```ql
DataFlowCallable viableImplInCallContext(DataFlowCall call, DataFlowCall ctx) {
  exists(DataFlowCallable enclosing |
    result = viableCallable(call) and
    enclosing = call.getEnclosingCallable() and
    enclosing = viableCallable(ctx)
  |
    not ... <`result` is impossible target for `call` given `ctx`> ...
  )
}
```
However, joining the virtual dispatch relation with itself in this way is
usually way too big to be feasible. Instead, the relation above should only be
defined for those values of `call` for which the set of resulting dispatch
targets might be reduced. To do this, define the set of `call`s that might for
some reason benefit from a call context as the following predicate:
```ql
predicate mayBenefitFromCallContext(DataFlowCall call)
```
And then define `DataFlowCallable viableImplInCallContext(DataFlowCall call,
DataFlowCall ctx)` as sketched above, but restricted to
`mayBenefitFromCallContext(call)`.

The shared implementation will then compare counts of virtual dispatch targets
using `viableCallable` and `viableImplInCallContext` for each `call` in
`mayBenefitFromCallContext(call)` and track call contexts during flow
calculation when differences in these counts show an improved precision in
further calls.

## Additional features

### Access path length limit

The maximum length of an access path is the maximum number of nested stores
that can be tracked. This is given by the following predicate:
```ql
int accessPathLimit() { result = 5 }
```
We have traditionally used 5 as a default value here, and real examples have
been observed to require at least this much. Changing this value has a direct
impact on performance for large databases.

### Hidden nodes

Certain synthetic nodes are hidden by default to prevent them from occurring in
path explanations. Which nodes are included in this is determined by the
following predicate:

```ql
predicate nodeIsHidden(Node n)
```

To include these nodes in path explanations, add the following to a
configuration:

```ql
predicate includeHiddenNodes() { any() }
```

### Show more nodes in path explanations

Path explanations skip over most nodes and only show the important nodes in a
path. To ensure that particular nodes are shown, define the following predicate
in a configuration:

```ql
predicate neverSkip(Node n)
```

### Unreachable nodes

Consider:
```java
foo(source1, false);
foo(source2, true);

foo(x, b) {
  if (b)
    sink(x);
}
```
Sometimes certain data-flow nodes can be unreachable based on the call context.
In the above example, only `source2` should be able to reach `sink`. This is
supported by the following predicate where one can specify unreachable nodes
given a call context.
```ql
predicate isUnreachableInCall(Node n, DataFlowCall callcontext) { .. }
```
Note that while this is a simple interface it does have some scalability issues
if the number of unreachable nodes is large combined with many call sites.

### `BarrierGuard`s

The class `BarrierGuard` must be defined. See
https://github.com/github/codeql/pull/1718 for details.

### Consistency checks

The file `dataflow/internal/DataFlowImplConsistency.qll` contains a number of
consistency checks to verify that the language-specific parts satisfy the
invariants that are expected by the shared implementation. Run these queries to
check for inconsistencies.


